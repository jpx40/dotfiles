/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./scripts/3rdparty-custom-fixes/codemirror/codemirror-as-global.js":
/*!**************************************************************************!*\
  !*** ./scripts/3rdparty-custom-fixes/codemirror/codemirror-as-global.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _3rdparty_codemirror_codemirror_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../3rdparty/codemirror/codemirror.js */ "./scripts/3rdparty/codemirror/codemirror.js");
/* harmony import */ var _3rdparty_codemirror_codemirror_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_codemirror_js__WEBPACK_IMPORTED_MODULE_0__);

window.CodeMirror = (_3rdparty_codemirror_codemirror_js__WEBPACK_IMPORTED_MODULE_0___default());

/***/ }),

/***/ "./scripts/3rdparty-custom-fixes/csslint/ignore-some-rules.js":
/*!********************************************************************!*\
  !*** ./scripts/3rdparty-custom-fixes/csslint/ignore-some-rules.js ***!
  \********************************************************************/
/***/ (() => {

/* global CSSLint */

(function () {
  var originalRules = CSSLint.getRules(),
    rulesToIgnore = ['box-model', 'adjoining-classes', 'box-sizing', 'compatible-vendor-prefixes', 'gradients', 'fallback-colors', 'bulletproof-font-face', 'regex-selectors', 'overqualified-elements', 'shorthand', 'duplicate-background-images', 'floats', 'font-sizes', 'ids', 'order-alphabetical'],
    newRules = originalRules.filter(function (rule) {
      if (rulesToIgnore.indexOf(rule.id) >= 0) {
        return false;
      }
      return true;
    });
  CSSLint.clearRules();
  newRules.forEach(function (rule) {
    CSSLint.addRule(rule);
  });
})();

/***/ }),

/***/ "./scripts/3rdparty-custom-fixes/csspretty/pre-csspretty.js":
/*!******************************************************************!*\
  !*** ./scripts/3rdparty-custom-fixes/csspretty/pre-csspretty.js ***!
  \******************************************************************/
/***/ (() => {

/*eslint-disable no-unused-vars */
var global = {};
/*eslint-enable no-unused-vars */

/***/ }),

/***/ "./scripts/3rdparty-custom-fixes/jquery/jquery-as-global.js":
/*!******************************************************************!*\
  !*** ./scripts/3rdparty-custom-fixes/jquery/jquery-as-global.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _3rdparty_jquery_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../3rdparty/jquery.js */ "./scripts/3rdparty/jquery.js");
/* harmony import */ var _3rdparty_jquery_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_jquery_js__WEBPACK_IMPORTED_MODULE_0__);

window.jQuery = _3rdparty_jquery_js__WEBPACK_IMPORTED_MODULE_0__;
window.$ = _3rdparty_jquery_js__WEBPACK_IMPORTED_MODULE_0__;

/***/ }),

/***/ "./scripts/3rdparty-custom-fixes/socket.io/socket.io-as-global.js":
/*!************************************************************************!*\
  !*** ./scripts/3rdparty-custom-fixes/socket.io/socket.io-as-global.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _3rdparty_socket_io_socket_io_slim_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../3rdparty/socket.io/socket.io.slim.dev.js */ "./scripts/3rdparty/socket.io/socket.io.slim.dev.js");
/* harmony import */ var _3rdparty_socket_io_socket_io_slim_dev_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_socket_io_socket_io_slim_dev_js__WEBPACK_IMPORTED_MODULE_0__);
// import { io } from '../../3rdparty/socket.io/socket.io.slim.js';

window.io = _3rdparty_socket_io_socket_io_slim_dev_js__WEBPACK_IMPORTED_MODULE_0__.io;

/***/ }),

/***/ "./scripts/3rdparty/amplify-store.js":
/*!*******************************************!*\
  !*** ./scripts/3rdparty/amplify-store.js ***!
  \*******************************************/
/***/ (function() {

(function (amplify, undefined) {
  var store = amplify.store = function (key, value, options) {
    var type = store.type;
    if (options && options.type && options.type in store.types) {
      type = options.type;
    }
    return store.types[type](key, value, options || {});
  };
  store.types = {};
  store.type = null;
  store.addType = function (type, storage) {
    if (!store.type) {
      store.type = type;
    }
    store.types[type] = storage;
    store[type] = function (key, value, options) {
      options = options || {};
      options.type = type;
      return store(key, value, options);
    };
  };
  store.error = function () {
    return "amplify.store quota exceeded";
  };
  var rprefix = /^__amplify__/;
  function createFromStorageInterface(storageType, storage) {
    store.addType(storageType, function (key, value, options) {
      var storedValue,
        parsed,
        i,
        remove,
        ret = value,
        now = new Date().getTime();
      if (!key) {
        ret = {};
        remove = [];
        i = 0;
        try {
          // accessing the length property works around a localStorage bug
          // in Firefox 4.0 where the keys don't update cross-page
          // we assign to key just to avoid Closure Compiler from removing
          // the access as "useless code"
          // https://bugzilla.mozilla.org/show_bug.cgi?id=662511
          key = storage.length;
          while (key = storage.key(i++)) {
            if (rprefix.test(key)) {
              parsed = JSON.parse(storage.getItem(key));
              if (parsed.expires && parsed.expires <= now) {
                remove.push(key);
              } else {
                ret[key.replace(rprefix, "")] = parsed.data;
              }
            }
          }
          while (key = remove.pop()) {
            storage.removeItem(key);
          }
        } catch (error) {}
        return ret;
      }

      // protect against name collisions with direct storage
      key = "__amplify__" + key;
      if (value === undefined) {
        storedValue = storage.getItem(key);
        parsed = storedValue ? JSON.parse(storedValue) : {
          expires: -1
        };
        if (parsed.expires && parsed.expires <= now) {
          storage.removeItem(key);
        } else {
          return parsed.data;
        }
      } else {
        if (value === null) {
          storage.removeItem(key);
        } else {
          parsed = JSON.stringify({
            data: value,
            expires: options.expires ? now + options.expires : null
          });
          try {
            storage.setItem(key, parsed);
            // quota exceeded
          } catch (error) {
            // expire old data and try again
            store[storageType]();
            try {
              storage.setItem(key, parsed);
            } catch (error) {
              throw store.error();
            }
          }
        }
      }
      return ret;
    });
  }

  // localStorage + sessionStorage
  // IE 8+, Firefox 3.5+, Safari 4+, Chrome 4+, Opera 10.5+, iPhone 2+, Android 2+
  for (var webStorageType in {
    localStorage: 1,
    sessionStorage: 1
  }) {
    // try/catch for file protocol in Firefox and Private Browsing in Safari 5
    try {
      // Safari 5 in Private Browsing mode exposes localStorage
      // but doesn't allow storing data, so we attempt to store and remove an item.
      // This will unfortunately give us a false negative if we're at the limit.
      window[webStorageType].setItem("__amplify__", "x");
      window[webStorageType].removeItem("__amplify__");
      createFromStorageInterface(webStorageType, window[webStorageType]);
    } catch (e) {}
  }

  // globalStorage
  // non-standard: Firefox 2+
  // https://developer.mozilla.org/en/dom/storage#globalStorage
  if (!store.types.localStorage && window.globalStorage) {
    // try/catch for file protocol in Firefox
    try {
      createFromStorageInterface("globalStorage", window.globalStorage[window.location.hostname]);
      // Firefox 2.0 and 3.0 have sessionStorage and globalStorage
      // make sure we default to globalStorage
      // but don't default to globalStorage in 3.5+ which also has localStorage
      if (store.type === "sessionStorage") {
        store.type = "globalStorage";
      }
    } catch (e) {}
  }

  // userData
  // non-standard: IE 5+
  // http://msdn.microsoft.com/en-us/library/ms531424(v=vs.85).aspx
  (function () {
    // IE 9 has quirks in userData that are a huge pain
    // rather than finding a way to detect these quirks
    // we just don't register userData if we have localStorage
    if (store.types.localStorage) {
      return;
    }

    // append to html instead of body so we can do this from the head
    var div = document.createElement("div"),
      attrKey = "amplify";
    div.style.display = "none";
    document.getElementsByTagName("head")[0].appendChild(div);

    // we can't feature detect userData support
    // so just try and see if it fails
    // surprisingly, even just adding the behavior isn't enough for a failure
    // so we need to load the data as well
    try {
      div.addBehavior("#default#userdata");
      div.load(attrKey);
    } catch (e) {
      div.parentNode.removeChild(div);
      return;
    }
    store.addType("userData", function (key, value, options) {
      div.load(attrKey);
      var attr,
        parsed,
        prevValue,
        i,
        remove,
        ret = value,
        now = new Date().getTime();
      if (!key) {
        ret = {};
        remove = [];
        i = 0;
        while (attr = div.XMLDocument.documentElement.attributes[i++]) {
          parsed = JSON.parse(attr.value);
          if (parsed.expires && parsed.expires <= now) {
            remove.push(attr.name);
          } else {
            ret[attr.name] = parsed.data;
          }
        }
        while (key = remove.pop()) {
          div.removeAttribute(key);
        }
        div.save(attrKey);
        return ret;
      }

      // convert invalid characters to dashes
      // http://www.w3.org/TR/REC-xml/#NT-Name
      // simplified to assume the starting character is valid
      // also removed colon as it is invalid in HTML attribute names
      key = key.replace(/[^\-._0-9A-Za-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c-\u200d\u203f\u2040\u2070-\u218f]/g, "-");
      // adjust invalid starting character to deal with our simplified sanitization
      key = key.replace(/^-/, "_-");
      if (value === undefined) {
        attr = div.getAttribute(key);
        parsed = attr ? JSON.parse(attr) : {
          expires: -1
        };
        if (parsed.expires && parsed.expires <= now) {
          div.removeAttribute(key);
        } else {
          return parsed.data;
        }
      } else {
        if (value === null) {
          div.removeAttribute(key);
        } else {
          // we need to get the previous value in case we need to rollback
          prevValue = div.getAttribute(key);
          parsed = JSON.stringify({
            data: value,
            expires: options.expires ? now + options.expires : null
          });
          div.setAttribute(key, parsed);
        }
      }
      try {
        div.save(attrKey);
        // quota exceeded
      } catch (error) {
        // roll the value back to the previous value
        if (prevValue === null) {
          div.removeAttribute(key);
        } else {
          div.setAttribute(key, prevValue);
        }

        // expire old data and try again
        store.userData();
        try {
          div.setAttribute(key, parsed);
          div.save(attrKey);
        } catch (error) {
          // roll the value back to the previous value
          if (prevValue === null) {
            div.removeAttribute(key);
          } else {
            div.setAttribute(key, prevValue);
          }
          throw store.error();
        }
      }
      return ret;
    });
  })();

  // in-memory storage
  // fallback for all browsers to enable the API even if we can't persist data
  (function () {
    var memory = {},
      timeout = {};
    function copy(obj) {
      return obj === undefined ? undefined : JSON.parse(JSON.stringify(obj));
    }
    store.addType("memory", function (key, value, options) {
      if (!key) {
        return copy(memory);
      }
      if (value === undefined) {
        return copy(memory[key]);
      }
      if (timeout[key]) {
        clearTimeout(timeout[key]);
        delete timeout[key];
      }
      if (value === null) {
        delete memory[key];
        return null;
      }
      memory[key] = value;
      if (options.expires) {
        timeout[key] = setTimeout(function () {
          delete memory[key];
          delete timeout[key];
        }, options.expires);
      }
      return value;
    });
  })();
})(this.amplify = this.amplify || {});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/colorpicker/colorpicker.js":
/*!***********************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/colorpicker/colorpicker.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

(function (mod) {
  if (true)
    // CommonJS
    mod(__webpack_require__(/*! codemirror */ "../node_modules/codemirror/lib/codemirror.js"));else {}
})(function (CodeMirror) {
  CodeMirror.defineExtension("colorpicker", function () {
    var cm = this;
    var color = {
      trim: function (str) {
        return str.replace(/^\s+|\s+$/g, '');
      },
      /**
       * @method format
       *
       * convert color to format string
       *
       *     // hex
       *     color.format({ r : 255, g : 255, b : 255 }, 'hex')  // #FFFFFF
       *
       *     // rgb
       *     color.format({ r : 255, g : 255, b : 255 }, 'rgb') // rgba(255, 255, 255, 0.5);
       *
       *     // rgba
       *     color.format({ r : 255, g : 255, b : 255, a : 0.5 }, 'rgb') // rgba(255, 255, 255, 0.5);
       *
       * @param {Object} obj  obj has r, g, b and a attributes
       * @param {"hex"/"rgb"} type  format string type
       * @returns {*}
       */
      format: function (obj, type) {
        if (type == 'hex') {
          var r = obj.r.toString(16);
          if (obj.r < 16) r = "0" + r;
          var g = obj.g.toString(16);
          if (obj.g < 16) g = "0" + g;
          var b = obj.b.toString(16);
          if (obj.b < 16) b = "0" + b;
          return "#" + [r, g, b].join("");
        } else if (type == 'rgb') {
          if (typeof obj.a == 'undefined') {
            return "rgb(" + [obj.r, obj.g, obj.b].join(",") + ")";
          } else {
            return "rgba(" + [obj.r, obj.g, obj.b, obj.a].join(",") + ")";
          }
        } else if (type == 'hsl') {
          if (typeof obj.a == 'undefined') {
            return "hsl(" + [obj.h, obj.s + '%', obj.l + '%'].join(",") + ")";
          } else {
            return "hsla(" + [obj.h, obj.s + '%', obj.l + '%', obj.a].join(",") + ")";
          }
        }
        return obj;
      },
      /**
       * @method rgb
       *
       * parse string to rgb color
       *
       * 		color.rgb("#FF0000") === { r : 255, g : 0, b : 0 }
       *
       * 		color.rgb("rgb(255, 0, 0)") == { r : 255, g : 0, b : }
       *
       * @param {String} str color string
       * @returns {Object}  rgb object
       */
      parse: function (str) {
        if (typeof str == 'string') {
          if (str.indexOf("rgb(") > -1) {
            var arr = str.replace("rgb(", "").replace(")", "").split(",");
            for (var i = 0, len = arr.length; i < len; i++) {
              arr[i] = parseInt(color.trim(arr[i]), 10);
            }
            return {
              type: 'rgb',
              r: arr[0],
              g: arr[1],
              b: arr[2],
              a: 1
            };
          } else if (str.indexOf("rgba(") > -1) {
            var arr = str.replace("rgba(", "").replace(")", "").split(",");
            for (var i = 0, len = arr.length; i < len; i++) {
              if (len - 1 == i) {
                arr[i] = parseFloat(color.trim(arr[i]));
              } else {
                arr[i] = parseInt(color.trim(arr[i]), 10);
              }
            }
            return {
              type: 'rgb',
              r: arr[0],
              g: arr[1],
              b: arr[2],
              a: arr[3]
            };
          } else if (str.indexOf("hsl(") > -1) {
            var arr = str.replace("hsl(", "").replace(")", "").split(",");
            for (var i = 0, len = arr.length; i < len; i++) {
              arr[i] = parseInt(color.trim(arr[i]), 10);
            }
            var obj = {
              type: 'hsl',
              h: arr[0],
              s: arr[1],
              l: arr[2],
              a: 1
            };
            var temp = color.HSLtoRGB(obj.h, obj.s, obj.l);
            obj.r = temp.r;
            obj.g = temp.g;
            obj.b = temp.b;
            return obj;
          } else if (str.indexOf("hsla(") > -1) {
            var arr = str.replace("hsla(", "").replace(")", "").split(",");
            for (var i = 0, len = arr.length; i < len; i++) {
              if (len - 1 == i) {
                arr[i] = parseFloat(color.trim(arr[i]));
              } else {
                arr[i] = parseInt(color.trim(arr[i]), 10);
              }
            }
            var obj = {
              type: 'hsl',
              h: arr[0],
              s: arr[1],
              l: arr[2],
              a: arr[3]
            };
            var temp = color.HSLtoRGB(obj.h, obj.s, obj.l);
            obj.r = temp.r;
            obj.g = temp.g;
            obj.b = temp.b;
            return obj;
          } else if (str.indexOf("#") == 0) {
            str = str.replace("#", "");
            var arr = [];
            if (str.length == 3) {
              for (var i = 0, len = str.length; i < len; i++) {
                var char = str.substr(i, 1);
                arr.push(parseInt(char + char, 16));
              }
            } else {
              for (var i = 0, len = str.length; i < len; i += 2) {
                arr.push(parseInt(str.substr(i, 2), 16));
              }
            }
            return {
              type: 'hex',
              r: arr[0],
              g: arr[1],
              b: arr[2],
              a: 1
            };
          }
        }
        return str;
      },
      /**
       * @method HSVtoRGB
       *
       * convert hsv to rgb
       *
       * 		color.HSVtoRGB(0,0,1) === #FFFFF === { r : 255, g : 0, b : 0 }
       *
       * @param {Number} H  hue color number  (min : 0, max : 360)
       * @param {Number} S  Saturation number  (min : 0, max : 1)
       * @param {Number} V  Value number 		(min : 0, max : 1 )
       * @returns {Object}
       */
      HSVtoRGB: function (H, S, V) {
        if (H == 360) {
          H = 0;
        }
        var C = S * V;
        var X = C * (1 - Math.abs(H / 60 % 2 - 1));
        var m = V - C;
        var temp = [];
        if (0 <= H && H < 60) {
          temp = [C, X, 0];
        } else if (60 <= H && H < 120) {
          temp = [X, C, 0];
        } else if (120 <= H && H < 180) {
          temp = [0, C, X];
        } else if (180 <= H && H < 240) {
          temp = [0, X, C];
        } else if (240 <= H && H < 300) {
          temp = [X, 0, C];
        } else if (300 <= H && H < 360) {
          temp = [C, 0, X];
        }
        return {
          r: Math.ceil((temp[0] + m) * 255),
          g: Math.ceil((temp[1] + m) * 255),
          b: Math.ceil((temp[2] + m) * 255)
        };
      },
      /**
       * @method RGBtoHSV
       *
       * convert rgb to hsv
       *
       * 		color.RGBtoHSV(0, 0, 255) === { h : 240, s : 1, v : 1 } === '#FFFF00'
       *
       * @param {Number} R  red color value
       * @param {Number} G  green color value
       * @param {Number} B  blue color value
       * @return {Object}  hsv color code
       */
      RGBtoHSV: function (R, G, B) {
        var R1 = R / 255;
        var G1 = G / 255;
        var B1 = B / 255;
        var MaxC = Math.max(R1, G1, B1);
        var MinC = Math.min(R1, G1, B1);
        var DeltaC = MaxC - MinC;
        var H = 0;
        if (DeltaC == 0) {
          H = 0;
        } else if (MaxC == R1) {
          H = 60 * ((G1 - B1) / DeltaC % 6);
        } else if (MaxC == G1) {
          H = 60 * ((B1 - R1) / DeltaC + 2);
        } else if (MaxC == B1) {
          H = 60 * ((R1 - G1) / DeltaC + 4);
        }
        if (H < 0) {
          H = 360 + H;
        }
        var S = 0;
        if (MaxC == 0) S = 0;else S = DeltaC / MaxC;
        var V = MaxC;
        return {
          h: H,
          s: S,
          v: V
        };
      },
      RGBtoHSL: function (r, g, b) {
        r /= 255, g /= 255, b /= 255;
        var max = Math.max(r, g, b),
          min = Math.min(r, g, b);
        var h,
          s,
          l = (max + min) / 2;
        if (max == min) {
          h = s = 0; // achromatic
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return {
          h: Math.round(h * 360),
          s: Math.round(s * 100),
          l: Math.round(l * 100)
        };
      },
      HUEtoRGB: function (p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      },
      HSLtoRGB: function (h, s, l) {
        var r, g, b;
        h /= 360;
        s /= 100;
        l /= 100;
        if (s == 0) {
          r = g = b = l; // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = this.HUEtoRGB(p, q, h + 1 / 3);
          g = this.HUEtoRGB(p, q, h);
          b = this.HUEtoRGB(p, q, h - 1 / 3);
        }
        return {
          r: r * 255,
          g: g * 255,
          b: b * 255
        };
      }
    };
    var hue_color = [{
      rgb: '#ff0000',
      start: .0
    }, {
      rgb: '#ffff00',
      start: .17
    }, {
      rgb: '#00ff00',
      start: .33
    }, {
      rgb: '#00ffff',
      start: .50
    }, {
      rgb: '#0000ff',
      start: .67
    }, {
      rgb: '#ff00ff',
      start: .83
    }, {
      rgb: '#ff0000',
      start: 1
    }];
    var $body, $root, $hue, $color, $value, $saturation, $drag_pointer, $drag_bar, $control, $controlPattern, $controlColor, $hueContainer, $opacity, $opacityContainer, $opacityColorBar, $formatChangeButton, $opacity_drag_bar, $information, $informationChange;
    var currentA, currentH, currentS, currentV;
    var $hexCode;
    var $rgb_r, $rgb_g, $rgb_b, $rgb_a;
    var $hsl_h, $hsl_s, $hsl_l, $hsl_a;
    var cssPrefix = getCssValuePrefix();
    var colorpickerCallback = function () {};
    var counter = 0;
    var cached = {};
    var isColorPickerShow = false;
    var isShortCut = false;
    var hideDelay = 2000;
    function dom(tag, className, attr) {
      if (typeof tag != 'string') {
        this.el = tag;
      } else {
        var el = document.createElement(tag);
        this.uniqId = counter++;
        el.className = className;
        attr = attr || {};
        for (var k in attr) {
          el.setAttribute(k, attr[k]);
        }
        this.el = el;
      }
    }
    dom.prototype.closest = function (cls) {
      var temp = this;
      var checkCls = false;
      while (!(checkCls = temp.hasClass(cls))) {
        if (temp.el.parentNode) {
          temp = new dom(temp.el.parentNode);
        } else {
          return null;
        }
      }
      if (checkCls) {
        return temp;
      }
      return null;
    };
    dom.prototype.removeClass = function (cls) {
      this.el.className = color.trim((" " + this.el.className + " ").replace(' ' + cls + ' ', ' '));
    };
    dom.prototype.hasClass = function (cls) {
      if (!this.el.className) {
        return false;
      } else {
        var newClass = ' ' + this.el.className + ' ';
        return newClass.indexOf(' ' + cls + ' ') > -1;
      }
    };
    dom.prototype.addClass = function (cls) {
      if (!this.hasClass(cls)) {
        this.el.className = this.el.className + " " + cls;
      }
    };
    dom.prototype.html = function (html) {
      this.el.innerHTML = html;
      return this;
    };
    dom.prototype.empty = function () {
      return this.html('');
    };
    dom.prototype.append = function (el) {
      if (typeof el == 'string') {
        this.el.appendChild(document.createTextNode(el));
      } else {
        this.el.appendChild(el.el || el);
      }
      return this;
    };
    dom.prototype.appendTo = function (target) {
      var t = target.el ? target.el : target;
      t.appendChild(this.el);
      return this;
    };
    dom.prototype.remove = function () {
      if (this.el.parentNode) {
        this.el.parentNode.removeChild(this.el);
      }
      return this;
    };
    dom.prototype.text = function () {
      return this.el.textContent;
    };
    dom.prototype.css = function (key, value) {
      if (arguments.length == 2) {
        this.el.style[key] = value;
      } else if (arguments.length == 1) {
        if (typeof key == 'string') {
          return getComputedStyle(this.el)[key];
        } else {
          var keys = key || {};
          for (var k in keys) {
            this.el.style[k] = keys[k];
          }
        }
      }
      return this;
    };
    dom.prototype.offset = function () {
      var rect = this.el.getBoundingClientRect();
      return {
        top: rect.top + document.body.scrollTop,
        left: rect.left + document.body.scrollLeft
      };
    };
    dom.prototype.position = function () {
      return {
        top: parseFloat(this.el.style.top),
        left: parseFloat(this.el.style.left)
      };
    };
    dom.prototype.width = function () {
      return this.el.offsetWidth;
    };
    dom.prototype.height = function () {
      return this.el.offsetHeight;
    };
    dom.prototype.dataKey = function (key) {
      return this.uniqId + '.' + key;
    };
    dom.prototype.data = function (key, value) {
      if (arguments.length == 2) {
        cached[this.dataKey(key)] = value;
      } else if (arguments.length == 1) {
        return cached[this.dataKey(key)];
      } else {
        var keys = Object.keys(cached);
        var uniqId = this.uniqId + ".";
        return keys.filter(function (key) {
          if (key.indexOf(uniqId) == 0) {
            return true;
          }
          return false;
        }).map(function (value) {
          return cached[value];
        });
      }
      return this;
    };
    dom.prototype.val = function (value) {
      if (arguments.length == 0) {
        return this.el.value;
      } else if (arguments.length == 1) {
        this.el.value = value;
      }
      return this;
    };
    dom.prototype.int = function () {
      return parseInt(this.val(), 10);
    };
    dom.prototype.show = function () {
      return this.css('display', 'block');
    };
    dom.prototype.hide = function () {
      return this.css('display', 'none');
    };
    function setRGBInput(r, g, b) {
      $rgb_r.val(r);
      $rgb_g.val(g);
      $rgb_b.val(b);
      $rgb_a.val(currentA);
    }
    function setHSLInput(h, s, l) {
      $hsl_h.val(h);
      $hsl_s.val(s + '%');
      $hsl_l.val(l + '%');
      $hsl_a.val(currentA);
    }
    function getHexFormat() {
      return color.format({
        r: $rgb_r.int(),
        g: $rgb_g.int(),
        b: $rgb_b.int()
      }, 'hex');
    }
    function convertRGB() {
      return color.HSVtoRGB(currentH, currentS, currentV);
    }
    function convertHEX() {
      return color.format(convertRGB(), 'hex');
    }
    function convertHSL() {
      var rgb = color.HSVtoRGB(currentH, currentS, currentV);
      return color.RGBtoHSL(rgb.r, rgb.g, rgb.b);
    }
    function getFormattedColor(format) {
      format = format || 'hex';
      if (format == 'rgb') {
        var rgb = convertRGB();
        rgb.a = currentA == 1 ? undefined : currentA;
        return color.format(rgb, 'rgb');
      } else if (format == 'hsl') {
        var hsl = convertHSL();
        hsl.a = currentA == 1 ? undefined : currentA;
        return color.format(hsl, 'hsl');
      } else {
        var rgb = convertRGB();
        return color.format(rgb, 'hex');
      }
    }
    function setControlColor(color) {
      $controlColor.css('background-color', color);
    }
    function setInputColor() {
      var format = $information.data('format') || 'hex';
      var rgb = null;
      if (format == 'hex') {
        $hexCode.val(convertHEX());
      } else if (format == 'rgb') {
        var rgb = convertRGB();
        setRGBInput(rgb.r, rgb.g, rgb.b);
      } else if (format == 'hsl') {
        var hsl = convertHSL();
        setHSLInput(hsl.h, hsl.s, hsl.l);
      }

      // set background
      setControlColor(getFormattedColor('rgb'));
      var rgb = convertRGB();
      var colorString = color.format(rgb, 'rgb');
      setOpacityColorBar(colorString);
      if (typeof colorpickerCallback == 'function') {
        if (!isNaN(currentA)) {
          colorpickerCallback(getFormattedColor(format));
        }
      }
    }
    function setMainColor(e) {
      e.preventDefault();
      var pos = $root.position(); // position for screen
      var w = $color.width();
      var h = $color.height();
      var x = e.clientX - pos.left;
      var y = e.clientY - pos.top;
      if (x < 0) x = 0;else if (x > w) x = w;
      if (y < 0) y = 0;else if (y > h) y = h;
      $drag_pointer.css({
        left: x - 5 + 'px',
        top: y - 5 + 'px'
      });
      $drag_pointer.data('pos', {
        x: x,
        y: y
      });
      caculateHSV();
      setInputColor();
    }
    function scale(startColor, endColor, t) {
      var obj = {
        r: parseInt(startColor.r + (endColor.r - startColor.r) * t, 10),
        g: parseInt(startColor.g + (endColor.g - startColor.g) * t, 10),
        b: parseInt(startColor.b + (endColor.b - startColor.b) * t, 10)
      };
      return color.format(obj, 'hex');
    }
    function checkHueColor(p) {
      var startColor, endColor;
      for (var i = 0; i < hue_color.length; i++) {
        if (hue_color[i].start >= p) {
          startColor = hue_color[i - 1];
          endColor = hue_color[i];
          break;
        }
      }
      if (startColor && endColor) {
        return scale(startColor, endColor, (p - startColor.start) / (endColor.start - startColor.start));
      }
      return hue_color[0].rgb;
    }
    function setBackgroundColor(color) {
      $color.css("background-color", color);
    }
    function setCurrentH(h) {
      currentH = h;
    }
    function setHueColor(e) {
      var min = $hueContainer.offset().left;
      var max = min + $hueContainer.width();
      var current = e ? pos(e).clientX : min + (max - min) * (currentH / 360);
      var dist;
      if (current < min) {
        dist = 0;
      } else if (current > max) {
        dist = 100;
      } else {
        dist = (current - min) / (max - min) * 100;
      }
      var x = $hueContainer.width() * (dist / 100);
      $drag_bar.css({
        left: x - Math.ceil($drag_bar.width() / 2) + 'px'
      });
      $drag_bar.data('pos', {
        x: x
      });
      var hueColor = checkHueColor(dist / 100);
      setBackgroundColor(hueColor);
      setCurrentH(dist / 100 * 360);
      setInputColor();
    }
    function getCssValuePrefix() {
      var rtrnVal = ''; //default to standard syntax
      var prefixes = ['', '-o-', '-ms-', '-moz-', '-webkit-'];

      // Create a temporary DOM object for testing
      var dom = document.createElement('div');
      for (var i = 0; i < prefixes.length; i++) {
        // Attempt to set the style
        dom.style.background = prefixes[i] + 'linear-gradient(#000000, #ffffff)';

        // Detect if the style was successfully set
        if (dom.style.background) {
          rtrnVal = prefixes[i];
        }
      }
      dom = null;
      // delete dom;

      return rtrnVal;
    }
    function setOpacityColorBar(hueColor) {
      var rgb = color.parse(hueColor);
      rgb.a = 0;
      var start = color.format(rgb, 'rgb');
      rgb.a = 1;
      var end = color.format(rgb, 'rgb');
      var prefix = cssPrefix;
      $opacityColorBar.css('background', 'linear-gradient(to right, ' + start + ', ' + end + ')');
    }
    function setOpacity(e) {
      var min = $opacityContainer.offset().left;
      var max = min + $opacityContainer.width();
      var current = pos(e).clientX;
      var dist;
      if (current < min) {
        dist = 0;
      } else if (current > max) {
        dist = 100;
      } else {
        dist = (current - min) / (max - min) * 100;
      }
      var x = $opacityContainer.width() * (dist / 100);
      $opacity_drag_bar.css({
        left: x - Math.ceil($opacity_drag_bar.width() / 2) + 'px'
      });
      $opacity_drag_bar.data('pos', {
        x: x
      });
      caculateOpacity();
      currentFormat();
      setInputColor();
    }
    function caculateOpacity() {
      var opacityPos = $opacity_drag_bar.data('pos') || {
        x: 0
      };
      var a = Math.round(opacityPos.x / $opacityContainer.width() * 100) / 100;
      currentA = isNaN(a) ? 1 : a;
    }
    function caculateHSV() {
      var pos = $drag_pointer.data('pos') || {
        x: 0,
        y: 0
      };
      var huePos = $drag_bar.data('pos') || {
        x: 0
      };
      var width = $color.width();
      var height = $color.height();
      var h = huePos.x / $hueContainer.width() * 360;
      var s = pos.x / width;
      var v = (height - pos.y) / height;
      if (width == 0) {
        h = 0;
        s = 0;
        v = 0;
      }
      currentH = h;
      currentS = s;
      currentV = v;
    }
    function pos(e) {
      if (e.touches && e.touches[0]) {
        return e.touches[0];
      }
      return e;
    }
    function checkNumberKey(e) {
      var code = e.which,
        isExcept = false;
      if (code == 37 || code == 39 || code == 8 || code == 46 || code == 9) isExcept = true;
      if (!isExcept && (code < 48 || code > 57)) return false;
      return true;
    }
    function setRGBtoHexColor(e) {
      var r = $rgb_r.val(),
        g = $rgb_g.val(),
        b = $rgb_b.val();
      if (r == "" || g == "" || b == "") return;
      if (parseInt(r) > 255) $rgb_r.val(255);else $rgb_r.val(parseInt(r));
      if (parseInt(g) > 255) $rgb_g.val(255);else $rgb_g.val(parseInt(g));
      if (parseInt(b) > 255) $rgb_b.val(255);else $rgb_b.val(parseInt(b));
      initColor(getHexFormat());
    }
    function setColorUI() {
      var x = $color.width() * currentS,
        y = $color.height() * (1 - currentV);
      $drag_pointer.css({
        left: x - 5 + "px",
        top: y - 5 + "px"
      });
      $drag_pointer.data('pos', {
        x: x,
        y: y
      });
      var hueX = $hueContainer.width() * (currentH / 360);
      $drag_bar.css({
        left: hueX - 7.5 + 'px'
      });
      $drag_bar.data('pos', {
        x: hueX
      });
      var opacityX = $opacityContainer.width() * (currentA || 0);
      $opacity_drag_bar.css({
        left: opacityX - 7.5 + 'px'
      });
      $opacity_drag_bar.data('pos', {
        x: opacityX
      });
    }
    function setCurrentHSV(h, s, v, a) {
      currentA = a;
      currentH = h;
      currentS = s;
      currentV = v;
    }
    function setCurrentFormat(format) {
      $information.data('format', format);
      initFormat();
    }
    function initColor(newColor) {
      var c = newColor || "#FF0000",
        colorObj = color.parse(c);
      setCurrentFormat(colorObj.type);
      setBackgroundColor(c);
      var hsv = color.RGBtoHSV(colorObj.r, colorObj.g, colorObj.b);
      setCurrentHSV(hsv.h, hsv.s, hsv.v, colorObj.a);
      setColorUI();
      setHueColor();
      setInputColor();
    }
    function addEvent(dom, eventName, callback) {
      dom.addEventListener(eventName, callback);
    }
    function removeEvent(dom, eventName, callback) {
      dom.removeEventListener(eventName, callback);
    }
    function EventColorMouseDown(e) {
      $color.data('isDown', true);
      setMainColor(e);
    }
    function EventColorMouseUp(e) {
      $color.data('isDown', false);
    }
    function EventDragBarMouseDown(e) {
      e.preventDefault();
      $hue.data('isDown', true);
    }
    function EventOpacityDragBarMouseDown(e) {
      e.preventDefault();
      $opacity.data('isDown', true);
    }
    function EventHueMouseDown(e) {
      $hue.data('isDown', true);
      setHueColor(e);
    }
    function EventOpacityMouseDown(e) {
      $opacity.data('isDown', true);
      setOpacity(e);
    }
    function EventHexCodeKeyDown(e) {
      if (e.which < 65 || e.which > 70) {
        return checkNumberKey(e);
      }
    }
    function EventHexCodeKeyUp(e) {
      var code = $hexCode.val();
      if (code.charAt(0) == '#' && code.length == 7) {
        initColor(code);
      }
    }
    function EventFormatChangeClick(e) {
      nextFormat();
    }
    function initEvent() {
      addEvent($color.el, 'mousedown', EventColorMouseDown);
      addEvent($color.el, 'mouseup', EventColorMouseUp);
      addEvent($drag_bar.el, 'mousedown', EventDragBarMouseDown);
      addEvent($opacity_drag_bar.el, 'mousedown', EventOpacityDragBarMouseDown);
      addEvent($hueContainer.el, 'mousedown', EventHueMouseDown);
      addEvent($opacityContainer.el, 'mousedown', EventOpacityMouseDown);
      addEvent($hexCode.el, 'keydown', EventHexCodeKeyDown);
      addEvent($hexCode.el, 'keyup', EventHexCodeKeyUp);
      addEvent($rgb_r.el, 'keydown', checkNumberKey);
      addEvent($rgb_r.el, 'keyup', setRGBtoHexColor);
      addEvent($rgb_g.el, 'keydown', checkNumberKey);
      addEvent($rgb_g.el, 'keyup', setRGBtoHexColor);
      addEvent($rgb_b.el, 'keydown', checkNumberKey);
      addEvent($rgb_b.el, 'keyup', setRGBtoHexColor);
      addEvent(document, 'mouseup', EventDocumentMouseUp);
      addEvent(document, 'mousemove', EventDocumentMouseMove);
      addEvent($formatChangeButton.el, 'click', EventFormatChangeClick);
    }
    function checkColorPickerClass(el) {
      var hasColorView = new dom(el).closest('codemirror-colorview');
      var hasColorPicker = new dom(el).closest('codemirror-colorpicker');
      var hasCodeMirror = new dom(el).closest('CodeMirror');
      var IsInHtml = el.nodeName == 'HTML';
      return !!(hasColorPicker || hasColorView || hasCodeMirror);
    }
    function checkInHtml(el) {
      var IsInHtml = el.nodeName == 'HTML';
      return IsInHtml;
    }
    function EventDocumentMouseUp(e) {
      $color.data('isDown', false);
      $hue.data('isDown', false);
      $opacity.data('isDown', false);

      // when color picker clicked in outside
      if (checkInHtml(e.target)) {
        //setHideDelay(hideDelay);
      } else if (checkColorPickerClass(e.target) == false) {
        hide();
      }
    }
    function EventDocumentMouseMove(e) {
      if ($color.data('isDown')) {
        setMainColor(e);
      }
      if ($hue.data('isDown')) {
        setHueColor(e);
      }
      if ($opacity.data('isDown')) {
        setOpacity(e);
      }
    }
    function destroy() {
      removeEvent($color.el, 'mousedown', EventColorMouseDown);
      removeEvent($color.el, 'mouseup', EventColorMouseUp);
      removeEvent($drag_bar.el, 'mousedown', EventDragBarMouseDown);
      removeEvent($opacity_drag_bar.el, 'mousedown', EventOpacityDragBarMouseDown);
      removeEvent($hueContainer.el, 'mousedown', EventHueMouseDown);
      removeEvent($opacityContainer.el, 'mousedown', EventOpacityMouseDown);
      removeEvent($hexCode.el, 'keydown', EventHexCodeKeyDown);
      removeEvent($hexCode.el, 'keyup', EventHexCodeKeyUp);
      removeEvent($rgb_r.el, 'keydown', checkNumberKey);
      removeEvent($rgb_r.el, 'keyup', setRGBtoHexColor);
      removeEvent($rgb_g.el, 'keydown', checkNumberKey);
      removeEvent($rgb_g.el, 'keyup', setRGBtoHexColor);
      removeEvent($rgb_b.el, 'keydown', checkNumberKey);
      removeEvent($rgb_b.el, 'keyup', setRGBtoHexColor);
      removeEvent(document, 'mouseup', EventDocumentMouseUp);
      removeEvent(document, 'mousemove', EventDocumentMouseMove);
      removeEvent($formatChangeButton.el, 'click', EventFormatChangeClick);

      // remove color picker callback
      colorpickerCallback = undefined;
    }
    function currentFormat() {
      var current_format = $information.data('format') || 'hex';
      if (currentA < 1 && current_format == 'hex') {
        var next_format = 'rgb';
        $information.removeClass(current_format);
        $information.addClass(next_format);
        $information.data('format', next_format);
        setInputColor();
      }
    }
    function initFormat() {
      var current_format = $information.data('format') || 'hex';
      $information.removeClass('hex');
      $information.removeClass('rgb');
      $information.removeClass('hsl');
      $information.addClass(current_format);
    }
    function nextFormat() {
      var current_format = $information.data('format') || 'hex';
      var next_format = 'hex';
      if (current_format == 'hex') {
        next_format = 'rgb';
      } else if (current_format == 'rgb') {
        next_format = 'hsl';
      } else if (current_format == 'hsl') {
        if (currentA == 1) {
          next_format = 'hex';
        } else {
          next_format = 'rgb';
        }
      }
      $information.removeClass(current_format);
      $information.addClass(next_format);
      $information.data('format', next_format);
      setInputColor();
    }
    function makeInputField(type) {
      var item = new dom('div', 'information-item ' + type);
      if (type == 'hex') {
        var field = new dom('div', 'input-field hex');
        $hexCode = new dom('input', 'input', {
          type: 'text'
        });
        field.append($hexCode);
        field.append(new dom('div', 'title').html('HEX'));
        item.append(field);
      } else if (type == 'rgb') {
        var field = new dom('div', 'input-field rgb-r');
        $rgb_r = new dom('input', 'input', {
          type: 'text'
        });
        field.append($rgb_r);
        field.append(new dom('div', 'title').html('R'));
        item.append(field);
        field = new dom('div', 'input-field rgb-g');
        $rgb_g = new dom('input', 'input', {
          type: 'text'
        });
        field.append($rgb_g);
        field.append(new dom('div', 'title').html('G'));
        item.append(field);
        field = new dom('div', 'input-field rgb-b');
        $rgb_b = new dom('input', 'input', {
          type: 'text'
        });
        field.append($rgb_b);
        field.append(new dom('div', 'title').html('B'));
        item.append(field);

        // rgba
        field = new dom('div', 'input-field rgb-a');
        $rgb_a = new dom('input', 'input', {
          type: 'text'
        });
        field.append($rgb_a);
        field.append(new dom('div', 'title').html('A'));
        item.append(field);
      } else if (type == 'hsl') {
        var field = new dom('div', 'input-field hsl-h');
        $hsl_h = new dom('input', 'input', {
          type: 'text'
        });
        field.append($hsl_h);
        field.append(new dom('div', 'title').html('H'));
        item.append(field);
        field = new dom('div', 'input-field hsl-s');
        $hsl_s = new dom('input', 'input', {
          type: 'text'
        });
        field.append($hsl_s);
        field.append(new dom('div', 'title').html('S'));
        item.append(field);
        field = new dom('div', 'input-field hsl-l');
        $hsl_l = new dom('input', 'input', {
          type: 'text'
        });
        field.append($hsl_l);
        field.append(new dom('div', 'title').html('L'));
        item.append(field);

        // rgba
        field = new dom('div', 'input-field hsl-a');
        $hsl_a = new dom('input', 'input', {
          type: 'text'
        });
        field.append($hsl_a);
        field.append(new dom('div', 'title').html('A'));
        item.append(field);
      }
      return item;
    }
    function init() {
      $body = new dom(document.body);
      $root = new dom('div', 'codemirror-colorpicker');
      $color = new dom('div', 'color');
      $drag_pointer = new dom('div', 'drag-pointer');
      $value = new dom('div', 'value');
      $saturation = new dom('div', 'saturation');
      $control = new dom('div', 'control');
      $controlPattern = new dom('div', 'empty');
      $controlColor = new dom('div', 'color');
      $hue = new dom('div', 'hue');
      $hueContainer = new dom('div', 'hue-container');
      $drag_bar = new dom('div', 'drag-bar');
      $opacity = new dom('div', 'opacity');
      $opacityContainer = new dom('div', 'opacity-container');
      $opacityColorBar = new dom('div', 'color-bar');
      $opacity_drag_bar = new dom('div', 'drag-bar2');
      $information = new dom('div', 'information hex');
      $informationChange = new dom('div', 'information-change');
      $formatChangeButton = new dom('button', 'format-change-button', {
        type: 'button'
      }).html('↔');
      $informationChange.append($formatChangeButton);
      $information.append(makeInputField('hex'));
      $information.append(makeInputField('rgb'));
      $information.append(makeInputField('hsl'));
      $information.append($informationChange);
      $value.append($drag_pointer);
      $saturation.append($value);
      $color.append($saturation);
      $hueContainer.append($drag_bar);
      $hue.append($hueContainer);
      $opacityContainer.append($opacityColorBar);
      $opacityContainer.append($opacity_drag_bar);
      $opacity.append($opacityContainer);
      $control.append($hue);
      $control.append($opacity);
      $control.append($controlPattern);
      $control.append($controlColor);
      $root.append($color);
      $root.append($control);
      $root.append($information);
      initHueColors();
      //initEvent();
      initColor();
    }
    ;
    function initHueColors() {
      for (var i = 0, len = hue_color.length; i < len; i++) {
        var hue = hue_color[i];
        var obj = color.parse(hue.rgb);
        hue.r = obj.r;
        hue.g = obj.g;
        hue.b = obj.b;
      }
    }

    /**
     * public methods
     */
    function setColor(value) {
      if (typeof value == "object") {
        if (!value.r || !value.g || !value.b) return;
        initColor(color.format(value, "hex"));
      } else if (typeof value == "string") {
        if (value.charAt(0) != "#") return;
        initColor(value);
      }
    }
    function getColor(type) {
      caculateHSV();
      var rgb = convertRGB();
      if (type) {
        return color.format(rgb, type);
      }
      return rgb;
    }
    function definePostion(opt) {
      var width = $root.width();
      var height = $root.height();

      // set left position for color picker
      var elementScreenLeft = opt.left - $body.el.scrollLeft;
      if (width + elementScreenLeft > window.innerWidth) {
        elementScreenLeft -= width + elementScreenLeft - window.innerWidth;
      }
      if (elementScreenLeft < 0) {
        elementScreenLeft = 0;
      }

      // set top position for color picker
      var elementScreenTop = opt.top - $body.el.scrollTop;
      if (height + elementScreenTop > window.innerHeight) {
        elementScreenTop -= height + elementScreenTop - window.innerHeight;
      }
      if (elementScreenTop < 0) {
        elementScreenTop = 0;
      }

      // set position
      $root.css({
        left: elementScreenLeft + 'px',
        top: elementScreenTop + 'px'
      });
    }
    function show(opt, color, callback) {
      destroy();
      initEvent();
      $root.appendTo(document.body);
      $root.css({
        position: 'fixed',
        // color picker has fixed position
        left: '-10000px',
        top: '-10000px'
      });
      $root.show();
      definePostion(opt);
      isColorPickerShow = true;
      isShortCut = opt.isShortCut || false;
      initColor(color);

      // define colorpicker callback
      colorpickerCallback = function (colorString) {
        callback(colorString);
      };

      // define hide delay
      hideDelay = opt.hideDelay || 2000;
      if (hideDelay > 0) {
        setHideDelay(hideDelay);
      }
    }
    var timerCloseColorPicker;
    function setHideDelay(delayTime) {
      delayTime = delayTime || 0;
      removeEvent($root.el, 'mouseenter');
      removeEvent($root.el, 'mouseleave');
      addEvent($root.el, 'mouseenter', function () {
        clearTimeout(timerCloseColorPicker);
      });
      addEvent($root.el, 'mouseleave', function () {
        clearTimeout(timerCloseColorPicker);
        timerCloseColorPicker = setTimeout(hide, delayTime);
      });
      clearTimeout(timerCloseColorPicker);
      timerCloseColorPicker = setTimeout(hide, delayTime);
    }
    function hide() {
      if (isColorPickerShow) {
        destroy();
        $root.hide();
        $root.remove();
        isColorPickerShow = false;
      }
    }
    init();
    return {
      isShortCut: function () {
        return isShortCut;
      },
      $root: $root,
      show: show,
      hide: hide,
      setColor: setColor,
      getColor: getColor
    };
  });
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/colorpicker/colorview_customized.js":
/*!********************************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/colorpicker/colorview_customized.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

(function (mod) {
  if (true)
    // CommonJS
    mod(__webpack_require__(/*! codemirror */ "../node_modules/codemirror/lib/codemirror.js"));else {}
})(function (CodeMirror) {
  "use strict";

  // color names
  var color_names = {
    aliceblue: "rgb(240, 248, 255)",
    antiquewhite: "rgb(250, 235, 215)",
    aqua: "rgb(0, 255, 255)",
    aquamarine: "rgb(127, 255, 212)",
    azure: "rgb(240, 255, 255)",
    beige: "rgb(245, 245, 220)",
    bisque: "rgb(255, 228, 196)",
    black: "rgb(0, 0, 0)",
    blanchedalmond: "rgb(255, 235, 205)",
    blue: "rgb(0, 0, 255)",
    blueviolet: "rgb(138, 43, 226)",
    brown: "rgb(165, 42, 42)",
    burlywood: "rgb(222, 184, 135)",
    cadetblue: "rgb(95, 158, 160)",
    chartreuse: "rgb(127, 255, 0)",
    chocolate: "rgb(210, 105, 30)",
    coral: "rgb(255, 127, 80)",
    cornflowerblue: "rgb(100, 149, 237)",
    cornsilk: "rgb(255, 248, 220)",
    crimson: "rgb(237, 20, 61)",
    cyan: "rgb(0, 255, 255)",
    darkblue: "rgb(0, 0, 139)",
    darkcyan: "rgb(0, 139, 139)",
    darkgoldenrod: "rgb(184, 134, 11)",
    darkgray: "rgb(169, 169, 169)",
    darkgrey: "rgb(169, 169, 169)",
    darkgreen: "rgb(0, 100, 0)",
    darkkhaki: "rgb(189, 183, 107)",
    darkmagenta: "rgb(139, 0, 139)",
    darkolivegreen: "rgb(85, 107, 47)",
    darkorange: "rgb(255, 140, 0)",
    darkorchid: "rgb(153, 50, 204)",
    darkred: "rgb(139, 0, 0)",
    darksalmon: "rgb(233, 150, 122)",
    darkseagreen: "rgb(143, 188, 143)",
    darkslateblue: "rgb(72, 61, 139)",
    darkslategray: "rgb(47, 79, 79)",
    darkslategrey: "rgb(47, 79, 79)",
    darkturquoise: "rgb(0, 206, 209)",
    darkviolet: "rgb(148, 0, 211)",
    deeppink: "rgb(255, 20, 147)",
    deepskyblue: "rgb(0, 191, 255)",
    dimgray: "rgb(105, 105, 105)",
    dimgrey: "rgb(105, 105, 105)",
    dodgerblue: "rgb(30, 144, 255)",
    firebrick: "rgb(178, 34, 34)",
    floralwhite: "rgb(255, 250, 240)",
    forestgreen: "rgb(34, 139, 34)",
    fuchsia: "rgb(255, 0, 255)",
    gainsboro: "rgb(220, 220, 220)",
    ghostwhite: "rgb(248, 248, 255)",
    gold: "rgb(255, 215, 0)",
    goldenrod: "rgb(218, 165, 32)",
    gray: "rgb(128, 128, 128)",
    grey: "rgb(128, 128, 128)",
    green: "rgb(0, 128, 0)",
    greenyellow: "rgb(173, 255, 47)",
    honeydew: "rgb(240, 255, 240)",
    hotpink: "rgb(255, 105, 180)",
    indianred: "rgb(205, 92, 92)",
    indigo: "rgb(75, 0, 130)",
    ivory: "rgb(255, 255, 240)",
    khaki: "rgb(240, 230, 140)",
    lavender: "rgb(230, 230, 250)",
    lavenderblush: "rgb(255, 240, 245)",
    lawngreen: "rgb(124, 252, 0)",
    lemonchiffon: "rgb(255, 250, 205)",
    lightblue: "rgb(173, 216, 230)",
    lightcoral: "rgb(240, 128, 128)",
    lightcyan: "rgb(224, 255, 255)",
    lightgoldenrodyellow: "rgb(250, 250, 210)",
    lightgreen: "rgb(144, 238, 144)",
    lightgray: "rgb(211, 211, 211)",
    lightgrey: "rgb(211, 211, 211)",
    lightpink: "rgb(255, 182, 193)",
    lightsalmon: "rgb(255, 160, 122)",
    lightseagreen: "rgb(32, 178, 170)",
    lightskyblue: "rgb(135, 206, 250)",
    lightslategray: "rgb(119, 136, 153)",
    lightslategrey: "rgb(119, 136, 153)",
    lightsteelblue: "rgb(176, 196, 222)",
    lightyellow: "rgb(255, 255, 224)",
    lime: "rgb(0, 255, 0)",
    limegreen: "rgb(50, 205, 50)",
    linen: "rgb(250, 240, 230)",
    magenta: "rgb(255, 0, 255)",
    maroon: "rgb(128, 0, 0)",
    mediumaquamarine: "rgb(102, 205, 170)",
    mediumblue: "rgb(0, 0, 205)",
    mediumorchid: "rgb(186, 85, 211)",
    mediumpurple: "rgb(147, 112, 219)",
    mediumseagreen: "rgb(60, 179, 113)",
    mediumslateblue: "rgb(123, 104, 238)",
    mediumspringgreen: "rgb(0, 250, 154)",
    mediumturquoise: "rgb(72, 209, 204)",
    mediumvioletred: "rgb(199, 21, 133)",
    midnightblue: "rgb(25, 25, 112)",
    mintcream: "rgb(245, 255, 250)",
    mistyrose: "rgb(255, 228, 225)",
    moccasin: "rgb(255, 228, 181)",
    navajowhite: "rgb(255, 222, 173)",
    navy: "rgb(0, 0, 128)",
    oldlace: "rgb(253, 245, 230)",
    olive: "rgb(128, 128, 0)",
    olivedrab: "rgb(107, 142, 35)",
    orange: "rgb(255, 165, 0)",
    orangered: "rgb(255, 69, 0)",
    orchid: "rgb(218, 112, 214)",
    palegoldenrod: "rgb(238, 232, 170)",
    palegreen: "rgb(152, 251, 152)",
    paleturquoise: "rgb(175, 238, 238)",
    palevioletred: "rgb(219, 112, 147)",
    papayawhip: "rgb(255, 239, 213)",
    peachpuff: "rgb(255, 218, 185)",
    peru: "rgb(205, 133, 63)",
    pink: "rgb(255, 192, 203)",
    plum: "rgb(221, 160, 221)",
    powderblue: "rgb(176, 224, 230)",
    purple: "rgb(128, 0, 128)",
    rebeccapurple: "rgb(102, 51, 153)",
    red: "rgb(255, 0, 0)",
    rosybrown: "rgb(188, 143, 143)",
    royalblue: "rgb(65, 105, 225)",
    saddlebrown: "rgb(139, 69, 19)",
    salmon: "rgb(250, 128, 114)",
    sandybrown: "rgb(244, 164, 96)",
    seagreen: "rgb(46, 139, 87)",
    seashell: "rgb(255, 245, 238)",
    sienna: "rgb(160, 82, 45)",
    silver: "rgb(192, 192, 192)",
    skyblue: "rgb(135, 206, 235)",
    slateblue: "rgb(106, 90, 205)",
    slategray: "rgb(112, 128, 144)",
    slategrey: "rgb(112, 128, 144)",
    snow: "rgb(255, 250, 250)",
    springgreen: "rgb(0, 255, 127)",
    steelblue: "rgb(70, 130, 180)",
    tan: "rgb(210, 180, 140)",
    teal: "rgb(0, 128, 128)",
    thistle: "rgb(216, 191, 216)",
    tomato: "rgb(255, 99, 71)",
    turquoise: "rgb(64, 224, 208)",
    violet: "rgb(238, 130, 238)",
    wheat: "rgb(245, 222, 179)",
    white: "rgb(255, 255, 255)",
    whitesmoke: "rgb(245, 245, 245)",
    yellow: "rgb(255, 255, 0)",
    yellowgreen: "rgb(154, 205, 50)",
    transparent: "rgba(0, 0, 0, 0)"
  };
  var colorpicker_class = 'codemirror-colorview';
  var colorpicker_background_class = 'codemirror-colorview-background';

  // Excluded tokens do not show color views..
  var excluded_token = ['comment', 'builtin'];
  CodeMirror.defineOption("colorpicker", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      if (cm.state.colorpicker) {
        cm.state.colorpicker.destroy();
        cm.state.colorpicker = null;
      }
      // remove event listener
    }

    if (val) {
      cm.state.colorpicker = new codemirror_colorpicker(cm, val);
    }
  });
  function onChange(cm, evt) {
    if (evt.origin == 'setValue') {
      // if content is changed by setValue method, it initialize markers
      cm.state.colorpicker.close_color_picker();
      cm.state.colorpicker.init_color_update();
      cm.state.colorpicker.style_color_update();
    } else {
      cm.state.colorpicker.style_color_update(cm.getCursor().line);
    }
  }
  function onUpdate(cm, evt) {
    if (!cm.state.colorpicker.isUpdate) {
      cm.state.colorpicker.isUpdate = true;
      cm.state.colorpicker.close_color_picker();
      cm.state.colorpicker.init_color_update();
      cm.state.colorpicker.style_color_update();
    }
  }
  function onRefresh(cm, evt) {
    onChange(cm, {
      origin: 'setValue'
    });
  }
  function onKeyup(cm, evt) {
    cm.state.colorpicker.keyup(evt);
  }
  function onMousedown(cm, evt) {
    if (cm.state.colorpicker.is_edit_mode()) {
      cm.state.colorpicker.check_mousedown(evt);
    }
  }
  function onPaste(cm, evt) {
    onChange(cm, {
      origin: 'setValue'
    });
  }
  function onScroll(cm) {
    cm.state.colorpicker.close_color_picker();
  }
  function debounce(callback, delay) {
    var t = undefined;
    return function (cm, e) {
      if (t) {
        clearTimeout(t);
      }
      t = setTimeout(function () {
        callback(cm, e);
      }, delay || 300);
    };
  }
  function has_class(el, cls) {
    if (!el || !el.className) {
      return false;
    } else {
      var newClass = ' ' + el.className + ' ';
      return newClass.indexOf(' ' + cls + ' ') > -1;
    }
  }
  function codemirror_colorpicker(cm, opt) {
    var self = this;
    if (typeof opt == 'boolean') {
      opt = {
        mode: 'view'
      };
    } else {
      opt = Object.assign({
        mode: 'view'
      }, opt || {});
    }
    this.opt = opt;
    this.cm = cm;
    this.markers = {};

    // set excluded token 
    excluded_token = this.opt.excluded_token || excluded_token;
    if (this.cm.colorpicker) {
      this.colorpicker = this.cm.colorpicker();
    } else if (this.opt.colorpicker) {
      this.colorpicker = this.opt.colorpicker;
    }
    this.init_event();
  }
  codemirror_colorpicker.prototype.init_event = function () {
    this.cm.on('mousedown', onMousedown);
    this.cm.on('keyup', onKeyup);
    this.cm.on('change', onChange);
    this.cm.on('update', onUpdate);
    this.cm.on('refresh', onRefresh);

    // create paste callback
    this.onPasteCallback = function (cm, callback) {
      return function (evt) {
        callback.call(this, cm, evt);
      };
    }(this.cm, onPaste);
    this.cm.getWrapperElement().addEventListener('paste', this.onPasteCallback);
    if (this.is_edit_mode()) {
      this.cm.on('scroll', debounce(onScroll, 50));
    }
  };
  codemirror_colorpicker.prototype.is_edit_mode = function () {
    return this.opt.mode == 'edit';
  };
  codemirror_colorpicker.prototype.is_view_mode = function () {
    return this.opt.mode == 'view';
  };
  codemirror_colorpicker.prototype.destroy = function () {
    this.cm.off('mousedown', onMousedown);
    this.cm.off('keyup', onKeyup);
    this.cm.off('change', onChange);
    this.cm.getWrapperElement().removeEventListener('paste', this.onPasteCallback);
    if (this.is_edit_mode()) {
      this.cm.off('scroll');
    }
  };
  codemirror_colorpicker.prototype.hasClass = function (el, className) {
    if (!el.className) {
      return false;
    } else {
      var newClass = ' ' + el.className + ' ';
      return newClass.indexOf(' ' + className + ' ') > -1;
    }
  };
  codemirror_colorpicker.prototype.check_mousedown = function (evt) {
    if (this.hasClass(evt.target, colorpicker_background_class)) {
      this.open_color_picker(evt.target.parentNode);
    } else {
      this.close_color_picker();
    }
  };
  codemirror_colorpicker.prototype.popup_color_picker = function (defalutColor) {
    var cursor = this.cm.getCursor();
    var self = this;
    var colorMarker = {
      lineNo: cursor.line,
      ch: cursor.ch,
      color: defalutColor || '#FFFFFF',
      isShortCut: true
    };
    Object.keys(this.markers).forEach(function (key) {
      var searchKey = "#" + key;
      if (searchKey.indexOf("#" + colorMarker.lineNo + ":") > -1) {
        var marker = self.markers[key];
        if (marker.ch <= colorMarker.ch && colorMarker.ch <= marker.ch + marker.color.length) {
          // when cursor has marker
          colorMarker.ch = marker.ch;
          colorMarker.color = marker.color;
          colorMarker.nameColor = marker.nameColor;
        }
      }
    });
    this.open_color_picker(colorMarker);
  };
  codemirror_colorpicker.prototype.open_color_picker = function (el) {
    var lineNo = el.lineNo;
    var ch = el.ch;
    var nameColor = el.nameColor;
    var color = el.color;
    if (this.colorpicker) {
      var self = this;
      var prevColor = color;
      var pos = this.cm.charCoords({
        line: lineNo,
        ch: ch
      });
      this.colorpicker.show({
        left: pos.left,
        top: pos.bottom,
        isShortCut: el.isShortCut || false,
        hideDelay: self.opt.hideDelay || 2000
      }, nameColor || color, function (newColor) {
        self.cm.replaceRange(newColor, {
          line: lineNo,
          ch: ch
        }, {
          line: lineNo,
          ch: ch + prevColor.length
        }, '*colorpicker');
        prevColor = newColor;
      });
    }
  };
  codemirror_colorpicker.prototype.close_color_picker = function (el) {
    if (this.colorpicker) {
      this.colorpicker.hide();
    }
  };
  codemirror_colorpicker.prototype.key = function (lineNo, ch) {
    return [lineNo, ch].join(":");
  };
  codemirror_colorpicker.prototype.keyup = function (evt) {
    if (this.colorpicker) {
      if (evt.key == 'Escape') {
        this.colorpicker.hide();
      } else if (this.colorpicker.isShortCut() == false) {
        this.colorpicker.hide();
      }
    }
  };
  codemirror_colorpicker.prototype.init_color_update = function () {
    this.markers = {}; // initialize marker list
  };

  codemirror_colorpicker.prototype.style_color_update = function (lineHandle) {
    if (lineHandle) {
      this.match(lineHandle);
    } else {
      var max = this.cm.lineCount();
      for (var lineNo = 0; lineNo < max; lineNo++) {
        this.match(lineNo);
      }
    }
  };
  codemirror_colorpicker.prototype.empty_marker = function (lineNo, lineHandle) {
    var list = lineHandle.markedSpans || [];
    for (var i = 0, len = list.length; i < len; i++) {
      var key = this.key(lineNo, list[i].from);
      if (key && has_class(list[i].marker.replacedWith, colorpicker_class)) {
        delete this.markers[key];
        list[i].marker.clear();
      }
    }
  };
  codemirror_colorpicker.prototype.color_regexp = /(#(?:[\da-f]{3}){1,2}|rgb\((?:\s*\d{1,3},\s*){2}\d{1,3}\s*\)|rgba\((?:\s*\d{1,3},\s*){3}\d*\.?\d+\s*\)|hsl\(\s*\d{1,3}(?:,\s*\d{1,3}%){2}\s*\)|hsla\(\s*\d{1,3}(?:,\s*\d{1,3}%){2},\s*\d*\.?\d+\s*\)|([\w_\-]+))/gi;
  codemirror_colorpicker.prototype.match_result = function (lineHandle) {
    return lineHandle.text.match(this.color_regexp);
  };
  codemirror_colorpicker.prototype.submatch = function (lineNo, lineHandle) {
    this.empty_marker(lineNo, lineHandle);
    var result = this.match_result(lineHandle);
    if (result && result.length) {
      var obj = {
        next: 0
      };
      for (var i = 0, len = result.length; i < len; i++) {
        if (result[i].indexOf('#') > -1 || result[i].indexOf('rgb') > -1 || result[i].indexOf('hsl') > -1) {
          this.render(obj, lineNo, lineHandle, result[i]);
        } else {
          var nameColor = color_names[result[i]];
          if (nameColor) {
            this.render(obj, lineNo, lineHandle, result[i], nameColor);
          }
        }
      }
    }
  };
  codemirror_colorpicker.prototype.match = function (lineNo) {
    var lineHandle = this.cm.getLineHandle(lineNo);
    var self = this;
    this.cm.operation(function () {
      self.submatch(lineNo, lineHandle);
    });
  };
  codemirror_colorpicker.prototype.make_element = function () {
    var el = document.createElement('div');
    el.className = colorpicker_class;
    if (this.is_edit_mode()) {
      el.title = "open color picker";
    } else {
      el.title = "";
    }
    el.back_element = this.make_background_element();
    el.appendChild(el.back_element);
    return el;
  };
  codemirror_colorpicker.prototype.make_background_element = function () {
    var el = document.createElement('div');
    el.className = colorpicker_background_class;
    return el;
  };
  codemirror_colorpicker.prototype.set_state = function (lineNo, start, color, nameColor) {
    var marker = this.create_marker(lineNo, start);
    marker.lineNo = lineNo;
    marker.ch = start;
    marker.color = color;
    marker.nameColor = nameColor;
    return marker;
  };
  codemirror_colorpicker.prototype.create_marker = function (lineNo, start) {
    var key = this.key(lineNo, start);
    if (!this.markers[key]) {
      this.markers[key] = this.make_element();
    }
    return this.markers[key];
  };
  codemirror_colorpicker.prototype.has_marker = function (lineNo, start) {
    var key = this.key(lineNo, start);
    return !!this.markers[key];
  };
  codemirror_colorpicker.prototype.update_element = function (el, color) {
    el.back_element.style.backgroundColor = color;
  };
  codemirror_colorpicker.prototype.set_mark = function (line, ch, el) {
    this.cm.setBookmark({
      line: line,
      ch: ch
    }, {
      widget: el,
      handleMouseEvents: true
    });
  };
  codemirror_colorpicker.prototype.is_excluded_token = function (line, ch) {
    var token = this.cm.getTokenAt({
      line: line,
      ch: ch
    }, true);
    var type = token.type;
    var state = token.state.state;
    if (type == null && state == 'block') return true;
    if (type == null && state == 'top') return true;
    // if (type == null && state == 'prop')  return true;

    var count = 0;
    for (var i = 0, len = excluded_token.length; i < len; i++) {
      if (type === excluded_token[i]) {
        count++;
        break;
      }
    }
    return count > 0; // true is that it has a excluded token 
  };

  codemirror_colorpicker.prototype.render = function (cursor, lineNo, lineHandle, color, nameColor) {
    var start = lineHandle.text.indexOf(color, cursor.next);
    if (this.is_excluded_token(lineNo, start) === true) {
      // excluded token do not show.
      return;
    }
    cursor.next = start + color.length;
    if (this.has_marker(lineNo, start)) {
      this.update_element(this.create_marker(lineNo, start), nameColor || color);
      this.set_state(lineNo, start, color, nameColor);
      return;
    }
    var el = this.create_marker(lineNo, start);
    this.update_element(el, nameColor || color);
    this.set_state(lineNo, start, color, nameColor || color);
    this.set_mark(lineNo, start, el);
  };
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/comment/comment.js":
/*!***************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/comment/comment.js ***!
  \***************************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var noOptions = {};
  var nonWS = /[^\s\u00a0]/;
  var Pos = CodeMirror.Pos;
  function firstNonWS(str) {
    var found = str.search(nonWS);
    return found == -1 ? 0 : found;
  }
  CodeMirror.commands.toggleComment = function (cm) {
    cm.toggleComment();
  };
  CodeMirror.defineExtension("toggleComment", function (options) {
    if (!options) options = noOptions;
    var cm = this;
    var minLine = Infinity,
      ranges = this.listSelections(),
      mode = null;
    for (var i = ranges.length - 1; i >= 0; i--) {
      var from = ranges[i].from(),
        to = ranges[i].to();
      if (from.line >= minLine) continue;
      if (to.line >= minLine) to = Pos(minLine, 0);
      minLine = from.line;
      if (mode == null) {
        if (cm.uncomment(from, to, options)) mode = "un";else {
          cm.lineComment(from, to, options);
          mode = "line";
        }
      } else if (mode == "un") {
        cm.uncomment(from, to, options);
      } else {
        cm.lineComment(from, to, options);
      }
    }
  });

  // Rough heuristic to try and detect lines that are part of multi-line string
  function probablyInsideString(cm, pos, line) {
    return /\bstring\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\'\"\`]/.test(line);
  }
  function getMode(cm, pos) {
    var mode = cm.getMode();
    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos);
  }
  CodeMirror.defineExtension("lineComment", function (from, to, options) {
    if (!options) options = noOptions;
    var self = this,
      mode = getMode(self, from);
    var firstLine = self.getLine(from.line);
    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;
    var commentString = options.lineComment || mode.lineComment;
    if (!commentString) {
      if (options.blockCommentStart || mode.blockCommentStart) {
        options.fullLines = true;
        self.blockComment(from, to, options);
      }
      return;
    }
    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);
    var pad = options.padding == null ? " " : options.padding;
    var blankLines = options.commentBlankLines || from.line == to.line;
    self.operation(function () {
      if (options.indent) {
        var baseString = null;
        for (var i = from.line; i < end; ++i) {
          var line = self.getLine(i);
          var whitespace = line.slice(0, firstNonWS(line));
          if (baseString == null || baseString.length > whitespace.length) {
            baseString = whitespace;
          }
        }
        for (var i = from.line; i < end; ++i) {
          var line = self.getLine(i),
            cut = baseString.length;
          if (!blankLines && !nonWS.test(line)) continue;
          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);
          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
        }
      } else {
        for (var i = from.line; i < end; ++i) {
          if (blankLines || nonWS.test(self.getLine(i))) self.replaceRange(commentString + pad, Pos(i, 0));
        }
      }
    });
  });
  CodeMirror.defineExtension("blockComment", function (from, to, options) {
    if (!options) options = noOptions;
    var self = this,
      mode = getMode(self, from);
    var startString = options.blockCommentStart || mode.blockCommentStart;
    var endString = options.blockCommentEnd || mode.blockCommentEnd;
    if (!startString || !endString) {
      if ((options.lineComment || mode.lineComment) && options.fullLines != false) self.lineComment(from, to, options);
      return;
    }
    if (/\bcomment\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return;
    var end = Math.min(to.line, self.lastLine());
    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;
    var pad = options.padding == null ? " " : options.padding;
    if (from.line > end) return;
    self.operation(function () {
      if (options.fullLines != false) {
        var lastLineHasText = nonWS.test(self.getLine(end));
        self.replaceRange(pad + endString, Pos(end));
        self.replaceRange(startString + pad, Pos(from.line, 0));
        var lead = options.blockCommentLead || mode.blockCommentLead;
        if (lead != null) for (var i = from.line + 1; i <= end; ++i) if (i != end || lastLineHasText) self.replaceRange(lead + pad, Pos(i, 0));
      } else {
        self.replaceRange(endString, to);
        self.replaceRange(startString, from);
      }
    });
  });
  CodeMirror.defineExtension("uncomment", function (from, to, options) {
    if (!options) options = noOptions;
    var self = this,
      mode = getMode(self, from);
    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()),
      start = Math.min(from.line, end);

    // Try finding line comments
    var lineString = options.lineComment || mode.lineComment,
      lines = [];
    var pad = options.padding == null ? " " : options.padding,
      didSomething;
    lineComment: {
      if (!lineString) break lineComment;
      for (var i = start; i <= end; ++i) {
        var line = self.getLine(i);
        var found = line.indexOf(lineString);
        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;
        if (found == -1 && nonWS.test(line)) break lineComment;
        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;
        lines.push(line);
      }
      self.operation(function () {
        for (var i = start; i <= end; ++i) {
          var line = lines[i - start];
          var pos = line.indexOf(lineString),
            endPos = pos + lineString.length;
          if (pos < 0) continue;
          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
          didSomething = true;
          self.replaceRange("", Pos(i, pos), Pos(i, endPos));
        }
      });
      if (didSomething) return true;
    }

    // Try block comments
    var startString = options.blockCommentStart || mode.blockCommentStart;
    var endString = options.blockCommentEnd || mode.blockCommentEnd;
    if (!startString || !endString) return false;
    var lead = options.blockCommentLead || mode.blockCommentLead;
    var startLine = self.getLine(start),
      open = startLine.indexOf(startString);
    if (open == -1) return false;
    var endLine = end == start ? startLine : self.getLine(end);
    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);
    var insideStart = Pos(start, open + 1),
      insideEnd = Pos(end, close + 1);
    if (close == -1 || !/comment/.test(self.getTokenTypeAt(insideStart)) || !/comment/.test(self.getTokenTypeAt(insideEnd)) || self.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1) return false;

    // Avoid killing block comments completely outside the selection.
    // Positions of the last startString before the start of the selection, and the first endString after it.
    var lastStart = startLine.lastIndexOf(startString, from.ch);
    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;
    // Positions of the first endString after the end of the selection, and the last startString before it.
    firstEnd = endLine.indexOf(endString, to.ch);
    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
    lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;
    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;
    self.operation(function () {
      self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end, close + endString.length));
      var openEnd = open + startString.length;
      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;
      self.replaceRange("", Pos(start, open), Pos(start, openEnd));
      if (lead) for (var i = start + 1; i <= end; ++i) {
        var line = self.getLine(i),
          found = line.indexOf(lead);
        if (found == -1 || nonWS.test(line.slice(0, found))) continue;
        var foundEnd = found + lead.length;
        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;
        self.replaceRange("", Pos(i, found), Pos(i, foundEnd));
      }
    });
    return true;
  });
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/display/placeholder.js":
/*!*******************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/display/placeholder.js ***!
  \*******************************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  CodeMirror.defineOption("placeholder", "", function (cm, val, old) {
    var prev = old && old != CodeMirror.Init;
    if (val && !prev) {
      cm.on("blur", onBlur);
      cm.on("change", onChange);
      cm.on("swapDoc", onChange);
      onChange(cm);
    } else if (!val && prev) {
      cm.off("blur", onBlur);
      cm.off("change", onChange);
      cm.off("swapDoc", onChange);
      clearPlaceholder(cm);
      var wrapper = cm.getWrapperElement();
      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
    }
    if (val && !cm.hasFocus()) onBlur(cm);
  });
  function clearPlaceholder(cm) {
    if (cm.state.placeholder) {
      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
      cm.state.placeholder = null;
    }
  }
  function setPlaceholder(cm) {
    clearPlaceholder(cm);
    var elt = cm.state.placeholder = document.createElement("pre");
    elt.style.cssText = "height: 0; overflow: visible";
    elt.style.direction = cm.getOption("direction");
    elt.className = "CodeMirror-placeholder";
    var placeHolder = cm.getOption("placeholder");
    if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder);
    elt.appendChild(placeHolder);
    cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
  }
  function onBlur(cm) {
    if (isEmpty(cm)) setPlaceholder(cm);
  }
  function onChange(cm) {
    var wrapper = cm.getWrapperElement(),
      empty = isEmpty(cm);
    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");
    if (empty) setPlaceholder(cm);else clearPlaceholder(cm);
  }
  function isEmpty(cm) {
    return cm.lineCount() === 1 && cm.getLine(0) === "";
  }
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/edit/closebrackets.js":
/*!******************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/edit/closebrackets.js ***!
  \******************************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  var defaults = {
    pairs: "()[]{}''\"\"",
    triples: "",
    explode: "[]{}"
  };
  var Pos = CodeMirror.Pos;
  CodeMirror.defineOption("autoCloseBrackets", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.removeKeyMap(keyMap);
      cm.state.closeBrackets = null;
    }
    if (val) {
      ensureBound(getOption(val, "pairs"));
      cm.state.closeBrackets = val;
      cm.addKeyMap(keyMap);
    }
  });
  function getOption(conf, name) {
    if (name == "pairs" && typeof conf == "string") return conf;
    if (typeof conf == "object" && conf[name] != null) return conf[name];
    return defaults[name];
  }
  var keyMap = {
    Backspace: handleBackspace,
    Enter: handleEnter
  };
  function ensureBound(chars) {
    for (var i = 0; i < chars.length; i++) {
      var ch = chars.charAt(i),
        key = "'" + ch + "'";
      if (!keyMap[key]) keyMap[key] = handler(ch);
    }
  }
  ensureBound(defaults.pairs + "`");
  function handler(ch) {
    return function (cm) {
      return handleChar(cm, ch);
    };
  }
  function getConfig(cm) {
    var deflt = cm.state.closeBrackets;
    if (!deflt || deflt.override) return deflt;
    var mode = cm.getModeAt(cm.getCursor());
    return mode.closeBrackets || deflt;
  }
  function handleBackspace(cm) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
    var pairs = getOption(conf, "pairs");
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    for (var i = ranges.length - 1; i >= 0; i--) {
      var cur = ranges[i].head;
      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
    }
  }
  function handleEnter(cm) {
    var conf = getConfig(cm);
    var explode = conf && getOption(conf, "explode");
    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    cm.operation(function () {
      var linesep = cm.lineSeparator() || "\n";
      cm.replaceSelection(linesep + linesep, null);
      cm.execCommand("goCharLeft");
      ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        var line = ranges[i].head.line;
        cm.indentLine(line, null, true);
        cm.indentLine(line + 1, null, true);
      }
    });
  }
  function contractSelection(sel) {
    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
    return {
      anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
      head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))
    };
  }
  function handleChar(cm, ch) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;
    var pairs = getOption(conf, "pairs");
    var pos = pairs.indexOf(ch);
    if (pos == -1) return CodeMirror.Pass;
    var triples = getOption(conf, "triples");
    var identical = pairs.charAt(pos + 1) == ch;
    var ranges = cm.listSelections();
    var opening = pos % 2 == 0;
    var type;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i],
        cur = range.head,
        curType;
      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
      if (opening && !range.empty()) {
        curType = "surround";
      } else if ((identical || !opening) && next == ch) {
        if (identical && stringStartsAfter(cm, cur)) curType = "both";else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch) curType = "skipThree";else curType = "skip";
      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
        if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;
        curType = "addFour";
      } else if (identical) {
        var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
        if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = "both";else return CodeMirror.Pass;
      } else if (opening && (cm.getLine(cur.line).length == cur.ch || isClosingBracket(next, pairs) || /\s/.test(next))) {
        curType = "both";
      } else {
        return CodeMirror.Pass;
      }
      if (!type) type = curType;else if (type != curType) return CodeMirror.Pass;
    }
    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
    cm.operation(function () {
      if (type == "skip") {
        cm.execCommand("goCharRight");
      } else if (type == "skipThree") {
        for (var i = 0; i < 3; i++) cm.execCommand("goCharRight");
      } else if (type == "surround") {
        var sels = cm.getSelections();
        for (var i = 0; i < sels.length; i++) sels[i] = left + sels[i] + right;
        cm.replaceSelections(sels, "around");
        sels = cm.listSelections().slice();
        for (var i = 0; i < sels.length; i++) sels[i] = contractSelection(sels[i]);
        cm.setSelections(sels);
      } else if (type == "both") {
        cm.replaceSelection(left + right, null);
        cm.triggerElectric(left + right);
        cm.execCommand("goCharLeft");
      } else if (type == "addFour") {
        cm.replaceSelection(left + left + left + left, "before");
        cm.execCommand("goCharRight");
      }
    });
  }
  function isClosingBracket(ch, pairs) {
    var pos = pairs.lastIndexOf(ch);
    return pos > -1 && pos % 2 == 1;
  }
  function charsAround(cm, pos) {
    var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));
    return str.length == 2 ? str : null;
  }
  function stringStartsAfter(cm, pos) {
    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
    return /\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)));
  }
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/edit/matchbrackets.js":
/*!******************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/edit/matchbrackets.js ***!
  \******************************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
  var Pos = CodeMirror.Pos;
  var matching = {
    "(": ")>",
    ")": "(<",
    "[": "]>",
    "]": "[<",
    "{": "}>",
    "}": "{<"
  };
  function findMatchingBracket(cm, where, config) {
    var line = cm.getLineHandle(where.line),
      pos = where.ch - 1;
    var afterCursor = config && config.afterCursor;
    if (afterCursor == null) afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);

    // A cursor is defined as between two characters, but in in vim command mode
    // (i.e. not insert mode), the cursor is visually represented as a
    // highlighted box on top of the 2nd character. Otherwise, we allow matches
    // from before or after the cursor.
    var match = !afterCursor && pos >= 0 && matching[line.text.charAt(pos)] || matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (config && config.strict && dir > 0 != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
    if (found == null) return null;
    return {
      from: Pos(where.line, pos),
      to: found && found.pos,
      match: found && found.ch == match.charAt(0),
      forward: dir > 0
    };
  }

  // bracketRegex is used to specify which type of bracket to scan
  // should be a regexp, e.g. /[[\]]/
  //
  // Note: If "where" is on an open bracket, then this bracket is ignored.
  //
  // Returns false when no bracket was found, null when it reached
  // maxScanLines and gave up
  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = config && config.maxScanLineLength || 10000;
    var maxScanLines = config && config.maxScanLines || 1000;
    var stack = [];
    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\]]/;
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1,
        end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);
        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
          var match = matching[ch];
          if (match.charAt(1) == ">" == dir > 0) stack.push(ch);else if (!stack.length) return {
            pos: Pos(lineNo, pos),
            ch: ch
          };else stack.pop();
        }
      }
    }
    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }
  function matchBrackets(cm, autoclear, config) {
    // Disable brace matching in long lines, since it'll cause hugely slow updates
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
    var marks = [],
      ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {
          className: style
        }));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen) marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {
          className: style
        }));
      }
    }
    if (marks.length) {
      // Kludge to work around the IE bug from issue #1193, where text
      // input stops going to the textare whever this fires.
      if (ie_lt8 && cm.state.focused) cm.focus();
      var clear = function () {
        cm.operation(function () {
          for (var i = 0; i < marks.length; i++) marks[i].clear();
        });
      };
      if (autoclear) setTimeout(clear, 800);else return clear;
    }
  }
  function doMatchBrackets(cm) {
    cm.operation(function () {
      if (cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }
  CodeMirror.defineOption("matchBrackets", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", doMatchBrackets);
      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
    }
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
    }
  });
  CodeMirror.defineExtension("matchBrackets", function () {
    matchBrackets(this, true);
  });
  CodeMirror.defineExtension("findMatchingBracket", function (pos, config, oldConfig) {
    // Backwards-compatibility kludge
    if (oldConfig || typeof config == "boolean") {
      if (!oldConfig) {
        config = config ? {
          strict: true
        } : null;
      } else {
        oldConfig.strict = config;
        config = oldConfig;
      }
    }
    return findMatchingBracket(this, pos, config);
  });
  CodeMirror.defineExtension("scanForBracket", function (pos, dir, style, config) {
    return scanForBracket(this, pos, dir, style, config);
  });
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/emmet/emmet-codemirror-plugin.js":
/*!*****************************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/emmet/emmet-codemirror-plugin.js ***!
  \*****************************************************************************/
/***/ (function() {

(function (global, factory) {
   true ? factory() : 0;
})(this, function () {
  'use strict';

  /**
   * Minimalistic backwards stream reader
   */
  var StreamReader = function StreamReader(string) {
    this.string = string;
    this.pos = this.string.length;
  };
  StreamReader.prototype.sol = function sol() {
    return this.pos === 0;
  };
  StreamReader.prototype.peek = function peek(offset) {
    return this.string.charCodeAt(this.pos - 1 + (offset || 0));
  };
  StreamReader.prototype.prev = function prev() {
    if (!this.sol()) {
      return this.string.charCodeAt(--this.pos);
    }
  };
  StreamReader.prototype.eat = function eat(match) {
    var ok = typeof match === 'function' ? match(this.peek()) : match === this.peek();
    if (ok) {
      this.pos--;
    }
    return ok;
  };
  StreamReader.prototype.eatWhile = function eatWhile(match) {
    var start = this.pos;
    while (this.eat(match)) {}
    return this.pos < start;
  };

  /**
   * Quotes-related utilities
   */

  var SINGLE_QUOTE = 39; // '
  var DOUBLE_QUOTE = 34; // "
  var ESCAPE = 92; // \

  /**
   * Check if given character code is a quote
   * @param  {Number}  c
   * @return {Boolean}
   */
  function isQuote(c) {
    return c === SINGLE_QUOTE || c === DOUBLE_QUOTE;
  }

  /**
   * Consumes quoted value, if possible
   * @param  {StreamReader} stream
   * @return {Boolean}      Returns `true` is value was consumed
   */
  function eatQuoted(stream) {
    var start = stream.pos;
    var quote = stream.prev();
    if (isQuote(quote)) {
      while (!stream.sol()) {
        if (stream.prev() === quote && stream.peek() !== ESCAPE) {
          return true;
        }
      }
    }
    stream.pos = start;
    return false;
  }
  var TAB = 9;
  var SPACE = 32;
  var SLASH = 47; // /
  var COLON = 58; // :
  var EQUALS = 61; // =
  var ANGLE_LEFT = 60; // <
  var ANGLE_RIGHT = 62; // >

  /**
   * Check if given reader’s current position points at the end of HTML tag
   * @param  {StreamReader} stream
   * @return {Boolean}
   */
  var isAtHTMLTag = function (stream) {
    var start = stream.pos;
    if (!stream.eat(ANGLE_RIGHT)) {
      return false;
    }
    var ok = false;
    stream.eat(SLASH); // possibly self-closed element

    while (!stream.sol()) {
      stream.eatWhile(isWhiteSpace);
      if (eatIdent(stream)) {
        // ate identifier: could be a tag name, boolean attribute or unquoted
        // attribute value
        if (stream.eat(SLASH)) {
          // either closing tag or invalid tag
          ok = stream.eat(ANGLE_LEFT);
          break;
        } else if (stream.eat(ANGLE_LEFT)) {
          // opening tag
          ok = true;
          break;
        } else if (stream.eat(isWhiteSpace)) {
          // boolean attribute
          continue;
        } else if (stream.eat(EQUALS)) {
          // simple unquoted value or invalid attribute
          ok = eatIdent(stream);
          break;
        } else if (eatAttributeWithUnquotedValue(stream)) {
          // identifier was a part of unquoted value
          ok = true;
          break;
        }

        // invalid tag
        break;
      }
      if (eatAttribute(stream)) {
        continue;
      }
      break;
    }
    stream.pos = start;
    return ok;
  };

  /**
   * Eats HTML attribute from given string.
   * @param  {StreamReader} state
   * @return {Boolean}       `true` if attribute was consumed.
   */
  function eatAttribute(stream) {
    return eatAttributeWithQuotedValue(stream) || eatAttributeWithUnquotedValue(stream);
  }

  /**
   * @param  {StreamReader} stream
   * @return {Boolean}
   */
  function eatAttributeWithQuotedValue(stream) {
    var start = stream.pos;
    if (eatQuoted(stream) && stream.eat(EQUALS) && eatIdent(stream)) {
      return true;
    }
    stream.pos = start;
    return false;
  }

  /**
   * @param  {StreamReader} stream
   * @return {Boolean}
   */
  function eatAttributeWithUnquotedValue(stream) {
    var start = stream.pos;
    if (stream.eatWhile(isUnquotedValue) && stream.eat(EQUALS) && eatIdent(stream)) {
      return true;
    }
    stream.pos = start;
    return false;
  }

  /**
   * Eats HTML identifier from stream
   * @param  {StreamReader} stream
   * @return {Boolean}
   */
  function eatIdent(stream) {
    return stream.eatWhile(isIdent);
  }

  /**
   * Check if given character code belongs to HTML identifier
   * @param  {Number}  c
   * @return {Boolean}
   */
  function isIdent(c) {
    return c === COLON || isAlpha(c) || isNumber(c);
  }

  /**
   * Check if given character code is alpha code (letter though A to Z)
   * @param  {Number}  c
   * @return {Boolean}
   */
  function isAlpha(c) {
    c &= ~32; // quick hack to convert any char code to uppercase char code
    return c >= 65 && c <= 90; // A-Z
  }

  /**
   * Check if given code is a number
   * @param  {Number}  c
   * @return {Boolean}
   */
  function isNumber(c) {
    return c > 47 && c < 58;
  }

  /**
   * Check if given code is a whitespace
   * @param  {Number}  c
   * @return {Boolean}
   */
  function isWhiteSpace(c) {
    return c === SPACE || c === TAB;
  }

  /**
   * Check if given code may belong to unquoted attribute value
   * @param  {Number}  c
   * @return {Boolean}
   */
  function isUnquotedValue(c) {
    return c && c !== EQUALS && !isWhiteSpace(c) && !isQuote(c);
  }
  var code = function (ch) {
    return ch.charCodeAt(0);
  };
  var SQUARE_BRACE_L = code('[');
  var SQUARE_BRACE_R = code(']');
  var ROUND_BRACE_L = code('(');
  var ROUND_BRACE_R = code(')');
  var CURLY_BRACE_L = code('{');
  var CURLY_BRACE_R = code('}');
  var specialChars = new Set('#.*:$-_!@%^+>/'.split('').map(code));
  var bracePairs = new Map().set(SQUARE_BRACE_L, SQUARE_BRACE_R).set(ROUND_BRACE_L, ROUND_BRACE_R).set(CURLY_BRACE_L, CURLY_BRACE_R);

  /**
   * Extracts Emmet abbreviation from given string.
   * The goal of this module is to extract abbreviation from current editor’s line,
   * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where
   * `|` is a current caret position.
   * @param {String}  line A text line where abbreviation should be expanded
   * @param {Number}  [pos] Caret position in line. If not given, uses end-of-line
   * @param {Boolean} [lookAhead] Allow parser to look ahead of `pos` index for
   * searching of missing abbreviation parts. Most editors automatically inserts
   * closing braces for `[`, `{` and `(`, which will most likely be right after
   * current caret position. So in order to properly expand abbreviation, user
   * must explicitly move caret right after auto-inserted braces. Whith this option
   * enabled, parser will search for closing braces right after `pos`. Default is `true`
   * @return {Object} Object with `abbreviation` and its `location` in given line
   * if abbreviation can be extracted, `null` otherwise
   */
  function extractAbbreviation$1(line, pos, lookAhead) {
    // make sure `pos` is within line range
    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));
    if (lookAhead == null || lookAhead === true) {
      pos = offsetPastAutoClosed(line, pos);
    }
    var c;
    var stream = new StreamReader(line);
    stream.pos = pos;
    var stack = [];
    while (!stream.sol()) {
      c = stream.peek();
      if (isCloseBrace(c)) {
        stack.push(c);
      } else if (isOpenBrace(c)) {
        if (stack.pop() !== bracePairs.get(c)) {
          // unexpected brace
          break;
        }
      } else if (has(stack, SQUARE_BRACE_R) || has(stack, CURLY_BRACE_R)) {
        // respect all characters inside attribute sets or text nodes
        stream.pos--;
        continue;
      } else if (isAtHTMLTag(stream) || !isAbbreviation(c)) {
        break;
      }
      stream.pos--;
    }
    if (!stack.length && stream.pos !== pos) {
      // found something, remove some invalid symbols from the
      // beginning and return abbreviation
      var abbreviation = line.slice(stream.pos, pos).replace(/^[\*\+\>\^]+/, '');
      return {
        abbreviation: abbreviation,
        location: pos - abbreviation.length
      };
    }
  }

  /**
   * Returns new `line` index which is right after characters beyound `pos` that
   * edditor will likely automatically close, e.g. }, ], and quotes
   * @param {String} line
   * @param {Number} pos
   * @return {Number}
   */
  function offsetPastAutoClosed(line, pos) {
    // closing quote is allowed only as a next character
    if (isQuote(line.charCodeAt(pos))) {
      pos++;
    }

    // offset pointer until non-autoclosed character is found
    while (isCloseBrace(line.charCodeAt(pos))) {
      pos++;
    }
    return pos;
  }
  function has(arr, value) {
    return arr.indexOf(value) !== -1;
  }
  function isAbbreviation(c) {
    return c > 64 && c < 91 // uppercase letter
    || c > 96 && c < 123 // lowercase letter
    || c > 47 && c < 58 // number
    || specialChars.has(c); // special character
  }

  function isOpenBrace(c) {
    return c === SQUARE_BRACE_L || c === ROUND_BRACE_L || c === CURLY_BRACE_L;
  }
  function isCloseBrace(c) {
    return c === SQUARE_BRACE_R || c === ROUND_BRACE_R || c === CURLY_BRACE_R;
  }
  var defaultOptions$1 = {
    /**
     * String for one-level indentation
     * @type {String}
     */
    indent: '\t',
    /**
     * Tag case: 'lower', 'upper' or '' (keep as-is)
     * @type {String}
     */
    tagCase: '',
    /**
     * Attribute name case: 'lower', 'upper' or '' (keep as-is)
     * @type {String}
     */
    attributeCase: '',
    /**
     * Attribute value quotes: 'single' or 'double'
     * @type {String}
     */
    attributeQuotes: 'double',
    /**
     * Enable output formatting (indentation and line breaks)
     * @type {Boolean}
     */
    format: true,
    /**
     * A list of tag names that should not get inner indentation
     * @type {Set}
     */
    formatSkip: ['html'],
    /**
     * A list of tag names that should *always* get inner indentation.
     * @type {Set}
     */
    formatForce: ['body'],
    /**
     * How many inline sibling elements should force line break for each tag.
     * Set to 0 to output all inline elements without formatting.
     * Set to 1 to output all inline elements with formatting (same as block-level).
     * @type {Number}
     */
    inlineBreak: 3,
    /**
     * Produce compact notation of boolean attribues: attributes where name equals value.
     * With this option enabled, output `<div contenteditable>` instead of
     * `<div contenteditable="contenteditable">`
     * @type {Boolean}
     */
    compactBooleanAttributes: false,
    /**
     * A set of boolean attributes
     * @type {Set}
     */
    booleanAttributes: ['contenteditable', 'seamless', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate', 'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly', 'required', 'reversed', 'selected', 'typemustmatch'],
    /**
     * Style of self-closing tags:
     * 'html'  – <br>
     * 'xml'   – <br/>
     * 'xhtml' – <br />
     * @type {String}
     */
    selfClosingStyle: 'html',
    /**
     * A set of inline-level elements
     * @type {Set}
     */
    inlineElements: ['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo', 'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q', 's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'textarea', 'tt', 'u', 'var']
  };

  /**
   * Creates output profile for given options (@see defaults)
   * @param {defaults} options
   */
  var Profile = function Profile(options) {
    this.options = Object.assign({}, defaultOptions$1, options);
    this.quoteChar = this.options.attributeQuotes === 'single' ? '\'' : '"';
  };

  /**
  	 * Returns value of given option name
  	 * @param {String} name
  	 * @return {*}
  	 */
  Profile.prototype.get = function get(name) {
    return this.options[name];
  };

  /**
   * Quote given string according to profile
   * @param {String} str String to quote
   * @return {String}
   */
  Profile.prototype.quote = function quote(str) {
    return "" + this.quoteChar + (str != null ? str : '') + this.quoteChar;
  };

  /**
   * Output given tag name accoding to options
   * @param {String} name
   * @return {String}
   */
  Profile.prototype.name = function name(name$1) {
    return strcase(name$1, this.options.tagCase);
  };

  /**
  	 * Outputs attribute name accoding to current settings
  	 * @param {String} Attribute name
  	 * @return {String}
  	 */
  Profile.prototype.attribute = function attribute(attr) {
    return strcase(attr, this.options.attributeCase);
  };

  /**
   * Check if given attribute is boolean
   * @param {Attribute} attr
   * @return {Boolean}
   */
  Profile.prototype.isBooleanAttribute = function isBooleanAttribute(attr) {
    return attr.options.boolean || this.get('booleanAttributes').indexOf((attr.name || '').toLowerCase()) !== -1;
  };

  /**
  	 * Returns a token for self-closing tag, depending on current options
  	 * @return {String}
  	 */
  Profile.prototype.selfClose = function selfClose() {
    switch (this.options.selfClosingStyle) {
      case 'xhtml':
        return ' /';
      case 'xml':
        return '/';
      default:
        return '';
    }
  };

  /**
  	 * Returns indent for given level
  	 * @param {Number} level Indentation level
  	 * @return {String}
  	 */
  Profile.prototype.indent = function indent(level) {
    var this$1 = this;
    level = level || 0;
    var output = '';
    while (level--) {
      output += this$1.options.indent;
    }
    return output;
  };

  /**
  	 * Check if given tag name belongs to inline-level element
  	 * @param {Node|String} node Parsed node or tag name
  	 * @return {Boolean}
  	 */
  Profile.prototype.isInline = function isInline(node) {
    if (typeof node === 'string') {
      return this.get('inlineElements').indexOf(node.toLowerCase()) !== -1;
    }

    // inline node is a node either with inline-level name or text-only node
    return node.name != null ? this.isInline(node.name) : node.isTextOnly;
  };

  /**
  	 * Outputs formatted field for given params
  	 * @param {Number} index Field index
  	 * @param {String} [placeholder] Field placeholder, can be empty
  	 * @return {String}
  	 */
  Profile.prototype.field = function field(index, placeholder) {
    return this.options.field(index, placeholder);
  };
  function strcase(string, type) {
    if (type) {
      string = type === 'upper' ? string.toUpperCase() : string.toLowerCase();
    }
    return string;
  }
  var Snippet = function Snippet(key, value) {
    this.key = key;
    this.value = value;
  };
  var SnippetsStorage = function SnippetsStorage(data) {
    this._string = new Map();
    this._regexp = new Map();
    this._disabled = false;
    this.load(data);
  };
  var prototypeAccessors = {
    disabled: {}
  };
  prototypeAccessors.disabled.get = function () {
    return this._disabled;
  };

  /**
   * Disables current store. A disabled store always returns `undefined`
   * on `get()` method
   */
  SnippetsStorage.prototype.disable = function disable() {
    this._disabled = true;
  };

  /**
   * Enables current store.
   */
  SnippetsStorage.prototype.enable = function enable() {
    this._disabled = false;
  };

  /**
   * Registers a new snippet item
   * @param {String|Regexp} key
   * @param {String|Function} value
   */
  SnippetsStorage.prototype.set = function set(key, value) {
    var this$1 = this;
    if (typeof key === 'string') {
      key.split('|').forEach(function (k) {
        return this$1._string.set(k, new Snippet(k, value));
      });
    } else if (key instanceof RegExp) {
      this._regexp.set(key, new Snippet(key, value));
    } else {
      throw new Error('Unknow snippet key: ' + key);
    }
    return this;
  };

  /**
   * Returns a snippet matching given key. It first tries to find snippet
   * exact match in a string key map, then tries to match one with regexp key
   * @param {String} key
   * @return {Snippet}
   */
  SnippetsStorage.prototype.get = function get(key) {
    var this$1 = this;
    if (this.disabled) {
      return undefined;
    }
    if (this._string.has(key)) {
      return this._string.get(key);
    }
    var keys = Array.from(this._regexp.keys());
    for (var i = 0, il = keys.length; i < il; i++) {
      if (keys[i].test(key)) {
        return this$1._regexp.get(keys[i]);
      }
    }
  };

  /**
   * Batch load of snippets data
   * @param {Object|Map} data
   */
  SnippetsStorage.prototype.load = function load(data) {
    var this$1 = this;
    this.reset();
    if (data instanceof Map) {
      data.forEach(function (value, key) {
        return this$1.set(key, value);
      });
    } else if (data && typeof data === 'object') {
      Object.keys(data).forEach(function (key) {
        return this$1.set(key, data[key]);
      });
    }
  };

  /**
   * Clears all stored snippets
   */
  SnippetsStorage.prototype.reset = function reset() {
    this._string.clear();
    this._regexp.clear();
  };

  /**
   * Returns all available snippets from given store
   */
  SnippetsStorage.prototype.values = function values() {
    if (this.disabled) {
      return [];
    }
    var string = Array.from(this._string.values());
    var regexp = Array.from(this._regexp.values());
    return string.concat(regexp);
  };
  Object.defineProperties(SnippetsStorage.prototype, prototypeAccessors);

  /**
   * A snippets registry. Contains snippets, separated by store and sorted by
   * priority: a store with higher priority takes precedence when resolving snippet
   * for given key
   */
  var SnippetsRegistry = function SnippetsRegistry(data) {
    var this$1 = this;
    this._registry = [];
    if (Array.isArray(data)) {
      data.forEach(function (snippets, level) {
        return this$1.add(level, snippets);
      });
    } else if (typeof data === 'object') {
      this.add(data);
    }
  };

  /**
   * Return store for given level
   * @param {Number} level
   * @return {SnippetsStorage}
   */
  SnippetsRegistry.prototype.get = function get(level) {
    var this$1 = this;
    for (var i = 0; i < this._registry.length; i++) {
      var item = this$1._registry[i];
      if (item.level === level) {
        return item.store;
      }
    }
  };

  /**
   * Adds new store for given level
   * @param {Number} [level] Store level (priority). Store with higher level
   * takes precedence when resolving snippets
   * @param {Object} [snippets] A snippets data for new store
   * @return {SnipetsStorage}
   */
  SnippetsRegistry.prototype.add = function add(level, snippets) {
    if (level != null && typeof level === 'object') {
      snippets = level;
      level = 0;
    }
    var store = new SnippetsStorage(snippets);

    // remove previous store from same level
    this.remove(level);
    this._registry.push({
      level: level,
      store: store
    });
    this._registry.sort(function (a, b) {
      return b.level - a.level;
    });
    return store;
  };

  /**
   * Remove registry with given level or store
   * @param {Number|SnippetsStorage} data Either level or snippets store
   */
  SnippetsRegistry.prototype.remove = function remove(data) {
    this._registry = this._registry.filter(function (item) {
      return item.level !== data && item.store !== data;
    });
  };

  /**
   * Returns snippet from registry that matches given name
   * @param {String} name
   * @return {Snippet}
   */
  SnippetsRegistry.prototype.resolve = function resolve(name) {
    var this$1 = this;
    for (var i = 0; i < this._registry.length; i++) {
      var snippet = this$1._registry[i].store.get(name);
      if (snippet) {
        return snippet;
      }
    }
  };

  /**
   * Returns all available snippets from current registry. Snippets with the
   * same key are resolved by their storage priority.
   * @param {Object} options
   * @param {Object} options.type Return snippets only of given type: 'string'
   * or 'regexp'. Returns all snippets if not defined
   * @return {Array}
   */
  SnippetsRegistry.prototype.all = function all(options) {
    options = options || {};
    var result = new Map();
    var fillResult = function (snippet) {
      var type = snippet.key instanceof RegExp ? 'regexp' : 'string';
      if ((!options.type || options.type === type) && !result.has(snippet.key)) {
        result.set(snippet.key, snippet);
      }
    };
    this._registry.forEach(function (item) {
      item.store.values().forEach(fillResult);
    });
    return Array.from(result.values());
  };

  /**
   * Removes all stores from registry
   */
  SnippetsRegistry.prototype.clear = function clear() {
    this._registry.length = 0;
  };

  /**
   * Attribute descriptor of parsed abbreviation node
   * @param {String} name Attribute name
   * @param {String} value Attribute value
   * @param {Object} options Additional custom attribute options
   * @param {Boolean} options.boolean Attribute is boolean (e.g. name equals value)
   * @param {Boolean} options.implied Attribute is implied (e.g. must be outputted
   * only if contains non-null value)
   */
  var Attribute = function Attribute(name, value, options) {
    this.name = name;
    this.value = value != null ? value : null;
    this.options = options || {};
  };

  /**
  	 * Create a copy of current attribute
  	 * @return {Attribute}
  	 */
  Attribute.prototype.clone = function clone() {
    return new Attribute(this.name, this.value, Object.assign({}, this.options));
  };

  /**
  	 * A string representation of current node
  	 */
  Attribute.prototype.valueOf = function valueOf() {
    return this.name + "=\"" + this.value + "\"";
  };

  /**
   * A parsed abbreviation AST node. Nodes build up an abbreviation AST tree
   */
  var Node = function Node(name, attributes) {
    var this$1 = this;

    // own properties
    this.name = name || null;
    this.value = null;
    this.repeat = null;
    this.selfClosing = false;
    this.children = [];

    /** @type {Node} Pointer to parent node */
    this.parent = null;

    /** @type {Node} Pointer to next sibling */
    this.next = null;

    /** @type {Node} Pointer to previous sibling */
    this.previous = null;
    this._attributes = [];
    if (Array.isArray(attributes)) {
      attributes.forEach(function (attr) {
        return this$1.setAttribute(attr);
      });
    }
  };
  var prototypeAccessors$1 = {
    attributes: {},
    attributesMap: {},
    isGroup: {},
    isTextOnly: {},
    firstChild: {},
    lastChild: {},
    childIndex: {},
    nextSibling: {},
    previousSibling: {},
    classList: {}
  };

  /**
  	 * Array of current node attributes
  	 * @return {Attribute[]} Array of attributes
  	 */
  prototypeAccessors$1.attributes.get = function () {
    return this._attributes;
  };

  /**
  	 * A shorthand to retreive node attributes as map
  	 * @return {Object}
  	 */
  prototypeAccessors$1.attributesMap.get = function () {
    return this.attributes.reduce(function (out, attr) {
      out[attr.name] = attr.options.boolean ? attr.name : attr.value;
      return out;
    }, {});
  };

  /**
  	 * Check if current node is a grouping one, e.g. has no actual representation
  	 * and is used for grouping subsequent nodes only
  	 * @return {Boolean}
  	 */
  prototypeAccessors$1.isGroup.get = function () {
    return !this.name && !this.value && !this._attributes.length;
  };

  /**
  	 * Check if given node is a text-only node, e.g. contains only value
  	 * @return {Boolean}
  	 */
  prototypeAccessors$1.isTextOnly.get = function () {
    return !this.name && !!this.value && !this._attributes.length;
  };

  /**
  	 * Returns first child node
  	 * @return {Node}
  	 */
  prototypeAccessors$1.firstChild.get = function () {
    return this.children[0];
  };

  /**
  	 * Returns last child of current node
  	 * @return {Node}
  	 */
  prototypeAccessors$1.lastChild.get = function () {
    return this.children[this.children.length - 1];
  };

  /**
  	 * Return index of current node in its parent child list
  	 * @return {Number} Returns -1 if current node is a root one
  	 */
  prototypeAccessors$1.childIndex.get = function () {
    return this.parent ? this.parent.children.indexOf(this) : -1;
  };

  /**
  	 * Returns next sibling of current node
  	 * @return {Node}
  	 */
  prototypeAccessors$1.nextSibling.get = function () {
    return this.next;
  };

  /**
  	 * Returns previous sibling of current node
  	 * @return {Node}
  	 */
  prototypeAccessors$1.previousSibling.get = function () {
    return this.previous;
  };

  /**
  	 * Returns array of unique class names in current node
  	 * @return {String[]}
  	 */
  prototypeAccessors$1.classList.get = function () {
    var attr = this.getAttribute('class');
    return attr && attr.value ? attr.value.split(/\s+/g).filter(uniqueClass) : [];
  };

  /**
  	 * Convenient alias to create a new node instance
  	 * @param {String} [name] Node name
  	 * @param {Object} [attributes] Attributes hash
  	 * @return {Node}
  	 */
  Node.prototype.create = function create(name, attributes) {
    return new Node(name, attributes);
  };

  /**
  	 * Sets given attribute for current node
  	 * @param {String|Object|Attribute} name Attribute name or attribute object
  	 * @param {String} [value] Attribute value
  	 */
  Node.prototype.setAttribute = function setAttribute(name, value) {
    var attr = createAttribute(name, value);
    var curAttr = this.getAttribute(name);
    if (curAttr) {
      this.replaceAttribute(curAttr, attr);
    } else {
      this._attributes.push(attr);
    }
  };

  /**
  	 * Check if attribute with given name exists in node
  	 * @param  {String} name
  	 * @return {Boolean}
  	 */
  Node.prototype.hasAttribute = function hasAttribute(name) {
    return !!this.getAttribute(name);
  };

  /**
  	 * Returns attribute object by given name
  	 * @param  {String} name
  	 * @return {Attribute}
  	 */
  Node.prototype.getAttribute = function getAttribute(name) {
    var this$1 = this;
    if (typeof name === 'object') {
      name = name.name;
    }
    for (var i = 0; i < this._attributes.length; i++) {
      var attr = this$1._attributes[i];
      if (attr.name === name) {
        return attr;
      }
    }
  };

  /**
  	 * Replaces attribute with new instance
  	 * @param {String|Attribute} curAttribute Current attribute name or instance
  	 * to replace
  	 * @param {String|Object|Attribute} newName New attribute name or attribute object
  	 * @param {String} [newValue] New attribute value
  	 */
  Node.prototype.replaceAttribute = function replaceAttribute(curAttribute, newName, newValue) {
    if (typeof curAttribute === 'string') {
      curAttribute = this.getAttribute(curAttribute);
    }
    var ix = this._attributes.indexOf(curAttribute);
    if (ix !== -1) {
      this._attributes.splice(ix, 1, createAttribute(newName, newValue));
    }
  };

  /**
  	 * Removes attribute with given name
  	 * @param  {String|Attribute} attr Atrtibute name or instance
  	 */
  Node.prototype.removeAttribute = function removeAttribute(attr) {
    if (typeof attr === 'string') {
      attr = this.getAttribute(attr);
    }
    var ix = this._attributes.indexOf(attr);
    if (ix !== -1) {
      this._attributes.splice(ix, 1);
    }
  };

  /**
  	 * Removes all attributes from current node
  	 */
  Node.prototype.clearAttributes = function clearAttributes() {
    this._attributes.length = 0;
  };

  /**
  	 * Adds given class name to class attribute
  	 * @param {String} token Class name token
  	 */
  Node.prototype.addClass = function addClass(token) {
    token = normalize(token);
    if (!this.hasAttribute('class')) {
      this.setAttribute('class', token);
    } else if (token && !this.hasClass(token)) {
      this.setAttribute('class', this.classList.concat(token).join(' '));
    }
  };

  /**
  	 * Check if current node contains given class name
  	 * @param {String} token Class name token
  	 * @return {Boolean}
  	 */
  Node.prototype.hasClass = function hasClass(token) {
    return this.classList.indexOf(normalize(token)) !== -1;
  };

  /**
  	 * Removes given class name from class attribute
  	 * @param {String} token Class name token
  	 */
  Node.prototype.removeClass = function removeClass(token) {
    token = normalize(token);
    if (this.hasClass(token)) {
      this.setAttribute('class', this.classList.filter(function (name) {
        return name !== token;
      }).join(' '));
    }
  };

  /**
  	 * Appends child to current node
  	 * @param {Node} node
  	 */
  Node.prototype.appendChild = function appendChild(node) {
    this.insertAt(node, this.children.length);
  };

  /**
  	 * Inserts given `newNode` before `refNode` child node
  	 * @param {Node} newNode
  	 * @param {Node} refNode
  	 */
  Node.prototype.insertBefore = function insertBefore(newNode, refNode) {
    this.insertAt(newNode, this.children.indexOf(refNode));
  };

  /**
  	 * Insert given `node` at `pos` position of child list
  	 * @param {Node} node
  	 * @param {Number} pos
  	 */
  Node.prototype.insertAt = function insertAt(node, pos) {
    if (pos < 0 || pos > this.children.length) {
      throw new Error('Unable to insert node: position is out of child list range');
    }
    var prev = this.children[pos - 1];
    var next = this.children[pos];
    node.remove();
    node.parent = this;
    this.children.splice(pos, 0, node);
    if (prev) {
      node.previous = prev;
      prev.next = node;
    }
    if (next) {
      node.next = next;
      next.previous = node;
    }
  };

  /**
  	 * Removes given child from current node
  	 * @param {Node} node
  	 */
  Node.prototype.removeChild = function removeChild(node) {
    var ix = this.children.indexOf(node);
    if (ix !== -1) {
      this.children.splice(ix, 1);
      if (node.previous) {
        node.previous.next = node.next;
      }
      if (node.next) {
        node.next.previous = node.previous;
      }
      node.parent = node.next = node.previous = null;
    }
  };

  /**
  	 * Removes current node from its parent
  	 */
  Node.prototype.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
  };

  /**
  	 * Creates a detached copy of current node
  	 * @param {Boolean} deep Clone node contents as well
  	 * @return {Node}
  	 */
  Node.prototype.clone = function clone(deep) {
    var clone = new Node(this.name);
    clone.value = this.value;
    clone.selfClosing = this.selfClosing;
    if (this.repeat) {
      clone.repeat = Object.assign({}, this.repeat);
    }
    this._attributes.forEach(function (attr) {
      return clone.setAttribute(attr.clone());
    });
    if (deep) {
      this.children.forEach(function (child) {
        return clone.appendChild(child.clone(true));
      });
    }
    return clone;
  };

  /**
  	 * Walks on each descendant node and invokes given `fn` function on it.
  	 * The function receives two arguments: the node itself and its depth level
  	 * from current node. If function returns `false`, it stops walking
  	 * @param {Function} fn
  	 */
  Node.prototype.walk = function walk(fn, _level) {
    _level = _level || 0;
    var ctx = this.firstChild;
    while (ctx) {
      // in case if context node will be detached during `fn` call
      var next = ctx.next;
      if (fn(ctx, _level) === false || ctx.walk(fn, _level + 1) === false) {
        return false;
      }
      ctx = next;
    }
  };

  /**
  	 * A helper method for transformation chaining: runs given `fn` function on
  	 * current node and returns the same node
  	 */
  Node.prototype.use = function use(fn) {
    var arguments$1 = arguments;
    var args = [this];
    for (var i = 1; i < arguments.length; i++) {
      args.push(arguments$1[i]);
    }
    fn.apply(null, args);
    return this;
  };
  Node.prototype.toString = function toString() {
    var this$1 = this;
    var attrs = this.attributes.map(function (attr) {
      attr = this$1.getAttribute(attr.name);
      var opt = attr.options;
      var out = "" + (opt && opt.implied ? '!' : '') + (attr.name || '');
      if (opt && opt.boolean) {
        out += '.';
      } else if (attr.value != null) {
        out += "=\"" + attr.value + "\"";
      }
      return out;
    });
    var out = "" + (this.name || '');
    if (attrs.length) {
      out += "[" + attrs.join(' ') + "]";
    }
    if (this.value != null) {
      out += "{" + this.value + "}";
    }
    if (this.selfClosing) {
      out += '/';
    }
    if (this.repeat) {
      out += "*" + (this.repeat.count ? this.repeat.count : '');
      if (this.repeat.value != null) {
        out += "@" + this.repeat.value;
      }
    }
    return out;
  };
  Object.defineProperties(Node.prototype, prototypeAccessors$1);

  /**
   * Attribute factory
   * @param  {String|Attribute|Object} name  Attribute name or attribute descriptor
   * @param  {*} value Attribute value
   * @return {Attribute}
   */
  function createAttribute(name, value) {
    if (name instanceof Attribute) {
      return name;
    }
    if (typeof name === 'string') {
      return new Attribute(name, value);
    }
    if (name && typeof name === 'object') {
      return new Attribute(name.name, name.value, name.options);
    }
  }

  /**
   * @param  {String} str
   * @return {String}
   */
  function normalize(str) {
    return String(str).trim();
  }
  function uniqueClass(item, i, arr) {
    return item && arr.indexOf(item) === i;
  }

  /**
   * A streaming, character code-based string reader
   */
  var StreamReader$1 = function StreamReader(string, start, end) {
    if (end == null && typeof string === 'string') {
      end = string.length;
    }
    this.string = string;
    this.pos = this.start = start || 0;
    this.end = end;
  };

  /**
  	 * Returns true only if the stream is at the end of the file.
  	 * @returns {Boolean}
  	 */
  StreamReader$1.prototype.eof = function eof() {
    return this.pos >= this.end;
  };

  /**
  	 * Creates a new stream instance which is limited to given `start` and `end`
  	 * range. E.g. its `eof()` method will look at `end` property, not actual
  	 * stream end
  	 * @param  {Point} start
  	 * @param  {Point} end
  	 * @return {StreamReader}
  	 */
  StreamReader$1.prototype.limit = function limit(start, end) {
    return new this.constructor(this.string, start, end);
  };

  /**
  	 * Returns the next character code in the stream without advancing it.
  	 * Will return NaN at the end of the file.
  	 * @returns {Number}
  	 */
  StreamReader$1.prototype.peek = function peek() {
    return this.string.charCodeAt(this.pos);
  };

  /**
  	 * Returns the next character in the stream and advances it.
  	 * Also returns <code>undefined</code> when no more characters are available.
  	 * @returns {Number}
  	 */
  StreamReader$1.prototype.next = function next() {
    if (this.pos < this.string.length) {
      return this.string.charCodeAt(this.pos++);
    }
  };

  /**
  	 * `match` can be a character code or a function that takes a character code
  	 * and returns a boolean. If the next character in the stream 'matches'
  	 * the given argument, it is consumed and returned.
  	 * Otherwise, `false` is returned.
  	 * @param {Number|Function} match
  	 * @returns {Boolean}
  	 */
  StreamReader$1.prototype.eat = function eat(match) {
    var ch = this.peek();
    var ok = typeof match === 'function' ? match(ch) : ch === match;
    if (ok) {
      this.next();
    }
    return ok;
  };

  /**
  	 * Repeatedly calls <code>eat</code> with the given argument, until it
  	 * fails. Returns <code>true</code> if any characters were eaten.
  	 * @param {Object} match
  	 * @returns {Boolean}
  	 */
  StreamReader$1.prototype.eatWhile = function eatWhile(match) {
    var start = this.pos;
    while (!this.eof() && this.eat(match)) {}
    return this.pos !== start;
  };

  /**
  	 * Backs up the stream n characters. Backing it up further than the
  	 * start of the current token will cause things to break, so be careful.
  	 * @param {Number} n
  	 */
  StreamReader$1.prototype.backUp = function backUp(n) {
    this.pos -= n || 1;
  };

  /**
  	 * Get the string between the start of the current token and the
  	 * current stream position.
  	 * @returns {String}
  	 */
  StreamReader$1.prototype.current = function current() {
    return this.substring(this.start, this.pos);
  };

  /**
  	 * Returns substring for given range
  	 * @param  {Number} start
  	 * @param  {Number} [end]
  	 * @return {String}
  	 */
  StreamReader$1.prototype.substring = function substring(start, end) {
    return this.string.slice(start, end);
  };

  /**
  	 * Creates error object with current stream state
  	 * @param {String} message
  	 * @return {Error}
  	 */
  StreamReader$1.prototype.error = function error(message) {
    var err = new Error(message + " at char " + (this.pos + 1));
    err.originalMessage = message;
    err.pos = this.pos;
    err.string = this.string;
    return err;
  };

  /**
   * Methods for consuming quoted values
   */

  var SINGLE_QUOTE$1 = 39; // '
  var DOUBLE_QUOTE$1 = 34; // "

  var defaultOptions$2 = {
    escape: 92,
    // \ character
    throws: false
  };

  /**
   * Consumes 'single' or "double"-quoted string from given string, if possible
   * @param  {StreamReader} stream
   * @param  {Number}  options.escape A character code of quote-escape symbol
   * @param  {Boolean} options.throws Throw error if quotes string can’t be properly consumed
   * @return {Boolean} `true` if quoted string was consumed. The contents
   *                   of quoted string will be availabe as `stream.current()`
   */
  var eatQuoted$1 = function (stream, options) {
    options = options ? Object.assign({}, defaultOptions$2, options) : defaultOptions$2;
    var start = stream.pos;
    var quote = stream.peek();
    if (stream.eat(isQuote$1)) {
      while (!stream.eof()) {
        switch (stream.next()) {
          case quote:
            stream.start = start;
            return true;
          case options.escape:
            stream.next();
            break;
        }
      }

      // If we’re here then stream wasn’t properly consumed.
      // Revert stream and decide what to do
      stream.pos = start;
      if (options.throws) {
        throw stream.error('Unable to consume quoted string');
      }
    }
    return false;
  };
  function isQuote$1(code) {
    return code === SINGLE_QUOTE$1 || code === DOUBLE_QUOTE$1;
  }

  /**
   * Check if given code is a number
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isNumber$1(code) {
    return code > 47 && code < 58;
  }

  /**
   * Check if given character code is alpha code (letter through A to Z)
   * @param  {Number}  code
   * @param  {Number}  [from]
   * @param  {Number}  [to]
   * @return {Boolean}
   */
  function isAlpha$1(code, from, to) {
    from = from || 65; // A
    to = to || 90; // Z
    code &= ~32; // quick hack to convert any char code to uppercase char code

    return code >= from && code <= to;
  }

  /**
   * Check if given character code is alpha-numeric (letter through A to Z or number)
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isAlphaNumeric(code) {
    return isNumber$1(code) || isAlpha$1(code);
  }
  function isWhiteSpace$1(code) {
    return code === 32 /* space */ || code === 9 /* tab */ || code === 160; /* non-breaking space */
  }

  /**
   * Check if given character code is a space
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isSpace(code) {
    return isWhiteSpace$1(code) || code === 10 /* LF */ || code === 13; /* CR */
  }

  var defaultOptions$1$1 = {
    escape: 92,
    // \ character
    throws: false
  };

  /**
   * Eats paired characters substring, for example `(foo)` or `[bar]`
   * @param  {StreamReader} stream
   * @param  {Number} open      Character code of pair openinig
   * @param  {Number} close     Character code of pair closing
   * @param  {Object} [options]
   * @return {Boolean}       Returns `true` if chacarter pair was successfully
   *                         consumed, it’s content will be available as `stream.current()`
   */
  function eatPair(stream, open, close, options) {
    options = options ? Object.assign({}, defaultOptions$1$1, options) : defaultOptions$1$1;
    var start = stream.pos;
    if (stream.eat(open)) {
      var stack = 1,
        ch;
      while (!stream.eof()) {
        if (eatQuoted$1(stream, options)) {
          continue;
        }
        ch = stream.next();
        if (ch === open) {
          stack++;
        } else if (ch === close) {
          stack--;
          if (!stack) {
            stream.start = start;
            return true;
          }
        } else if (ch === options.escape) {
          stream.next();
        }
      }

      // If we’re here then paired character can’t be consumed
      stream.pos = start;
      if (options.throws) {
        throw stream.error("Unable to find matching pair for " + String.fromCharCode(open));
      }
    }
    return false;
  }
  var ASTERISK = 42; // *

  /**
   * Consumes node repeat token from current stream position and returns its
   * parsed value
   * @param  {StringReader} stream
   * @return {Object}
   */
  var consumeRepeat = function (stream) {
    if (stream.eat(ASTERISK)) {
      stream.start = stream.pos;

      // XXX think about extending repeat syntax with through numbering
      return {
        count: stream.eatWhile(isNumber$1) ? +stream.current() : null
      };
    }
  };
  var opt = {
    throws: true
  };

  /**
   * Consumes quoted literal from current stream position and returns it’s inner,
   * unquoted, value
   * @param  {StringReader} stream
   * @return {String} Returns `null` if unable to consume quoted value from current
   * position
   */
  var consumeQuoted = function (stream) {
    if (eatQuoted$1(stream, opt)) {
      return stream.current().slice(1, -1);
    }
  };
  var LCURLY = 123; // {
  var RCURLY = 125; // }

  var opt$1 = {
    throws: true
  };

  /**
   * Consumes text node, e.g. contents of `{...}` and returns its inner value
   * @param  {StringReader} stream
   * @return {String} Consumed text content or `null` otherwise
   */
  var consumeTextNode = function (stream) {
    return eatPair(stream, LCURLY, RCURLY, opt$1) ? stream.current().slice(1, -1) : null;
  };
  var EXCL = 33; // .
  var DOT$1 = 46; // .
  var EQUALS$1 = 61; // =
  var ATTR_OPEN = 91; // [
  var ATTR_CLOSE = 93; // ]

  var reAttributeName = /^\!?[\w\-:\$@]+\.?$/;

  /**
   * Consumes attributes defined in square braces from given stream.
   * Example:
   * [attr col=3 title="Quoted string" selected. support={react}]
   * @param {StringReader} stream
   * @returns {Array} Array of consumed attributes
   */
  var consumeAttributes = function (stream) {
    if (!stream.eat(ATTR_OPEN)) {
      return null;
    }
    var result = [];
    var token, attr;
    while (!stream.eof()) {
      stream.eatWhile(isWhiteSpace$1);
      if (stream.eat(ATTR_CLOSE)) {
        return result; // End of attribute set
      } else if ((token = consumeQuoted(stream)) != null) {
        // Consumed quoted value: anonymous attribute
        result.push({
          name: null,
          value: token
        });
      } else if (eatUnquoted(stream)) {
        // Consumed next word: could be either attribute name or unquoted default value
        token = stream.current();
        if (!reAttributeName.test(token)) {
          // anonymous attribute
          result.push({
            name: null,
            value: token
          });
        } else {
          // Looks like a regular attribute
          attr = parseAttributeName(token);
          result.push(attr);
          if (stream.eat(EQUALS$1)) {
            // Explicitly defined value. Could be a word, a quoted string
            // or React-like expression
            if ((token = consumeQuoted(stream)) != null) {
              attr.value = token;
            } else if ((token = consumeTextNode(stream)) != null) {
              attr.value = token;
              attr.options = {
                before: '{',
                after: '}'
              };
            } else if (eatUnquoted(stream)) {
              attr.value = stream.current();
            }
          }
        }
      } else {
        throw stream.error('Expected attribute name');
      }
    }
    throw stream.error('Expected closing "]" brace');
  };
  function parseAttributeName(name) {
    var options = {};

    // If a first character in attribute name is `!` — it’s an implied
    // default attribute
    if (name.charCodeAt(0) === EXCL) {
      name = name.slice(1);
      options.implied = true;
    }

    // Check for last character: if it’s a `.`, user wants boolean attribute
    if (name.charCodeAt(name.length - 1) === DOT$1) {
      name = name.slice(0, name.length - 1);
      options.boolean = true;
    }
    var attr = {
      name: name
    };
    if (Object.keys(options).length) {
      attr.options = options;
    }
    return attr;
  }

  /**
   * Eats token that can be an unquoted value from given stream
   * @param  {StreamReader} stream
   * @return {Boolean}
   */
  function eatUnquoted(stream) {
    var start = stream.pos;
    if (stream.eatWhile(isUnquoted)) {
      stream.start = start;
      return true;
    }
  }
  function isUnquoted(code) {
    return !isSpace(code) && !isQuote$1(code) && code !== ATTR_OPEN && code !== ATTR_CLOSE && code !== EQUALS$1;
  }
  var HASH = 35; // #
  var DOT = 46; // .
  var SLASH$1 = 47; // /

  /**
   * Consumes a single element node from current abbreviation stream
   * @param  {StringReader} stream
   * @return {Node}
   */
  var consumeElement = function (stream) {
    // consume element name, if provided
    var start = stream.pos;
    var node = new Node(eatName(stream));
    var next;
    while (!stream.eof()) {
      if (stream.eat(DOT)) {
        node.addClass(eatName(stream));
      } else if (stream.eat(HASH)) {
        node.setAttribute('id', eatName(stream));
      } else if (stream.eat(SLASH$1)) {
        // A self-closing indicator must be at the end of non-grouping node
        if (node.isGroup) {
          stream.backUp(1);
          throw stream.error('Unexpected self-closing indicator');
        }
        node.selfClosing = true;
        if (next = consumeRepeat(stream)) {
          node.repeat = next;
        }
        break;
      } else if (next = consumeAttributes(stream)) {
        for (var i = 0, il = next.length; i < il; i++) {
          node.setAttribute(next[i]);
        }
      } else if ((next = consumeTextNode(stream)) !== null) {
        node.value = next;
      } else if (next = consumeRepeat(stream)) {
        node.repeat = next;
      } else {
        break;
      }
    }
    if (start === stream.pos) {
      throw stream.error("Unable to consume abbreviation node, unexpected " + stream.peek());
    }
    return node;
  };
  function eatName(stream) {
    stream.start = stream.pos;
    stream.eatWhile(isName);
    return stream.current();
  }
  function isName(code) {
    return isAlphaNumeric(code) || code === 45 /* - */ || code === 58 /* : */ || code === 36 /* $ */ || code === 64 /* @ */ || code === 33 /* ! */ || code === 95 /* _ */ || code === 37 /* % */;
  }

  var GROUP_START = 40; // (
  var GROUP_END = 41; // )
  var OP_SIBLING = 43; // +
  var OP_CHILD = 62; // >
  var OP_CLIMB = 94; // ^

  /**
   * Parses given string into a node tree
   * @param  {String} str Abbreviation to parse
   * @return {Node}
   */
  function parse(str) {
    var stream = new StreamReader$1(str.trim());
    var root = new Node();
    var ctx = root,
      groupStack = [],
      ch;
    while (!stream.eof()) {
      ch = stream.peek();
      if (ch === GROUP_START) {
        // start of group
        // The grouping node should be detached to properly handle
        // out-of-bounds `^` operator. Node will be attached right on group end
        var node = new Node();
        var groupCtx = groupStack.length ? last(groupStack)[0] : ctx;
        groupStack.push([node, groupCtx, stream.pos]);
        ctx = node;
        stream.next();
        continue;
      } else if (ch === GROUP_END) {
        // end of group
        var lastGroup = groupStack.pop();
        if (!lastGroup) {
          throw stream.error('Unexpected ")" group end');
        }
        var node$1 = lastGroup[0];
        ctx = lastGroup[1];
        stream.next();

        // a group can have a repeater
        if (node$1.repeat = consumeRepeat(stream)) {
          ctx.appendChild(node$1);
        } else {
          // move all children of group into parent node
          while (node$1.firstChild) {
            ctx.appendChild(node$1.firstChild);
          }
          // for convenience, groups can be joined with optional `+` operator
          stream.eat(OP_SIBLING);
        }
        continue;
      }
      var node$2 = consumeElement(stream);
      ctx.appendChild(node$2);
      if (stream.eof()) {
        break;
      }
      switch (stream.peek()) {
        case OP_SIBLING:
          stream.next();
          continue;
        case OP_CHILD:
          stream.next();
          ctx = node$2;
          continue;
        case OP_CLIMB:
          // it’s perfectly valid to have multiple `^` operators
          while (stream.eat(OP_CLIMB)) {
            ctx = ctx.parent || ctx;
          }
          continue;
      }
    }
    if (groupStack.length) {
      stream.pos = groupStack.pop()[2];
      throw stream.error('Expected group close');
    }
    return root;
  }
  function last(arr) {
    return arr[arr.length - 1];
  }

  /**
   * Parses given abbreviation and un-rolls it into a full tree: recursively
   * replaces repeated elements with actual nodes
   * @param  {String} abbr
   * @return {Node}
   */
  var index = function (abbr) {
    var tree = parse(abbr);
    tree.walk(unroll);
    return tree;
  };
  function unroll(node) {
    if (!node.repeat || !node.repeat.count) {
      return;
    }
    for (var i = 1; i < node.repeat.count; i++) {
      var clone = node.clone(true);
      clone.repeat.value = i;
      clone.walk(unroll);
      node.parent.insertBefore(clone, node);
    }
    node.repeat.value = node.repeat.count;
  }

  /**
   * For every node in given `tree`, finds matching snippet from `registry` and
   * resolves it into a parsed abbreviation. Resolved node is then updated or
   * replaced with matched abbreviation tree.
   *
   * A HTML registry basically contains aliases to another Emmet abbreviations,
   * e.g. a predefined set of name, attribues and so on, possibly a complex
   * abbreviation with multiple elements. So we have to get snippet, parse it
   * and recursively resolve it.
   *
   * @param  {Node} tree                 Parsed Emmet abbreviation
   * @param  {SnippetsRegistry} registry Registry with all available snippets
   * @return {Node} Updated tree
   */

  var index$1 = function (tree, registry) {
    tree.walk(function (node) {
      return resolveNode(node, registry);
    });
    return tree;
  };
  function resolveNode(node, registry) {
    var stack = new Set();
    var resolve = function (node) {
      var snippet = registry.resolve(node.name);
      // A snippet in stack means circular reference.
      // It can be either a user error or a perfectly valid snippet like
      // "img": "img[src alt]/", e.g. an element with predefined shape.
      // In any case, simply stop parsing and keep element as is
      if (!snippet || stack.has(snippet)) {
        return;
      }

      // In case if matched snippet is a function, pass control into it
      if (typeof snippet.value === 'function') {
        return snippet.value(node, registry, resolve);
      }
      var tree = index(snippet.value);
      stack.add(snippet);
      tree.walk(resolve);
      stack.delete(snippet);

      // move current node contents into new tree
      var childTarget = findDeepestNode(tree);
      merge(childTarget, node);
      while (tree.firstChild) {
        node.parent.insertBefore(tree.firstChild, node);
      }
      childTarget.parent.insertBefore(node, childTarget);
      childTarget.remove();
    };
    resolve(node);
  }

  /**
   * Adds data from first node into second node and returns it
   * @param  {Node} from
   * @param  {Node} to
   * @return {Node}
   */
  function merge(from, to) {
    to.name = from.name;
    if (from.selfClosing) {
      to.selfClosing = true;
    }
    if (from.value != null) {
      to.value = from.value;
    }
    if (from.repeat) {
      to.repeat = Object.assign({}, from.repeat);
    }
    return mergeAttributes(from, to);
  }

  /**
   * Transfer attributes from first element to second one and preserve first
   * element’s attributes order
   * @param  {Node} from
   * @param  {Node} to
   * @return {Node}
   */
  function mergeAttributes(from, to) {
    mergeClassNames(from, to);

    // It’s important to preserve attributes order: ones in `from` have higher
    // pripority than in `to`. Collect attributes in map in order they should
    // appear in `to`
    var attrMap = new Map();
    var attrs = from.attributes;
    for (var i = 0; i < attrs.length; i++) {
      attrMap.set(attrs[i].name, attrs[i].clone());
    }
    attrs = to.attributes.slice();
    for (var i$1 = 0, attr = void 0, a = void 0; i$1 < attrs.length; i$1++) {
      attr = attrs[i$1];
      if (attrMap.has(attr.name)) {
        a = attrMap.get(attr.name);
        a.value = attr.value;

        // If user explicitly wrote attribute in abbreviation, it’s no longer
        // implied and should be outputted even if value is empty
        if (a.options.implied) {
          a.options.implied = false;
        }
      } else {
        attrMap.set(attr.name, attr);
      }
      to.removeAttribute(attr);
    }
    var newAttrs = Array.from(attrMap.values());
    for (var i$2 = 0; i$2 < newAttrs.length; i$2++) {
      to.setAttribute(newAttrs[i$2]);
    }
    return to;
  }

  /**
   * Adds class names from first node to second one
   * @param  {Node} from
   * @param  {Node} to
   * @return {Node}
   */
  function mergeClassNames(from, to) {
    var classNames = from.classList;
    for (var i = 0; i < classNames.length; i++) {
      to.addClass(classNames[i]);
    }
    return to;
  }

  /**
   * Finds node which is the deepest for in current node or node iteself.
   * @param  {Node} node
   * @return {Node}
   */
  function findDeepestNode(node) {
    while (node.children.length) {
      node = node.children[node.children.length - 1];
    }
    return node;
  }
  var inlineElements = new Set('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(','));
  var elementMap = {
    p: 'span',
    ul: 'li',
    ol: 'li',
    table: 'tr',
    tr: 'td',
    tbody: 'tr',
    thead: 'tr',
    tfoot: 'tr',
    colgroup: 'col',
    select: 'option',
    optgroup: 'option',
    audio: 'source',
    video: 'source',
    object: 'param',
    map: 'area'
  };

  /**
   * Returns best child node name for given parent node name
   * @param  {String} parentName Name of parent node
   * @return {String}
   */
  function resolveImplicitName(parentName) {
    parentName = (parentName || '').toLowerCase();
    return elementMap[parentName] || (inlineElements.has(parentName) ? 'span' : 'div');
  }

  /**
   * Adds missing tag names for given tree depending on node’s parent name
   */
  var implicitTags = function (tree) {
    tree.walk(function (node) {
      // resolve only nameless nodes without content
      if (node.name == null && node.attributes.length) {
        node.name = resolveImplicitName(node.parent.name);
      }
    });
    return tree;
  };

  /**
   * Locates all occurances of given `token` which are not escaped (e.g. are not
   * preceded with `\`) given in `str`
   * @param  {String} str
   * @return {Array}  Array of token ranges
   */
  function findUnescapedTokens(str, token) {
    var result = new Set();
    var tlen = token.length;

    // 1. Find all occurances of tokens
    var pos = 0;
    while ((pos = str.indexOf(token, pos)) !== -1) {
      result.add(pos);
      pos += tlen;
    }
    if (result.size) {
      // 2. Remove ones that escaped
      var pos$1 = 0;
      var len = str.length;
      while (pos$1 < len) {
        if (str[pos$1++] === '\\') {
          result.delete(pos$1++);
        }
      }
    }
    return Array.from(result).map(function (ix) {
      return range(ix, tlen);
    });
  }

  /**
   * Replaces `ranges`, generated by `range()` function, with given `value` in `str`
   * @param  {String} str    Where to replace ranges
   * @param  {Array} ranges Ranes, created by `range()` function
   * @param  {String|Function} value  Replacement value. If it’s a function, it
   * will take a range value as argument and should return a new string
   * @return {String}
   */
  function replaceRanges(str, ranges, value) {
    // should walk from the end of array to keep ranges valid after replacement
    for (var i = ranges.length - 1; i >= 0; i--) {
      var r = ranges[i];
      str = str.substring(0, r[0]) + (typeof value === 'function' ? value(str.substr(r[0], r[1])) : value) + str.substring(r[0] + r[1]);
    }
    return str;
  }
  function range(start, length) {
    return [start, length];
  }
  var numberingToken = '$';

  /**
   * Numbering of expanded abbreviation: finds all nodes with `$` in value
   * or attributes and replaces its occurances with repeater value
   */
  var applyNumbering = function (tree) {
    tree.walk(applyNumbering$1);
    return tree;
  };

  /**
   * Applies numbering for given node: replaces occurances of numbering token
   * in node’s name, content and attributes
   * @param  {Node} node
   * @return {Node}
   */
  function applyNumbering$1(node) {
    var repeater = findRepeater(node);
    if (repeater && repeater.value != null) {
      // NB replace numbering in nodes with explicit repeater only:
      // it solves issues with abbreviations like `xsl:if[test=$foo]` where
      // `$foo` is preferred output
      var value = repeater.value;
      node.name = replaceNumbering(node.name, value);
      node.value = replaceNumbering(node.value, value);
      node.attributes.forEach(function (attr) {
        var copy = node.getAttribute(attr.name).clone();
        copy.name = replaceNumbering(attr.name, value);
        copy.value = replaceNumbering(attr.value, value);
        node.replaceAttribute(attr.name, copy);
      });
    }
    return node;
  }

  /**
   * Returns repeater object for given node
   * @param  {Node} node
   * @return {Object}
   */
  function findRepeater(node) {
    while (node) {
      if (node.repeat) {
        return node.repeat;
      }
      node = node.parent;
    }
  }

  /**
   * Replaces numbering in given string
   * @param  {String} str
   * @param  {Number} value
   * @return {String}
   */
  function replaceNumbering(str, value) {
    // replace numbering in strings only: skip explicit wrappers that could
    // contain unescaped numbering tokens
    if (typeof str === 'string') {
      var ranges = getNumberingRanges(str);
      return replaceNumberingRanges(str, ranges, value);
    }
    return str;
  }

  /**
   * Returns numbering ranges, e.g. ranges of `$` occurances, in given string.
   * Multiple adjacent ranges are combined
   * @param  {String} str
   * @return {Array}
   */
  function getNumberingRanges(str) {
    return findUnescapedTokens(str || '', numberingToken).reduce(function (out, range$$1) {
      // skip ranges that actually belongs to output placeholder or tabstops
      if (!/[#{]/.test(str[range$$1[0] + 1] || '')) {
        var lastRange = out[out.length - 1];
        if (lastRange && lastRange[0] + lastRange[1] === range$$1[0]) {
          lastRange[1] += range$$1[1];
        } else {
          out.push(range$$1);
        }
      }
      return out;
    }, []);
  }

  /**
   * @param  {String} str
   * @param  {Array} ranges
   * @param  {Number} value
   * @return {String}
   */
  function replaceNumberingRanges(str, ranges, value) {
    var replaced = replaceRanges(str, ranges, function (token) {
      var _value = String(value);
      // pad values for multiple numbering tokens, e.g. 3 for $$$ becomes 003
      while (_value.length < token.length) {
        _value = '0' + _value;
      }
      return _value;
    });

    // unescape screened numbering tokens
    return unescapeString(replaced);
  }

  /**
   * Unescapes characters, screened with `\`, in given string
   * @param  {String} str
   * @return {String}
   */
  function unescapeString(str) {
    var i = 0,
      result = '';
    var len = str.length;
    while (i < len) {
      var ch = str[i++];
      result += ch === '\\' ? str[i++] || '' : ch;
    }
    return result;
  }

  /** Placeholder for inserted content */
  var placeholder = '$#';

  /** Placeholder for caret */
  var caret = '|';
  var reUrl = /^((?:https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
  var reEmail = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/;
  var reProto = /^([a-z]+:)?\/\//i;

  /**
   * Inserts content into node with implicit repeat count: this node is then
   * duplicated for each content item and content itself is inserted either into
   * deepest child or instead of a special token.
   *
   * This method uses two distinct steps: `prepare()` and `insert()` since most
   * likely these steps will be used separately to properly insert content
   * with unescaped `$` numbering markers.
   *
   * @param {Node} tree Parsed abbreviation
   * @param {String[]} content Array of content items to insert
   * @return {Node}
   */
  /**
   * Finds nodes with implicit repeat and creates `amount` copies of it in tree
   * @param  {Node} tree
   * @param  {Number} amount
   * @return {Node}
   */
  function prepare(tree, amount) {
    amount = amount || 1;
    tree.walk(function (node) {
      if (node.repeat && node.repeat.count === null) {
        for (var i = 0; i < amount; i++) {
          var clone = node.clone(true);
          clone.repeat.implicit = true;
          clone.repeat.count = amount;
          clone.repeat.value = i + 1;
          clone.repeat.index = i;
          node.parent.insertBefore(clone, node);
        }
        node.remove();
      }
    });
    return tree;
  }

  /**
   * Inserts content into implicitly repeated nodes, created by `prepare()` method
   * @param  {Node} tree
   * @param  {String[]} content
   * @return {Node}
   */
  function insert(tree, content) {
    if (Array.isArray(content) && content.length) {
      var updated = false;
      tree.walk(function (node) {
        if (node.repeat && node.repeat.implicit) {
          updated = true;
          insertContent(node, content[node.repeat.index]);
        }
      });
      if (!updated) {
        // no node with implicit repeat was found, insert content as
        // deepest child
        setNodeContent(findDeepestNode$1(tree), content.join('\n'));
      }
    }
    return tree;
  }

  /**
   * Inserts `content` into given `node`: either replaces output placeholders
   * or inserts it into deepest child node
   * @param  {Node} node
   * @param  {String} content
   * @return {Node}
   */
  function insertContent(node, content) {
    var inserted = insertContentIntoPlaceholder(node, content);
    node.walk(function (child) {
      return inserted |= insertContentIntoPlaceholder(child, content);
    });
    if (!inserted) {
      // no placeholders were found in node, insert content into deepest child
      setNodeContent(findDeepestNode$1(node), content);
    }
    return node;
  }

  /**
   * Inserts given `content` into placeholders for given `node`. Placeholders
   * might be available in attribute values and node content
   * @param  {Node} node
   * @param  {String} content
   * @return {Boolean} Returns `true` if placeholders were found and replaced in node
   */
  function insertContentIntoPlaceholder(node, content) {
    var state = {
      replaced: false
    };
    node.value = replacePlaceholder(node.value, content, state);
    node.attributes.forEach(function (attr) {
      if (attr.value) {
        node.setAttribute(attr.name, replacePlaceholder(attr.value, content, state));
      }
    });
    return state.replaced;
  }

  /**
   * Replaces all placeholder occurances in given `str` with `value`
   * @param  {String} str
   * @param  {String} value
   * @param  {Object} [_state] If provided, set `replaced` property of given
   * object to `true` if placeholder was found and replaced
   * @return {String}
   */
  function replacePlaceholder(str, value, _state) {
    if (typeof str === 'string') {
      var ranges = findUnescapedTokens(str, placeholder);
      if (ranges.length) {
        if (_state) {
          _state.replaced = true;
        }
        str = replaceRanges(str, ranges, value);
      }
    }
    return str;
  }

  /**
   * Finds node which is the deepest for in current node or node iteself.
   * @param  {Node} node
   * @return {Node}
   */
  function findDeepestNode$1(node) {
    while (node.children.length) {
      node = node.children[node.children.length - 1];
    }
    return node;
  }

  /**
   * Updates content of given node
   * @param {Node} node
   * @param {String} content
   */
  function setNodeContent(node, content) {
    // find caret position and replace it with content, if possible
    if (node.value) {
      var ranges = findUnescapedTokens(node.value, caret);
      if (ranges.length) {
        node.value = replaceRanges(node.value, ranges, content);
        return;
      }
    }
    if (node.name.toLowerCase('a') || node.hasAttribute('href')) {
      // special case: inserting content into `<a>` tag
      if (reUrl.test(content)) {
        node.setAttribute('href', (reProto.test(content) ? '' : 'http://') + content);
      } else if (reEmail.test(content)) {
        node.setAttribute('href', 'mailto:' + content);
      }
    }
    node.value = content;
  }
  var defaultOptions$3 = {
    element: '__',
    modifier: '_'
  };
  var reElement = /^(-+)([a-z0-9]+)/i;
  var reModifier = /^(_+)([a-z0-9]+)/i;
  var blockCandidates1 = function (className) {
    return /^[a-z]\-/i.test(className);
  };
  var blockCandidates2 = function (className) {
    return /^[a-z]/i.test(className);
  };

  /**
   * BEM transformer: updates class names written as `-element` and
   * `_modifier` into full class names as described in BEM specs. Also adds missing
   * class names: fir example, if node contains `.block_modifier` class, ensures
   * that element contains `.block` class as well
   */
  var bem = function (tree, options) {
    options = Object.assign({}, defaultOptions$3, options);
    tree.walk(function (node) {
      return expandClassNames(node, options);
    });
    var lookup = createBlockLookup(tree);
    tree.walk(function (node) {
      return expandShortNotation(node, lookup, options);
    });
    return tree;
  };

  /**
   * Expands existing class names in BEM notation in given `node`.
   * For example, if node contains `b__el_mod` class name, this method ensures
   * that element contains `b__el` class as well
   * @param  {Node} node
   * @param  {Object} options
   * @return {Set}
   */
  function expandClassNames(node, options) {
    var classNames = node.classList.reduce(function (out, cl) {
      // remove all modifiers from class name to get a base element name
      var ix = cl.indexOf(options.modifier);
      if (ix !== -1) {
        out.add(cl.slice(0, ix));
      }
      return out.add(cl);
    }, new Set());
    if (classNames.size) {
      node.setAttribute('class', Array.from(classNames).join(' '));
    }
  }

  /**
   * Expands short BEM notation, e.g. `-element` and `_modifier`
   * @param  {Node} node      Parsed Emmet abbreviation node
   * @param  {Map} lookup     BEM block name lookup
   * @param  {Object} options
   */
  function expandShortNotation(node, lookup, options) {
    var classNames = node.classList.reduce(function (out, cl) {
      var prefix, m;
      var originalClass = cl;

      // parse element definition (could be only one)
      if (m = cl.match(reElement)) {
        prefix = getBlockName(node, lookup, m[1]) + options.element + m[2];
        out.add(prefix);
        cl = cl.slice(m[0].length);
      }

      // parse modifiers definitions (may contain multiple)
      while (m = cl.match(reModifier)) {
        if (!prefix) {
          prefix = getBlockName(node, lookup, m[1]);
          out.add(prefix);
        }
        out.add("" + prefix + options.modifier + m[2]);
        cl = cl.slice(m[0].length);
      }
      if (cl === originalClass) {
        // class name wasn’t modified: it’s not a BEM-specific class,
        // add it as-is into output
        out.add(originalClass);
      }
      return out;
    }, new Set());
    node.setAttribute('class', Array.from(classNames).join(' '));
  }

  /**
   * Creates block name lookup for each node in given tree, e.g. finds block
   * name explicitly for each node
   * @param  {Node} tree
   * @return {Map}
   */
  function createBlockLookup(tree) {
    var lookup = new Map();
    tree.walk(function (node) {
      var classNames = node.classList;
      if (classNames.length) {
        // guess best block name from class or use parent’s block name
        lookup.set(node, find(classNames, blockCandidates1) || find(classNames, blockCandidates2) || lookup.get(node.parent));
      }
    });
    return lookup;
  }

  /**
   * Returns block name for given `node` by `prefix`, which tells the depth of
   * of parent node lookup
   * @param  {Node} node
   * @param  {Map} lookup
   * @param  {String} prefix
   * @return {String}
   */
  function getBlockName(node, lookup, prefix) {
    var depth = prefix.length > 1 ? prefix.length : 0;
    while (node.parent && depth--) {
      node = node.parent;
    }
    return lookup.get(node);
  }
  function find(arr, filter) {
    return arr.filter(filter)[0];
  }

  /**
   * JSX transformer: replaces `class` and `for` attributes with `className` and
   * `htmlFor` attributes respectively
   */
  var jsx = function (tree) {
    tree.walk(function (node) {
      replace(node, 'class', 'className');
      replace(node, 'for', 'htmlFor');
    });
    return tree;
  };
  function replace(node, oldName, newName) {
    var attr = node.getAttribute(oldName);
    if (attr) {
      attr.name = newName;
    }
  }
  var reSupporterNames = /^xsl:(variable|with\-param)$/i;

  /**
   * XSL transformer: removes `select` attributes from certain nodes that contain
   * children
   */
  var xsl = function (tree) {
    tree.walk(function (node) {
      if (reSupporterNames.test(node.name || '') && (node.children.length || node.value)) {
        node.removeAttribute('select');
      }
    });
    return tree;
  };
  var supportedAddons = {
    bem: bem,
    jsx: jsx,
    xsl: xsl
  };

  /**
   * Runs additional transforms on given tree.
   * These transforms may introduce side-effects and unexpected result
   * so they are not applied by default, authors must specify which addons
   * in `addons` argument as `{addonName: addonOptions}`
   * @param {Node} tree Parsed Emmet abbreviation
   * @param {Object} addons Add-ons to apply and their options
   */
  var addons = function (tree, addons) {
    Object.keys(addons || {}).forEach(function (key) {
      if (key in supportedAddons) {
        var addonOpt = typeof addons[key] === 'object' ? addons[key] : null;
        tree = tree.use(supportedAddons[key], addonOpt);
      }
    });
    return tree;
  };

  /**
   * Applies basic HTML-specific transformations for given parsed abbreviation:
   * – resolve implied tag names
   * – insert repeated content
   * – resolve node numbering
   */
  var index$2 = function (tree, content, appliedAddons) {
    if (typeof content === 'string') {
      content = [content];
    } else if (content && typeof content === 'object' && !Array.isArray(content)) {
      appliedAddons = content;
      content = null;
    }
    return tree.use(implicitTags).use(prepare, Array.isArray(content) ? content.length : null).use(applyNumbering).use(insert, content).use(addons, appliedAddons);
  };

  /**
   * Replaces all unescaped ${variable} occurances in given parsed abbreviation
   * `tree` with values provided in `variables` hash. Precede `$` with `\` to
   * escape it and skip replacement
   * @param {Node} tree Parsed abbreviation tree
   * @param {Object} variables Variables values
   * @return {Node}
   */
  function replaceVariables(tree, variables) {
    variables = variables || {};
    tree.walk(function (node) {
      return replaceInNode(node, variables);
    });
    return tree;
  }
  function replaceInNode(node, variables) {
    // Replace variables in attributes.
    var attrs = node.attributes;
    for (var i = 0, il = attrs.length; i < il; i++) {
      var attr = attrs[i];
      if (typeof attr.value === 'string') {
        node.setAttribute(attr.name, replaceInString(attr.value, variables));
      }
    }
    if (node.value != null) {
      node.value = replaceInString(node.value, variables);
    }
    return node;
  }

  /**
   * Replaces all unescaped `${variable}` occurances in given string with values
   * from `variables` object
   * @param  {String} string
   * @param  {Object} variables
   * @return {String}
   */
  function replaceInString(string, variables) {
    var model = createModel(string);
    var offset = 0;
    var output = '';
    for (var i = 0, il = model.variables.length; i < il; i++) {
      var v = model.variables[i];
      var value = v.name in variables ? variables[v.name] : v.name;
      if (typeof value === 'function') {
        value = value(model.string, v, offset + v.location);
      }
      output += model.string.slice(offset, v.location) + value;
      offset = v.location + v.length;
    }
    return output + model.string.slice(offset);
  }

  /**
   * Creates variable model from given string. The model contains a `string` with
   * all escaped variable tokens written without escape symbol and `variables`
   * property with all unescaped variables and their ranges
   * @param  {String} string
   * @return {Object}
   */
  function createModel(string) {
    var reVariable = /\$\{([a-z][\w\-]*)\}/ig;
    var escapeCharCode = 92; // `\` symbol
    var variables = [];

    // We have to replace unescaped (e.g. not preceded with `\`) tokens.
    // Instead of writing a stream parser, we’ll cut some edges here:
    // 1. Find all tokens
    // 2. Walk string char-by-char and resolve only tokens that are not escaped
    var tokens = new Map();
    var m;
    while (m = reVariable.exec(string)) {
      tokens.set(m.index, m);
    }
    if (tokens.size) {
      var start = 0,
        pos = 0,
        len = string.length;
      var output = '';
      while (pos < len) {
        if (string.charCodeAt(pos) === escapeCharCode && tokens.has(pos + 1)) {
          // Found escape symbol that escapes variable: we should
          // omit this symbol in output string and skip variable
          var token = tokens.get(pos + 1);
          output += string.slice(start, pos) + token[0];
          start = pos = token.index + token[0].length;
          tokens.delete(pos + 1);
          continue;
        }
        pos++;
      }
      string = output + string.slice(start);

      // Not using `.map()` here to reduce memory allocations
      var validMatches = Array.from(tokens.values());
      for (var i = 0, il = validMatches.length; i < il; i++) {
        var token$1 = validMatches[i];
        variables.push({
          name: token$1[1],
          location: token$1.index,
          length: token$1[0].length
        });
      }
    }
    return {
      string: string,
      variables: variables
    };
  }
  var DOLLAR = 36; // $
  var COLON$1 = 58; // :
  var ESCAPE$1 = 92; // \
  var OPEN_BRACE = 123; // {
  var CLOSE_BRACE = 125; // }

  /**
   * Finds fields in given string and returns object with field-less string
   * and array of fileds found
   * @param  {String} string
   * @return {Object}
   */
  function parse$2$1(string) {
    var stream = new StreamReader$1(string);
    var fields = [];
    var cleanString = '',
      offset = 0,
      pos = 0;
    var code, field;
    while (!stream.eof()) {
      code = stream.peek();
      pos = stream.pos;
      if (code === ESCAPE$1) {
        stream.next();
        stream.next();
      } else if (field = consumeField(stream, cleanString.length + pos - offset)) {
        fields.push(field);
        cleanString += stream.string.slice(offset, pos) + field.placeholder;
        offset = stream.pos;
      } else {
        stream.next();
      }
    }
    return new FieldString(cleanString + stream.string.slice(offset), fields);
  }

  /**
   * Marks given `string` with `fields`: wraps each field range with
   * `${index:placeholder}` (by default) or any other token produced by `token`
   * function, if provided
   * @param  {String} string String to mark
   * @param  {Array} fields Array of field descriptor. A field descriptor is a
   * `{index, location, length}` array. It is important that fields in array
   * must be ordered by their location in string: some fields my refer the same
   * location so they must appear in order that user expects.
   * @param  {Function} [token] Function that generates field token. This function
   * received two arguments: `index` and `placeholder` and should return string
   * @return {String}  String with marked fields
   */
  function mark(string, fields, token) {
    token = token || createToken;

    // order fields by their location and appearence
    // NB field ranges should not overlap! (not supported yet)
    var ordered = fields.map(function (field, order) {
      return {
        order: order,
        field: field,
        end: field.location + field.length
      };
    }).sort(function (a, b) {
      return a.end - b.end || a.order - b.order;
    });

    // mark ranges in string
    var offset = 0;
    var result = ordered.map(function (item) {
      var placeholder = string.substr(item.field.location, item.field.length);
      var prefix = string.slice(offset, item.field.location);
      offset = item.end;
      return prefix + token(item.field.index, placeholder);
    });
    return result.join('') + string.slice(offset);
  }

  /**
   * Creates field token for string
   * @param  {Number} index       Field index
   * @param  {String} placeholder Field placeholder, could be empty string
   * @return {String}
   */
  function createToken(index, placeholder) {
    return placeholder ? "${" + index + ":" + placeholder + "}" : "${" + index + "}";
  }

  /**
   * Consumes field from current stream position: it can be an `$index` or
   * or `${index}` or `${index:placeholder}`
   * @param  {StreamReader} stream
   * @param  {Number}       location Field location in *clean* string
   * @return {Object} Object with `index` and `placeholder` properties if
   * fieald was successfully consumed, `null` otherwise
   */
  function consumeField(stream, location) {
    var start = stream.pos;
    if (stream.eat(DOLLAR)) {
      // Possible start of field
      var index = consumeIndex(stream);
      var placeholder = '';

      // consumed $index placeholder
      if (index != null) {
        return new Field(index, placeholder, location);
      }
      if (stream.eat(OPEN_BRACE)) {
        index = consumeIndex(stream);
        if (index != null) {
          if (stream.eat(COLON$1)) {
            placeholder = consumePlaceholder(stream);
          }
          if (stream.eat(CLOSE_BRACE)) {
            return new Field(index, placeholder, location);
          }
        }
      }
    }

    // If we reached here then there’s no valid field here, revert
    // back to starting position
    stream.pos = start;
  }

  /**
   * Consumes a placeholder: value right after `:` in field. Could be empty
   * @param  {StreamReader} stream
   * @return {String}
   */
  function consumePlaceholder(stream) {
    var code;
    var stack = [];
    stream.start = stream.pos;
    while (!stream.eof()) {
      code = stream.peek();
      if (code === OPEN_BRACE) {
        stack.push(stream.pos);
      } else if (code === CLOSE_BRACE) {
        if (!stack.length) {
          break;
        }
        stack.pop();
      }
      stream.next();
    }
    if (stack.length) {
      throw stream.error('Unable to find matching "}" for curly brace at ' + stack.pop());
    }
    return stream.current();
  }

  /**
   * Consumes integer from current stream position
   * @param  {StreamReader} stream
   * @return {Number}
   */
  function consumeIndex(stream) {
    stream.start = stream.pos;
    if (stream.eatWhile(isNumber$1)) {
      return Number(stream.current());
    }
  }
  var Field = function Field(index, placeholder, location) {
    this.index = index;
    this.placeholder = placeholder;
    this.location = location;
    this.length = this.placeholder.length;
  };
  var FieldString = function FieldString(string, fields) {
    this.string = string;
    this.fields = fields;
  };
  FieldString.prototype.mark = function mark$1(token) {
    return mark(this.string, this.fields, token);
  };
  FieldString.prototype.toString = function toString() {
    return string;
  };
  var defaultFieldsRenderer = function (text) {
    return text;
  };

  /**
   * Output node is an object containing generated output for given Emmet
   * abbreviation node. Output node can be passed to various processors that
   * may shape-up final node output. The final output is simply a concatenation
   * of `.open`, `.text` and `.close` properties and its `.before*` and `.after*`
   * satellites
   * @param {Node}     node           Parsed Emmet abbreviation node
   * @param {Function} fieldsRenderer A function for rendering fielded text (text with
   * tabstops) for current node. @see ./render.js for details
   */
  var OutputNode = function OutputNode(node, fieldsRenderer, options) {
    if (typeof fieldsRenderer === 'object') {
      options = fieldsRenderer;
      fieldsRenderer = null;
    }
    this.node = node;
    this._fieldsRenderer = fieldsRenderer || defaultFieldsRenderer;
    this.open = null;
    this.beforeOpen = '';
    this.afterOpen = '';
    this.close = null;
    this.beforeClose = '';
    this.afterClose = '';
    this.text = null;
    this.beforeText = '';
    this.afterText = '';
    this.indent = '';
    this.newline = '';
    if (options) {
      Object.assign(this, options);
    }
  };
  OutputNode.prototype.clone = function clone() {
    return new this.constructor(this.node, this);
  };

  /**
  	 * Properly indents given multiline text
  	 * @param {String} text
  	 */
  OutputNode.prototype.indentText = function indentText(text) {
    var this$1 = this;
    var lines = splitByLines$1(text);
    if (lines.length === 1) {
      // no newlines, nothing to indent
      return text;
    }

    // No newline and no indent means no formatting at all:
    // in this case we should replace newlines with spaces
    var nl = !this.newline && !this.indent ? ' ' : this.newline;
    return lines.map(function (line, i) {
      return i ? this$1.indent + line : line;
    }).join(nl);
  };

  /**
  	 * Renders given text with fields
  	 * @param {String} text
  	 * @return {String}
  	 */
  OutputNode.prototype.renderFields = function renderFields(text) {
    return this._fieldsRenderer(text);
  };
  OutputNode.prototype.toString = function toString(children) {
    var open = this._wrap(this.open, this.beforeOpen, this.afterOpen);
    var close = this._wrap(this.close, this.beforeClose, this.afterClose);
    var text = this._wrap(this.text, this.beforeText, this.afterText);
    return open + text + (children != null ? children : '') + close;
  };
  OutputNode.prototype._wrap = function _wrap(str, before, after) {
    before = before != null ? before : '';
    after = after != null ? after : '';

    // automatically trim whitespace for non-empty wraps
    if (str != null) {
      str = before ? str.replace(/^\s+/, '') : str;
      str = after ? str.replace(/\s+$/, '') : str;
      return before + this.indentText(str) + after;
    }
    return '';
  };

  /**
   * Splits given text by lines
   * @param  {String} text
   * @return {String[]}
   */
  function splitByLines$1(text) {
    return (text || '').split(/\r\n|\r|\n/g);
  }

  /**
   * Default output of field (tabstop)
   * @param  {Number} index       Field index
   * @param  {String} placeholder Field placeholder, can be null
   * @return {String}
   */
  var defaultField = function (index, placeholder) {
    return placeholder || '';
  };

  /**
   * Renders given parsed abbreviation `tree` via `formatter` function.
  
   * @param {Node}     tree      Parsed Emmet abbreviation
   * @param {Function} [field]   Optional function to format field/tabstop (@see `defaultField`)
   * @param {Function} formatter Output formatter function. It takes an output node—
   * a special wrapper for parsed node that holds formatting and output properties—
   * and updates its output properties to shape-up node’s output.
   * Function arguments:
   * 	– `outNode`: OutputNode
   * 	– `renderFields`: a helper function that parses fields/tabstops from given
   * 	   text and replaces them with `field` function output.
   * 	   It also takes care about field indicies and ensures that the same indicies
   * 	   from different nodes won’t collide
   */
  function render(tree, field, formatter) {
    if (typeof formatter === 'undefined') {
      formatter = field;
      field = null;
    }
    field = field || defaultField;

    // Each node may contain fields like `${1:placeholder}`.
    // Since most modern editors will link all fields with the same
    // index, we have to ensure that different nodes has their own indicies.
    // We’ll use this `fieldState` object to globally increment field indices
    // during output
    var fieldState = {
      index: 1
    };
    var fieldsRenderer = function (text) {
      return text == null ? field(fieldState.index++) : getFieldsModel(text, fieldState).mark(field);
    };
    return run(tree.children, formatter, fieldsRenderer);
  }
  function run(nodes, formatter, fieldsRenderer) {
    return nodes.filter(notGroup).map(function (node) {
      var outNode = formatter(new OutputNode(node, fieldsRenderer));
      return outNode ? outNode.toString(run(node.children, formatter, fieldsRenderer)) : '';
    }).join('');
  }
  function notGroup(node) {
    return !node.isGroup;
  }

  /**
   * Returns fields (tab-stops) model with properly updated indices that won’t
   * collide with fields in other nodes of foprmatted tree
   * @param  {String|Object} text Text to get fields model from or model itself
   * @param  {Object} fieldState Abbreviation tree-wide field state reference
   * @return {Object} Field model
   */
  function getFieldsModel(text, fieldState) {
    var model = typeof text === 'object' ? text : parse$2$1(text);
    var largestIndex = -1;
    model.fields.forEach(function (field) {
      field.index += fieldState.index;
      if (field.index > largestIndex) {
        largestIndex = field.index;
      }
    });
    if (largestIndex !== -1) {
      fieldState.index = largestIndex + 1;
    }
    return model;
  }
  var TOKEN = /^(.*?)([A-Z_]+)(.*?)$/;
  var TOKEN_OPEN = 91; // [
  var TOKEN_CLOSE = 93; // ]

  /**
   * A basic templating engine.
   * Takes every `[TOKEN]` from given string and replaces it with
   * `TOKEN` value from given `data` attribute. The token itself may contain
   * various characters between `[`, token name and `]`. Contents of `[...]` will
   * be outputted only if `TOKEN` value is not empty. Also, only `TOKEN` name will
   * be replaced with actual value, all other characters will remain as is.
   *
   * Example:
   * ```
   * template('[<NAME>]', {NAME: 'foo'}) -> "<foo>"
   * template('[<NAME>]', {}) -> ""
   * ```
   */
  function template(str, data) {
    if (str == null) {
      return str;
    }

    // NB since token may contain inner `[` and `]`, we can’t just use regexp
    // for replacement, should manually parse string instead
    var stack = [];
    var replacer = function (str, left, token, right) {
      return data[token] != null ? left + data[token] + right : '';
    };
    var output = '';
    var offset = 0,
      i = 0;
    var code, lastPos;
    while (i < str.length) {
      code = str.charCodeAt(i);
      if (code === TOKEN_OPEN) {
        stack.push(i);
      } else if (code === TOKEN_CLOSE) {
        lastPos = stack.pop();
        if (!stack.length) {
          output += str.slice(offset, lastPos) + str.slice(lastPos + 1, i).replace(TOKEN, replacer);
          offset = i + 1;
        }
      }
      i++;
    }
    return output + str.slice(offset);
  }

  /**
   * Various utility methods used by formatters
   */

  /**
   * Splits given text by lines
   * @param  {String} text
   * @return {String[]}
   */
  function splitByLines(text) {
    return (text || '').split(/\r\n|\r|\n/g);
  }

  /**
   * Check if given node is a first child in its parent
   * @param  {Node}  node
   * @return {Boolean}
   */
  function isFirstChild(node) {
    return node.parent.firstChild === node;
  }

  /**
   * Check if given node is a last child in its parent node
   * @param  {Node}  node
   * @return {Boolean}
   */

  /**
   * Check if given node is a root node
   * @param  {Node}  node
   * @return {Boolean}
   */
  function isRoot(node) {
    return node && !node.parent;
  }

  /**
   * Check if given node is a pseudo-snippet: a text-only node with explicitly
   * defined children
   * @param  {Node}  node
   * @return {Boolean}
   */
  function isPseudoSnippet(node) {
    return node.isTextOnly && !!node.children.length;
  }

  /**
   * Handles pseudo-snippet node.
   * A pseudo-snippet is a text-only node with explicitly defined children.
   * For such case, we have to figure out if pseudo-snippet contains fields
   * (tab-stops) in node value and “split” it: make contents before field with
   * lowest index node’s “open” part and contents after lowest index — “close”
   * part. With this trick a final output will look like node’s children
   * are nested inside node value
   * @param  {OutputNode} outNode
   * @return {Boolean} Returns “true” if given node is a pseudo-snippets,
   * `false` otherwise
   */
  function handlePseudoSnippet(outNode) {
    var node = outNode.node; // original abbreviaiton node

    if (isPseudoSnippet(node)) {
      var fieldsModel = parse$2$1(node.value);
      var field = findLowestIndexField(fieldsModel);
      if (field) {
        var parts = splitFieldsModel(fieldsModel, field);
        outNode.open = outNode.renderFields(parts[0]);
        outNode.close = outNode.renderFields(parts[1]);
      } else {
        outNode.text = outNode.renderFields(fieldsModel);
      }
      return true;
    }
    return false;
  }

  /**
   * Finds field with lowest index in given text
   * @param  {Object} model
   * @return {Object}
   */
  function findLowestIndexField(model) {
    return model.fields.reduce(function (result, field) {
      return !result || field.index < result.index ? field : result;
    }, null);
  }

  /**
   * Splits given fields model in two parts by given field
   * @param  {Object} model
   * @param  {Object} field
   * @return {Array} Two-items array
   */
  function splitFieldsModel(model, field) {
    var ix = model.fields.indexOf(field);
    var left = new model.constructor(model.string.slice(0, field.location), model.fields.slice(0, ix));
    var right = new model.constructor(model.string.slice(field.location + field.length), model.fields.slice(ix + 1));
    return [left, right];
  }
  var commentOptions = {
    // enable node commenting
    enabled: false,
    // attributes that should trigger node commenting on specific node,
    // if commenting is enabled
    trigger: ['id', 'class'],
    // comment before opening tag
    before: '',
    // comment after closing tag
    after: '\n<!-- /[#ID][.CLASS] -->'
  };

  /**
   * Renders given parsed Emmet abbreviation as HTML, formatted according to
   * `profile` options
   * @param  {Node}     tree    Parsed Emmet abbreviation
   * @param  {Profile}  profile Output profile
   * @param  {Object}  [options] Additional formatter options
   * @return {String}
   */
  function html(tree, profile, options) {
    options = Object.assign({}, options);
    options.comment = Object.assign({}, commentOptions, options.comment);
    return render(tree, options.field, function (outNode) {
      outNode = setFormatting(outNode, profile);
      if (!handlePseudoSnippet(outNode)) {
        var node = outNode.node;
        if (node.name) {
          var name = profile.name(node.name);
          var attrs = formatAttributes(outNode, profile);
          outNode.open = "<" + name + attrs + (node.selfClosing ? profile.selfClose() : '') + ">";
          if (!node.selfClosing) {
            outNode.close = "</" + name + ">";
          }
          commentNode(outNode, options.comment);
        }

        // Do not generate fields for nodes with empty value and children
        // or if node is self-closed
        if (node.value || !node.children.length && !node.selfClosing) {
          outNode.text = outNode.renderFields(node.value);
        }
      }
      return outNode;
    });
  }

  /**
   * Updates formatting properties for given output node
   * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node
   * @param  {Profile}    profile Output profile
   * @return {OutputNode}
   */
  function setFormatting(outNode, profile) {
    var node = outNode.node;
    if (shouldFormatNode(node, profile)) {
      outNode.indent = profile.indent(getIndentLevel(node, profile));
      outNode.newline = '\n';
      var prefix = outNode.newline + outNode.indent;

      // do not format the very first node in output
      if (!isRoot(node.parent) || !isFirstChild(node)) {
        outNode.beforeOpen = prefix;
        if (node.isTextOnly) {
          outNode.beforeText = prefix;
        }
      }
      if (hasInnerFormatting(node, profile)) {
        if (!node.isTextOnly) {
          outNode.beforeText = prefix + profile.indent(1);
        }
        outNode.beforeClose = prefix;
      }
    }
    return outNode;
  }

  /**
   * Check if given node should be formatted
   * @param  {Node} node
   * @param  {Profile} profile
   * @return {Boolean}
   */
  function shouldFormatNode(node, profile) {
    if (!profile.get('format')) {
      return false;
    }
    if (node.parent.isTextOnly && node.parent.children.length === 1 && parse$2$1(node.parent.value).fields.length) {
      // Edge case: do not format the only child of text-only node,
      // but only if parent contains fields
      return false;
    }
    return isInline(node, profile) ? shouldFormatInline(node, profile) : true;
  }

  /**
   * Check if given inline node should be formatted as well, e.g. it contains
   * enough adjacent siblings that should force formatting
   * @param  {Node} node
   * @param  {Profile} profile
   * @return {Boolean}
   */
  function shouldFormatInline(node, profile) {
    if (!isInline(node, profile)) {
      return false;
    }
    if (isPseudoSnippet(node)) {
      return true;
    }

    // check if inline node is the next sibling of block-level node
    if (node.childIndex === 0) {
      // first node in parent: format if it’s followed by a block-level element
      var next = node;
      while (next = next.nextSibling) {
        if (!isInline(next, profile)) {
          return true;
        }
      }
    } else if (!isInline(node.previousSibling, profile)) {
      // node is right after block-level element
      return true;
    }
    if (profile.get('inlineBreak')) {
      // check for adjacent inline elements before and after current element
      var adjacentInline = 1;
      var before = node,
        after = node;
      while (isInlineElement(before = before.previousSibling, profile)) {
        adjacentInline++;
      }
      while (isInlineElement(after = after.nextSibling, profile)) {
        adjacentInline++;
      }
      if (adjacentInline >= profile.get('inlineBreak')) {
        return true;
      }
    }

    // Another edge case: inline node contains node that should receive foramtting
    for (var i = 0, il = node.children.length; i < il; i++) {
      if (shouldFormatNode(node.children[i], profile)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Check if given node contains inner formatting, e.g. any of its children should
   * be formatted
   * @param  {Node} node
   * @param  {Profile} profile
   * @return {Boolean}
   */
  function hasInnerFormatting(node, profile) {
    // check if node if forced for inner formatting
    var nodeName = (node.name || '').toLowerCase();
    if (profile.get('formatForce').indexOf(nodeName) !== -1) {
      return true;
    }

    // check if any of children should receive formatting
    // NB don’t use `childrent.some()` to reduce memory allocations
    for (var i = 0; i < node.children.length; i++) {
      if (shouldFormatNode(node.children[i], profile)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Outputs attributes of given abbreviation node as HTML attributes
   * @param  {OutputNode} outNode
   * @param  {Profile}    profile
   * @return {String}
   */
  function formatAttributes(outNode, profile) {
    var node = outNode.node;
    return node.attributes.map(function (attr) {
      if (attr.options.implied && attr.value == null) {
        return null;
      }
      var attrName = profile.attribute(attr.name);
      var attrValue = null;

      // handle boolean attributes
      if (attr.options.boolean || profile.get('booleanAttributes').indexOf(attrName.toLowerCase()) !== -1) {
        if (profile.get('compactBooleanAttributes') && attr.value == null) {
          return " " + attrName;
        } else if (attr.value == null) {
          attrValue = attrName;
        }
      }
      if (attrValue == null) {
        attrValue = outNode.renderFields(attr.value);
      }
      return " " + attrName + "=" + profile.quote(attrValue);
    }).join('');
  }

  /**
   * Check if given node is inline-level
   * @param  {Node}  node
   * @param  {Profile}  profile
   * @return {Boolean}
   */
  function isInline(node, profile) {
    return node && node.isTextOnly || isInlineElement(node, profile);
  }

  /**
   * Check if given node is inline-level element, e.g. element with explicitly
   * defined node name
   * @param  {Node}  node
   * @param  {Profile}  profile
   * @return {Boolean}
   */
  function isInlineElement(node, profile) {
    return node && profile.isInline(node);
  }

  /**
   * Computes indent level for given node
   * @param  {Node} node
   * @param  {Profile} profile
   * @param  {Number} level
   * @return {Number}
   */
  function getIndentLevel(node, profile) {
    // Increase indent level IF NOT:
    // * parent is text-only node
    // * there’s a parent node with a name that is explicitly set to decrease level
    var skip = profile.get('formatSkip') || [];
    var level = node.parent.isTextOnly ? -2 : -1;
    var ctx = node;
    while (ctx = ctx.parent) {
      if (skip.indexOf((ctx.name || '').toLowerCase()) === -1) {
        level++;
      }
    }
    return level < 0 ? 0 : level;
  }

  /**
   * Comments given output node, if required
   * @param  {OutputNode} outNode
   * @param  {Object} options
   */
  function commentNode(outNode, options) {
    var node = outNode.node;
    if (!options.enabled || !options.trigger || !node.name) {
      return;
    }
    var attrs = outNode.node.attributes.reduce(function (out, attr) {
      if (attr.name && attr.value != null) {
        out[attr.name.toUpperCase().replace(/-/g, '_')] = attr.value;
      }
      return out;
    }, {});

    // add comment only if attribute trigger is present
    for (var i = 0, il = options.trigger.length; i < il; i++) {
      if (options.trigger[i].toUpperCase() in attrs) {
        outNode.open = template(options.before, attrs) + outNode.open;
        if (outNode.close) {
          outNode.close += template(options.after, attrs);
        }
        break;
      }
    }
  }

  /**
   * Common utility methods for indent-based syntaxes (Slim, Pug, etc.)
   */

  var reId = /^id$/i;
  var reClass = /^class$/i;
  var defaultAttrOptions = {
    primary: function (attrs) {
      return attrs.join('');
    },
    secondary: function (attrs) {
      return attrs.map(function (attr) {
        return attr.isBoolean ? attr.name : attr.name + "=" + attr.value;
      }).join(', ');
    }
  };
  var defaultNodeOptions = {
    open: null,
    close: null,
    omitName: /^div$/i,
    attributes: defaultAttrOptions
  };
  function indentFormat(outNode, profile, options) {
    options = Object.assign({}, defaultNodeOptions, options);
    var node = outNode.node;
    outNode.indent = profile.indent(getIndentLevel$1(node, profile));
    outNode.newline = '\n';

    // Do not format the very first node in output
    if (!isRoot(node.parent) || !isFirstChild(node)) {
      outNode.beforeOpen = outNode.newline + outNode.indent;
    }
    if (node.name) {
      var data = Object.assign({
        NAME: profile.name(node.name),
        SELF_CLOSE: node.selfClosing ? options.selfClose : null
      }, getAttributes(outNode, profile, options.attributes));

      // omit tag name if node has primary attributes
      if (options.omitName && options.omitName.test(data.NAME) && data.PRIMARY_ATTRS) {
        data.NAME = null;
      }
      if (options.open != null) {
        outNode.open = template(options.open, data);
      }
      if (options.close != null) {
        outNode.close = template(options.close, data);
      }
    }
    return outNode;
  }

  /**
   * Formats attributes of given node into a string.
   * @param  {OutputNode} node          Output node wrapper
   * @param  {Profile}    profile       Output profile
   * @param  {Object}     options       Additional formatting options
   * @return {String}
   */
  function getAttributes(outNode, profile, options) {
    options = Object.assign({}, defaultAttrOptions, options);
    var primary = [],
      secondary = [];
    var node = outNode.node;
    node.attributes.forEach(function (attr) {
      if (attr.options.implied && attr.value == null) {
        return null;
      }
      var name = profile.attribute(attr.name);
      var value = outNode.renderFields(attr.value);
      if (reId.test(name)) {
        value && primary.push("#" + value);
      } else if (reClass.test(name)) {
        value && primary.push("." + value.replace(/\s+/g, '.'));
      } else {
        var isBoolean = attr.value == null && (attr.options.boolean || profile.get('booleanAttributes').indexOf(name.toLowerCase()) !== -1);
        secondary.push({
          name: name,
          value: value,
          isBoolean: isBoolean
        });
      }
    });
    return {
      PRIMARY_ATTRS: options.primary(primary) || null,
      SECONDARY_ATTRS: options.secondary(secondary) || null
    };
  }

  /**
   * Computes indent level for given node
   * @param  {Node} node
   * @param  {Profile} profile
   * @param  {Number} level
   * @return {Number}
   */
  function getIndentLevel$1(node, profile) {
    var level = node.parent.isTextOnly ? -2 : -1;
    var ctx = node;
    while (ctx = ctx.parent) {
      level++;
    }
    return level < 0 ? 0 : level;
  }
  var reNl = /\n|\r/;

  /**
   * Renders given parsed Emmet abbreviation as HAML, formatted according to
   * `profile` options
   * @param  {Node}    tree      Parsed Emmet abbreviation
   * @param  {Profile} profile   Output profile
   * @param  {Object}  [options] Additional formatter options
   * @return {String}
   */
  function haml(tree, profile, options) {
    options = options || {};
    var nodeOptions = {
      open: '[%NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)][SELF_CLOSE]',
      selfClose: '/',
      attributes: {
        secondary: function secondary(attrs) {
          return attrs.map(function (attr) {
            return attr.isBoolean ? "" + attr.name + (profile.get('compactBooleanAttributes') ? '' : '=true') : attr.name + "=" + profile.quote(attr.value);
          }).join(' ');
        }
      }
    };
    return render(tree, options.field, function (outNode) {
      outNode = indentFormat(outNode, profile, nodeOptions);
      outNode = updateFormatting(outNode, profile);
      if (!handlePseudoSnippet(outNode)) {
        var node = outNode.node;

        // Do not generate fields for nodes with empty value and children
        // or if node is self-closed
        if (node.value || !node.children.length && !node.selfClosing) {
          outNode.text = outNode.renderFields(formatNodeValue(node, profile));
        }
      }
      return outNode;
    });
  }

  /**
   * Updates formatting properties for given output node
   * NB Unlike HTML, HAML is indent-based format so some formatting options from
   * `profile` will not take effect, otherwise output will be broken
   * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node
   * @param  {Profile}    profile Output profile
   * @return {OutputNode}
   */
  function updateFormatting(outNode, profile) {
    var node = outNode.node;
    if (!node.isTextOnly && node.value) {
      // node with text: put a space before single-line text
      outNode.beforeText = reNl.test(node.value) ? outNode.newline + outNode.indent + profile.indent(1) : ' ';
    }
    return outNode;
  }
  /**
   * Formats value of given node: for multiline text we should add a ` |` suffix
   * at the end of each line. Also ensure that text is perfectly aligned.
   * @param  {Node}    node
   * @param  {Profile} profile
   * @return {String|null}
   */
  function formatNodeValue(node, profile) {
    if (node.value != null && reNl.test(node.value)) {
      var lines = splitByLines(node.value);
      var indent = profile.indent(1);
      var maxLength = lines.reduce(function (prev, line) {
        return Math.max(prev, line.length);
      }, 0);
      return lines.map(function (line, i) {
        return "" + (i ? indent : '') + pad(line, maxLength) + " |";
      }).join('\n');
    }
    return node.value;
  }
  function pad(text, len) {
    while (text.length < len) {
      text += ' ';
    }
    return text;
  }
  var reNl$1 = /\n|\r/;
  var secondaryAttrs = {
    none: '[ SECONDARY_ATTRS]',
    round: '[(SECONDARY_ATTRS)]',
    curly: '[{SECONDARY_ATTRS}]',
    square: '[[SECONDARY_ATTRS]'
  };

  /**
   * Renders given parsed Emmet abbreviation as Slim, formatted according to
   * `profile` options
   * @param  {Node}    tree      Parsed Emmet abbreviation
   * @param  {Profile} profile   Output profile
   * @param  {Object}  [options] Additional formatter options
   * @return {String}
   */
  function slim(tree, profile, options) {
    options = options || {};
    var SECONDARY_ATTRS = options.attributeWrap && secondaryAttrs[options.attributeWrap] || secondaryAttrs.none;
    var booleanAttr = SECONDARY_ATTRS === secondaryAttrs.none ? function (attr) {
      return attr.name + "=true";
    } : function (attr) {
      return attr.name;
    };
    var nodeOptions = {
      open: "[NAME][PRIMARY_ATTRS]" + SECONDARY_ATTRS + "[SELF_CLOSE]",
      selfClose: '/',
      attributes: {
        secondary: function secondary(attrs) {
          return attrs.map(function (attr) {
            return attr.isBoolean ? booleanAttr(attr) : attr.name + "=" + profile.quote(attr.value);
          }).join(' ');
        }
      }
    };
    return render(tree, options.field, function (outNode, renderFields) {
      outNode = indentFormat(outNode, profile, nodeOptions);
      outNode = updateFormatting$1(outNode, profile);
      if (!handlePseudoSnippet(outNode)) {
        var node = outNode.node;

        // Do not generate fields for nodes with empty value and children
        // or if node is self-closed
        if (node.value || !node.children.length && !node.selfClosing) {
          outNode.text = outNode.renderFields(formatNodeValue$1(node, profile));
        }
      }
      return outNode;
    });
  }

  /**
   * Updates formatting properties for given output node
   * NB Unlike HTML, Slim is indent-based format so some formatting options from
   * `profile` will not take effect, otherwise output will be broken
   * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node
   * @param  {Profile}    profile Output profile
   * @return {OutputNode}
   */
  function updateFormatting$1(outNode, profile) {
    var node = outNode.node;
    var parent = node.parent;

    // Edge case: a single inline-level child inside node without text:
    // allow it to be inlined
    if (profile.get('inlineBreak') === 0 && isInline$1(node, profile) && !isRoot(parent) && parent.value == null && parent.children.length === 1) {
      outNode.beforeOpen = ': ';
    }
    if (!node.isTextOnly && node.value) {
      // node with text: put a space before single-line text
      outNode.beforeText = reNl$1.test(node.value) ? outNode.newline + outNode.indent + profile.indent(1) : ' ';
    }
    return outNode;
  }

  /**
   * Formats value of given node: for multiline text we should precede each
   * line with `| ` with one-level deep indent
   * @param  {Node} node
   * @param  {Profile} profile
   * @return {String|null}
   */
  function formatNodeValue$1(node, profile) {
    if (node.value != null && reNl$1.test(node.value)) {
      var indent = profile.indent(1);
      return splitByLines(node.value).map(function (line, i) {
        return "" + indent + (i ? ' ' : '|') + " " + line;
      }).join('\n');
    }
    return node.value;
  }

  /**
   * Check if given node is inline-level
   * @param  {Node}  node
   * @param  {Profile}  profile
   * @return {Boolean}
   */
  function isInline$1(node, profile) {
    return node && (node.isTextOnly || profile.isInline(node));
  }
  var reNl$2 = /\n|\r/;

  /**
   * Renders given parsed Emmet abbreviation as Pug, formatted according to
   * `profile` options
   * @param  {Node}    tree      Parsed Emmet abbreviation
   * @param  {Profile} profile   Output profile
   * @param  {Object}  [options] Additional formatter options
   * @return {String}
   */
  function pug(tree, profile, options) {
    options = options || {};
    var nodeOptions = {
      open: '[NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)]',
      attributes: {
        secondary: function secondary(attrs) {
          return attrs.map(function (attr) {
            return attr.isBoolean ? attr.name : attr.name + "=" + profile.quote(attr.value);
          }).join(', ');
        }
      }
    };
    return render(tree, options.field, function (outNode) {
      outNode = indentFormat(outNode, profile, nodeOptions);
      outNode = updateFormatting$2(outNode, profile);
      if (!handlePseudoSnippet(outNode)) {
        var node = outNode.node;
        // Do not generate fields for nodes with empty value and children
        // or if node is self-closed
        if (node.value || !node.children.length && !node.selfClosing) {
          outNode.text = outNode.renderFields(formatNodeValue$2(node, profile));
        }
      }
      return outNode;
    });
  }

  /**
   * Updates formatting properties for given output node
   * NB Unlike HTML, Pug is indent-based format so some formatting options from
   * `profile` will not take effect, otherwise output will be broken
   * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node
   * @param  {Profile}    profile Output profile
   * @return {OutputNode}
   */
  function updateFormatting$2(outNode, profile) {
    var node = outNode.node;
    if (!node.isTextOnly && node.value) {
      // node with text: put a space before single-line text
      outNode.beforeText = reNl$2.test(node.value) ? outNode.newline + outNode.indent + profile.indent(1) : ' ';
    }
    return outNode;
  }

  /**
   * Formats value of given node: for multiline text we should precede each
   * line with `| ` with one-level deep indent
   * @param  {Node} node
   * @param  {Profile} profile
   * @return {String|null}
   */
  function formatNodeValue$2(node, profile) {
    if (node.value != null && reNl$2.test(node.value)) {
      var indent = profile.indent(1);
      return splitByLines(node.value).map(function (line) {
        return indent + "| " + line;
      }).join('\n');
    }
    return node.value;
  }
  var supportedSyntaxed = {
    html: html,
    haml: haml,
    slim: slim,
    pug: pug
  };

  /**
   * Outputs given parsed abbreviation in specified syntax
   * @param {Node}     tree     Parsed abbreviation tree
   * @param {Profile}  profile  Output profile
   * @param {String}   [syntax] Output syntax. If not given, `html` syntax is used
   * @param {Function} options.field A function to output field/tabstop for
   * host editor. This function takes two arguments: `index` and `placeholder` and
   * should return a string that represents tabstop in host editor. By default
   * only a placeholder is returned
   * @example
   * {
   * 	field(index, placeholder) {
   * 		// return field in TextMate-style, e.g. ${1} or ${2:foo}
   * 		return `\${${index}${placeholder ? ':' + placeholder : ''}}`;
   *  }
   * }
   * @return {String}
   */
  var index$3 = function (tree, profile, syntax, options) {
    if (typeof syntax === 'object') {
      options = syntax;
      syntax = null;
    }
    if (!supports(syntax)) {
      // fallback to HTML if given syntax is not supported
      syntax = 'html';
    }
    return supportedSyntaxed[syntax](tree, profile, options);
  };

  /**
   * Check if given syntax is supported
   * @param {String} syntax
   * @return {Boolean}
   */
  function supports(syntax) {
    return !!syntax && syntax in supportedSyntaxed;
  }

  /**
   * A wrapper for holding CSS value
   */
  var CSSValue = function CSSValue() {
    this.type = 'css-value';
    this.value = [];
  };
  var prototypeAccessors$2 = {
    size: {}
  };
  prototypeAccessors$2.size.get = function () {
    return this.value.length;
  };
  CSSValue.prototype.add = function add(value) {
    this.value.push(value);
  };
  CSSValue.prototype.has = function has(value) {
    return this.value.indexOf(value) !== -1;
  };
  CSSValue.prototype.toString = function toString() {
    return this.value.join(' ');
  };
  Object.defineProperties(CSSValue.prototype, prototypeAccessors$2);
  var HASH$1 = 35; // #
  var DOT$1$1 = 46; // .

  /**
   * Consumes a color token from given string
   * @param  {StreamReader} stream
   * @return {Color} Returns consumend color object, `undefined` otherwise
   */
  var consumeColor = function (stream) {
    // supported color variations:
    // #abc   → #aabbccc
    // #0     → #000000
    // #fff.5 → rgba(255, 255, 255, 0.5)
    // #t     → transparent
    if (stream.peek() === HASH$1) {
      stream.start = stream.pos;
      stream.next();
      stream.eat(116) /* t */ || stream.eatWhile(isHex);
      var base = stream.current();

      // a hex color can be followed by `.num` alpha value
      stream.start = stream.pos;
      if (stream.eat(DOT$1$1) && !stream.eatWhile(isNumber$1)) {
        throw stream.error('Unexpected character for alpha value of color');
      }
      return new Color(base, stream.current());
    }
  };
  var Color = function Color(value, alpha) {
    this.type = 'color';
    this.raw = value;
    this.alpha = Number(alpha != null && alpha !== '' ? alpha : 1);
    value = value.slice(1); // remove #

    var r = 0,
      g = 0,
      b = 0;
    if (value === 't') {
      this.alpha = 0;
    } else {
      switch (value.length) {
        case 0:
          break;
        case 1:
          r = g = b = value + value;
          break;
        case 2:
          r = g = b = value;
          break;
        case 3:
          r = value[0] + value[0];
          g = value[1] + value[1];
          b = value[2] + value[2];
          break;
        default:
          value += value;
          r = value.slice(0, 2);
          g = value.slice(2, 4);
          b = value.slice(4, 6);
      }
    }
    this.r = parseInt(r, 16);
    this.g = parseInt(g, 16);
    this.b = parseInt(b, 16);
  };

  /**
  	 * Output current color as hex value
  	 * @param {Boolean} shor Produce short value (e.g. #fff instead of #ffffff), if possible
  	 * @return {String}
  	 */
  Color.prototype.toHex = function toHex$1(short) {
    var fn = short && isShortHex(this.r) && isShortHex(this.g) && isShortHex(this.b) ? toShortHex : toHex;
    return '#' + fn(this.r) + fn(this.g) + fn(this.b);
  };

  /**
  	 * Output current color as `rgba?(...)` CSS color
  	 * @return {String}
  	 */
  Color.prototype.toRGB = function toRGB() {
    var values = [this.r, this.g, this.b];
    if (this.alpha !== 1) {
      values.push(this.alpha.toFixed(8).replace(/\.?0+$/, ''));
    }
    return (values.length === 3 ? 'rgb' : 'rgba') + "(" + values.join(', ') + ")";
  };
  Color.prototype.toString = function toString(short) {
    if (!this.r && !this.g && !this.b && !this.alpha) {
      return 'transparent';
    }
    return this.alpha === 1 ? this.toHex(short) : this.toRGB();
  };

  /**
   * Check if given code is a hex value (/0-9a-f/)
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isHex(code) {
    return isNumber$1(code) || isAlpha$1(code, 65, 70); // A-F
  }

  function isShortHex(hex) {
    return !(hex % 17);
  }
  function toShortHex(num) {
    return (num >> 4).toString(16);
  }
  function toHex(num) {
    return pad$1(num.toString(16), 2);
  }
  function pad$1(value, len) {
    while (value.length < len) {
      value = '0' + value;
    }
    return value;
  }

  /**
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isAlphaNumericWord(code) {
    return isNumber$1(code) || isAlphaWord(code);
  }

  /**
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isAlphaWord(code) {
    return code === 95 /* _ */ || isAlpha$1(code);
  }
  var PERCENT = 37; // %
  var DOT$1$2 = 46; // .
  var DASH$1 = 45; // -

  /**
   * Consumes numeric CSS value (number with optional unit) from current stream,
   * if possible
   * @param  {StreamReader} stream
   * @return {NumericValue}
   */
  var consumeNumericValue = function (stream) {
    stream.start = stream.pos;
    if (eatNumber(stream)) {
      var num = stream.current();
      stream.start = stream.pos;

      // eat unit, which can be a % or alpha word
      stream.eat(PERCENT) || stream.eatWhile(isAlphaWord);
      return new NumericValue(num, stream.current());
    }
  };

  /**
   * A numeric CSS value with optional unit
   */
  var NumericValue = function NumericValue(value, unit) {
    this.type = 'numeric';
    this.value = Number(value);
    this.unit = unit || '';
  };
  NumericValue.prototype.toString = function toString() {
    return "" + this.value + this.unit;
  };

  /**
   * Eats number value from given stream
   * @param  {StreamReader} stream
   * @return {Boolean} Returns `true` if number was consumed
   */
  function eatNumber(stream) {
    var start = stream.pos;
    var negative = stream.eat(DASH$1);
    var hadDot = false,
      consumed = false,
      code;
    while (!stream.eof()) {
      code = stream.peek();

      // either a second dot or not a number: stop parsing
      if (code === DOT$1$2 ? hadDot : !isNumber$1(code)) {
        break;
      }
      consumed = true;
      if (code === DOT$1$2) {
        hadDot = true;
      }
      stream.next();
    }
    if (negative && !consumed) {
      // edge case: consumed dash only, bail out
      stream.pos = start;
    }
    return start !== stream.pos;
  }
  var DOLLAR$1 = 36; // $
  var DASH$2 = 45; // -
  var AT$1 = 64; // @

  /**
   * Consumes a keyword: either a variable (a word that starts with $ or @) or CSS
   * keyword or shorthand
   * @param  {StreamReader} stream
   * @param  {Boolean} [short] Use short notation for consuming value.
   * The difference between “short” and “full” notation is that first one uses
   * alpha characters only and used for extracting keywords from abbreviation,
   * while “full” notation also supports numbers and dashes
   * @return {String} Consumed variable
   */
  var consumeKeyword = function (stream, short) {
    stream.start = stream.pos;
    if (stream.eat(DOLLAR$1) || stream.eat(AT$1)) {
      // SCSS or LESS variable
      stream.eatWhile(isVariableName);
    } else if (short) {
      stream.eatWhile(isAlphaWord);
    } else {
      stream.eatWhile(isKeyword);
    }
    return stream.start !== stream.pos ? new Keyword(stream.current()) : null;
  };
  var Keyword = function Keyword(value) {
    this.type = 'keyword';
    this.value = value;
  };
  Keyword.prototype.toString = function toString() {
    return this.value;
  };
  function isKeyword(code) {
    return isAlphaNumericWord(code) || code === DASH$2;
  }
  function isVariableName(code) {
    return code === 45 /* - */ || isAlphaNumericWord(code);
  }
  var opt$1$1 = {
    throws: true
  };

  /**
   * Consumes 'single' or "double"-quoted string from given string, if possible
   * @param  {StreamReader} stream
   * @return {String}
   */
  var consumeQuoted$1 = function (stream) {
    if (eatQuoted$1(stream, opt$1$1)) {
      return new QuotedString(stream.current());
    }
  };
  var QuotedString = function QuotedString(value) {
    this.type = 'string';
    this.value = value;
  };
  QuotedString.prototype.toString = function toString() {
    return this.value;
  };
  var LBRACE = 40; // (
  var RBRACE = 41; // )
  var COMMA = 44; // ,

  /**
   * Consumes arguments from given string.
   * Arguments are comma-separated list of CSS values inside round braces, e.g.
   * `(1, a2, 'a3')`. Nested lists and quoted strings are supported
   * @param  {StreamReader} stream
   * @return {Array}        Array of arguments, `null` if arguments cannot be consumed
   */
  function consumeArgumentList(stream) {
    if (!stream.eat(LBRACE)) {
      // not an argument list
      return null;
    }
    var level = 1,
      code,
      arg;
    var argsList = [];
    while (!stream.eof()) {
      if (arg = consumeArgument(stream)) {
        argsList.push(arg);
      } else {
        // didn’t consumed argument, expect argument separator or end-of-arguments
        stream.eatWhile(isWhiteSpace$1);
        if (stream.eat(RBRACE)) {
          // end of arguments list
          break;
        }
        if (!stream.eat(COMMA)) {
          throw stream.error('Expected , or )');
        }
      }
    }
    return argsList;
  }

  /**
   * Consumes a single argument. An argument is a `CSSValue`, e.g. it could be
   * a space-separated string of value
   * @param  {StreamReader} stream
   * @return {CSSValue}
   */
  function consumeArgument(stream) {
    var result = new CSSValue();
    var value;
    while (!stream.eof()) {
      stream.eatWhile(isWhiteSpace$1);
      value = consumeNumericValue(stream) || consumeColor(stream) || consumeQuoted$1(stream) || consumeKeywordOrFunction(stream);
      if (!value) {
        break;
      }
      result.add(value);
    }
    return result.size ? result : null;
  }

  /**
   * Consumes either function call like `foo()` or keyword like `foo`
   * @param  {StreamReader} stream
   * @return {Keyword|FunctionCall}
   */
  function consumeKeywordOrFunction(stream) {
    var kw = consumeKeyword(stream);
    if (kw) {
      var args = consumeArgumentList(stream);
      return args ? new FunctionCall(kw.toString(), args) : kw;
    }
  }
  var FunctionCall = function FunctionCall(name, args) {
    this.type = 'function';
    this.name = name;
    this.args = args || [];
  };
  FunctionCall.prototype.toString = function toString() {
    return this.name + "(" + this.args.join(', ') + ")";
  };
  var EXCL$1 = 33; // !
  var DOLLAR$1$1 = 36; // $
  var PLUS = 43; // +
  var DASH = 45; // -
  var COLON$2 = 58; // :
  var AT = 64; // @

  /**
   * Parses given Emmet CSS abbreviation and returns it as parsed Node tree
   * @param {String} abbr
   * @return {Node}
   */
  var index$4 = function (abbr) {
    var root = new Node();
    var stream = new StreamReader$1(abbr);
    var node;
    while (!stream.eof()) {
      var node$1 = new Node(consumeIdent(stream));
      node$1.value = consumeValue(stream);
      var args = consumeArgumentList(stream);
      if (args) {
        // technically, arguments in CSS are anonymous Emmet Node attributes,
        // but since Emmet can support only one anonymous, `null`-name
        // attribute (for good reasons), we’ll use argument index as name
        for (var i = 0; i < args.length; i++) {
          node$1.setAttribute(String(i), args[i]);
        }
      }

      // Consume `!important` modifier at the end of expression
      if (stream.eat(EXCL$1)) {
        node$1.value.add('!');
      }
      root.appendChild(node$1);

      // CSS abbreviations cannot be nested, only listed
      if (!stream.eat(PLUS)) {
        break;
      }
    }
    if (!stream.eof()) {
      throw stream.error('Unexpected character');
    }
    return root;
  };

  /**
   * Consumes CSS property identifier from given stream
   * @param  {StreamReader} stream
   * @return {String}
   */
  function consumeIdent(stream) {
    stream.start = stream.pos;
    stream.eatWhile(isIdentPrefix);
    stream.eatWhile(isIdent$1);
    return stream.start !== stream.pos ? stream.current() : null;
  }

  /**
   * Consumes embedded value from Emmet CSS abbreviation stream
   * @param  {StreamReader} stream
   * @return {CSSValue}
   */
  function consumeValue(stream) {
    var values = new CSSValue();
    var value;
    while (!stream.eof()) {
      // use colon as value separator
      stream.eat(COLON$2);
      if (value = consumeNumericValue(stream) || consumeColor(stream)) {
        // edge case: a dash after unit-less numeric value or color should
        // be treated as value separator, not negative sign
        if (!value.unit) {
          stream.eat(DASH);
        }
      } else {
        stream.eat(DASH);
        value = consumeKeyword(stream, true);
      }
      if (!value) {
        break;
      }
      values.add(value);
    }
    return values;
  }

  /**
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isIdent$1(code) {
    return isAlphaWord(code);
  }

  /**
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isIdentPrefix(code) {
    return code === AT || code === DOLLAR$1$1 || code === EXCL$1;
  }
  var DASH$1$1 = 45; // -

  /**
   * Calculates fuzzy match score of how close `abbr` matches given `string`.
   * @param  {String} abbr        Abbreviation to score
   * @param  {String} string      String to match
   * @param  {Number} [fuzziness] Fuzzy factor
   * @return {Number}             Match score
   */
  var stringScore = function (abbr, string) {
    if (abbr === string) {
      return 1;
    }

    // a string MUST start with the same character as abbreviation
    if (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {
      return 0;
    }
    var abbrLength = abbr.length;
    var stringLength = string.length;
    var i = 1,
      j = 1,
      score = stringLength;
    var ch1, ch2, found, acronym;
    while (i < abbrLength) {
      ch1 = abbr.charCodeAt(i);
      found = false;
      acronym = false;
      while (j < stringLength) {
        ch2 = string.charCodeAt(j);
        if (ch1 === ch2) {
          found = true;
          score += (stringLength - j) * (acronym ? 2 : 1);
          break;
        }

        // add acronym bonus for exactly next match after unmatched `-`
        acronym = ch2 === DASH$1$1;
        j++;
      }
      if (!found) {
        break;
      }
      i++;
    }
    return score && score * (i / abbrLength) / sum(stringLength);
  };

  /**
   * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n
   * @param  {Number} n
   * @return {Number}
   */
  function sum(n) {
    return n * (n + 1) / 2;
  }
  var reProperty = /^([a-z\-]+)(?:\s*:\s*([^\n\r]+))?$/;
  var DASH$1$2 = 45; // -

  /**
   * Creates a special structure for resolving CSS properties from plain CSS
   * snippets.
   * Almost all CSS snippets are aliases for real CSS properties with available
   * value variants, optionally separated by `|`. Most values are keywords that
   * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,
   * more specific properties, like `border` and `border-style`. For such cases
   * keywords from more specific properties should be available in shorthands too.
   * @param {Snippet[]} snippets
   * @return {CSSSnippet[]}
   */
  var cssSnippets = function (snippets) {
    return nest(snippets.map(function (snippet) {
      return new CSSSnippet(snippet.key, snippet.value);
    }));
  };
  var CSSSnippet = function CSSSnippet(key, value) {
    this.key = key;
    this.value = value;
    this.property = null;

    // detect if given snippet is a property
    var m = value && value.match(reProperty);
    if (m) {
      this.property = m[1];
      this.value = m[2];
    }
    this.dependencies = [];
  };
  var prototypeAccessors$3 = {
    defaulValue: {}
  };
  CSSSnippet.prototype.addDependency = function addDependency(dep) {
    this.dependencies.push(dep);
  };
  prototypeAccessors$3.defaulValue.get = function () {
    return this.value != null ? splitValue(this.value)[0] : null;
  };

  /**
   * Returns list of unique keywords for current CSS snippet and its dependencies
   * @return {String[]}
   */
  CSSSnippet.prototype.keywords = function keywords() {
    var stack = [];
    var keywords = new Set();
    var i = 0,
      item,
      candidates;
    if (this.property) {
      // scan valid CSS-properties only
      stack.push(this);
    }
    while (i < stack.length) {
      // NB Keep items in stack instead of push/pop to avoid possible
      // circular references
      item = stack[i++];
      if (item.value) {
        candidates = splitValue(item.value).filter(isKeyword$1);

        // extract possible keywords from snippet value
        for (var j = 0; j < candidates.length; j++) {
          keywords.add(candidates[j].trim());
        }

        // add dependencies into scan stack
        for (var j$1 = 0, deps = item.dependencies; j$1 < deps.length; j$1++) {
          if (stack.indexOf(deps[j$1]) === -1) {
            stack.push(deps[j$1]);
          }
        }
      }
    }
    return Array.from(keywords);
  };
  Object.defineProperties(CSSSnippet.prototype, prototypeAccessors$3);

  /**
   * Nests more specific CSS properties into shorthand ones, e.g.
   * background-position-x -> background-position -> background
   * @param  {CSSSnippet[]} snippets
   * @return {CSSSnippet[]}
   */
  function nest(snippets) {
    snippets = snippets.sort(snippetsSort);
    var stack = [];

    // For sorted list of CSS properties, create dependency graph where each
    // shorthand property contains its more specific one, e.g.
    // backgound -> background-position -> background-position-x
    for (var i = 0, cur = void 0, prev = void 0; i < snippets.length; i++) {
      cur = snippets[i];
      if (!cur.property) {
        // not a CSS property, skip it
        continue;
      }

      // Check if current property belongs to one from parent stack.
      // Since `snippets` array is sorted, items are perfectly aligned
      // from shorthands to more specific variants
      while (stack.length) {
        prev = stack[stack.length - 1];
        if (cur.property.indexOf(prev.property) === 0 && cur.property.charCodeAt(prev.property.length) === DASH$1$2) {
          prev.addDependency(cur);
          stack.push(cur);
          break;
        }
        stack.pop();
      }
      if (!stack.length) {
        stack.push(cur);
      }
    }
    return snippets;
  }

  /**
   * A sorting function for array of snippets
   * @param  {CSSSnippet} a
   * @param  {CSSSnippet} b
   * @return {Number}
   */
  function snippetsSort(a, b) {
    if (a.key === b.key) {
      return 0;
    }
    return a.key < b.key ? -1 : 1;
  }

  /**
   * Check if given string is a keyword candidate
   * @param  {String}  str
   * @return {Boolean}
   */
  function isKeyword$1(str) {
    return /^\s*[\w\-]+/.test(str);
  }
  function splitValue(value) {
    return String(value).split('|');
  }
  var globalKeywords = ['auto', 'inherit', 'unset'];
  var unitlessProperties = ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'];
  var unitAliases = {
    e: 'em',
    p: '%',
    x: 'ex',
    r: 'rem'
  };

  /**
   * For every node in given `tree`, finds matching snippet from `registry` and
   * updates node with snippet data.
   *
   * This resolver uses fuzzy matching for searching matched snippets and their
   * keyword values.
   */

  var index$5 = function (tree, registry) {
    var snippets = convertToCSSSnippets(registry);
    tree.walk(function (node) {
      return resolveNode$1(node, snippets);
    });
    return tree;
  };
  function convertToCSSSnippets(registry) {
    return cssSnippets(registry.all({
      type: 'string'
    }));
  }

  /**
   * Resolves given node: finds matched CSS snippets using fuzzy match and resolves
   * keyword aliases from node value
   * @param  {Node} node
   * @param  {CSSSnippet[]} snippets
   * @return {Node}
   */
  function resolveNode$1(node, snippets) {
    var snippet = findBestMatch(node.name, snippets, 'key');
    if (!snippet) {
      // Edge case: `!important` snippet
      return node.name === '!' ? setNodeAsText(node, '!important') : node;
    }
    return snippet.property ? resolveAsProperty(node, snippet) : resolveAsSnippet(node, snippet);
  }

  /**
   * Resolves given parsed abbreviation node as CSS propery
   * @param {Node} node
   * @param {CSSSnippet} snippet
   * @return {Node}
   */
  function resolveAsProperty(node, snippet) {
    var abbr = node.name;
    node.name = snippet.property;
    if (node.value && typeof node.value === 'object') {
      // resolve keyword shortcuts
      var keywords = snippet.keywords();
      if (!node.value.size) {
        // no value defined, try to resolve unmatched part as a keyword alias
        var kw = findBestMatch(getUnmatchedPart(abbr, snippet.key), keywords);
        if (!kw) {
          // no matching value, try to get default one
          kw = snippet.defaulValue;
          if (kw && kw.indexOf('${') === -1) {
            // Quick and dirty test for existing field. If not, wrap
            // default value in a field
            kw = "${1:" + kw + "}";
          }
        }
        if (kw) {
          node.value.add(kw);
        }
      } else {
        // replace keyword aliases in current node value
        for (var i = 0, token = void 0; i < node.value.value.length; i++) {
          token = node.value.value[i];
          if (token === '!') {
            token = (!i ? '${1} ' : '') + "!important";
          } else if (isKeyword$1$1(token)) {
            token = findBestMatch(token.value, keywords) || findBestMatch(token.value, globalKeywords) || token;
          } else if (isNumericValue(token)) {
            token = resolveNumericValue(node.name, token);
          }
          node.value.value[i] = token;
        }
      }
    }
    return node;
  }

  /**
   * Resolves given parsed abbreviation node as a snippet: a plain code chunk
   * @param {Node} node
   * @param {CSSSnippet} snippet
   * @return {Node}
   */
  function resolveAsSnippet(node, snippet) {
    return setNodeAsText(node, snippet.value);
  }

  /**
   * Sets given parsed abbreviation node as a text snippet
   * @param {Node} node
   * @param {String} text
   * @return {Node}
   */
  function setNodeAsText(node, text) {
    node.name = null;
    node.value = text;
    return node;
  }

  /**
   * Finds best matching item from `items` array
   * @param {String} abbr  Abbreviation to match
   * @param {Array}  items List of items for match
   * @param {String} [key] If `items` is a list of objects, use `key` as object
   * property to test against
   * @return {*}
   */
  function findBestMatch(abbr, items, key) {
    if (!abbr) {
      return null;
    }
    var matchedItem = null;
    var maxScore = 0;
    for (var i = 0, item = void 0; i < items.length; i++) {
      item = items[i];
      var score = stringScore(abbr, getScoringPart(item, key));
      if (score === 1) {
        // direct hit, no need to look further
        return item;
      }
      if (score && score >= maxScore) {
        maxScore = score;
        matchedItem = item;
      }
    }
    return matchedItem;
  }
  function getScoringPart(item, key) {
    var value = item && typeof item === 'object' ? item[key] : item;
    var m = (value || '').match(/^[\w-@]+/);
    return m ? m[0] : value;
  }

  /**
   * Returns a part of `abbr` that wasn’t directly matched agains `string`.
   * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`
   * since `a` wasn’t found in string stream
   * @param {String} abbr
   * @param {String} string
   * @return {String}
   */
  function getUnmatchedPart(abbr, string) {
    for (var i = 0, lastPos = 0; i < abbr.length; i++) {
      lastPos = string.indexOf(abbr[i], lastPos);
      if (lastPos === -1) {
        return abbr.slice(i);
      }
      lastPos++;
    }
    return '';
  }

  /**
   * Check if given CSS value token is a keyword
   * @param {*} token
   * @return {Boolean}
   */
  function isKeyword$1$1(token) {
    return tokenTypeOf(token, 'keyword');
  }

  /**
   * Check if given CSS value token is a numeric value
   * @param  {*}  token
   * @return {Boolean}
   */
  function isNumericValue(token) {
    return tokenTypeOf(token, 'numeric');
  }
  function tokenTypeOf(token, type) {
    return token && typeof token === 'object' && token.type === type;
  }

  /**
   * Resolves numeric value for given CSS property
   * @param  {String} property    CSS property name
   * @param  {NumericValue} token CSS numeric value token
   * @return {NumericValue}
   */
  function resolveNumericValue(property, token) {
    if (token.unit) {
      token.unit = unitAliases[token.unit] || token.unit;
    } else if (token.value !== 0 && unitlessProperties.indexOf(property) === -1) {
      // use `px` for integers, `em` for floats
      // NB: num|0 is a quick alternative to Math.round(0)
      token.unit = token.value === (token.value | 0) ? 'px' : 'em';
    }
    return token;
  }
  var defaultOptions$4 = {
    shortHex: true,
    format: {
      between: ': ',
      after: ';'
    }
  };

  /**
   * Renders given parsed Emmet CSS abbreviation as CSS-like
   * stylesheet, formatted according to `profile` options
   * @param  {Node}     tree    Parsed Emmet abbreviation
   * @param  {Profile}  profile Output profile
   * @param  {Object}  [options] Additional formatter options
   * @return {String}
   */
  function css(tree, profile, options) {
    options = Object.assign({}, defaultOptions$4, options);
    return render(tree, options.field, function (outNode) {
      var node = outNode.node;
      var value = String(node.value || '');
      if (node.attributes.length) {
        var fieldValues = node.attributes.map(function (attr) {
          return stringifyAttribute(attr, options);
        });
        value = injectFields(value, fieldValues);
      }
      outNode.open = node.name && profile.name(node.name);
      outNode.afterOpen = options.format.between;
      outNode.text = outNode.renderFields(value || null);
      if (outNode.open) {
        outNode.afterText = options.format.after;
      }
      if (profile.get('format')) {
        outNode.newline = '\n';
        if (tree.lastChild !== node) {
          outNode.afterText += outNode.newline;
        }
      }
      return outNode;
    });
  }

  /**
   * Injects given field values at each field of given string
   * @param  {String}   string
   * @param  {String[]} attributes
   * @return {FieldString}
   */
  function injectFields(string, values) {
    var fieldsModel = parse$2$1(string);
    var fieldsAmount = fieldsModel.fields.length;
    if (fieldsAmount) {
      values = values.slice();
      if (values.length > fieldsAmount) {
        // More values that output fields: collapse rest values into
        // a single token
        values = values.slice(0, fieldsAmount - 1).concat(values.slice(fieldsAmount - 1).join(', '));
      }
      while (values.length) {
        var value = values.shift();
        var field = fieldsModel.fields.shift();
        var delta = value.length - field.length;
        fieldsModel.string = fieldsModel.string.slice(0, field.location) + value + fieldsModel.string.slice(field.location + field.length);

        // Update location of the rest fields in string
        for (var i = 0, il = fieldsModel.fields.length; i < il; i++) {
          fieldsModel.fields[i].location += delta;
        }
      }
    }
    return fieldsModel;
  }
  function stringifyAttribute(attr, options) {
    if (attr.value && typeof attr.value === 'object' && attr.value.type === 'css-value') {
      return attr.value.value.map(function (token) {
        if (token && typeof token === 'object') {
          return token.type === 'color' ? token.toString(options.shortHex) : token.toString();
        }
        return String(token);
      }).join(' ');
    }
    return attr.value != null ? String(attr.value) : '';
  }
  var syntaxFormat = {
    css: {
      between: ': ',
      after: ';'
    },
    scss: 'css',
    less: 'css',
    sass: {
      between: ': ',
      after: ''
    },
    stylus: {
      between: ' ',
      after: ''
    }
  };

  /**
   * Outputs given parsed abbreviation in specified stylesheet syntax
   * @param {Node}     tree     Parsed abbreviation tree
   * @param {Profile}  profile  Output profile
   * @param {String}   [syntax] Output syntax. If not given, `css` syntax is used
   * @param {Function} options.field A function to output field/tabstop for
   * host editor. This function takes two arguments: `index` and `placeholder` and
   * should return a string that represents tabstop in host editor. By default
   * only a placeholder is returned
   * @example
   * {
   * 	field(index, placeholder) {
   * 		// return field in TextMate-style, e.g. ${1} or ${2:foo}
   * 		return `\${${index}${placeholder ? ':' + placeholder : ''}}`;
   *  }
   * }
   * @return {String}
   */
  var index$6 = function (tree, profile, syntax, options) {
    if (typeof syntax === 'object') {
      options = syntax;
      syntax = null;
    }
    if (!supports$1(syntax)) {
      // fallback to CSS if given syntax is not supported
      syntax = 'css';
    }
    options = Object.assign({}, options, {
      format: getFormat(syntax, options)
    });

    // CSS abbreviations doesn’t support nesting so simply
    // output root node children
    return css(tree, profile, options);
  };

  /**
   * Check if given syntax is supported
   * @param {String} syntax
   * @return {Boolean}
   */
  function supports$1(syntax) {
    return !!syntax && syntax in syntaxFormat;
  }

  /**
   * Returns formatter object for given syntax
   * @param  {String} syntax
   * @param  {Object} [options]
   * @return {Object} Formatter object as defined in `syntaxFormat`
   */
  function getFormat(syntax, options) {
    var format = syntaxFormat[syntax];
    if (typeof format === 'string') {
      format = syntaxFormat[format];
    }
    return Object.assign({}, format, options && options.format);
  }
  var html$1 = {
    "a": "a[href]",
    "a:link": "a[href='http://${0}']",
    "a:mail": "a[href='mailto:${0}']",
    "abbr": "abbr[title]",
    "acr|acronym": "acronym[title]",
    "base": "base[href]/",
    "basefont": "basefont/",
    "br": "br/",
    "frame": "frame/",
    "hr": "hr/",
    "bdo": "bdo[dir]",
    "bdo:r": "bdo[dir=rtl]",
    "bdo:l": "bdo[dir=ltr]",
    "col": "col/",
    "link": "link[rel=stylesheet href]/",
    "link:css": "link[href='${1:style}.css']",
    "link:print": "link[href='${1:print}.css' media=print]",
    "link:favicon": "link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']",
    "link:touch": "link[rel=apple-touch-icon href='${1:favicon.png}']",
    "link:rss": "link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']",
    "link:atom": "link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']",
    "link:im|link:import": "link[rel=import href='${1:component}.html']",
    "meta": "meta/",
    "meta:utf": "meta[http-equiv=Content-Type content='text/html;charset=UTF-8']",
    "meta:vp": "meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']",
    "meta:compat": "meta[http-equiv=X-UA-Compatible content='${1:IE=7}']",
    "meta:edge": "meta:compat[content='${1:ie=edge}']",
    "meta:redirect": "meta[http-equiv=refresh content='0; url=${1:http://example.com}']",
    "style": "style",
    "script": "script[!src]",
    "script:src": "script[src]",
    "img": "img[src alt]/",
    "img:s|img:srcset": "img[srcset src alt]",
    "img:z|img:sizes": "img[sizes srcset src alt]",
    "picture": "picture",
    "src|source": "source/",
    "src:sc|source:src": "source[src type]",
    "src:s|source:srcset": "source[srcset]",
    "src:t|source:type": "source[srcset type='${1:image/}']",
    "src:z|source:sizes": "source[sizes srcset]",
    "src:m|source:media": "source[media='(${1:min-width: })' srcset]",
    "src:mt|source:media:type": "source:media[type='${2:image/}']",
    "src:mz|source:media:sizes": "source:media[sizes srcset]",
    "src:zt|source:sizes:type": "source[sizes srcset type='${1:image/}']",
    "iframe": "iframe[src frameborder=0]",
    "embed": "embed[src type]/",
    "object": "object[data type]",
    "param": "param[name value]/",
    "map": "map[name]",
    "area": "area[shape coords href alt]/",
    "area:d": "area[shape=default]",
    "area:c": "area[shape=circle]",
    "area:r": "area[shape=rect]",
    "area:p": "area[shape=poly]",
    "form": "form[action]",
    "form:get": "form[method=get]",
    "form:post": "form[method=post]",
    "label": "label[for]",
    "input": "input[type=${1:text}]/",
    "inp": "input[name=${1} id=${1}]",
    "input:h|input:hidden": "input[type=hidden name]",
    "input:t|input:text": "inp",
    "input:search": "inp[type=search]",
    "input:email": "inp[type=email]",
    "input:url": "inp[type=url]",
    "input:p|input:password": "inp[type=password]",
    "input:datetime": "inp[type=datetime]",
    "input:date": "inp[type=date]",
    "input:datetime-local": "inp[type=datetime-local]",
    "input:month": "inp[type=month]",
    "input:week": "inp[type=week]",
    "input:time": "inp[type=time]",
    "input:tel": "inp[type=tel]",
    "input:number": "inp[type=number]",
    "input:color": "inp[type=color]",
    "input:c|input:checkbox": "inp[type=checkbox]",
    "input:r|input:radio": "inp[type=radio]",
    "input:range": "inp[type=range]",
    "input:f|input:file": "inp[type=file]",
    "input:s|input:submit": "input[type=submit value]",
    "input:i|input:image": "input[type=image src alt]",
    "input:b|input:button": "input[type=button value]",
    "input:reset": "input:button[type=reset]",
    "isindex": "isindex/",
    "select": "select[name=${1} id=${1}]",
    "select:d|select:disabled": "select[disabled.]",
    "opt|option": "option[value]",
    "textarea": "textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]",
    "marquee": "marquee[behavior direction]",
    "menu:c|menu:context": "menu[type=context]",
    "menu:t|menu:toolbar": "menu[type=toolbar]",
    "video": "video[src]",
    "audio": "audio[src]",
    "html:xml": "html[xmlns=http://www.w3.org/1999/xhtml]",
    "keygen": "keygen/",
    "command": "command/",
    "btn:s|button:s|button:submit": "button[type=submit]",
    "btn:r|button:r|button:reset": "button[type=reset]",
    "btn:d|button:d|button:disabled": "button[disabled.]",
    "fst:d|fset:d|fieldset:d|fieldset:disabled": "fieldset[disabled.]",
    "bq": "blockquote",
    "fig": "figure",
    "figc": "figcaption",
    "pic": "picture",
    "ifr": "iframe",
    "emb": "embed",
    "obj": "object",
    "cap": "caption",
    "colg": "colgroup",
    "fst": "fieldset",
    "btn": "button",
    "optg": "optgroup",
    "tarea": "textarea",
    "leg": "legend",
    "sect": "section",
    "art": "article",
    "hdr": "header",
    "ftr": "footer",
    "adr": "address",
    "dlg": "dialog",
    "str": "strong",
    "prog": "progress",
    "mn": "main",
    "tem": "template",
    "fset": "fieldset",
    "datag": "datagrid",
    "datal": "datalist",
    "kg": "keygen",
    "out": "output",
    "det": "details",
    "cmd": "command",
    "ri:d|ri:dpr": "img:s",
    "ri:v|ri:viewport": "img:z",
    "ri:a|ri:art": "pic>src:m+img",
    "ri:t|ri:type": "pic>src:t+img",
    "!!!": "{<!DOCTYPE html>}",
    "doc": "html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+meta:edge+title{${1:Document}})+body",
    "!|html:5": "!!!+doc",
    "c": "{<!-- ${0} -->}",
    "cc:ie": "{<!--[if IE]>${0}<![endif]-->}",
    "cc:noie": "{<!--[if !IE]><!-->${0}<!--<![endif]-->}"
  };
  var css$1 = {
    "@f": "@font-face {\n\tfont-family: ${1};\n\tsrc: url(${1});\n}",
    "@ff": "@font-face {\n\tfont-family: '${1:FontName}';\n\tsrc: url('${2:FileName}.eot');\n\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\n\t\t url('${2:FileName}.woff') format('woff'),\n\t\t url('${2:FileName}.ttf') format('truetype'),\n\t\t url('${2:FileName}.svg#${1:FontName}') format('svg');\n\tfont-style: ${3:normal};\n\tfont-weight: ${4:normal};\n}",
    "@i|@import": "@import url(${0});",
    "@kf": "@keyframes ${1:identifier} {\n\t${2}\n}",
    "@m|@media": "@media ${1:screen} {\n\t${0}\n}",
    "ac": "align-content:flex-start|flex-end|center|space-between|space-around|stretch",
    "ai": "align-items:flex-start|flex-end|center|baseline|stretch",
    "anim": "animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}",
    "animdel": "animation-delay:${1:time}",
    "animdir": "animation-direction:normal|reverse|alternate|alternate-reverse",
    "animdur": "animation-duration:${1:0}s",
    "animfm": "animation-fill-mode:both|forwards|backwards",
    "animic": "animation-iteration-count:1|infinite",
    "animn": "animation-name",
    "animps": "animation-play-state:running|paused",
    "animtf": "animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})",
    "ap": "appearance:none",
    "as": "align-self:auto|flex-start|flex-end|center|baseline|stretch",
    "b": "bottom",
    "bd": "border:${1:1px} ${2:solid} ${3:#000}",
    "bdb": "border-bottom:${1:1px} ${2:solid} ${3:#000}",
    "bdbc": "border-bottom-color:#${1:000}",
    "bdbi": "border-bottom-image:url(${0})",
    "bdbk": "border-break:close",
    "bdbli": "border-bottom-left-image:url(${0})|continue",
    "bdblrs": "border-bottom-left-radius",
    "bdbri": "border-bottom-right-image:url(${0})|continue",
    "bdbrrs": "border-bottom-right-radius",
    "bdbs": "border-bottom-style",
    "bdbw": "border-bottom-width",
    "bdc": "border-color:#${1:000}",
    "bdci": "border-corner-image:url(${0})|continue",
    "bdcl": "border-collapse:collapse|separate",
    "bdf": "border-fit:repeat|clip|scale|stretch|overwrite|overflow|space",
    "bdi": "border-image:url(${0})",
    "bdl": "border-left:${1:1px} ${2:solid} ${3:#000}",
    "bdlc": "border-left-color:#${1:000}",
    "bdlen": "border-length",
    "bdli": "border-left-image:url(${0})",
    "bdls": "border-left-style",
    "bdlw": "border-left-width",
    "bdr": "border-right:${1:1px} ${2:solid} ${3:#000}",
    "bdrc": "border-right-color:#${1:000}",
    "bdri": "border-right-image:url(${0})",
    "bdrs": "border-radius",
    "bdrst": "border-right-style",
    "bdrw": "border-right-width",
    "bds": "border-style:hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset",
    "bdsp": "border-spacing",
    "bdt": "border-top:${1:1px} ${2:solid} ${3:#000}",
    "bdtc": "border-top-color:#${1:000}",
    "bdti": "border-top-image:url(${0})",
    "bdtli": "border-top-left-image:url(${0})|continue",
    "bdtlrs": "border-top-left-radius",
    "bdtri": "border-top-right-image:url(${0})|continue",
    "bdtrrs": "border-top-right-radius",
    "bdts": "border-top-style",
    "bdtw": "border-top-width",
    "bdw": "border-width",
    "bfv": "backface-visibility:hidden|visible",
    "bg": "background:#${1:000}",
    "bga": "background-attachment:fixed|scroll",
    "bgbk": "background-break:bounding-box|each-box|continuous",
    "bgc": "background-color:#${1:fff}",
    "bgcp": "background-clip:padding-box|border-box|content-box|no-clip",
    "bgi": "background-image:url(${0})",
    "bgo": "background-origin:padding-box|border-box|content-box",
    "bgp": "background-position:${1:0} ${2:0}",
    "bgpx": "background-position-x",
    "bgpy": "background-position-y",
    "bgr": "background-repeat:no-repeat|repeat-x|repeat-y|space|round",
    "bgsz": "background-size:contain|cover",
    "bxsh": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color}|none",
    "bxsz": "box-sizing:border-box|content-box|border-box",
    "c": "color:#${1:000}",
    "cl": "clear:both|left|right|none",
    "cm": "/* ${0} */",
    "cnt": "content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters({$0})",
    "coi": "counter-increment",
    "colm": "columns",
    "colmc": "column-count",
    "colmf": "column-fill",
    "colmg": "column-gap",
    "colmr": "column-rule",
    "colmrc": "column-rule-color",
    "colmrs": "column-rule-style",
    "colmrw": "column-rule-width",
    "colms": "column-span",
    "colmw": "column-width",
    "cor": "counter-reset",
    "cp": "clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})",
    "cps": "caption-side:top|bottom",
    "cur": "cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text",
    "d": "display:block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group",
    "ec": "empty-cells:show|hide",
    "f": "font:${1:1em} ${2:sans-serif}",
    "fef": "font-effect:none|engrave|emboss|outline",
    "fem": "font-emphasize",
    "femp": "font-emphasize-position:before|after",
    "fems": "font-emphasize-style:none|accent|dot|circle|disc",
    "ff": "font-family:serif|sans-serif|cursive|fantasy|monospace",
    "fl": "float:left|right|none",
    "fs": "font-style:italic|normal|oblique",
    "fsm": "font-smoothing:antialiased|subpixel-antialiased|none",
    "fst": "font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded",
    "fv": "font-variant:normal|small-caps",
    "fw": "font-weight:normal|bold|bolder|lighter",
    "fx": "flex",
    "fxb": "flex-basis:fill|max-content|min-content|fit-content|content",
    "fxd": "flex-direction:row|row-reverse|column|column-reverse",
    "fxf": "flex-flow",
    "fxg": "flex-grow",
    "fxsh": "flex-shrink",
    "fxw": "flex-wrap:nowrap|wrap|wrap-reverse",
    "fz": "font-size",
    "fza": "font-size-adjust",
    "h": "height",
    "jc": "justify-content:flex-start|flex-end|center|space-between|space-around",
    "l": "left",
    "lg": "background-image:linear-gradient(${1})",
    "lh": "line-height",
    "lis": "list-style",
    "lisi": "list-style-image",
    "lisp": "list-style-position:inside|outside",
    "list": "list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman",
    "lts": "letter-spacing:normal",
    "m": "margin",
    "mah": "max-height",
    "mar": "max-resolution",
    "maw": "max-width",
    "mb": "margin-bottom",
    "mih": "min-height",
    "mir": "min-resolution",
    "miw": "min-width",
    "ml": "margin-left",
    "mr": "margin-right",
    "mt": "margin-top",
    "ol": "outline",
    "olc": "outline-color:#${1:000}|invert",
    "olo": "outline-offset",
    "ols": "outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset",
    "olw": "outline-width|thin|medium|thick",
    "op": "opacity",
    "ord": "order",
    "ori": "orientation:landscape|portrait",
    "orp": "orphans",
    "ov": "overflow:hidden|visible|hidden|scroll|auto",
    "ovs": "overflow-style:scrollbar|auto|scrollbar|panner|move|marquee",
    "ovx": "overflow-x:hidden|visible|hidden|scroll|auto",
    "ovy": "overflow-y:hidden|visible|hidden|scroll|auto",
    "p": "padding",
    "pb": "padding-bottom",
    "pgba": "page-break-after:auto|always|left|right",
    "pgbb": "page-break-before:auto|always|left|right",
    "pgbi": "page-break-inside:auto|avoid",
    "pl": "padding-left",
    "pos": "position:relative|absolute|relative|fixed|static",
    "pr": "padding-right",
    "pt": "padding-top",
    "q": "quotes",
    "qen": "quotes:'\\201C' '\\201D' '\\2018' '\\2019'",
    "qru": "quotes:'\\00AB' '\\00BB' '\\201E' '\\201C'",
    "r": "right",
    "rsz": "resize:none|both|horizontal|vertical",
    "t": "top",
    "ta": "text-align:left|center|right|justify",
    "tal": "text-align-last:left|center|right",
    "tbl": "table-layout:fixed",
    "td": "text-decoration:none|underline|overline|line-through",
    "te": "text-emphasis:none|accent|dot|circle|disc|before|after",
    "th": "text-height:auto|font-size|text-size|max-size",
    "ti": "text-indent",
    "tj": "text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan",
    "to": "text-outline:${1:0} ${2:0} ${3:#000}",
    "tov": "text-overflow:ellipsis|clip",
    "tr": "text-replace",
    "trf": "transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})",
    "trfo": "transform-origin",
    "trfs": "transform-style:preserve-3d",
    "trs": "transition:${1:prop} ${2:time}",
    "trsde": "transition-delay:${1:time}",
    "trsdu": "transition-duration:${1:time}",
    "trsp": "transition-property:${1:prop}",
    "trstf": "transition-timing-function:${1:fn}",
    "tsh": "text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}",
    "tt": "text-transform:uppercase|lowercase|capitalize|none",
    "tw": "text-wrap:none|normal|unrestricted|suppress",
    "us": "user-select:none",
    "v": "visibility:hidden|visible|collapse",
    "va": "vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub",
    "w": "width",
    "whs": "white-space:nowrap|pre|pre-wrap|pre-line|normal",
    "whsc": "white-space-collapse:normal|keep-all|loose|break-strict|break-all",
    "wid": "widows",
    "wm": "writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl",
    "wob": "word-break:normal|keep-all|break-all",
    "wos": "word-spacing",
    "wow": "word-wrap:none|unrestricted|suppress|break-word|normal",
    "z": "z-index",
    "zom": "zoom:1"
  };
  var index$7 = {
    html: html$1,
    css: css$1
  };
  var latin = {
    "common": ["lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipisicing", "elit"],
    "words": ["exercitationem", "perferendis", "perspiciatis", "laborum", "eveniet", "sunt", "iure", "nam", "nobis", "eum", "cum", "officiis", "excepturi", "odio", "consectetur", "quasi", "aut", "quisquam", "vel", "eligendi", "itaque", "non", "odit", "tempore", "quaerat", "dignissimos", "facilis", "neque", "nihil", "expedita", "vitae", "vero", "ipsum", "nisi", "animi", "cumque", "pariatur", "velit", "modi", "natus", "iusto", "eaque", "sequi", "illo", "sed", "ex", "et", "voluptatibus", "tempora", "veritatis", "ratione", "assumenda", "incidunt", "nostrum", "placeat", "aliquid", "fuga", "provident", "praesentium", "rem", "necessitatibus", "suscipit", "adipisci", "quidem", "possimus", "voluptas", "debitis", "sint", "accusantium", "unde", "sapiente", "voluptate", "qui", "aspernatur", "laudantium", "soluta", "amet", "quo", "aliquam", "saepe", "culpa", "libero", "ipsa", "dicta", "reiciendis", "nesciunt", "doloribus", "autem", "impedit", "minima", "maiores", "repudiandae", "ipsam", "obcaecati", "ullam", "enim", "totam", "delectus", "ducimus", "quis", "voluptates", "dolores", "molestiae", "harum", "dolorem", "quia", "voluptatem", "molestias", "magni", "distinctio", "omnis", "illum", "dolorum", "voluptatum", "ea", "quas", "quam", "corporis", "quae", "blanditiis", "atque", "deserunt", "laboriosam", "earum", "consequuntur", "hic", "cupiditate", "quibusdam", "accusamus", "ut", "rerum", "error", "minus", "eius", "ab", "ad", "nemo", "fugit", "officia", "at", "in", "id", "quos", "reprehenderit", "numquam", "iste", "fugiat", "sit", "inventore", "beatae", "repellendus", "magnam", "recusandae", "quod", "explicabo", "doloremque", "aperiam", "consequatur", "asperiores", "commodi", "optio", "dolor", "labore", "temporibus", "repellat", "veniam", "architecto", "est", "esse", "mollitia", "nulla", "a", "similique", "eos", "alias", "dolore", "tenetur", "deleniti", "porro", "facere", "maxime", "corrupti"]
  };
  var ru = {
    "common": ["далеко-далеко", "за", "словесными", "горами", "в стране", "гласных", "и согласных", "живут", "рыбные", "тексты"],
    "words": ["вдали", "от всех", "они", "буквенных", "домах", "на берегу", "семантика", "большого", "языкового", "океана", "маленький", "ручеек", "даль", "журчит", "по всей", "обеспечивает", "ее", "всеми", "необходимыми", "правилами", "эта", "парадигматическая", "страна", "которой", "жаренные", "предложения", "залетают", "прямо", "рот", "даже", "всемогущая", "пунктуация", "не", "имеет", "власти", "над", "рыбными", "текстами", "ведущими", "безорфографичный", "образ", "жизни", "однажды", "одна", "маленькая", "строчка", "рыбного", "текста", "имени", "lorem", "ipsum", "решила", "выйти", "большой", "мир", "грамматики", "великий", "оксмокс", "предупреждал", "о", "злых", "запятых", "диких", "знаках", "вопроса", "коварных", "точках", "запятой", "но", "текст", "дал", "сбить", "себя", "толку", "он", "собрал", "семь", "своих", "заглавных", "букв", "подпоясал", "инициал", "за", "пояс", "пустился", "дорогу", "взобравшись", "первую", "вершину", "курсивных", "гор", "бросил", "последний", "взгляд", "назад", "силуэт", "своего", "родного", "города", "буквоград", "заголовок", "деревни", "алфавит", "подзаголовок", "своего", "переулка", "грустный", "реторический", "вопрос", "скатился", "его", "щеке", "продолжил", "свой", "путь", "дороге", "встретил", "рукопись", "она", "предупредила", "моей", "все", "переписывается", "несколько", "раз", "единственное", "что", "меня", "осталось", "это", "приставка", "возвращайся", "ты", "лучше", "свою", "безопасную", "страну", "послушавшись", "рукописи", "наш", "продолжил", "свой", "путь", "вскоре", "ему", "повстречался", "коварный", "составитель", "рекламных", "текстов", "напоивший", "языком", "речью", "заманивший", "свое", "агентство", "которое", "использовало", "снова", "снова", "своих", "проектах", "если", "переписали", "то", "живет", "там", "до", "сих", "пор"]
  };
  var sp = {
    "common": ["mujer", "uno", "dolor", "más", "de", "poder", "mismo", "si"],
    "words": ["ejercicio", "preferencia", "perspicacia", "laboral", "paño", "suntuoso", "molde", "namibia", "planeador", "mirar", "demás", "oficinista", "excepción", "odio", "consecuencia", "casi", "auto", "chicharra", "velo", "elixir", "ataque", "no", "odio", "temporal", "cuórum", "dignísimo", "facilismo", "letra", "nihilista", "expedición", "alma", "alveolar", "aparte", "león", "animal", "como", "paria", "belleza", "modo", "natividad", "justo", "ataque", "séquito", "pillo", "sed", "ex", "y", "voluminoso", "temporalidad", "verdades", "racional", "asunción", "incidente", "marejada", "placenta", "amanecer", "fuga", "previsor", "presentación", "lejos", "necesariamente", "sospechoso", "adiposidad", "quindío", "pócima", "voluble", "débito", "sintió", "accesorio", "falda", "sapiencia", "volutas", "queso", "permacultura", "laudo", "soluciones", "entero", "pan", "litro", "tonelada", "culpa", "libertario", "mosca", "dictado", "reincidente", "nascimiento", "dolor", "escolar", "impedimento", "mínima", "mayores", "repugnante", "dulce", "obcecado", "montaña", "enigma", "total", "deletéreo", "décima", "cábala", "fotografía", "dolores", "molesto", "olvido", "paciencia", "resiliencia", "voluntad", "molestias", "magnífico", "distinción", "ovni", "marejada", "cerro", "torre", "y", "abogada", "manantial", "corporal", "agua", "crepúsculo", "ataque", "desierto", "laboriosamente", "angustia", "afortunado", "alma", "encefalograma", "materialidad", "cosas", "o", "renuncia", "error", "menos", "conejo", "abadía", "analfabeto", "remo", "fugacidad", "oficio", "en", "almácigo", "vos", "pan", "represión", "números", "triste", "refugiado", "trote", "inventor", "corchea", "repelente", "magma", "recusado", "patrón", "explícito", "paloma", "síndrome", "inmune", "autoinmune", "comodidad", "ley", "vietnamita", "demonio", "tasmania", "repeler", "apéndice", "arquitecto", "columna", "yugo", "computador", "mula", "a", "propósito", "fantasía", "alias", "rayo", "tenedor", "deleznable", "ventana", "cara", "anemia", "corrupto"]
  };
  var langs = {
    latin: latin,
    ru: ru,
    sp: sp
  };
  var defaultOptions$5 = {
    wordCount: 30,
    skipCommon: false,
    lang: 'latin'
  };

  /**
   * Replaces given parsed Emmet abbreviation node with nodes filled with
   * Lorem Ipsum stub text.
   * @param {Node} node
   * @return {Node}
   */
  var index$8 = function (node, options) {
    options = Object.assign({}, defaultOptions$5, options);
    var dict = langs[options.lang] || langs.latin;
    var startWithCommon = !options.skipCommon && !isRepeating(node);
    if (!node.repeat && !isRoot$1(node.parent)) {
      // non-repeating element, insert text stub as a content of parent node
      // and remove current one
      node.parent.value = paragraph(dict, options.wordCount, startWithCommon);
      node.remove();
    } else {
      // Replace named node with generated content
      node.value = paragraph(dict, options.wordCount, startWithCommon);
      node.name = resolveImplicitName(node.parent.name);
    }
    return node;
  };
  function isRoot$1(node) {
    return !node.parent;
  }

  /**
   * Returns random integer between <code>from</code> and <code>to</code> values
   * @param {Number} from
   * @param {Number} to
   * @returns {Number}
   */
  function rand(from, to) {
    return Math.floor(Math.random() * (to - from) + from);
  }

  /**
   * @param {Array} arr
   * @param {Number} count
   * @returns {Array}
   */
  function sample(arr, count) {
    var len = arr.length;
    var iterations = Math.min(len, count);
    var result = new Set();
    while (result.size < iterations) {
      result.add(arr[rand(0, len)]);
    }
    return Array.from(result);
  }
  function choice(val) {
    return val[rand(0, val.length - 1)];
  }
  function sentence(words, end) {
    if (words.length) {
      words = [capitalize(words[0])].concat(words.slice(1));
    }
    return words.join(' ') + (end || choice('?!...')); // more dots than question marks
  }

  function capitalize(word) {
    return word[0].toUpperCase() + word.slice(1);
  }

  /**
   * Insert commas at randomly selected words. This function modifies values
   * inside <code>words</code> array
   * @param {Array} words
   */
  function insertCommas(words) {
    if (words.length < 2) {
      return words;
    }
    words = words.slice();
    var len = words.length;
    var hasComma = /,$/;
    var totalCommas = 0;
    if (len > 3 && len <= 6) {
      totalCommas = rand(0, 1);
    } else if (len > 6 && len <= 12) {
      totalCommas = rand(0, 2);
    } else {
      totalCommas = rand(1, 4);
    }
    for (var i = 0, pos = void 0, word = void 0; i < totalCommas; i++) {
      pos = rand(0, len - 2);
      if (!hasComma.test(words[pos])) {
        words[pos] += ',';
      }
    }
    return words;
  }

  /**
   * Generate a paragraph of "Lorem ipsum" text
   * @param {Object} dict Words dictionary (see `lang/*.json`)
   * @param {Number} wordCount Words count in paragraph
   * @param {Boolean} startWithCommon Should paragraph start with common
   * "lorem ipsum" sentence.
   * @returns {String}
   */
  function paragraph(dict, wordCount, startWithCommon) {
    var result = [];
    var totalWords = 0;
    var words;
    if (startWithCommon && dict.common) {
      words = dict.common.slice(0, wordCount);
      totalWords += words.length;
      result.push(sentence(insertCommas(words), '.'));
    }
    while (totalWords < wordCount) {
      words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));
      totalWords += words.length;
      result.push(sentence(insertCommas(words)));
    }
    return result.join(' ');
  }

  /**
   * Check if given node is in repeating context, e.g. node itself or one of its
   * parent is repeated
   * @param  {Node}  node
   * @return {Boolean}
   */
  function isRepeating(node) {
    while (node.parent) {
      if (node.repeat && node.repeat.value && node.repeat.value > 1) {
        return true;
      }
      node = node.parent;
    }
    return false;
  }

  /**
   * Expands given abbreviation into code
   * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation
   * @param  {Object} options
   * @return {String}
   */
  function expand$1(abbr, options) {
    options = options || {};
    if (typeof abbr === 'string') {
      abbr = parse$1(abbr, options);
    }
    return index$3(abbr, options.profile, options.syntax, options.format);
  }

  /**
   * Parses given Emmet abbreviation into a final abbreviation tree with all
   * required transformations applied
   * @param {String} Abbreviation to parse
   * @param  {Object} options
   * @return {Node}
   */
  function parse$1(abbr, options) {
    return index(abbr).use(index$1, options.snippets).use(replaceVariables, options.variables).use(index$2, options.text, options.addons);
  }

  /**
   * Expands given abbreviation into code
   * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation
   * @param  {Object} options
   * @return {String}
   */
  function expand$2(abbr, options) {
    options = options || {};
    if (typeof abbr === 'string') {
      abbr = parse$2(abbr, options);
    }
    return index$6(abbr, options.profile, options.syntax, options.format);
  }

  /**
   * Parses given Emmet abbreviation into a final abbreviation tree with all
   * required transformations applied
   * @param {String|Node} Abbreviation to parse or already parsed abbreviation
   * @param  {Object} options
   * @return {Node}
   */
  function parse$2(abbr, options) {
    if (typeof abbr === 'string') {
      abbr = index$4(abbr);
    }
    return abbr.use(index$5, options.snippets);
  }
  var reLorem = /^lorem([a-z]*)(\d*)$/;

  /**
   * Constructs a snippets registry, filled with snippets, for given options
   * @param  {String} syntax  Abbreviation syntax
   * @param  {Object|Object[]} snippets Additional snippets
   * @return {SnippetsRegistry}
   */
  var snippetsRegistryFactory = function (syntax, snippets) {
    var registrySnippets = [index$7[syntax] || index$7.html];
    if (Array.isArray(snippets)) {
      snippets.forEach(function (item) {
        // if array item is a string, treat it as a reference to globally
        // defined snippets
        registrySnippets.push(typeof item === 'string' ? index$7[item] : item);
      });
    } else if (typeof snippets === 'object') {
      registrySnippets.push(snippets);
    }
    var registry = new SnippetsRegistry(registrySnippets.filter(Boolean));

    // for non-stylesheet syntaxes add Lorem Ipsum generator
    if (syntax !== 'css') {
      registry.get(0).set(reLorem, loremGenerator);
    }
    return registry;
  };
  function loremGenerator(node) {
    var options = {};
    var m = node.name.match(reLorem);
    if (m[1]) {
      options.lang = m[1];
    }
    if (m[2]) {
      options.wordCount = +m[2];
    }
    return index$8(node, options);
  }

  /**
   * Default variables used in snippets to insert common values into predefined snippets
   * @type {Object}
   */
  var defaultVariables = {
    lang: 'en',
    locale: 'en-US',
    charset: 'UTF-8'
  };

  /**
   * A list of syntaxes that should use Emmet CSS abbreviations:
   * a variations of default abbreivation that holds values right in abbreviation name
   * @type {Set}
   */
  var stylesheetSyntaxes = new Set(['css', 'sass', 'scss', 'less', 'stylus', 'sss']);
  var defaultOptions = {
    /**
     * Abbreviation output syntax
     * @type {String}
     */
    syntax: 'html',
    /**
     * Field/tabstop generator for editor. Most editors support TextMate-style
     * fields: ${0} or ${1:item}. So for TextMate-style fields this function
     * will look like this:
     * @example
     * (index, placeholder) => `\${${index}${placeholder ? ':' + placeholder : ''}}`
     *
     * @param  {Number} index         Placeholder index. Fields with the same indices
     * should be linked
     * @param  {String} [placeholder] Field placeholder
     * @return {String}
     */
    field: function (index$$1, placeholder) {
      return placeholder || '';
    },
    /**
     * Insert given text string(s) into expanded abbreviation
     * If array of strings is given, the implicitly repeated element (e.g. `li*`)
     * will be repeated by the amount of items in array
     * @type {String|String[]}
     */
    text: null,
    /**
     * Either predefined output profile or options for output profile. Used for
     * abbreviation output
     * @type {Profile|Object}
     */
    profile: null,
    /**
     * Custom variables for variable resolver
     * @see @emmetio/variable-resolver
     * @type {Object}
     */
    variables: {},
    /**
     * Custom predefined snippets for abbreviation. The expanded abbreviation
     * will try to match given snippets that may contain custom elements,
     * predefined attributes etc.
     * May also contain array of items: either snippets (Object) or references
     * to default syntax snippets (String; the key in default snippets hash)
     * @see @emmetio/snippets
     * @type {Object|SnippetsRegistry}
     */
    snippets: {},
    /**
     * Hash of additional transformations that should be applied to expanded
     * abbreviation, like BEM or JSX. Since these transformations introduce
     * side-effect, they are disabled by default and should be enabled by
     * providing a transform name as a key and transform options as value:
     * @example
     * {
     *     bem: {element: '--'},
     *     jsx: true // no options, just enable transform
     * }
     * @see @emmetio/html-transform/lib/addons
     * @type {Object}
     */
    addons: null,
    /**
     * Additional options for syntax formatter
     * @see @emmetio/markup-formatters
     * @type {Object}
     */
    format: null
  };

  /**
   * Expands given abbreviation into string, formatted according to provided
   * syntax and options
   * @param  {String|Node} abbr        Abbreviation string or parsed abbreviation tree
   * @param  {String|Object} [options] Parsing and formatting options (object) or
   * abbreviation syntax (string)
   * @return {String}
   */
  function expand$$1(abbr, options) {
    options = createOptions(options);
    return isStylesheet(options.syntax) ? expand$2(abbr, options) : expand$1(abbr, options);
  }

  /**
   * Parses given abbreviation into AST tree. This tree can be later formatted to
   * string with `expand` function
   * @param  {String} abbr             Abbreviation to parse
   * @param  {String|Object} [options] Parsing and formatting options (object) or
   * abbreviation syntax (string)
   * @return {Node}
   */
  function parse$$1(abbr, options) {
    options = createOptions(options);
    return isStylesheet(options.syntax) ? parse$2(abbr, options) : parse$1(abbr, options);
  }

  /**
   * Creates snippets registry for given syntax and additional `snippets`
   * @param  {String} syntax   Snippets syntax, used for retreiving predefined snippets
   * @param  {SnippetsRegistry|Object|Object[]} [snippets] Additional snippets
   * @return {SnippetsRegistry}
   */
  function createSnippetsRegistry(syntax, snippets) {
    return snippets instanceof SnippetsRegistry ? snippets : snippetsRegistryFactory(isStylesheet(syntax) ? 'css' : syntax, snippets);
  }
  function createOptions(options) {
    if (typeof options === 'string') {
      options = {
        syntax: options
      };
    }
    options = Object.assign({}, defaultOptions, options);
    options.format = Object.assign({
      field: options.field
    }, options.format);
    options.profile = createProfile(options);
    options.variables = Object.assign({}, defaultVariables, options.variables);
    options.snippets = createSnippetsRegistry(isStylesheet(options.syntax) ? 'css' : options.syntax, options.snippets);
    return options;
  }

  /**
   * Check if given syntax belongs to stylesheet markup.
   * Emmet uses different abbreviation flavours: one is a default markup syntax,
   * used for HTML, Slim, Pug etc, the other one is used for stylesheets and
   * allows embedded values in abbreviation name
   * @param  {String}  syntax
   * @return {Boolean}
   */
  function isStylesheet(syntax) {
    return stylesheetSyntaxes.has(syntax);
  }

  /**
   * Creates output profile from given options
   * @param  {Object} options
   * @return {Profile}
   */
  function createProfile(options) {
    return options.profile instanceof Profile ? options.profile : new Profile(options.profile);
  }

  /**
   * Syntaxes known by Emmet. All other syntaxes shoud map to one of these
   * @type {Set}
   */
  var knownSyntaxes = new Set(['html', 'xml', 'xsl', 'jsx', 'js', 'pug', 'slim', 'haml', 'css', 'sass', 'scss', 'less', 'sss', 'stylus']);

  /**
   * Common context checker for abbreviation auto-activation for
   * stylesheet syntaxes (CSS, SCSS, LESS etc.)
   * @param  {CodeMirror} editor
   * @return {Boolean}
   */
  var stylesheetAutoActivationContext = function (editor, pos) {
    var tokenType = editor.getTokenTypeAt(pos || editor.getCursor());
    // NB may return `property` or `property error` type
    return tokenType && /^property\b/.test(tokenType);
  };
  var autoActivationContext = {
    html: function html(editor, pos) {
      // Do not provide automatic abbreviation completion inside HTML tags,
      // e.g. work only inside plain text token
      return editor.getTokenTypeAt(pos || editor.getCursor()) === null;
    },
    css: stylesheetAutoActivationContext,
    less: stylesheetAutoActivationContext,
    sass: stylesheetAutoActivationContext,
    scss: stylesheetAutoActivationContext
  };

  /**
   * Detect Emmet syntax from given editor’s position.
   * @param {CodeMirror}     editor
   * @param {CodeMirror.Pos} [pos]
   * @return {String}        Returns `null` if Emmet syntax can’t be detected
   */
  function detectSyntax(editor, pos) {
    var mode = editor.getModeAt(pos || editor.getCursor());
    var syntax = mode.name === 'xml' ? 'html' : mode.name;
    if (isSupported(syntax)) {
      return syntax;
    }

    // No supported syntax found, try from Emmet-specific options
    var emmetOpt = editor.getOption('emmet');
    if (emmetOpt && isSupported(emmetOpt.syntax)) {
      return emmetOpt.syntax;
    }
    return null;
  }

  /**
   * Check if given syntax is supported by Emmet
   * @param  {String}  syntax
   * @return {Boolean}
   */
  function isSupported(syntax) {
    return knownSyntaxes.has(syntax);
  }

  /**
   * Check if current editor’s context (syntax, scope) allows automatic Emmet
   * abbreviation activation as user types text. If this function returns `false`,
   * it is recommended to not create any Emmet completions when user types text,
   * but insert them when user activated autocomplete popup manually
   * @param  {CodeMirror}  editor
   * @param  {CodeMirror.Pos} [pos]
   * @return {Boolean}
   */
  function hasAutoActivateContext(editor, pos) {
    var syntax = detectSyntax(editor, pos);
    return syntax && (!autoActivationContext[syntax] || autoActivationContext[syntax](editor, pos));
  }

  /**
   * Returns token used for single indentation in given editor
   * @param  {CodeMirror} editor
   * @return {String}
   */
  function getIndentation(editor) {
    if (!editor.getOption('indentWithTabs')) {
      return repeatString(' ', editor.getOption('indentUnit'));
    }
    return '\t';
  }

  /**
   * Normalizes text according to given CodeMirror instance indentation
   * preferences
   * @param  {String}     text
   * @param  {CodeMirror} editor
   * @param  {String}     [indentation] Applies `indentText()` with given argument,
   *                                    if provided
   * @return {String}
   */
  function normalizeText(editor, text, indentation) {
    var lines = splitByLines$2(text);
    var indent = getIndentation(editor);
    if (indent !== '\t') {
      lines = lines.map(function (line) {
        return line.replace(/^\t+/, function (tabs) {
          return repeatString(indent, tabs.length);
        });
      });
    }
    if (indentation) {
      lines = lines.map(function (line, i) {
        return i ? indentation + line : line;
      });
    }
    return lines.join('\n');
  }

  /**
   * Indents each line, except first one, in given text
   * @param  {String} text
   * @param  {String} indentation
   * @return {String}
   */

  /**
   * Splits given text by lines
   * @param  {String} text
   * @return {String[]} Lines of text
   */
  function splitByLines$2(text) {
    return Array.isArray(text) ? text : text.split(/\r\n|\r|\n/g);
  }
  function repeatString(str, count) {
    var result = '';
    while (0 < count--) {
      result += str;
    }
    return result;
  }

  /**
   * Quick and dirty way to remove fields from given string
   * @param  {String} str
   * @return {String}
   */
  function removeFields(str) {
    return str.replace(/\$\{\d+(:[^\}]+)?\}/g, '');
  }

  /**
   * Check if given range contains point
   * @param  {CodeMirror.Range} range
   * @param  {CodeMirror.Pos} pos
   * @param  {Boolean} [exclude] Exclude range and and start
   * @return {Boolean}
   */
  function containsPos(range, pos, exclude) {
    return exclude ? comparePos(pos, range.from) > 0 && comparePos(pos, range.to) < 0 : comparePos(pos, range.from) >= 0 && comparePos(pos, range.to) <= 0;
  }
  function comparePos(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }
  var cursorMark = '[[::emmet-cursor::]]';

  // NB CodeMirror doesn’t natively supports tabstops
  var editorField = function (index, placeholder) {
    if (placeholder === void 0) placeholder = '';
    return placeholder;
  };

  /**
   * Expands given abbreviation for given editor.
   * The editor is used to detect abbreviation syntax and provide
   * tag context for markup abbreviations
   * @param  {String|Node} abbr
   * @param  {CodeMirror}  editor
   * @return {String}
   * @throws Error if abbreviation is invalid
   */
  function expandAbbreviation(abbr, editor, options) {
    return expand$$1(abbr, Object.assign({
      syntax: detectSyntax(editor),
      field: editorField
    }, getExpandOptions(editor), options));
  }

  /**
   * Parses abbreviation for given editor
   * @param  {String} abbr
   * @param  {CodeMirror} editor
   * @return {Node}
   * @throws Error if abbreviation is invalid
   */
  function parseAbbreviation(abbr, editor) {
    return parse$$1(abbr, Object.assign({
      syntax: detectSyntax(editor)
    }, getExpandOptions(editor)));
  }

  /**
   * Extracts abbreviation from given position of editor
   * @param  {CodeMirror}     editor
   * @param  {CodeMirror.Pos} [pos]
   * @return {Object}         Object with `{abbreviation, location}` properties or `null`
   */
  function extractAbbreviation(editor, pos) {
    pos = pos || pos.getCursor();
    var line = editor.getLine(pos.line);
    return extractAbbreviation$1(line, pos.ch, true);
  }

  /**
   * Returns abbreviation model: object with `ast` and `snippet` properties
   * that contains parsed and expanded abbreviation respectively
   * @param  {String} abbreviation
   * @param  {CodeMirror} editor
   * @return {Object} Returns `null` if abbreviation cannot be parsed
   */
  function createAbbreviationModel(abbreviation, editor) {
    try {
      var ast = parseAbbreviation(abbreviation, editor);
      return {
        ast: ast,
        abbreviation: abbreviation,
        snippet: expandAbbreviation(abbreviation, editor)
      };
    } catch (err) {
      // console.warn('Unable to build Emmet abbreviation model', err);
      return null;
    }
  }

  /**
   * Expands given abbreviation and inserts expanded result into editor, maintaining
   * proper indentation and final cursor position
   * @param  {CodeMirror} editor CodeMirror editor instance
   * @param  {String|Object} abbr  Abbreviation to expand (string or parsed)
   * @param  {CodeMirror.Range} range Location of abbreviation in editor
   * @return {Boolean} Returns `true` if abbreviation was successfully expanded and inserted
   */
  function expandAndInsert(editor, abbr, range) {
    var cursorMarked = false;
    var newSelectionSize = 0;
    var expanded;
    try {
      expanded = expandAbbreviation(abbr, editor, {
        // CodeMirror doesn’t support snippets with tab-stops natively so we have
        // to mark first output with a special token so we can find it later
        // to properly plant cursor into new position
        field: function field(index, placeholder) {
          if (placeholder === void 0) placeholder = '';
          if (!cursorMarked) {
            cursorMarked = true;
            newSelectionSize = placeholder.length;
            placeholder = cursorMark + placeholder;
          }
          return placeholder;
        }
      });
    } catch (err) {
      // Invalid abbreviation
      // console.warn(err);
      return false;
    }
    var line = editor.getLine(range.from.line);
    var matchIndent = line.match(/^\s+/);
    expanded = normalizeText(editor, expanded, matchIndent && matchIndent[0]);
    var newCursorPos = expanded.length;
    if (cursorMarked) {
      // Remove cursor stub and re-position cursor
      newCursorPos = expanded.indexOf(cursorMark);
      expanded = expanded.slice(0, newCursorPos) + expanded.slice(newCursorPos + cursorMark.length);
    }

    // Replace abbreviation with expanded result
    return editor.operation(function () {
      editor.replaceRange(expanded, range.from, range.to);

      // Position cursor
      var startIx = editor.indexFromPos(range.from);
      var newCursor = editor.posFromIndex(newCursorPos + startIx);
      if (newSelectionSize) {
        editor.setSelection(newCursor, {
          line: newCursor.line,
          ch: newCursor.ch + newSelectionSize
        });
      } else {
        editor.setCursor(newCursor);
      }
      return true;
    });
  }

  /**
   * Returns options object for syntax from given editor. In most cases, it detects
   * XML-style syntax (HTML, XML, XHTML) and returns options configured for proper
   * output
   * @param  {CodeMirror} editor
   * @param  {Point}      [pos]  Point in editor where syntax should be detected.
   *                             Uses `editor.getCursor()` in not given
   * @return {Object}
   */
  function getExpandOptions(editor, pos) {
    var mode = editor.getModeAt(pos || editor.getCursor());
    var emmetOpt = editor.getOption('emmet');
    var profile = emmetOpt && emmetOpt.profile;
    if (mode.name === 'xml') {
      profile = Object.assign({
        selfClosingStyle: mode.configuration
      }, profile);
    }
    return Object.assign({
      profile: profile,
      snippets: snippetsFromOptions(editor, detectSyntax(editor, pos))
    }, emmetOpt);
  }

  /**
   * Returns custom snippets from Emmet options of given editor
   * @param  {CodeMirror} editor
   * @param  {String} syntax
   * @return {Object}
   */
  function snippetsFromOptions(editor, syntax) {
    var emmetOpt = editor.getOption('emmet');
    if (emmetOpt) {
      return isStylesheet(syntax) ? emmetOpt.stylesheetSnippets : emmetOpt.markupSnippets;
    }
  }
  var emmetMarkerClass = 'emmet-abbreviation';

  /**
   * Editor’s `change` event handler that marks Emmet abbreviation when editor
   * content is updated
   * @param  {CodeMirror} editor
   */
  function markOnEditorChange(editor) {
    var marker = findMarker(editor, editor.getCursor());
    if (marker && isValidMarker(editor, marker)) {
      return;
    }

    // No valid marker under caret, remove all registered markers
    // and create a new one
    clearMarkers(editor);
    if (hasAutoActivateContext(editor)) {
      markAbbreviation(editor, editor.getCursor());
    }
  }

  /**
   * Returns *valid* Emmet abbreviation marker (if any) for given position of editor
   * @param  {CodeMirror}     editor
   * @param  {CodeMirror.Pos} [pos]
   * @return {CodeMirror.TextMarker}
   */
  function findMarker(editor, pos) {
    var markers = editor.findMarksAt(pos);
    for (var i = 0; i < markers.length; i++) {
      if (markers[i].className === emmetMarkerClass) {
        return markers[i];
      }
    }
  }

  /**
   * Marks Emmet abbreviation for given editor position, if possible
   * @param  {TextEditor} editor   Editor where abbreviation marker should be created
   * @param  {Point}      pos      Buffer position where abbreviation should be created.
   *                               Abbreviation will be automatically extracted from
   *                               given position
   * @param  {Boolean}    [forced] Indicates that user forcibly requested abbreviation
   *                               marker (e.g. was not activated automatically).
   *                               Affects abbreviation detection policy
   * @return {DisplayMarker} Returns `undefined` if no valid abbreviation under caret
   */
  function markAbbreviation(editor, pos, forced) {
    var marker = findMarker(editor, pos);
    if (marker) {
      // there’s active marker with valid abbreviation
      return marker;
    }

    // No active marker: remove previous markers and create new one, if possible
    clearMarkers(editor);
    var extracted = extractAbbreviation(editor, pos);
    var model = extracted && createAbbreviationModel(extracted.abbreviation, editor);
    if (model && (forced || allowedForAutoActivation(model))) {
      var from = {
        line: pos.line,
        ch: extracted.location
      };
      var to = {
        line: pos.line,
        ch: extracted.location + extracted.abbreviation.length
      };
      var marker$1 = editor.markText(from, to, {
        inclusiveRight: true,
        clearWhenEmpty: true,
        className: emmetMarkerClass
      });
      marker$1.model = model;
      return marker$1;
    }
  }

  /**
   * Removes Emmmet abbreviation markers from given editor
   * @param  {TextEditor} editor
   */
  function clearMarkers(editor) {
    var markers = editor.getAllMarks();
    for (var i = 0; i < markers.length; i++) {
      if (markers[i].className === emmetMarkerClass) {
        markers[i].clear();
      }
    }
  }

  /**
   * Check if given abbreviation model is allowed for auto-activated abbreviation
   * marker. Used to reduce falsy activations
   * @param  {Object} model Parsed abbreviation model (see `createAbbreviationModel()`)
   * @return {Boolean}
   */
  function allowedForAutoActivation(model) {
    var rootNode = model.ast.children[0];
    // The very first node should start with alpha character
    // Skips falsy activations for something like `$foo` etc.
    return rootNode && /^[a-z]/i.test(rootNode.name);
  }

  /**
   * Ensures that given editor Emmet abbreviation marker contains valid Emmet abbreviation
   * and updates abbreviation model if required
   * @param {CodeMirror} editor
   * @param {CodeMirror.TextMarket} marker
   * @return {Boolean} `true` if marker contains valid abbreviation
   */
  function isValidMarker(editor, marker) {
    var range = marker.find();

    // No newlines inside abreviation
    if (range.from.line !== range.to.line) {
      return false;
    }

    // Make sure marker contains valid abbreviation
    var text = editor.getRange(range.from, range.to);
    if (!text || /^\s|\s$/g.test(text)) {
      return false;
    }
    if (!marker.model || marker.model.abbreviation !== text) {
      // marker contents was updated, re-parse abbreviation
      marker.model = createAbbreviationModel(text, editor);
    }
    return !!(marker.model && marker.model.snippet);
  }

  /**
   * Expand abbreviation command
   * @param  {CodeMirror} editor
   */
  var emmetExpandAbbreviation = function (editor) {
    if (editor.somethingSelected()) {
      return editor.constructor.Pass;
    }
    var pos = editor.getCursor();
    var marker = findMarker(editor, pos);
    var result = false;

    // Handle two possible options: expand abbreviation from Emmet marker that
    // matches given location or extract & expand abbreviation from cursor
    // position. The last one may happen if either `markeEmmetAbbreviation`
    // option is turned off or user moved cursor away from Emmet marker and
    // tries to expand another abbreviation

    if (marker) {
      result = expandAndInsert(editor, marker.model.ast, marker.find());
    } else {
      var abbrData = extractAbbreviation(editor, pos);
      if (abbrData) {
        var range = {
          from: {
            line: pos.line,
            ch: abbrData.location
          },
          to: {
            line: pos.line,
            ch: abbrData.location + abbrData.abbreviation.length
          }
        };
        result = expandAndInsert(editor, abbrData.abbreviation, range);
      }
    }
    clearMarkers(editor);

    // If no abbreviation was expanded, allow editor to handle different
    // action for keyboard shortcut (Tab key mostly)
    return result || editor.constructor.Pass;
  };

  /**
   * Inserts formatted line tag between tags
   * @param  {CodeMirror} editor
   */
  var emmetInsertLineBreak = function (editor) {
    var cursor = editor.getCursor();
    var mode = editor.getModeAt(cursor);
    if (mode.name === 'xml') {
      var next = Object.assign({}, cursor, {
        ch: cursor.ch + 1
      });
      var left = editor.getTokenAt(cursor);
      var right = editor.getTokenAt(Object.assign({}, cursor, {
        ch: cursor.ch + 1
      }));
      if (left.type === 'tag bracket' && left.string === '>' && right.type === 'tag bracket' && right.string === '</') {
        var matchIndent = editor.getLine(cursor.line).match(/^\s+/);
        var curIndent = matchIndent ? matchIndent[0] : '';
        var indent = getIndentation(editor);

        // Insert formatted line break
        var before = "\n" + curIndent + indent;
        var after = "\n" + curIndent;
        editor.replaceRange(before + after, cursor, cursor);

        // Position cursor
        var startIx = editor.indexFromPos(cursor);
        var newCursor = editor.posFromIndex(startIx + before.length);
        editor.setCursor(newCursor);
        return;
      }
    }
    return editor.constructor.Pass;
  };

  /**
   * Returns available completions from given editor
   * @param  {CodeMirror}      editor
   * @param  {String}          abbrModel   Parsed Emmet abbreviation model for which
   *                                       completions should be populated
   *                                       (see `createAbbreviationModel()`)
   * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor
   * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor
   * @return {EmmetCompletion[]}
   */
  var autocompleteProvider = function (editor, abbrModel, abbrPos, cursorPos) {
    cursorPos = cursorPos || editor.getCursor();
    var syntax = detectSyntax(editor, cursorPos);
    if (!syntax) {
      // Unsupported syntax
      return [];
    }
    return isStylesheet(syntax) ? getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos) : getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos);
  };

  /**
   * Returns completions for markup syntaxes (HTML, Slim, Pug etc.)
   * @param  {CodeMirror}      editor
   * @param  {Object}          abbrModel   Parsed Emmet abbreviation model for which
   *                                       completions should be populated
   *                                       (see `createAbbreviationModel()`)
   * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor
   * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor
   * @return {EmmetCompletion[]}
   */
  function getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos) {
    var result = [];
    cursorPos = cursorPos || editor.getCursor();
    var abbrRange = {
      from: abbrPos,
      to: {
        line: abbrPos.line,
        ch: abbrPos.ch + abbrModel.abbreviation.length
      }
    };
    result.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation', abbrModel.snippet, function () {
      return expandAndInsert(editor, abbrModel.abbreviation, abbrRange);
    }));

    // Make sure that current position precedes element name (e.g. not attribute,
    // class, id etc.)
    var prefix = getMarkupPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);
    if (prefix !== null) {
      var prefixRange = {
        from: {
          line: cursorPos.line,
          ch: cursorPos.ch - prefix.length
        },
        to: cursorPos
      };
      var completions = getSnippetCompletions(editor, cursorPos).filter(function (snippet) {
        return snippet.key !== prefix && snippet.key.indexOf(prefix) === 0;
      }).map(function (snippet) {
        return new EmmetCompletion('snippet', editor, prefixRange, snippet.key, snippet.preview, snippet.key);
      });
      result = result.concat(completions);
    }
    return result;
  }

  /**
   * Returns completions for stylesheet syntaxes
   * @param  {CodeMirror} editor
   * @param  {Object} abbrModel
   * @param  {CodeMirror.Pos} abbrPos
   * @param  {CodeMirror.Pos} cursorPos
   * @return {EmmetCompletion[]}
   */
  function getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos) {
    var result = [];
    cursorPos = cursorPos || editor.getCursor();
    var abbrRange = {
      from: abbrPos,
      to: {
        line: abbrPos.line,
        ch: abbrPos.ch + abbrModel.abbreviation.length
      }
    };
    result.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation', abbrModel.snippet, function () {
      return expandAndInsert(editor, abbrModel.abbreviation, abbrRange);
    }));

    // Make sure that current position precedes element name (e.g. not attribute,
    // class, id etc.)
    var prefix = getStylesheetPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);
    if (prefix !== null) {
      var prefixRange = {
        from: {
          line: cursorPos.line,
          ch: cursorPos.ch - prefix.length
        },
        to: cursorPos
      };
      var completions = getSnippetCompletions(editor, cursorPos).filter(function (snippet) {
        return snippet.key !== prefix && snippet.key.indexOf(prefix) === 0;
      }).map(function (snippet) {
        return new EmmetCompletion('snippet', editor, prefixRange, snippet.key, snippet.preview, snippet.key);
      });
      result = result.concat(completions);
    }
    return result;
  }

  /**
   * Returns all possible snippets completions for given editor context.
   * Completions are cached in editor for for re-use
   * @param  {CodeMirror} editor
   * @param  {CodeMirror.Pos} pos
   * @return {Array}
   */
  function getSnippetCompletions(editor, pos) {
    var syntax = detectSyntax(editor, pos);
    if (!editor.state.emmetCompletions) {
      editor.state.emmetCompletions = {};
    }
    var cache = editor.state.emmetCompletions;
    if (!(syntax in cache)) {
      var registry = createSnippetsRegistry(syntax, snippetsFromOptions(editor, syntax));
      if (isStylesheet(syntax)) {
        // Collect snippets for stylesheet context: just a plain list of
        // snippets, converted specifically for CSS context
        cache[syntax] = convertToCSSSnippets(registry).map(function (snippet) {
          var preview = snippet.property;
          var keywords = snippet.keywords();
          if (keywords.length) {
            preview += ": " + removeFields(keywords.join(' | '));
          }
          return {
            key: snippet.key,
            value: snippet.value,
            keywords: keywords,
            preview: preview
          };
        });
      } else {
        // Collect snippets for markup syntaxes: HTML, XML, Slim, Pug etc.
        // Not just a plain snippets list but thier expanded result as well
        var field = function (index, placeholder) {
          return placeholder || '';
        };
        var expandOpt = {
          syntax: syntax,
          field: field
        };
        cache[syntax] = registry.all({
          type: 'string'
        }).map(function (snippet) {
          return {
            key: snippet.key,
            value: snippet.value,
            preview: expandAbbreviation(snippet.value, editor, expandOpt)
          };
        });
      }
    }
    return cache[syntax];
  }

  /**
   * Returns node element prefix, if applicable, for given `pos` in abbreviation
   * for markup syntaxes completions
   * @param  {String} abbr
   * @param  {Number} pos
   * @return {String} Returns `null` if not in element name context
   */
  function getMarkupPrefix(abbr, pos) {
    return getPrefix(abbr, pos, /[\w:\-\$@]+$/);
  }

  /**
   * Returns node element prefix, if applicable, for given `pos` in abbreviation
   * for stylesheet syntaxes completions
   * @param  {String} abbr
   * @param  {Number} pos
   * @return {String} Returns `null` if not in element name context
   */
  function getStylesheetPrefix(abbr, pos) {
    return getPrefix(abbr, pos, /[\w-@$]+$/);
  }

  /**
   * Get snippet completion prefix that matches given `match` regexp from `pos`
   * character pasition of given `abbr` abbreviation
   * @param  {String} abbr
   * @param  {Number} pos
   * @param  {RegExp} match
   * @return {String}
   */
  function getPrefix(abbr, pos, match) {
    if (pos === 0) {
      // Word prefix is at the beginning of abbreviation: it’s an element
      // context for sure
      return '';
    }
    var m = abbr.slice(0, pos).match(match);
    var prefix = m && m[0] || '';

    // Check if matched prefix is either at the beginning of abbreviation or
    // at the element bound, e.g. right after operator
    if (prefix && (prefix === abbr || /[>\^\+\(\)]/.test(abbr[pos - prefix.length - 1]))) {
      return prefix;
    }
    return null;
  }
  var EmmetCompletion = function EmmetCompletion(type, editor, range, label, preview, snippet) {
    this.type = type;
    this.editor = editor;
    this.range = range;
    this.label = label;
    this.preview = preview;
    this.snippet = snippet;
    this._inserted = false;
  };
  EmmetCompletion.prototype.insert = function insert() {
    if (!this._inserted) {
      this._inserted = true;
      if (typeof this.snippet === 'function') {
        this.snippet(this.editor, this.range);
      } else {
        this.editor.replaceRange(this.snippet, this.range.from, this.range.to);

        // Position cursor
        var startIx = this.editor.indexFromPos(this.range.from);
        var newCursor = this.editor.posFromIndex(startIx + this.snippet.length);
        this.editor.setCursor(newCursor);
      }
    }
  };
  var Node$2 = function Node(stream, type, open, close) {
    this.stream = stream;
    this.type = type;
    this.open = open;
    this.close = close;
    this.children = [];
    this.parent = null;
  };
  var prototypeAccessors$4 = {
    name: {},
    attributes: {},
    start: {},
    end: {},
    firstChild: {},
    nextSibling: {},
    previousSibling: {}
  };

  /**
  	 * Returns node name
  	 * @return {String}
  	 */
  prototypeAccessors$4.name.get = function () {
    if (this.type === 'tag' && this.open) {
      return this.open && this.open.name && this.open.name.value;
    }
    return '#' + this.type;
  };

  /**
  	 * Returns attributes of current node
  	 * @return {Array}
  	 */
  prototypeAccessors$4.attributes.get = function () {
    return this.open && this.open.attributes;
  };

  /**
  	 * Returns node’s start position in stream
  	 * @return {*}
  	 */
  prototypeAccessors$4.start.get = function () {
    return this.open && this.open.start;
  };

  /**
  	 * Returns node’s start position in stream
  	 * @return {*}
  	 */
  prototypeAccessors$4.end.get = function () {
    return this.close ? this.close.end : this.open && this.open.end;
  };
  prototypeAccessors$4.firstChild.get = function () {
    return this.children[0];
  };
  prototypeAccessors$4.nextSibling.get = function () {
    var ix = this.getIndex();
    return ix !== -1 ? this.parent.children[ix + 1] : null;
  };
  prototypeAccessors$4.previousSibling.get = function () {
    var ix = this.getIndex();
    return ix !== -1 ? this.parent.children[ix - 1] : null;
  };

  /**
  	 * Returns current element’s index in parent list of child nodes
  	 * @return {Number}
  	 */
  Node$2.prototype.getIndex = function getIndex() {
    return this.parent ? this.parent.children.indexOf(this) : -1;
  };

  /**
  	 * Adds given node as a child
  	 * @param {Node} node
  	 * @return {Node} Current node
  	 */
  Node$2.prototype.addChild = function addChild(node) {
    this.removeChild(node);
    this.children.push(node);
    node.parent = this;
    return this;
  };

  /**
  	 * Removes given node from current node’s child list
  	 * @param  {Node} node
  	 * @return {Node} Current node
  	 */
  Node$2.prototype.removeChild = function removeChild(node) {
    var ix = this.children.indexOf(node);
    if (ix !== -1) {
      this.children.splice(ix, 1);
      node.parent = null;
    }
    return this;
  };
  Object.defineProperties(Node$2.prototype, prototypeAccessors$4);

  /**
   * A token factory method
   * @param  {StreamReader}   stream
   * @param  {Point|Function} start  Tokens’ start location or stream consumer
   * @param  {Point}          [end]  Tokens’ end location
   * @return {Token}
   */
  var token = function (stream, start, end) {
    return typeof start === 'function' ? eatToken(stream, start) : new Token(stream, start, end);
  };

  /**
   * Consumes characters from given stream that matches `fn` call and returns it
   * as token, if consumed
   * @param  {StreamReader} stream
   * @param  {Function} test
   * @return {Token}
   */
  function eatToken(stream, test) {
    var start = stream.pos;
    if (stream.eatWhile(test)) {
      return new Token(stream, start, stream.pos);
    }
    stream.pos = start;
  }

  /**
   * A structure describing text fragment in content stream
   */
  var Token = function Token(stream, start, end) {
    this.stream = stream;
    this.start = start != null ? start : stream.start;
    this.end = end != null ? end : stream.pos;
    this._value = null;
  };
  var prototypeAccessors$1$1 = {
    value: {}
  };

  /**
  	 * Returns token textual value
  	 * NB implemented as getter to reduce unnecessary memory allocations for
  	 * strings that not required
  	 * @return {String}
  	 */
  prototypeAccessors$1$1.value.get = function () {
    if (this._value === null) {
      var start = this.stream.start;
      var end = this.stream.pos;
      this.stream.start = this.start;
      this.stream.pos = this.end;
      this._value = this.stream.current();
      this.stream.start = start;
      this.stream.pos = end;
    }
    return this._value;
  };
  Token.prototype.toString = function toString() {
    return this.value;
  };
  Token.prototype.valueOf = function valueOf() {
    return this.value + " [" + this.start + "; " + this.end + "]";
  };
  Object.defineProperties(Token.prototype, prototypeAccessors$1$1);
  var LANGLE = 60;
  var RANGLE = 62; // < and >
  var LSQUARE = 91;
  var RSQUARE = 93; // [ and ]
  var LROUND = 40;
  var RROUND = 41; // ( and )
  var LCURLY$1 = 123;
  var RCURLY$1 = 125; // { and }

  var opt$2 = {
    throws: true
  };

  /**
   * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded
   * quoted values
   * @param  {StreamReader} stream
   * @return {Token} A token with consumed paired character
   */
  var eatPaired = function (stream) {
    var start = stream.pos;
    var consumed = eatPair(stream, LANGLE, RANGLE, opt$2) || eatPair(stream, LSQUARE, RSQUARE, opt$2) || eatPair(stream, LROUND, RROUND, opt$2) || eatPair(stream, LCURLY$1, RCURLY$1, opt$2);
    if (consumed) {
      return token(stream, start);
    }
  };
  var SLASH$1$1 = 47; // /
  var EQUALS$2 = 61; // =
  var RIGHT_ANGLE$1 = 62; // >

  /**
   * Consumes attributes from given stream
   * @param {StreamReader} stream
   * @return {Array} Array of consumed attributes
   */
  var eatAttributes = function (stream) {
    var result = [];
    var name, value, attr;
    while (!stream.eof()) {
      stream.eatWhile(isSpace);
      attr = {
        start: stream.pos
      };

      // A name could be a regular name or expression:
      // React-style – <div {...props}>
      // Angular-style – <div [ng-for]>
      if (attr.name = eatAttributeName(stream)) {
        // Consumed attribute name. Can be an attribute with name
        // or boolean attribute. The value can be React-like expression
        if (stream.eat(EQUALS$2)) {
          attr.value = eatAttributeValue(stream);
        } else {
          attr.boolean = true;
        }
        attr.end = stream.pos;
        result.push(attr);
      } else if (isTerminator(stream.peek())) {
        // look for tag terminator in order to skip any other possible characters
        // (maybe junk)
        break;
      } else {
        stream.next();
      }
    }
    return result;
  };

  /**
   * Consumes attribute name from current location
   * @param  {StreamReader} stream
   * @return {Token}
   */
  function eatAttributeName(stream) {
    return eatPaired(stream) || token(stream, isAttributeName);
  }

  /**
   * Consumes attribute value from given location
   * @param  {StreamReader} stream
   * @return {Token}
   */
  function eatAttributeValue(stream) {
    var start = stream.pos;
    if (eatQuoted$1(stream)) {
      // Should return token that points to unquoted value.
      // Use stream readers’ public API to traverse instead of direct
      // manipulation
      var current = stream.pos;
      var valueStart, valueEnd;
      stream.pos = start;
      stream.next();
      valueStart = stream.start = stream.pos;
      stream.pos = current;
      stream.backUp(1);
      valueEnd = stream.pos;
      var result = token(stream, valueStart, valueEnd);
      stream.pos = current;
      return result;
    }
    return eatPaired(stream) || eatUnquoted$1(stream);
  }

  /**
   * Check if given code belongs to attribute name.
   * NB some custom HTML variations allow non-default values in name, like `*ngFor`
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isAttributeName(code) {
    return code !== EQUALS$2 && !isTerminator(code) && !isSpace(code);
  }

  /**
   * Check if given code is tag terminator
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isTerminator(code) {
    return code === RIGHT_ANGLE$1 || code === SLASH$1$1;
  }

  /**
   * Eats unquoted value from stream
   * @param  {StreamReader} stream
   * @return {Token}
   */
  function eatUnquoted$1(stream) {
    return token(stream, isUnquoted$1);
  }

  /**
   * Check if given character code is valid unquoted value
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isUnquoted$1(code) {
    return !isNaN(code) && !isQuote$1(code) && !isSpace(code) && !isTerminator(code);
  }
  var DASH$2$1 = 45; // -
  var DOT$2 = 46; // .
  var SLASH$2 = 47; // /
  var COLON$3 = 58; // :
  var LEFT_ANGLE = 60; // <
  var RIGHT_ANGLE = 62; // >
  var UNDERSCORE = 95; // _

  /**
   * Parses tag definition (open or close tag) from given stream state
   * @param {StreamReader} stream Content stream reader
   * @return {Object}
   */
  var tag = function (stream) {
    var start = stream.pos;
    if (stream.eat(LEFT_ANGLE)) {
      var model = {
        type: stream.eat(SLASH$2) ? 'close' : 'open'
      };
      if (model.name = eatTagName(stream)) {
        if (model.type !== 'close') {
          model.attributes = eatAttributes(stream);
          stream.eatWhile(isSpace);
          model.selfClosing = stream.eat(SLASH$2);
        }
        if (stream.eat(RIGHT_ANGLE)) {
          // tag properly closed
          return Object.assign(token(stream, start), model);
        }
      }
    }

    // invalid tag, revert to original position
    stream.pos = start;
    return null;
  };

  /**
   * Eats HTML identifier (tag or attribute name) from given stream
   * @param  {StreamReader} stream
   * @return {Token}
   */
  function eatTagName(stream) {
    return token(stream, isTagName);
  }

  /**
   * Check if given character code can be used as HTML/XML tag name
   * @param  {Number}  code
   * @return {Boolean}
   */
  function isTagName(code) {
    return isAlphaNumeric(code) || code === COLON$3 // colon is used for namespaces
    || code === DOT$2 // in rare cases declarative tag names may have dots in names
    || code === DASH$2$1 || code === UNDERSCORE;
  }

  /**
   * Eats array of character codes from given stream
   * @param  {StreamReader} stream
   * @param  {Number[]} codes  Array of character codes
   * @return {Boolean}
   */
  function eatArray(stream, codes) {
    var start = stream.pos;
    for (var i = 0; i < codes.length; i++) {
      if (!stream.eat(codes[i])) {
        stream.pos = start;
        return false;
      }
    }
    stream.start = start;
    return true;
  }

  /**
   * Consumes section from given string which starts with `open` character codes
   * and ends with `close` character codes
   * @param  {StreamReader} stream
   * @param  {Number[]} open
   * @param  {Number[]} close
   * @return {Boolean}  Returns `true` if section was consumed
   */
  function eatSection(stream, open, close, allowUnclosed) {
    var start = stream.pos;
    if (eatArray(stream, open)) {
      // consumed `<!--`, read next until we find ending part or reach the end of input
      while (!stream.eof()) {
        if (eatArray(stream, close)) {
          return true;
        }
        stream.next();
      }

      // unclosed section is allowed
      if (allowUnclosed) {
        return true;
      }
      stream.pos = start;
      return false;
    }

    // unable to find section, revert to initial position
    stream.pos = start;
    return null;
  }

  /**
   * Converts given string into array of character codes
   * @param  {String} str
   * @return {Number[]}
   */
  function toCharCodes(str) {
    return str.split('').map(function (ch) {
      return ch.charCodeAt(0);
    });
  }
  var open = toCharCodes('<!--');
  var close = toCharCodes('-->');

  /**
   * Consumes HTML comment from given stream
   * @param  {StreamReader} stream
   * @return {Token}
   */
  var comment = function (stream) {
    var start = stream.pos;
    if (eatSection(stream, open, close, true)) {
      var result = token(stream, start);
      result.type = 'comment';
      return result;
    }
    return null;
  };
  var open$1 = toCharCodes('<![CDATA[');
  var close$1 = toCharCodes(']]>');

  /**
   * Consumes CDATA from given stream
   * @param  {StreamReader} stream
   * @return {Token}
   */
  var cdata = function (stream) {
    var start = stream.pos;
    if (eatSection(stream, open$1, close$1, true)) {
      var result = token(stream, start);
      result.type = 'cdata';
      return result;
    }
    return null;
  };
  var defaultOptions$6 = {
    /**
     * Expect XML content in searching content. It alters how should-be-empty
     * elements are treated: for example, in XML mode parser will try to locate
     * closing pair for `<br>` tag
     * @type {Boolean}
     */
    xml: false,
    special: ['script', 'style'],
    /**
     * List of elements that should be treated as empty (e.g. without closing tag)
     * in non-XML syntax
     * @type {Array}
     */
    empty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr']
  };

  /**
   * Parses given content into a DOM-like structure
   * @param  {String|StreamReader} content
   * @param  {Object} options
   * @return {Node}
   */
  function parse$3(content, options) {
    options = Object.assign({}, defaultOptions$6, options);
    var stream = typeof content === 'string' ? new StreamReader$1(content) : content;
    var root = new Node$2(stream, 'root');
    var empty = new Set(options.empty);
    var special = options.special.reduce(function (map, name) {
      return map.set(name, toCharCodes("</" + name + ">"));
    }, new Map());
    var isEmpty = function (token, name) {
      return token.selfClosing || !options.xml && empty.has(name);
    };
    var m,
      node,
      name,
      stack = [root];
    while (!stream.eof()) {
      if (m = match(stream)) {
        name = getName(m);
        if (m.type === 'open') {
          // opening tag
          node = new Node$2(stream, 'tag', m);
          last$1(stack).addChild(node);
          if (special.has(name)) {
            node.close = consumeSpecial(stream, special.get(name));
          } else if (!isEmpty(m, name)) {
            stack.push(node);
          }
        } else if (m.type === 'close') {
          // closing tag, find it’s matching opening tag
          for (var i = stack.length - 1; i > 0; i--) {
            if (stack[i].name.toLowerCase() === name) {
              stack[i].close = m;
              stack = stack.slice(0, i);
              break;
            }
          }
        } else {
          last$1(stack).addChild(new Node$2(stream, m.type, m));
        }
      } else {
        stream.next();
      }
    }
    return root;
  }

  /**
   * Matches known token in current state of given stream
   * @param  {ContentStreamReader} stream
   * @return {Token}
   */
  function match(stream) {
    // fast-path optimization: check for `<` code
    if (stream.peek() === 60 /* < */) {
      return comment(stream) || cdata(stream) || tag(stream);
    }
  }

  /**
   * @param  {StreamReader} stream
   * @param  {Number[]} codes
   * @return {Token}
   */
  function consumeSpecial(stream, codes) {
    var start = stream.pos;
    var m;
    while (!stream.eof()) {
      if (eatArray(stream, codes)) {
        stream.pos = stream.start;
        return tag(stream);
      }
      stream.next();
    }
    stream.pos = start;
    return null;
  }

  /**
   * Returns name of given matched token
   * @param  {Token} tag
   * @return {String}
   */
  function getName(tag$$1) {
    return tag$$1.name ? tag$$1.name.value.toLowerCase() : "#" + tag$$1.type;
  }
  function last$1(arr) {
    return arr[arr.length - 1];
  }

  /**
   * A syntax-specific model container, used to get unified access to underlying
   * parsed document
   */
  var SyntaxModel = function SyntaxModel(dom, type, syntax) {
    this.dom = dom;
    this.type = type;
    this.syntax = syntax;
  };

  /**
  	 * Returns best matching node for given point
  	 * @param  {CodeMirror.Pos}   pos
  	 * @param  {Boolean} [exclude] Exclude node’s start and end positions from
  	 *                             search
  	 * @return {Node}
  	 */
  SyntaxModel.prototype.nodeForPoint = function nodeForPoint(pos, exclude) {
    var ctx = this.dom.firstChild;
    var found = null;
    while (ctx) {
      if (containsPos(range$1(ctx), pos, exclude)) {
        // Found matching tag. Try to find deeper, more accurate match
        found = ctx;
        ctx = ctx.firstChild;
      } else {
        ctx = ctx.nextSibling;
      }
    }
    return found;
  };
  function range$1(node) {
    return {
      from: node.start,
      to: node.end
    };
  }
  var LINE_END = 10; // \n

  /**
   * A stream reader for CodeMirror editor
   */
  var CodeMirrorStreamReader = function (StreamReader) {
    function CodeMirrorStreamReader(editor, pos, limit) {
      StreamReader.call(this);
      var CodeMirror = editor.constructor;
      this.editor = editor;
      this.start = this.pos = pos || CodeMirror.Pos(0, 0);
      var lastLine = editor.lastLine();
      this._eof = limit ? limit.to : CodeMirror.Pos(lastLine, this._lineLength(lastLine));
      this._sof = limit ? limit.from : CodeMirror.Pos(0, 0);
    }
    if (StreamReader) CodeMirrorStreamReader.__proto__ = StreamReader;
    CodeMirrorStreamReader.prototype = Object.create(StreamReader && StreamReader.prototype);
    CodeMirrorStreamReader.prototype.constructor = CodeMirrorStreamReader;

    /**
     * Returns true only if the stream is at the beginning of the file.
     * @returns {Boolean}
     */
    CodeMirrorStreamReader.prototype.sof = function sof() {
      return comparePos(this.pos, this._sof) <= 0;
    };

    /**
     * Returns true only if the stream is at the end of the file.
     * @returns {Boolean}
     */
    CodeMirrorStreamReader.prototype.eof = function eof() {
      return comparePos(this.pos, this._eof) >= 0;
    };

    /**
     * Creates a new stream instance which is limited to given `start` and `end`
     * points for underlying buffer
     * @param  {CodeMirror.Pos} start
     * @param  {CodeMirror.Pos} end
     * @return {CodeMirrorStreamReader}
     */
    CodeMirrorStreamReader.prototype.limit = function limit(from, to) {
      return new this.constructor(this.editor, from, {
        from: from,
        to: to
      });
    };

    /**
     * Returns the next character code in the stream without advancing it.
     * Will return NaN at the end of the file.
     * @returns {Number}
     */
    CodeMirrorStreamReader.prototype.peek = function peek() {
      var ref = this.pos;
      var line = ref.line;
      var ch = ref.ch;
      var lineStr = this.editor.getLine(this.pos.line);
      return ch < lineStr.length ? lineStr.charCodeAt(ch) : LINE_END;
    };

    /**
     * Returns the next character in the stream and advances it.
     * Also returns NaN when no more characters are available.
     * @returns {Number}
     */
    CodeMirrorStreamReader.prototype.next = function next() {
      if (!this.eof()) {
        var code = this.peek();
        this.pos = Object.assign({}, this.pos, {
          ch: this.pos.ch + 1
        });
        if (this.pos.ch >= this._lineLength(this.pos.line)) {
          this.pos.line++;
          this.pos.ch = 0;
        }
        if (this.eof()) {
          // handle edge case where position can move on next line
          // after EOF
          this.pos = Object.assign({}, this._eof);
        }
        return code;
      }
      return NaN;
    };

    /**
     * Backs up the stream n characters. Backing it up further than the
     * start of the current token will cause things to break, so be careful.
     * @param {Number} n
     */
    CodeMirrorStreamReader.prototype.backUp = function backUp(n) {
      var this$1 = this;
      var CodeMirror = this.editor.constructor;
      var ref = this.pos;
      var line = ref.line;
      var ch = ref.ch;
      ch -= n || 1;
      while (line >= 0 && ch < 0) {
        line--;
        ch += this$1._lineLength(line);
      }
      this.pos = line < 0 || ch < 0 ? CodeMirror.Pos(0, 0) : CodeMirror.Pos(line, ch);
      return this.peek();
    };

    /**
     * Get the string between the start of the current token and the
     * current stream position.
     * @returns {String}
     */
    CodeMirrorStreamReader.prototype.current = function current() {
      return this.substring(this.start, this.pos);
    };

    /**
     * Returns contents for given range
     * @param  {Point} from
     * @param  {Point} to
     * @return {String}
     */
    CodeMirrorStreamReader.prototype.substring = function substring(from, to) {
      return this.editor.getRange(from, to);
    };

    /**
     * Creates error object with current stream state
     * @param {String} message
     * @return {Error}
     */
    CodeMirrorStreamReader.prototype.error = function error(message) {
      var err = new Error(message + " at line " + this.pos.line + ", column " + this.pos.ch);
      err.originalMessage = message;
      err.pos = this.pos;
      err.string = this.string;
      return err;
    };

    /**
     * Returns length of given line, including line ending
     * @param  {Number} line
     * @return {Number}
     */
    CodeMirrorStreamReader.prototype._lineLength = function _lineLength(line) {
      var isLast = line === this.editor.lastLine();
      return this.editor.getLine(line).length + (isLast ? 0 : 1);
    };
    return CodeMirrorStreamReader;
  }(StreamReader$1);

  /**
   * Creates DOM-like model for given text editor
   * @param  {CodeMirror} editor
   * @param  {String}     syntax
   * @return {Node}
   */
  function create(editor, syntax) {
    var stream = new CodeMirrorStreamReader(editor);
    var xml = syntax === 'xml';
    try {
      return new SyntaxModel(parse$3(stream, {
        xml: xml
      }), 'html', syntax || 'html');
    } catch (err) {
      console.warn(err);
    }
  }
  function getModel(editor) {
    var syntax = getSyntax(editor);
    return create(editor, syntax);
  }
  function getCachedModel(editor) {
    if (!editor.state._emmetModel) {
      editor.state._emmetModel = getModel(editor);
    }
    return editor.state._emmetModel;
  }
  function resetCachedModel(editor) {
    editor.state._emmetModel = null;
  }

  /**
   * Returns parser-supported syntax of given editor (like 'html', 'css' etc.).
   * Returns `null` if editor’s syntax is unsupported
   * @param  {CodeMirror} editor
   * @return {String}
   */
  function getSyntax(editor) {
    var mode = editor.getMode();
    if (mode.name === 'htmlmixed') {
      return 'html';
    }
    return mode.name === 'xml' ? mode.configuration : mode.name;
  }
  var openTagMark = 'emmet-open-tag';
  var closeTagMark = 'emmet-close-tag';

  /**
   * Finds matching tag pair for given position in editor
   * @param  {CodeMirror} editor
   * @param  {CodeMirror.Pos} pos
   * @return {Object}
   */
  function matchTag(editor, pos) {
    pos = pos || editor.getCursor();

    // First, check if there are tag markers in editor
    var marked = getMarkedTag(editor);

    // If marks found, validate them: make sure cursor is either in open
    // or close tag
    if (marked) {
      if (containsPos(marked.open.find(), pos)) {
        // Point is inside open tag, make sure if there’s a closing tag,
        // it matches open tag content
        if (!marked.close || text(editor, marked.open) === text(editor, marked.close)) {
          return marked;
        }
      } else if (marked.close) {
        // There’s a close tag, make sure pointer is inside it and it matches
        // open tag
        if (containsPos(marked.close.find(), pos) && text(editor, marked.open) === text(editor, marked.close)) {
          return marked;
        }
      }
    }

    // Markers are not valid anymore, remove them
    clearTagMatch(editor);

    // Find new tag pair from parsed HTML model and mark them
    var node = findTagPair(editor, pos);
    if (node && node.type === 'tag') {
      return {
        open: createTagMark(editor, node.open.name, openTagMark),
        close: node.close && createTagMark(editor, node.close.name, closeTagMark)
      };
    }
  }
  function getMarkedTag(editor) {
    var open, close;
    editor.getAllMarks().forEach(function (mark) {
      if (mark.className === openTagMark) {
        open = mark;
      } else if (mark.className === closeTagMark) {
        close = mark;
      }
    });
    return open ? {
      open: open,
      close: close
    } : null;
  }

  /**
   * Removes all matched tag pair markers from editor
   * @param  {CodeMirror} editor
   */
  function clearTagMatch(editor) {
    editor.getAllMarks().forEach(function (mark) {
      if (mark.className === openTagMark || mark.className === closeTagMark) {
        mark.clear();
      }
    });
  }

  /**
   * Finds tag pair (open and close, if any) form parsed HTML model of given editor
   * @param  {CodeMirror} editor
   * @param  {CodeMirror.Pos} pos
   * @return {Object}
   */
  function findTagPair(editor, pos) {
    var model = editor.getEmmetDocumentModel();
    return model && model.nodeForPoint(pos || editor.getCursor());
  }
  function createTagMark(editor, tag, className) {
    return editor.markText(tag.start, tag.end, {
      className: className,
      inclusiveLeft: true,
      inclusiveRight: true,
      clearWhenEmpty: false
    });
  }
  function text(editor, mark) {
    var range = mark.find();
    return range ? editor.getRange(range.from, range.to) : '';
  }
  function renameTag(editor, obj) {
    var tag = getMarkedTag(editor);
    var pos = obj.from;
    if (!tag) {
      return;
    }
    if (containsPos(tag.open.find(), pos) && tag.close) {
      // Update happened inside open tag, update close tag as well
      updateTag(editor, tag.open, tag.close);
    } else if (tag.close && containsPos(tag.close.find(), pos)) {
      // Update happened inside close tag, update open tag as well
      updateTag(editor, tag.close, tag.open);
    }
  }
  function updateTag(editor, source, dest) {
    var name = text$1(editor, source);
    var range = dest.find();
    var m = name.match(/[\w:\-]+/);
    var newName = !name ? '' : m && m[0];
    if (newName != null) {
      if (editor.getRange(range.from, range.to) !== newName) {
        editor.replaceRange(newName, range.from, range.to);
      }
    } else {
      // User entered something that wasn’t a valid tag name.
      clearTagMatch(editor);
    }
  }
  function text$1(editor, mark) {
    var range = mark.find();
    return range ? editor.getRange(range.from, range.to) : '';
  }
  var commands = {
    emmetExpandAbbreviation: emmetExpandAbbreviation,
    emmetInsertLineBreak: emmetInsertLineBreak
  };

  /**
   * Registers Emmet extension on given CodeMirror constructor.
   * This file is designed to be imported somehow into the app (CommonJS, ES6,
   * Rollup/Webpack/whatever). If you simply want to add a <script> into your page
   * that registers Emmet extension on global CodeMirror constructor, use
   * `browser.js` instead
   */
  function registerEmmetExtension(CodeMirror) {
    // Register Emmet commands
    Object.assign(CodeMirror.commands, commands);

    // Defines options that allows abbreviation marking in text editor
    CodeMirror.defineOption('markEmmetAbbreviation', true, function (editor, value) {
      if (value) {
        editor.on('change', markOnEditorChange);
      } else {
        editor.off('change', markOnEditorChange);
        clearMarkers(editor);
      }
    });
    CodeMirror.defineOption('autoRenameTags', true, function (editor, value) {
      value ? editor.on('change', renameTag) : editor.off('change', renameTag);
    });
    CodeMirror.defineOption('markTagPairs', false, function (editor, value) {
      if (value) {
        editor.on('cursorActivity', matchTag);
        editor.on('change', resetCachedModel);
      } else {
        editor.off('cursorActivity', matchTag);
        editor.off('change', resetCachedModel);
        resetCachedModel(editor);
        clearTagMatch(editor);
      }
    });

    // Additional options for Emmet, for Expand Abbreviation action mostly:
    // https://github.com/emmetio/expand-abbreviation/blob/master/index.js#L26
    CodeMirror.defineOption('emmet', {});

    /**
     * Returns Emmet completions for context from `pos` position.
     * Abbreviations are calculated for marked abbreviation at given position.
     * If no parsed abbreviation marker is available and `force` argument is
     * given, tries to mark abbreviation and populate completions list again.
     * @param  {CodeMirror.Pos} [pos]
     * @param  {Boolean}        [force]
     * @return {EmmetCompletion[]}
     */
    CodeMirror.defineExtension('getEmmetCompletions', function (pos, force) {
      var editor = this;
      if (typeof pos === 'boolean') {
        force = pos;
        pos = null;
      }
      var abbrRange, list;
      pos = pos || editor.getCursor();
      if (editor.getOption('markEmmetAbbreviation')) {
        // Get completions from auto-inserted marker
        var marker = findMarker(editor, pos) || force && markAbbreviation(editor, pos, true);
        if (marker) {
          abbrRange = marker.find();
          list = autocompleteProvider(editor, marker.model, abbrRange.from, pos);
        }
      } else {
        // No abbreviation auto-marker, try to extract abbreviation from given
        // cursor location
        var extracted = extractAbbreviation(editor, pos);
        if (extracted) {
          var model = createAbbreviationModel(extracted.abbreviation, editor);
          if (model) {
            abbrRange = {
              from: {
                line: pos.line,
                ch: extracted.location
              },
              to: {
                line: pos.line,
                ch: extracted.location + extracted.abbreviation.length
              }
            };
            list = autocompleteProvider(editor, model, abbrRange.from, pos);
          }
        }
      }
      if (list && list.length) {
        return {
          from: abbrRange.from,
          to: abbrRange.to,
          list: list
        };
      }
    });

    /**
     * Returns valid Emmet abbreviation and its location in editor from given
     * position
     * @param  {CodeMirror.Pos} [pos] Position from which abbreviation should be
     *                                extracted. If not given, current cursor
     *                                position is used
     * @return {Object} Object with `abbreviation` and `location` properties
     * or `null` if there’s no valid abbreviation
     */
    CodeMirror.defineExtension('getEmmetAbbreviation', function (pos) {
      var editor = this;
      pos = pos || editor.getCursor();
      var marker = findMarker(editor, pos);
      if (marker) {
        return {
          abbreviation: marker.model.abbreviation,
          ast: marker.model.ast,
          location: marker.find().from,
          fromMarker: true
        };
      }
      var extracted = extractAbbreviation(editor, pos);
      if (extracted) {
        try {
          return {
            abbreviation: extracted.abbreviation,
            ast: parseAbbreviation(extracted.abbreviation, editor),
            location: {
              line: pos.line,
              ch: extracted.location
            },
            fromMarker: false
          };
        } catch (err) {
          // Will throw if abbreviation is invalid
        }
      }
      return null;
    });
    CodeMirror.defineExtension('findEmmetMarker', function (pos) {
      return findMarker(this, pos || this.getCursor());
    });
    CodeMirror.defineExtension('getEmmetDocumentModel', function () {
      var editor = this;
      return editor.getOption('markTagPairs') ? getCachedModel(editor) : getModel(editor);
    });
  }
  if (typeof CodeMirror !== 'undefined') {
    registerEmmetExtension(CodeMirror);
  }
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/hint/css-hint_customized.js":
/*!************************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/hint/css-hint_customized.js ***!
  \************************************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"), require("../../mode/css/css"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror", "../../mode/css/css"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var pseudoClasses = {
    link: 1,
    visited: 1,
    active: 1,
    hover: 1,
    focus: 1,
    "first-letter": 1,
    "first-line": 1,
    "first-child": 1,
    before: 1,
    after: 1,
    lang: 1
  };
  CodeMirror.registerHelper("hint", "css", function (cm) {
    var cur = cm.getCursor(),
      token = cm.getTokenAt(cur);
    var inner = CodeMirror.innerMode(cm.getMode(), token.state);
    if (inner.mode.name != "css") return;
    if (token.type == "keyword" && "!important".indexOf(token.string) == 0) return {
      list: ["!important"],
      from: CodeMirror.Pos(cur.line, token.start),
      to: CodeMirror.Pos(cur.line, token.end)
    };
    var start = token.start,
      end = cur.ch,
      word = token.string.slice(0, end - start);
    var strBeforeCursor = cm.getRange({
        line: 0,
        ch: 0
      }, cm.getCursor('start')),
      strAfterCursor = cm.getValue().substr(strBeforeCursor.length);

    // if (/[^\w$_-]/.test(word)) {     // Original test
    if (/[^\w\.#$_-]/.test(word)) {
      // With this modified test, "#" and "." characters would be considered part of the word
      word = "";
      start = end = cur.ch;
    }
    var spec = CodeMirror.resolveMode("text/css");
    var result = [];
    function add(keywords, allowMatchAnywhere) {
      for (var name in keywords) if (!word || name.lastIndexOf(word, 0) == 0) {
        if (typeof keywords[name] === 'object') {
          result.push(keywords[name]);
        } else {
          result.push(name);
        }
      }
      // If truthy allowMatchAnywhere is passed, the typed string would match the typed characters anywhere in the
      // available CSS selectors. The "anywhere" matches would be added to the bottom of the list in alphabetical order
      if (allowMatchAnywhere) {
        var anywhereMatches = [];
        for (var name in keywords) {
          if (!word || name.lastIndexOf(word, 0) == 0) {
            // do nothing (those matches have already been added previously)
          } else if (!word || name.indexOf(word) >= 0) {
            // anywhereMatches.push(name);
            if (typeof keywords[name] === 'object') {
              anywhereMatches.push(keywords[name]);
            } else {
              anywhereMatches.push(name);
            }
          }
        }
        anywhereMatches = anywhereMatches.sort();
        result = result.concat(anywhereMatches);
      }
    }
    var isCssHintForSelector = false;
    var st = inner.state.state;

    // For autocompleting CSS selectors with "window.existingCSSSelectors" and to make it work with space character,
    // default hintOptions.closeCharacters is overridden and check for whitespace ("\s") is removed, but autocomplete
    // list shouldn't show up for the other cases of autocomplete (like autocompleting CSS property), so we just
    // return from the function for all other cases if the last character is a whitespace.
    if (token.type == "variable-3" || ["pseudo", "block", "maybeprop", "prop", "parens", "at", "params", "media", "media_parens"].indexOf(st) >= 0) {
      var lastCharacterTyped = cm.getRange({
        line: 0,
        ch: 0
      }, cm.getCursor('start'));
      if (lastCharacterTyped.substr(-1).match(/\s/)) {
        return;
      }
    }
    if (st == "pseudo" || token.type == "variable-3") {
      add(pseudoClasses);
    } else if (st == "block" || st == "maybeprop") {
      /*
      add(spec.propertyKeywords);
      */
      var onAddingAutoCompleteOptionsForCSSProperty = ((cm.options || {}).hintOptions || {}).onAddingAutoCompleteOptionsForCSSProperty;
      if (onAddingAutoCompleteOptionsForCSSProperty) {
        onAddingAutoCompleteOptionsForCSSProperty(add);
      } else {
        add(spec.propertyKeywords);
      }
    } else if (st == "prop" || st == "parens" || st == "at" || st == "params") {
      add(spec.valueKeywords);
      add(spec.colorKeywords);
    } else if (st == "media" || st == "media_parens") {
      add(spec.mediaTypes);
      add(spec.mediaFeatures);
    } else if (st === 'top') {
      var str = strBeforeCursor; // String before cursor
      str = str.substring(str.lastIndexOf('}') + 1);
      str = str.substring(str.lastIndexOf(',') + 1);
      str = str.trimLeft();
      var stringBeforeFilteringNewLine = str;
      str = str.substring(str.lastIndexOf('\r') + 1);
      str = str.substring(str.lastIndexOf('\n') + 1);
      if (stringBeforeFilteringNewLine !== str) {
        return;
      }
      str = str.trimLeft();
      var selectorBeforeCursor = str; // Selector before cursor
      if (selectorBeforeCursor.length >= 3) {
        // Show hint only if selector before cursor has 3 or more characters
        end = cur.ch;
        start = cur.ch - selectorBeforeCursor.length;
        word = selectorBeforeCursor;
        isCssHintForSelector = true;
        var onAddingAutoCompleteOptionsForSelector = ((cm.options || {}).hintOptions || {}).onAddingAutoCompleteOptionsForSelector;
        if (onAddingAutoCompleteOptionsForSelector) {
          onAddingAutoCompleteOptionsForSelector(add);
        }
      }
    }
    if (result.length) {
      var ob = {
        list: result,
        from: CodeMirror.Pos(cur.line, start),
        to: CodeMirror.Pos(cur.line, end)
      };
      if (isCssHintForSelector) {
        ob.selectedHint = -1; // Do not auto-select the first item if the hint is for CSS selector

        CodeMirror.on(ob, 'select', function (selectedText, selectedEl) {
          var onCssHintSelectForSelector = ((cm.options || {}).hintOptions || {}).onCssHintSelectForSelector;
          if (onCssHintSelectForSelector) {
            onCssHintSelectForSelector(selectedText, selectedEl);
          }
        });
        CodeMirror.on(ob, 'shown', function () {
          var onCssHintShownForSelector = ((cm.options || {}).hintOptions || {}).onCssHintShownForSelector;
          if (onCssHintShownForSelector) {
            onCssHintShownForSelector();
          }
        });
      }
      return ob;
    }
  });
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/hint/show-hint_customized.js":
/*!*************************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/hint/show-hint_customized.js ***!
  \*************************************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function (cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = {
      hint: getHints
    };
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };
  CodeMirror.defineExtension("showHint", function (options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections();
    if (selections.length > 1) return;
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++) if (selections[i].head.line != selections[i].anchor.line) return;
    }
    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;
    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });
  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
    var self = this;
    cm.on("cursorActivity", this.activityFunc = function () {
      self.cursorActivity();
    });
  }
  var requestAnimationFrame = window.requestAnimationFrame || function (fn) {
    return setTimeout(fn, 1000 / 60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
  Completion.prototype = {
    close: function () {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);
      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },
    active: function () {
      return this.cm.state.completionActive == this;
    },
    pick: function (data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);else this.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },
    cursorActivity: function () {
      if (this.debounce) {
        // See: http://stackoverflow.com/questions/42322248/typeerror-requestanimationframe-called-on-an-object-that-does-not-implement-i
        //      The commented out code resulted in similar error on Firefox.
        // cancelAnimationFrame(this.debounce);     // Somehow, this doesn't work well in showing hints for Firefox extension
        window.cancelAnimationFrame(this.debounce); // But, this works fine
        this.debounce = 0;
      }
      var pos = this.cm.getCursor(),
        line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < this.startPos.ch || this.cm.somethingSelected() || pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1))) {
        this.close();
      } else {
        var self = this;
        // See: http://stackoverflow.com/questions/42322248/typeerror-requestanimationframe-called-on-an-object-that-does-not-implement-i
        //      The commented out code resulted in similar error on Firefox.
        // this.debounce = requestAnimationFrame(function() {self.update();});      // Somehow, this doesn't work well in showing hints for Firefox extension
        this.debounce = window.requestAnimationFrame(function () {
          self.update();
        }); // But, this works fine
        if (this.widget) this.widget.disable();
      }
    },
    update: function (first) {
      if (this.tick == null) return;
      var self = this,
        myTick = ++this.tick;
      fetchHints(this.options.hint, this.cm, this.options, function (data) {
        if (self.tick == myTick) self.finishUpdate(data, first);
      });
    },
    finishUpdate: function (data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");
      var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
      if (this.widget) this.widget.close();
      this.data = data;
      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };
  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor) for (var prop in editor) if (editor[prop] !== undefined) out[prop] = editor[prop];
    if (options) for (var prop in options) if (options[prop] !== undefined) out[prop] = options[prop];
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos);
    return out;
  }
  function getText(completion) {
    if (typeof completion == "string") return completion;else return completion.text;
  }
  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function () {
        handle.moveFocus(-1);
      },
      Down: function () {
        handle.moveFocus(1);
      },
      PageUp: function () {
        handle.moveFocus(-handle.menuSize() + 1, true);
      },
      PageDown: function () {
        handle.moveFocus(handle.menuSize() - 1, true);
      },
      Home: function () {
        handle.setFocus(0);
      },
      End: function () {
        handle.setFocus(handle.length - 1);
      },
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string") bound = function (cm) {
        return val(cm, handle);
      };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val)) bound = baseMap[val];else bound = val;
      ourMap[key] = bound;
    }
    if (custom) for (var key in custom) if (custom.hasOwnProperty(key)) addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra) for (var key in extra) if (extra.hasOwnProperty(key)) addBinding(key, extra[key]);
    return ourMap;
  }
  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }
  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this,
      cm = completion.cm;
    var hints = this.hints = document.createElement("ul");
    // hints.className = "CodeMirror-hints";
    hints.className = "CodeMirror-hints " + (completion.options.className || '');
    this.selectedHint = data.selectedHint || 0;
    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement("li")),
        cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left,
      top = pos.bottom,
      below = true;
    hints.style.left = left + "px";
    hints.style.top = top + "px";
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
    (completion.options.container || document.body).appendChild(hints);
    var box = hints.getBoundingClientRect(),
      overlapY = box.bottom - winH;
    var scrolls = hints.scrollHeight > hints.clientHeight + 1;
    var startScroll = cm.getScrollInfo();
    if (overlapY > 0) {
      var height = box.bottom - box.top,
        curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) {
        // Fits above cursor
        hints.style.top = (top = pos.top - height) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = winH - 5 + "px";
        hints.style.top = (top = pos.bottom - box.top) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = winW - 5 + "px";
        overlapX -= box.right - box.left - winW;
      }
      hints.style.left = (left = pos.left - overlapX) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling) node.style.paddingRight = cm.display.nativeBarWidth + "px";
    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function (n, avoidWrap) {
        widget.changeActive(widget.selectedHint + n, avoidWrap);
      },
      setFocus: function (n) {
        widget.changeActive(n);
      },
      menuSize: function () {
        return widget.screenAmount();
      },
      length: completions.length,
      close: function () {
        completion.close();
      },
      pick: function () {
        widget.pick();
      },
      data: data
    }));
    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function () {
        closingOnBlur = setTimeout(function () {
          completion.close();
        }, 100);
      });
      cm.on("focus", this.onFocus = function () {
        clearTimeout(closingOnBlur);
      });
    }
    cm.on("scroll", this.onScroll = function () {
      var curScroll = cm.getScrollInfo(),
        editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = left + startScroll.left - curScroll.left + "px";
    });
    CodeMirror.on(hints, "dblclick", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        widget.pick();
      }
    });
    CodeMirror.on(hints, "click", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });
    CodeMirror.on(hints, "mousedown", function () {
      setTimeout(function () {
        cm.focus();
      }, 20);
    });
    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }
  Widget.prototype = {
    close: function () {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);
      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },
    disable: function () {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = {
        Enter: function () {
          widget.picked = true;
        }
      };
      this.completion.cm.addKeyMap(this.keyMap);
    },
    pick: function () {
      this.completion.pick(this.data, this.selectedHint);
    },
    changeActive: function (i, avoidWrap) {
      if (i >= this.data.list.length) i = avoidWrap ? this.data.list.length - 1 : 0;else if (i < 0) i = avoidWrap ? 0 : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      // var node = this.hints.childNodes[this.selectedHint];
      var node = this.hints.childNodes[this.selectedHint === -1 ? 0 : this.selectedHint]; // If this.selectedHint is -1 (-1 indicates do not select any item), get 0th hint childNode (which would always be there)
      node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop) this.hints.scrollTop = node.offsetTop - 3;else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight) this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },
    screenAmount: function () {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };
  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers;
    var result = [];
    for (var i = 0; i < helpers.length; i++) if (helpers[i].supportsSelection) result.push(helpers[i]);
    return result;
  }
  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options);
    } else {
      var result = hint(cm, options);
      if (result && result.then) result.then(callback);else callback(result);
    }
  }
  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"),
      words;
    if (helpers.length) {
      var resolved = function (cm, callback, options) {
        var app = applicableHelpers(cm, helpers);
        function run(i) {
          if (i == app.length) return callback(null);
          fetchHints(app[i], cm, options, function (result) {
            if (result && result.list.length > 0) callback(result);else run(i + 1);
          });
        }
        run(0);
      };
      resolved.async = true;
      resolved.supportsSelection = true;
      return resolved;
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function (cm) {
        return CodeMirror.hint.fromList(cm, {
          words: words
        });
      };
    } else if (CodeMirror.hint.anyword) {
      return function (cm, options) {
        return CodeMirror.hint.anyword(cm, options);
      };
    } else {
      return function () {};
    }
  }
  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });
  CodeMirror.registerHelper("hint", "fromList", function (cm, options) {
    var cur = cm.getCursor(),
      token = cm.getTokenAt(cur);
    var to = CodeMirror.Pos(cur.line, token.end);
    if (token.string && /\w/.test(token.string[token.string.length - 1])) {
      var term = token.string,
        from = CodeMirror.Pos(cur.line, token.start);
    } else {
      var term = "",
        from = to;
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term) found.push(word);
    }
    if (found.length) return {
      list: found,
      from: from,
      to: to
    };
  });
  CodeMirror.commands.autocomplete = CodeMirror.showHint;
  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null
  };
  CodeMirror.defineOption("hintOptions", null);
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/lint/css-lint_customized.js":
/*!************************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/lint/css-lint_customized.js ***!
  \************************************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Depends on csslint.js from https://github.com/stubbornella/csslint

// declare global: CSSLint

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.registerHelper("lint", "css", function (text, options) {
    var found = [];
    // if (!window.CSSLint) {
    if (typeof CSSLint === 'undefined') {
      // In Firefox WebExtension, "window.CSSLint" is not available, while "CSSLint" is available
      // Firefox WebExtensions behave slightly differently for global variables declared-using-"var" vs declared-using-"window."
      // References:
      //     https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Content_scripts
      //     https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Xray_vision
      if (window.console) {
        window.console.error("Error: window.CSSLint not defined, CodeMirror CSS linting cannot run.");
      }
      return found;
    }
    var results = CSSLint.verify(text, options),
      messages = results.messages,
      message = null;
    for (var i = 0; i < messages.length; i++) {
      message = messages[i];
      var startLine = message.line - 1,
        endLine = message.line - 1,
        startCol = message.col - 1,
        endCol = message.col;
      found.push({
        from: CodeMirror.Pos(startLine, startCol),
        to: CodeMirror.Pos(endLine, endCol),
        message: message.message,
        severity: message.type
      });
    }
    return found;
  });
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/lint/lint.js":
/*!*********************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/lint/lint.js ***!
  \*********************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var GUTTER_ID = "CodeMirror-lint-markers";
  function showTooltip(e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip";
    tt.appendChild(content.cloneNode(true));
    document.body.appendChild(tt);
    function position(e) {
      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
      tt.style.left = e.clientX + 5 + "px";
    }
    CodeMirror.on(document, "mousemove", position);
    position(e);
    if (tt.style.opacity != null) tt.style.opacity = 1;
    return tt;
  }
  function rm(elt) {
    if (elt.parentNode) elt.parentNode.removeChild(elt);
  }
  function hideTooltip(tt) {
    if (!tt.parentNode) return;
    if (tt.style.opacity == null) rm(tt);
    tt.style.opacity = 0;
    setTimeout(function () {
      rm(tt);
    }, 600);
  }
  function showTooltipFor(e, content, node) {
    var tooltip = showTooltip(e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      if (tooltip) {
        hideTooltip(tooltip);
        tooltip = null;
      }
    }
    var poll = setInterval(function () {
      if (tooltip) for (var n = node;; n = n.parentNode) {
        if (n && n.nodeType == 11) n = n.host;
        if (n == document.body) return;
        if (!n) {
          hide();
          break;
        }
      }
      if (!tooltip) return clearInterval(poll);
    }, 400);
    CodeMirror.on(node, "mouseout", hide);
  }
  function LintState(cm, options, hasGutter) {
    this.marked = [];
    this.options = options;
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function (e) {
      onMouseOver(cm, e);
    };
    this.waitingFor = 0;
  }
  function parseOptions(_cm, options) {
    if (options instanceof Function) return {
      getAnnotations: options
    };
    if (!options || options === true) options = {};
    return options;
  }
  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    for (var i = 0; i < state.marked.length; ++i) state.marked[i].clear();
    state.marked.length = 0;
  }
  function makeMarker(labels, severity, multiple, tooltips) {
    var marker = document.createElement("div"),
      inner = marker;
    marker.className = "CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker-multiple";
    }
    if (tooltips != false) CodeMirror.on(inner, "mouseover", function (e) {
      showTooltipFor(e, labels, inner);
    });
    return marker;
  }
  function getMaxSeverity(a, b) {
    if (a == "error") return a;else return b;
  }
  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i < annotations.length; ++i) {
      var ann = annotations[i],
        line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }
  function annotationTooltip(ann) {
    var severity = ann.severity;
    if (!severity) severity = "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message-" + severity;
    if (typeof ann.messageHTML != 'undefined') {
      tip.innerHTML = ann.messageHTML;
    } else {
      tip.appendChild(document.createTextNode(ann.message));
    }
    return tip;
  }
  function lintAsync(cm, getAnnotations, passOptions) {
    var state = cm.state.lint;
    var id = ++state.waitingFor;
    function abort() {
      id = -1;
      cm.off("change", abort);
    }
    cm.on("change", abort);
    getAnnotations(cm.getValue(), function (annotations, arg2) {
      cm.off("change", abort);
      if (state.waitingFor != id) return;
      if (arg2 && annotations instanceof CodeMirror) annotations = arg2;
      cm.operation(function () {
        updateLinting(cm, annotations);
      });
    }, passOptions, cm);
  }
  function startLinting(cm) {
    var state = cm.state.lint,
      options = state.options;
    /*
     * Passing rules in `options` property prevents JSHint (and other linters) from complaining
     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.
     */
    var passOptions = options.options || options;
    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!getAnnotations) return;
    if (options.async || getAnnotations.async) {
      lintAsync(cm, getAnnotations, passOptions);
    } else {
      var annotations = getAnnotations(cm.getValue(), passOptions, cm);
      if (!annotations) return;
      if (annotations.then) annotations.then(function (issues) {
        cm.operation(function () {
          updateLinting(cm, issues);
        });
      });else cm.operation(function () {
        updateLinting(cm, annotations);
      });
    }
  }
  function updateLinting(cm, annotationsNotSorted) {
    clearMarks(cm);
    var state = cm.state.lint,
      options = state.options;
    var annotations = groupByLine(annotationsNotSorted);
    for (var line = 0; line < annotations.length; ++line) {
      var anns = annotations[line];
      if (!anns) continue;
      var maxSeverity = null;
      var tipLabel = state.hasGutter && document.createDocumentFragment();
      for (var i = 0; i < anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity;
        if (!severity) severity = "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);
        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));
        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
          className: "CodeMirror-lint-mark-" + severity,
          __annotation: ann
        }));
      }
      if (state.hasGutter) cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1, state.options.tooltips));
    }
    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
  }
  function onChange(cm) {
    var state = cm.state.lint;
    if (!state) return;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function () {
      startLinting(cm);
    }, state.options.delay || 500);
  }
  function popupTooltips(annotations, e) {
    var target = e.target || e.srcElement;
    var tooltip = document.createDocumentFragment();
    for (var i = 0; i < annotations.length; i++) {
      var ann = annotations[i];
      tooltip.appendChild(annotationTooltip(ann));
    }
    showTooltipFor(e, tooltip, target);
  }
  function onMouseOver(cm, e) {
    var target = e.target || e.srcElement;
    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
    var box = target.getBoundingClientRect(),
      x = (box.left + box.right) / 2,
      y = (box.top + box.bottom) / 2;
    var spans = cm.findMarksAt(cm.coordsChar({
      left: x,
      top: y
    }, "client"));
    var annotations = [];
    for (var i = 0; i < spans.length; ++i) {
      var ann = spans[i].__annotation;
      if (ann) annotations.push(ann);
    }
    if (annotations.length) popupTooltips(annotations, e);
  }
  CodeMirror.defineOption("lint", false, function (cm, val, old) {
    if (old && old != CodeMirror.Init) {
      clearMarks(cm);
      if (cm.state.lint.options.lintOnChange !== false) cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      clearTimeout(cm.state.lint.timeout);
      delete cm.state.lint;
    }
    if (val) {
      var gutters = cm.getOption("gutters"),
        hasLintGutter = false;
      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
      if (state.options.lintOnChange !== false) cm.on("change", onChange);
      if (state.options.tooltips != false && state.options.tooltips != "gutter") CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);
      startLinting(cm);
    }
  });
  CodeMirror.defineExtension("performLint", function () {
    if (this.state.lint) startLinting(this);
  });
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/search/searchcursor.js":
/*!*******************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/search/searchcursor.js ***!
  \*******************************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"))
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod)
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var Pos = CodeMirror.Pos;
  function regexpFlags(regexp) {
    var flags = regexp.flags;
    return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");
  }
  function ensureGlobal(regexp) {
    return regexp.global ? regexp : new RegExp(regexp.source, regexpFlags(regexp) + "g");
  }
  function maybeMultiline(regexp) {
    return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source);
  }
  function searchRegexpForward(doc, regexp, start) {
    regexp = ensureGlobal(regexp);
    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
      regexp.lastIndex = ch;
      var string = doc.getLine(line),
        match = regexp.exec(string);
      if (match) return {
        from: Pos(line, match.index),
        to: Pos(line, match.index + match[0].length),
        match: match
      };
    }
  }
  function searchRegexpForwardMultiline(doc, regexp, start) {
    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start);
    regexp = ensureGlobal(regexp);
    var string,
      chunk = 1;
    for (var line = start.line, last = doc.lastLine(); line <= last;) {
      // This grows the search buffer in exponentially-sized chunks
      // between matches, so that nearby matches are fast and don't
      // require concatenating the whole document (in case we're
      // searching for something that has tons of matches), but at the
      // same time, the amount of retries is limited.
      for (var i = 0; i < chunk; i++) {
        var curLine = doc.getLine(line++);
        string = string == null ? curLine : string + "\n" + curLine;
      }
      chunk = chunk * 2;
      regexp.lastIndex = start.ch;
      var match = regexp.exec(string);
      if (match) {
        var before = string.slice(0, match.index).split("\n"),
          inside = match[0].split("\n");
        var startLine = start.line + before.length - 1,
          startCh = before[before.length - 1].length;
        return {
          from: Pos(startLine, startCh),
          to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
          match: match
        };
      }
    }
  }
  function lastMatchIn(string, regexp) {
    var cutOff = 0,
      match;
    for (;;) {
      regexp.lastIndex = cutOff;
      var newMatch = regexp.exec(string);
      if (!newMatch) return match;
      match = newMatch;
      cutOff = match.index + (match[0].length || 1);
      if (cutOff == string.length) return match;
    }
  }
  function searchRegexpBackward(doc, regexp, start) {
    regexp = ensureGlobal(regexp);
    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
      var string = doc.getLine(line);
      if (ch > -1) string = string.slice(0, ch);
      var match = lastMatchIn(string, regexp);
      if (match) return {
        from: Pos(line, match.index),
        to: Pos(line, match.index + match[0].length),
        match: match
      };
    }
  }
  function searchRegexpBackwardMultiline(doc, regexp, start) {
    regexp = ensureGlobal(regexp);
    var string,
      chunk = 1;
    for (var line = start.line, first = doc.firstLine(); line >= first;) {
      for (var i = 0; i < chunk; i++) {
        var curLine = doc.getLine(line--);
        string = string == null ? curLine.slice(0, start.ch) : curLine + "\n" + string;
      }
      chunk *= 2;
      var match = lastMatchIn(string, regexp);
      if (match) {
        var before = string.slice(0, match.index).split("\n"),
          inside = match[0].split("\n");
        var startLine = line + before.length,
          startCh = before[before.length - 1].length;
        return {
          from: Pos(startLine, startCh),
          to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
          match: match
        };
      }
    }
  }
  var doFold, noFold;
  if (String.prototype.normalize) {
    doFold = function (str) {
      return str.normalize("NFD").toLowerCase();
    };
    noFold = function (str) {
      return str.normalize("NFD");
    };
  } else {
    doFold = function (str) {
      return str.toLowerCase();
    };
    noFold = function (str) {
      return str;
    };
  }

  // Maps a position in a case-folded line back to a position in the original line
  // (compensating for codepoints increasing in number during folding)
  function adjustPos(orig, folded, pos, foldFunc) {
    if (orig.length == folded.length) return pos;
    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {
      if (min == max) return min;
      var mid = min + max >> 1;
      var len = foldFunc(orig.slice(0, mid)).length;
      if (len == pos) return mid;else if (len > pos) max = mid;else min = mid + 1;
    }
  }
  function searchStringForward(doc, query, start, caseFold) {
    // Empty string would match anything and never progress, so we
    // define it to match nothing instead.
    if (!query.length) return null;
    var fold = caseFold ? doFold : noFold;
    var lines = fold(query).split(/\r|\n\r?/);
    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
      var orig = doc.getLine(line).slice(ch),
        string = fold(orig);
      if (lines.length == 1) {
        var found = string.indexOf(lines[0]);
        if (found == -1) continue search;
        var start = adjustPos(orig, string, found, fold) + ch;
        return {
          from: Pos(line, adjustPos(orig, string, found, fold) + ch),
          to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)
        };
      } else {
        var cutFrom = string.length - lines[0].length;
        if (string.slice(cutFrom) != lines[0]) continue search;
        for (var i = 1; i < lines.length - 1; i++) if (fold(doc.getLine(line + i)) != lines[i]) continue search;
        var end = doc.getLine(line + lines.length - 1),
          endString = fold(end),
          lastLine = lines[lines.length - 1];
        if (endString.slice(0, lastLine.length) != lastLine) continue search;
        return {
          from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
          to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))
        };
      }
    }
  }
  function searchStringBackward(doc, query, start, caseFold) {
    if (!query.length) return null;
    var fold = caseFold ? doFold : noFold;
    var lines = fold(query).split(/\r|\n\r?/);
    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
      var orig = doc.getLine(line);
      if (ch > -1) orig = orig.slice(0, ch);
      var string = fold(orig);
      if (lines.length == 1) {
        var found = string.lastIndexOf(lines[0]);
        if (found == -1) continue search;
        return {
          from: Pos(line, adjustPos(orig, string, found, fold)),
          to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))
        };
      } else {
        var lastLine = lines[lines.length - 1];
        if (string.slice(0, lastLine.length) != lastLine) continue search;
        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++) if (fold(doc.getLine(start + i)) != lines[i]) continue search;
        var top = doc.getLine(line + 1 - lines.length),
          topString = fold(top);
        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search;
        return {
          from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
          to: Pos(line, adjustPos(orig, string, lastLine.length, fold))
        };
      }
    }
  }
  function SearchCursor(doc, query, pos, options) {
    this.atOccurrence = false;
    this.doc = doc;
    pos = pos ? doc.clipPos(pos) : Pos(0, 0);
    this.pos = {
      from: pos,
      to: pos
    };
    var caseFold;
    if (typeof options == "object") {
      caseFold = options.caseFold;
    } else {
      // Backwards compat for when caseFold was the 4th argument
      caseFold = options;
      options = null;
    }
    if (typeof query == "string") {
      if (caseFold == null) caseFold = false;
      this.matches = function (reverse, pos) {
        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold);
      };
    } else {
      query = ensureGlobal(query);
      if (!options || options.multiline !== false) this.matches = function (reverse, pos) {
        return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos);
      };else this.matches = function (reverse, pos) {
        return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos);
      };
    }
  }
  SearchCursor.prototype = {
    findNext: function () {
      return this.find(false);
    },
    findPrevious: function () {
      return this.find(true);
    },
    find: function (reverse) {
      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to));

      // Implements weird auto-growing behavior on null-matches for
      // backwards-compatiblity with the vim code (unfortunately)
      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {
        if (reverse) {
          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1);else if (result.from.line == this.doc.firstLine()) result = null;else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)));
        } else {
          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1);else if (result.to.line == this.doc.lastLine()) result = null;else result = this.matches(reverse, Pos(result.to.line + 1, 0));
        }
      }
      if (result) {
        this.pos = result;
        this.atOccurrence = true;
        return this.pos.match || true;
      } else {
        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
        this.pos = {
          from: end,
          to: end
        };
        return this.atOccurrence = false;
      }
    },
    from: function () {
      if (this.atOccurrence) return this.pos.from;
    },
    to: function () {
      if (this.atOccurrence) return this.pos.to;
    },
    replace: function (newText, origin) {
      if (!this.atOccurrence) return;
      var lines = CodeMirror.splitLines(newText);
      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
      this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
    }
  };
  CodeMirror.defineExtension("getSearchCursor", function (query, pos, caseFold) {
    return new SearchCursor(this.doc, query, pos, caseFold);
  });
  CodeMirror.defineDocExtension("getSearchCursor", function (query, pos, caseFold) {
    return new SearchCursor(this, query, pos, caseFold);
  });
  CodeMirror.defineExtension("selectMatches", function (query, caseFold) {
    var ranges = [];
    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
    while (cur.findNext()) {
      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
      ranges.push({
        anchor: cur.from(),
        head: cur.to()
      });
    }
    if (ranges.length) this.setSelections(ranges, 0);
  });
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/selection/active-line.js":
/*!*********************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/selection/active-line.js ***!
  \*********************************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";
  var GUTT_CLASS = "CodeMirror-activeline-gutter";
  CodeMirror.defineOption("styleActiveLine", false, function (cm, val, old) {
    var prev = old == CodeMirror.Init ? false : old;
    if (val == prev) return;
    if (prev) {
      cm.off("beforeSelectionChange", selectionChange);
      clearActiveLines(cm);
      delete cm.state.activeLines;
    }
    if (val) {
      cm.state.activeLines = [];
      updateActiveLines(cm, cm.listSelections());
      cm.on("beforeSelectionChange", selectionChange);
    }
  });
  function clearActiveLines(cm) {
    for (var i = 0; i < cm.state.activeLines.length; i++) {
      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
    }
  }
  function sameArray(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) if (a[i] != b[i]) return false;
    return true;
  }
  function updateActiveLines(cm, ranges) {
    var active = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var option = cm.getOption("styleActiveLine");
      if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty()) continue;
      var line = cm.getLineHandleVisualStart(range.head.line);
      if (active[active.length - 1] != line) active.push(line);
    }
    if (sameArray(cm.state.activeLines, active)) return;
    cm.operation(function () {
      clearActiveLines(cm);
      for (var i = 0; i < active.length; i++) {
        cm.addLineClass(active[i], "wrap", WRAP_CLASS);
        cm.addLineClass(active[i], "background", BACK_CLASS);
        cm.addLineClass(active[i], "gutter", GUTT_CLASS);
      }
      cm.state.activeLines = active;
    });
  }
  function selectionChange(cm, sel) {
    updateActiveLines(cm, sel.ranges);
  }
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/codemirror.js":
/*!***************************************************!*\
  !*** ./scripts/3rdparty/codemirror/codemirror.js ***!
  \***************************************************/
/***/ (function(module) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
   true ? module.exports = factory() : 0;
})(this, function () {
  'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;
  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);
  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);
  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) {
    presto_version = Number(presto_version[1]);
  }
  if (presto_version && presto_version >= 15) {
    presto = false;
    webkit = true;
  }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || ie && ie_version >= 9;
  function classTest(cls) {
    return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
  }
  var rmClass = function (node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count) {
      e.removeChild(e.firstChild);
    }
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) {
      e.className = className;
    }
    if (style) {
      e.style.cssText = style;
    }
    if (typeof content == "string") {
      e.appendChild(document.createTextNode(content));
    } else if (content) {
      for (var i = 0; i < content.length; ++i) {
        e.appendChild(content[i]);
      }
    }
    return e;
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e;
  }
  var range;
  if (document.createRange) {
    range = function (node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r;
    };
  } else {
    range = function (node, start, end) {
      var r = document.body.createTextRange();
      try {
        r.moveToElementText(node.parentNode);
      } catch (e) {
        return r;
      }
      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r;
    };
  }
  function contains(parent, child) {
    if (child.nodeType == 3)
      // Android browser always returns false when child is a textnode
      {
        child = child.parentNode;
      }
    if (parent.contains) {
      return parent.contains(child);
    }
    do {
      if (child.nodeType == 11) {
        child = child.host;
      }
      if (child == parent) {
        return true;
      }
    } while (child = child.parentNode);
  }
  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch (e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
      activeElement = activeElement.shadowRoot.activeElement;
    }
    return activeElement;
  }
  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) {
      node.className += (current ? " " : "") + cls;
    }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++) {
      if (as[i] && !classTest(as[i]).test(b)) {
        b += " " + as[i];
      }
    }
    return b;
  }
  var selectInput = function (node) {
    node.select();
  };
  if (ios)
    // Mobile Safari apparently has a bug where select() is broken.
    {
      selectInput = function (node) {
        node.selectionStart = 0;
        node.selectionEnd = node.value.length;
      };
    } else if (ie)
    // Suppress mysterious IE10 errors
    {
      selectInput = function (node) {
        try {
          node.select();
        } catch (_e) {}
      };
    }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }
  function copyObj(obj, target, overwrite) {
    if (!target) {
      target = {};
    }
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
        target[prop] = obj[prop];
      }
    }
    return target;
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) {
        end = string.length;
      }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end) {
        return n + (end - i);
      }
      n += nextTab - i;
      n += tabSize - n % tabSize;
      i = nextTab + 1;
    }
  }
  var Delayed = function () {
    this.id = null;
  };
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };
  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i) {
      if (array[i] == elt) {
        return i;
      }
    }
    return -1;
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {
    toString: function () {
      return "CodeMirror.Pass";
    }
  };

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {
    scroll: false
  };
  var sel_mouse = {
    origin: "*mouse"
  };
  var sel_move = {
    origin: "+move"
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) {
        nextTab = string.length;
      }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal) {
        return pos + Math.min(skipped, goal - col);
      }
      col += nextTab - pos;
      col += tabSize - col % tabSize;
      pos = nextTab + 1;
      if (col >= goal) {
        return pos;
      }
    }
  }
  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n) {
      spaceStrs.push(lst(spaceStrs) + " ");
    }
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) {
      out[i] = f(array[i], i);
    }
    return out;
  }
  function insertSorted(array, value, score) {
    var pos = 0,
      priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) {
      pos++;
    }
    array.splice(pos, 0, value);
  }
  function nothing() {}
  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) {
      copyObj(props, inst);
    }
    return inst;
  }
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }
  function isWordChar(ch, helper) {
    if (!helper) {
      return isWordCharBasic(ch);
    }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
      return true;
    }
    return helper.test(ch);
  }
  function isEmpty(obj) {
    for (var n in obj) {
      if (obj.hasOwnProperty(n) && obj[n]) {
        return false;
      }
    }
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) {
    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
  }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
      pos += dir;
    }
    return pos;
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) {
        return from;
      }
      var midF = (from + to) / 2,
        mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) {
        return pred(mid) ? from : to;
      }
      if (pred(mid)) {
        to = mid;
      } else {
        from = mid + dir;
      }
    }
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    if (!webkit && !(gecko && mobile)) {
      d.scroller.draggable = true;
    }
    if (place) {
      if (place.appendChild) {
        place.appendChild(d.wrapper);
      } else {
        place(d.wrapper);
      }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;
    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;
    d.activeTouch = null;
    input.init(d);
  }

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) {
      throw new Error("There is no line " + (n + doc.first) + " in the document.");
    }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i],
          sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [],
      n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) {
        text = text.slice(0, end.ch);
      }
      if (n == start.line) {
        text = text.slice(start.ch);
      }
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    }); // iter aborts when callback returns truthy value
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) {
      for (var n = line; n; n = n.parent) {
        n.height += diff;
      }
    }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) {
      return null;
    }
    var cur = line.parent,
      no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) {
          break;
        }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1],
          ch = child.height;
        if (h < ch) {
          chunk = child;
          continue outer;
        }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i],
        lh = line.height;
      if (h < lh) {
        break;
      }
      h -= lh;
    }
    return n + i;
  }
  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }
  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if (sticky === void 0) sticky = null;
    if (!(this instanceof Pos)) {
      return new Pos(line, ch, sticky);
    }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }
  function equalCursorPos(a, b) {
    return a.sticky == b.sticky && cmp(a, b) == 0;
  }
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function maxPos(a, b) {
    return cmp(a, b) < 0 ? b : a;
  }
  function minPos(a, b) {
    return cmp(a, b) < 0 ? a : b;
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function clipPos(doc, pos) {
    if (pos.line < doc.first) {
      return Pos(doc.first, 0);
    }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) {
      return Pos(last, getLine(doc, last).text.length);
    }
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) {
      return Pos(pos.line, linelen);
    } else if (ch < 0) {
      return Pos(pos.line, 0);
    } else {
      return pos;
    }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) {
      out[i] = clipPos(doc, array[i]);
    }
    return out;
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false;
  var sawCollapsedSpans = false;
  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }
  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from;
    this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) {
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker) {
          return span;
        }
      }
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i] != span) {
        (r || (r = [])).push(spans[i]);
      }
    }
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
          marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
          marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
        }
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) {
      return null;
    }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) {
      return null;
    }
    var startCh = change.from.ch,
      endCh = change.to.ch,
      isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1,
      offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) {
            span.to = startCh;
          } else if (sameLine) {
            span.to = found.to == null ? null : found.to + offset;
          }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) {
          span$1.to += offset;
        }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        } else {
          span$1.from += offset;
          if (sameLine) {
            (first || (first = [])).push(span$1);
          }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) {
      first = clearEmptySpans(first);
    }
    if (last && last != first) {
      last = clearEmptySpans(last);
    }
    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2,
        gapMarkers;
      if (gap > 0 && first) {
        for (var i$2 = 0; i$2 < first.length; ++i$2) {
          if (first[i$2].to == null) {
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
          }
        }
      }
      for (var i$3 = 0; i$3 < gap; ++i$3) {
        newMarkers.push(gapMarkers);
      }
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
        spans.splice(i--, 1);
      }
    }
    if (!spans.length) {
      return null;
    }
    return spans;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
            (markers || (markers = [])).push(mark);
          }
        }
      }
    });
    if (!markers) {
      return null;
    }
    var parts = [{
      from: from,
      to: to
    }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i],
        m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
          continue;
        }
        var newParts = [j, 1],
          dfrom = cmp(p.from, m.from),
          dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
          newParts.push({
            from: p.from,
            to: m.from
          });
        }
        if (dto > 0 || !mk.inclusiveRight && !dto) {
          newParts.push({
            from: m.to,
            to: p.to
          });
        }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) {
      return;
    }
    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.detachLine(line);
    }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) {
      return;
    }
    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.attachLine(line);
    }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) {
    return marker.inclusiveLeft ? -1 : 0;
  }
  function extraRight(marker) {
    return marker.inclusiveRight ? 1 : 0;
  }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) {
      return lenDiff;
    }
    var aPos = a.find(),
      bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) {
      return -fromCmp;
    }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) {
      return toCmp;
    }
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans,
      found;
    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAtSide(line, true);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAtSide(line, false);
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (!sp.marker.collapsed) {
          continue;
        }
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
          continue;
        }
        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
          return true;
        }
      }
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line)) {
      line = merged.find(-1, true).line;
    }
    return line;
  }
  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN),
      vis = visualLine(line);
    if (line == vis) {
      return lineN;
    }
    return lineNo(vis);
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) {
      return lineN;
    }
    var line = getLine(doc, lineN),
      merged;
    if (!lineIsHidden(doc, line)) {
      return lineN;
    }
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed) {
          continue;
        }
        if (sp.from == null) {
          return true;
        }
        if (sp.marker.widgetNode) {
          continue;
        }
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
          return true;
        }
      }
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length) {
      return true;
    }
    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
        return true;
      }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);
    var h = 0,
      chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) {
        break;
      } else {
        h += line.height;
      }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) {
          break;
        } else {
          h += cur.height;
        }
      }
    }
    return h;
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) {
      return 0;
    }
    var len = line.text.length,
      merged,
      cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display,
      doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) {
      return f(from, to, "ltr", 0);
    }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) {
      f(from, to, "ltr");
    }
  }
  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) {
        return i;
      }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }
    }
    return found != null ? found : bidiOther;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = function () {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) {
        return lowTypes.charAt(code);
      } else if (0x590 <= code && code <= 0x5f4) {
        return "R";
      } else if (0x600 <= code && code <= 0x6f9) {
        return arabicTypes.charAt(code - 0x600);
      } else if (0x6ee <= code && code <= 0x8ac) {
        return "r";
      } else if (0x2000 <= code && code <= 0x200b) {
        return "w";
      } else if (code == 0x200c) {
        return "b";
      } else {
        return "L";
      }
    }
    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/,
      isStrong = /[LRr]/,
      countsAsLeft = /[Lb1n]/,
      countsAsNum = /[1n]/;
    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from;
      this.to = to;
    }
    return function (str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";
      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
        return false;
      }
      var len = str.length,
        types = [];
      for (var i = 0; i < len; ++i) {
        types.push(charType(str.charCodeAt(i)));
      }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") {
          types[i$1] = prev;
        } else {
          prev = type;
        }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") {
          types[i$2] = "n";
        } else if (isStrong.test(type$1)) {
          cur = type$1;
          if (type$1 == "r") {
            types[i$2] = "R";
          }
        }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
          types[i$3] = "1";
        } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
          types[i$3] = prev$1;
        }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") {
          types[i$4] = "N";
        } else if (type$3 == "%") {
          var end = void 0;
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
          for (var j = i$4; j < end; ++j) {
            types[j] = replace;
          }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") {
          types[i$5] = "L";
        } else if (isStrong.test(type$4)) {
          cur$1 = type$4;
        }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = void 0;
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? before ? "L" : "R" : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) {
            types[j$1] = replace$1;
          }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [],
        m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7,
            at = order.length;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) {
                order.splice(at, 0, new BidiSpan(1, pos, j$2));
              }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else {
              ++j$2;
            }
          }
          if (pos < i$7) {
            order.splice(at, 0, new BidiSpan(1, pos, i$7));
          }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }
      return direction == "rtl" ? order.reverse() : order;
    };
  }();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) {
      order = line.order = bidiOrdering(line.text, direction);
    }
    return order;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];
  var on = function (emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };
  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers;
  }
  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers,
        arr = map$$1 && map$$1[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1) {
          map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1));
        }
      }
    }
  }
  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) {
      handlers[i].apply(null, args);
    }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string") {
      e = {
        type: e,
        preventDefault: function () {
          this.defaultPrevented = true;
        }
      };
    }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }
  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) {
      return;
    }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) {
      if (indexOf(set, arr[i]) == -1) {
        set.push(arr[i]);
      }
    }
  }
  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function (type, f) {
      on(this, type, f);
    };
    ctor.prototype.off = function (type, f) {
      off(this, type, f);
    };
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) {
        b = 1;
      } else if (e.button & 2) {
        b = 3;
      } else if (e.button & 4) {
        b = 2;
      }
    }
    if (mac && e.ctrlKey && b == 1) {
      b = 3;
    }
    return b;
  }

  // Detect drag-and-drop
  var dragAndDrop = function () {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) {
      return false;
    }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0) {
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
      }
    }
    var node = zwspSupported ? elt("span", "\u200b") : elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) {
      return badBidiRects;
    }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) {
      return false;
    } // Safari returns null in some cases (#2780)
    return badBidiRects = r1.right - r0.right < 3;
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0,
      result = [],
      l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) {
        nl = string.length;
      }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function (string) {
    return string.split(/\r\n?|\n/);
  };
  var hasSelection = window.getSelection ? function (te) {
    try {
      return te.selectionStart != te.selectionEnd;
    } catch (e) {
      return false;
    }
  } : function (te) {
    var range$$1;
    try {
      range$$1 = te.ownerDocument.selection.createRange();
    } catch (e) {}
    if (!range$$1 || range$$1.parentElement() != te) {
      return false;
    }
    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0;
  };
  var hasCopyEvent = function () {
    var e = elt("div");
    if ("oncopy" in e) {
      return true;
    }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  }();
  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) {
      return badZoomedRects;
    }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // Known modes, by name and by MIME
  var modes = {};
  var mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2) {
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    }
    modes[name] = mode;
  }
  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") {
        found = {
          name: found
        };
      }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml");
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json");
    }
    if (typeof spec == "string") {
      return {
        name: spec
      };
    } else {
      return spec || {
        name: "null"
      };
    }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) {
      return getMode(options, "text/plain");
    }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) {
          continue;
        }
        if (modeObj.hasOwnProperty(prop)) {
          modeObj["_" + prop] = modeObj[prop];
        }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) {
      modeObj.helperType = spec.helperType;
    }
    if (spec.modeProps) {
      for (var prop$1 in spec.modeProps) {
        modeObj[prop$1] = spec.modeProps[prop$1];
      }
    }
    return modeObj;
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  }
  function copyState(mode, state) {
    if (state === true) {
      return state;
    }
    if (mode.copyState) {
      return mode.copyState(state);
    }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) {
        val = val.concat([]);
      }
      nstate[n] = val;
    }
    return nstate;
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) {
        break;
      }
      state = info.state;
      mode = info.mode;
    }
    return info || {
      mode: mode,
      state: state
    };
  }
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function (string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };
  StringStream.prototype.eol = function () {
    return this.pos >= this.string.length;
  };
  StringStream.prototype.sol = function () {
    return this.pos == this.lineStart;
  };
  StringStream.prototype.peek = function () {
    return this.string.charAt(this.pos) || undefined;
  };
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length) {
      return this.string.charAt(this.pos++);
    }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") {
      ok = ch == match;
    } else {
      ok = ch && (match.test ? match.test(ch) : match(ch));
    }
    if (ok) {
      ++this.pos;
      return ch;
    }
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)) {}
    return this.pos > start;
  };
  StringStream.prototype.eatSpace = function () {
    var this$1 = this;
    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
      ++this$1.pos;
    }
    return this.pos > start;
  };
  StringStream.prototype.skipToEnd = function () {
    this.pos = this.string.length;
  };
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {
      this.pos = found;
      return true;
    }
  };
  StringStream.prototype.backUp = function (n) {
    this.pos -= n;
  };
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) {
        return caseInsensitive ? str.toLowerCase() : str;
      };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) {
          this.pos += pattern.length;
        }
        return true;
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) {
        return null;
      }
      if (match && consume !== false) {
        this.pos += match[0].length;
      }
      return match;
    }
  };
  StringStream.prototype.current = function () {
    return this.string.slice(this.start, this.pos);
  };
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try {
      return inner();
    } finally {
      this.lineStart -= n;
    }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n);
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos);
  };
  var SavedContext = function (state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };
  var Context = function (doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };
  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) {
      this.maxLookAhead = n;
    }
    return line;
  };
  Context.prototype.baseToken = function (n) {
    var this$1 = this;
    if (!this.baseTokens) {
      return null;
    }
    while (this.baseTokens[this.baseTokenPos] <= n) {
      this$1.baseTokenPos += 2;
    }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: type && type.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - n
    };
  };
  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) {
      this.maxLookAhead--;
    }
  };
  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext) {
      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
    } else {
      return new Context(doc, copyState(doc.mode, saved), line);
    }
  };
  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
  };

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen],
      lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) {
      return st.push(end, style);
    }, lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function (o) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o],
        i = 1,
        at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end) {
            st.splice(i, 1, end, st[i + 1], i_end);
          }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) {
          return;
        }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };
    for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);
    return {
      styles: st,
      classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
    };
  }
  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) {
        context.state = resetState;
      }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) {
        line.styleClasses = result.classes;
      } else if (line.styleClasses) {
        line.styleClasses = null;
      }
      if (updateFrontier === cm.doc.highlightFrontier) {
        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
      }
    }
    return line.styles;
  }
  function getContextBefore(cm, n, precise) {
    var doc = cm.doc,
      display = cm.display;
    if (!doc.mode.startState) {
      return new Context(doc, true, n);
    }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) {
      doc.modeFrontier = context.line;
    }
    return context;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") {
      callBlankLine(mode, context.state);
    }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }
  function callBlankLine(mode, state) {
    if (mode.blankLine) {
      return mode.blankLine(state);
    }
    if (!mode.innerMode) {
      return;
    }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) {
      return inner.mode.blankLine(inner.state);
    }
  }
  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) {
        inner[0] = innerMode(mode, state).mode;
      }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) {
        return style;
      }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }
  var Token = function (stream, type, state) {
    this.start = stream.start;
    this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc,
      mode = doc.mode,
      style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line),
      context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context),
      tokens;
    if (asArray) {
      tokens = [];
    }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) {
        tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
      }
    }
    return asArray ? tokens : new Token(stream, style, context.state);
  }
  function extractLineClasses(type, output) {
    if (type) {
      for (;;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
        if (!lineClass) {
          break;
        }
        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? "bgClass" : "textClass";
        if (output[prop] == null) {
          output[prop] = lineClass[2];
        } else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(output[prop])) {
          output[prop] += " " + lineClass[2];
        }
      }
    }
    return type;
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) {
      flattenSpans = cm.options.flattenSpans;
    }
    var curStart = 0,
      curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context),
      style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") {
      extractLineClasses(callBlankLine(mode, context.state), lineClasses);
    }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) {
          processLine(cm, text, context, stream.pos);
        }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) {
          style = "m-" + (style ? mName + " " + style : mName);
        }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent,
      minline,
      doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) {
        return doc.first;
      }
      var line = getLine(doc, search - 1),
        after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
        return search;
      }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) {
      return;
    }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break;
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function (text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  Line.prototype.lineNo = function () {
    return lineNo(this);
  };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    if (line.styles) {
      line.styles = null;
    }
    if (line.order != null) {
      line.order = null;
    }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) {
      updateLineHeight(line, estHeight);
    }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {};
  var styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) {
      return null;
    }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {
      pre: eltP("pre", [content], "CodeMirror-line"),
      content: content,
      col: 0,
      pos: 0,
      cm: cm,
      trailingSpace: false,
      splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
    };
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line,
        order = void 0;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass) {
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        }
        if (line.styleClasses.textClass) {
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
        }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0) {
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
      }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
        builder.content.className = "cm-tab-wrap-hack";
      }
    }
    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className) {
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
    }
    return builder;
  }
  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) {
      return;
    }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars,
      mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) {
        mustWrap = true;
      }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt]));
          } else {
            content.appendChild(txt);
          }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) {
          break;
        }
        pos += skipped + 1;
        var txt$1 = void 0;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize,
            tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt$1]));
          } else {
            content.appendChild(txt$1);
          }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) {
        fullStyle += startStyle;
      }
      if (endStyle) {
        fullStyle += endStyle;
      }
      var token = elt("span", [content], fullStyle, css);
      if (title) {
        token.title = title;
      }
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) {
      return text;
    }
    var spaceBefore = trailingBefore,
      result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
        ch = "\u00a0";
      }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos,
        end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = void 0;
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) {
            break;
          }
        }
        if (part.to >= end) {
          return inner(builder, text, style, startStyle, endStyle, title, css);
        }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }
  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
    }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget) {
        widget = builder.content.appendChild(document.createElement("span"));
      }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans,
      allText = line.text,
      at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
        builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
      }
      return;
    }
    var len = allText.length,
      pos = 0,
      i = 1,
      text = "",
      style,
      css;
    var nextChange = 0,
      spanStyle,
      spanEndStyle,
      spanStartStyle,
      title,
      collapsed;
    for (;;) {
      if (nextChange == pos) {
        // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null;
        nextChange = Infinity;
        var foundBookmarks = [],
          endStyles = void 0;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j],
            m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) {
              spanStyle += " " + m.className;
            }
            if (m.css) {
              css = (css ? css + ";" : "") + m.css;
            }
            if (m.startStyle && sp.from == pos) {
              spanStartStyle += " " + m.startStyle;
            }
            if (m.endStyle && sp.to == nextChange) {
              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
            }
            if (m.title && !title) {
              title = m.title;
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
              collapsed = sp;
            }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) {
          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
            if (endStyles[j$1 + 1] == nextChange) {
              spanEndStyle += " " + endStyles[j$1];
            }
          }
        }
        if (!collapsed || collapsed.from == pos) {
          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
            buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
          }
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) {
            return;
          }
          if (collapsed.to == pos) {
            collapsed = false;
          }
        }
      }
      if (pos >= len) {
        break;
      }
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [],
      nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }
  var operationGroup = null;
  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }
  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks,
      i = 0;
    do {
      for (; i < callbacks.length; i++) {
        callbacks[i].call(null);
      }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers) {
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        }
      }
    } while (i < callbacks.length);
  }
  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) {
      return;
    }
    try {
      fireCallbacksForOps(group);
    } finally {
      operationGroup = null;
      endCb(group);
    }
  }
  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2),
      list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function (i) {
      list.push(function () {
        return arr[i].apply(null, args);
      });
    };
    for (var i = 0; i < arr.length; ++i) loop(i);
  }
  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) {
      delayed[i]();
    }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") {
        updateLineText(cm, lineView);
      } else if (type == "gutter") {
        updateLineGutter(cm, lineView, lineN, dims);
      } else if (type == "class") {
        updateLineClasses(cm, lineView);
      } else if (type == "widget") {
        updateLineWidgets(cm, lineView, dims);
      }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode) {
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) {
        lineView.node.style.zIndex = 2;
      }
    }
    return lineView.node;
  }
  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) {
      cls += " CodeMirror-linebackground";
    }
    if (lineView.background) {
      if (cls) {
        lineView.background.className = cls;
      } else {
        lineView.background.parentNode.removeChild(lineView.background);
        lineView.background = null;
      }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) {
      lineView.node = built.pre;
    }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }
  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass) {
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    } else if (lineView.node != lineView.text) {
      lineView.node.className = "";
    }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }
  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass) {
        gutterWrap.className += " " + lineView.line.gutterClass;
      }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
        lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
      }
      if (markers) {
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k],
            found = markers.hasOwnProperty(id) && markers[id];
          if (found) {
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
          }
        }
      }
    }
  }
  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) {
      lineView.alignable = null;
    }
    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
      next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget") {
        lineView.node.removeChild(node);
      }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) {
      lineView.bgClass = built.bgClass;
    }
    if (built.textClass) {
      lineView.textClass = built.textClass;
    }
    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++) {
        insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
      }
    }
  }
  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) {
      return;
    }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i],
        node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) {
        node.setAttribute("cm-ignore-events", "true");
      }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above) {
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      } else {
        wrap.appendChild(node);
      }
      signalLater(widget, "redraw");
    }
  }
  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) {
        node.style.marginLeft = -dims.gutterTotalWidth + "px";
      }
    }
  }
  function widgetHeight(widget) {
    if (widget.height != null) {
      return widget.height;
    }
    var cm = widget.doc.cm;
    if (!cm) {
      return 0;
    }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter) {
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      }
      if (widget.noHScroll) {
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
        return true;
      }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingH(display) {
    if (display.cachedPaddingH) {
      return display.cachedPaddingH;
    }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {
      left: parseInt(style.paddingLeft),
      right: parseInt(style.paddingRight)
    };
    if (!isNaN(data.left) && !isNaN(data.right)) {
      display.cachedPaddingH = data;
    }
    return data;
  }
  function scrollGap(cm) {
    return scrollerGap - cm.display.nativeBarWidth;
  }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i],
            next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2) {
            heights.push((cur.bottom + next.top) / 2 - rect.top);
          }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line) {
      return {
        map: lineView.measure.map,
        cache: lineView.measure.cache
      };
    }
    for (var i = 0; i < lineView.rest.length; i++) {
      if (lineView.rest[i] == line) {
        return {
          map: lineView.measure.maps[i],
          cache: lineView.measure.caches[i]
        };
      }
    }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
      if (lineNo(lineView.rest[i$1]) > lineN) {
        return {
          map: lineView.measure.maps[i$1],
          cache: lineView.measure.caches[i$1],
          before: true
        };
      }
    }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
      return cm.display.view[findViewIndex(cm, lineN)];
    }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
      return ext;
    }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view) {
      view = updateExternalMeasurement(cm, line);
    }
    var info = mapFromLineView(view, line, lineN);
    return {
      line: line,
      view: view,
      rect: null,
      map: info.map,
      cache: info.cache,
      before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) {
      ch = -1;
    }
    var key = ch + (bias || ""),
      found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect) {
        prepared.rect = prepared.view.text.getBoundingClientRect();
      }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) {
        prepared.cache[key] = found;
      }
    }
    return {
      left: found.left,
      right: found.right,
      top: varHeight ? found.rtop : found.top,
      bottom: varHeight ? found.rbottom : found.bottom
    };
  }
  var nullRect = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];
      if (ch < mStart) {
        start = 0;
        end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) {
          collapse = "right";
        }
      }
      if (start != null) {
        node = map$$1[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
          collapse = bias;
        }
        if (bias == "left" && start == 0) {
          while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          }
        }
        if (bias == "right" && start == mEnd - mStart) {
          while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          }
        }
        break;
      }
    }
    return {
      node: node,
      start: start,
      end: end,
      collapse: collapse,
      coverStart: mStart,
      coverEnd: mEnd
    };
  }
  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") {
      for (var i = 0; i < rects.length; i++) {
        if ((rect = rects[i]).left != rect.right) {
          break;
        }
      }
    } else {
      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
        if ((rect = rects[i$1]).left != rect.right) {
          break;
        }
      }
    }
    return rect;
  }
  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node,
      start = place.start,
      end = place.end,
      collapse = place.collapse;
    var rect;
    if (node.nodeType == 3) {
      // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) {
        // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
          --start;
        }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
          ++end;
        }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else {
          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
        }
        if (rect.left || rect.right || start == 0) {
          break;
        }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) {
        rect = maybeUpdateRectForZooming(cm.display.measure, rect);
      }
    } else {
      // If it is a widget, simply get the box for the whole widget.
      if (start > 0) {
        collapse = bias = "right";
      }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      } else {
        rect = node.getBoundingClientRect();
      }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan) {
        rect = {
          left: rSpan.left,
          right: rSpan.left + charWidth(cm.display),
          top: rSpan.top,
          bottom: rSpan.bottom
        };
      } else {
        rect = nullRect;
      }
    }
    var rtop = rect.top - prepared.rect.top,
      rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++) {
      if (mid < heights[i]) {
        break;
      }
    }
    var top = i ? heights[i - 1] : 0,
      bot = heights[i];
    var result = {
      left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
      top: top,
      bottom: bot
    };
    if (!rect.left && !rect.right) {
      result.bogus = true;
    }
    if (!cm.options.singleCursorHeightPerLine) {
      result.rtop = rtop;
      result.rbottom = rbot;
    }
    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
      return rect;
    }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {
      left: rect.left * scaleX,
      right: rect.right * scaleX,
      top: rect.top * scaleY,
      bottom: rect.bottom * scaleY
    };
  }
  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) {
        for (var i = 0; i < lineView.rest.length; i++) {
          lineView.measure.caches[i] = {};
        }
      }
    }
  }
  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++) {
      clearLineMeasurementCacheFor(cm.display.view[i]);
    }
  }
  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) {
      cm.display.maxLineChanged = true;
    }
    cm.display.lineNumChars = null;
  }
  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
    }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
  }
  function pageScrollY() {
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
    }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop;
  }
  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) {
      for (var i = 0; i < lineObj.widgets.length; ++i) {
        if (lineObj.widgets[i].above) {
          height += widgetHeight(lineObj.widgets[i]);
        }
      }
    }
    return height;
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height;
      rect.bottom += height;
    }
    if (context == "line") {
      return rect;
    }
    if (!context) {
      context = "local";
    }
    var yOff = heightAtLine(lineObj);
    if (context == "local") {
      yOff += paddingTop(cm.display);
    } else {
      yOff -= cm.display.viewOffset;
    }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") {
      return coords;
    }
    var left = coords.left,
      top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }
    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {
      left: left - lineSpaceBox.left,
      top: top - lineSpaceBox.top
    };
  }
  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) {
      lineObj = getLine(cm.doc, pos.line);
    }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) {
        m.left = m.right;
      } else {
        m.right = m.left;
      }
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj, cm.doc.direction),
      ch = pos.ch,
      sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) {
      return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
    }
    function getBidi(ch, partPos, invert) {
      var part = order[partPos],
        right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert);
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) {
      val.other = getBidi(ch, other, sticky != "before");
    }
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) {
      left = charWidth(cm.display) * pos.ch;
    }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {
      left: left,
      right: left,
      top: top,
      bottom: top + lineObj.height
    };
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) {
      pos.outside = true;
    }
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) {
      return PosWithInfo(doc.first, 0, null, true, -1);
    }
    var lineN = lineAtHeight(doc, y),
      last = doc.first + doc.size - 1;
    if (lineN > last) {
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1);
    }
    if (x < 0) {
      x = 0;
    }
    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) {
        lineN = lineNo(lineObj = mergedPos.to.line);
      } else {
        return found;
      }
    }
  }
  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
    }, end, 0);
    end = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch).top > y;
    }, begin, end);
    return {
      begin: begin,
      end: end
    };
  }
  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
  }
  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight$$1 = widgetTopHeight(lineObj);
    var begin = 0,
      end = lineObj.text.length,
      ltr = true;
    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null,
      boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight$$1;
      box.bottom += widgetHeight$$1;
      if (!boxIsAfter(box, x, y, false)) {
        return false;
      }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true;
    }, begin, end);
    var baseX,
      sticky,
      outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x,
        atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) {
        ch++;
      }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y == ltr ? "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top || y >= coords.bottom;
    }
    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX);
  }
  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i],
        ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y) {
        part = order[index - 1];
      }
    }
    return part;
  }
  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) {
      end--;
    }
    var part = null,
      closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) {
        continue;
      }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) {
      part = order[order.length - 1];
    }
    // Clip the part to the wrapped line.
    if (part.from < begin) {
      part = {
        from: begin,
        to: part.to,
        level: part.level
      };
    }
    if (part.to > end) {
      part = {
        from: part.from,
        to: end,
        level: part.level
      };
    }
    return part;
  }
  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) {
      return display.cachedTextHeight;
    }
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) {
      display.cachedTextHeight = height;
    }
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) {
      return display.cachedCharWidth;
    }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(),
      width = (rect.right - rect.left) / 10;
    if (width > 2) {
      display.cachedCharWidth = width;
    }
    return width || 10;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display,
      left = {},
      width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display),
      wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) {
        return 0;
      }
      var widgetsHeight = 0;
      if (line.widgets) {
        for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height) {
            widgetsHeight += line.widgets[i].height;
          }
        }
      }
      if (wrapping) {
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      } else {
        return widgetsHeight + th;
      }
    };
  }
  function estimateLineHeights(cm) {
    var doc = cm.doc,
      est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
      return null;
    }
    var x,
      y,
      space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try {
      x = e.clientX - space.left;
      y = e.clientY - space.top;
    } catch (e) {
      return null;
    }
    var coords = coordsChar(cm, x, y),
      line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) {
      return null;
    }
    n -= cm.display.viewFrom;
    if (n < 0) {
      return null;
    }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) {
        return i;
      }
    }
  }
  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }
  function prepareSelection(cm, primary) {
    if (primary === void 0) primary = true;
    var doc = cm.doc,
      result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) {
        continue;
      }
      var range$$1 = doc.sel.ranges[i];
      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) {
        continue;
      }
      var collapsed = range$$1.empty();
      if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range$$1.head, curFragment);
      }
      if (!collapsed) {
        drawSelectionRange(cm, range$$1, selFragment);
      }
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }
  function cmpCoords(a, b) {
    return a.top - b.top || a.left - b.left;
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display,
      doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display),
      leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";
    function add(left, top, width, bottom) {
      if (top < 0) {
        top = 0;
      }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
    }
    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }
      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = dir == "ltr" == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop];
      }
      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");
        var openStart = fromArg == null && from == 0,
          openEnd = toArg == null && to == lineLen;
        var first = i == 0,
          last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) {
          // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else {
          // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) {
            add(leftSide, fromPos.bottom, null, toPos.top);
          }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }
        if (!start || cmpCoords(fromPos, start) < 0) {
          start = fromPos;
        }
        if (cmpCoords(toPos, start) < 0) {
          start = toPos;
        }
        if (!end || cmpCoords(fromPos, end) < 0) {
          end = fromPos;
        }
        if (cmpCoords(toPos, end) < 0) {
          end = toPos;
        }
      });
      return {
        start: start,
        end: end
      };
    }
    var sFrom = range$$1.from(),
      sTo = range$$1.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line),
        toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top) {
        add(leftSide, leftEnd.bottom, null, rightStart.top);
      }
    }
    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) {
      return;
    }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0) {
      display.blinker = setInterval(function () {
        return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    } else if (cm.options.cursorBlinkRate < 0) {
      display.cursorDiv.style.visibility = "hidden";
    }
  }
  function ensureFocus(cm) {
    if (!cm.state.focused) {
      cm.display.input.focus();
      onFocus(cm);
    }
  }
  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }
  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
    }
    if (cm.options.readOnly == "nocursor") {
      return;
    }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) {
          setTimeout(function () {
            return cm.display.input.reset(true);
          }, 20);
        } // Issue #1730
      }

      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) {
      return;
    }
    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused) {
        cm.display.shift = false;
      }
    }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i],
        height = void 0;
      if (cur.hidden) {
        continue;
      }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) {
        height = textHeight(display);
      }
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) {
          for (var j = 0; j < cur.rest.length; j++) {
            updateWidgetHeight(cur.rest[j]);
          }
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) {
      for (var i = 0; i < line.widgets.length; ++i) {
        var w = line.widgets[i],
          parent = w.node.parentNode;
        if (parent) {
          w.height = parent.offsetHeight;
        }
      }
    }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
    var from = lineAtHeight(doc, top),
      to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line,
        ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {
      from: from,
      to: Math.max(to, from + 1)
    };
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display,
      view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
      return;
    }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth,
      left = comp + "px";
    for (var i = 0; i < view.length; i++) {
      if (!view[i].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i].gutter) {
            view[i].gutter.style.left = left;
          }
          if (view[i].gutterBackground) {
            view[i].gutterBackground.style.left = left;
          }
        }
        var align = view[i].alignable;
        if (align) {
          for (var j = 0; j < align.length; j++) {
            align[j].style.left = left;
          }
        }
      }
    }
    if (cm.options.fixedGutter) {
      display.gutters.style.left = comp + gutterW + "px";
    }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) {
      return false;
    }
    var doc = cm.doc,
      last = lineNumberFor(cm.options, doc.first + doc.size - 1),
      display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth,
        padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) {
      return;
    }
    var display = cm.display,
      box = display.sizer.getBoundingClientRect(),
      doScroll = null;
    if (rect.top + box.top < 0) {
      doScroll = true;
    } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
      doScroll = false;
    }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) {
      margin = 0;
    }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {
        left: Math.min(coords.left, endCoords.left),
        top: Math.min(coords.top, endCoords.top) - margin,
        right: Math.max(coords.left, endCoords.left),
        bottom: Math.max(coords.bottom, endCoords.bottom) + margin
      };
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop,
        startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
          changed = true;
        }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
          changed = true;
        }
      }
      if (!changed) {
        break;
      }
    }
    return rect;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
    }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display,
      snapMargin = textHeight(cm.display);
    if (rect.top < 0) {
      rect.top = 0;
    }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm),
      result = {};
    if (rect.bottom - rect.top > screen) {
      rect.bottom = rect.top + screen;
    }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin,
      atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) {
        result.scrollTop = newTop;
      }
    }
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) {
      rect.right = rect.left + screenw;
    }
    if (rect.left < 10) {
      result.scrollLeft = 0;
    } else if (rect.left < screenleft) {
      result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10));
    } else if (rect.right > screenw + screenleft - 3) {
      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
    }
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) {
      return;
    }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {
      from: cur,
      to: cur,
      margin: cm.options.cursorScrollMargin
    };
  }
  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) {
      resolveScrollToPos(cm);
    }
    if (x != null) {
      cm.curOp.scrollLeft = x;
    }
    if (y != null) {
      cm.curOp.scrollTop = y;
    }
  }
  function scrollToRange(cm, range$$1) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range$$1;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;
    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from),
        to = estimateCoords(cm, range$$1.to);
      scrollToCoordsRange(cm, from, to, range$$1.margin);
    }
  }
  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) {
      return;
    }
    if (!gecko) {
      updateDisplaySimple(cm, {
        top: val
      });
    }
    setScrollTop(cm, val, true);
    if (gecko) {
      updateDisplaySimple(cm);
    }
    startWorker(cm, 100);
  }
  function setScrollTop(cm, val, forceScroll) {
    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
    if (cm.display.scroller.scrollTop == val && !forceScroll) {
      return;
    }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) {
      cm.display.scroller.scrollTop = val;
    }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
      return;
    }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) {
      cm.display.scroller.scrollLeft = val;
    }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display,
      gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth,
      clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }
  var NativeScrollbars = function (place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert);
    place(horiz);
    on(vert, "scroll", function () {
      if (vert.clientHeight) {
        scroll(vert.scrollTop, "vertical");
      }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) {
        scroll(horiz.scrollLeft, "horizontal");
      }
    });
    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) {
      this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
    }
  };
  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;
    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }
    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }
    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) {
        this.zeroWidthHack();
      }
      this.checkedZeroWidth = true;
    }
    return {
      right: needsV ? sWidth : 0,
      bottom: needsH ? sWidth : 0
    };
  };
  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) {
      this.horiz.scrollLeft = pos;
    }
    if (this.disableHoriz) {
      this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
    }
  };
  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) {
      this.vert.scrollTop = pos;
    }
    if (this.disableVert) {
      this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
    }
  };
  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed();
    this.disableVert = new Delayed();
  };
  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt$$1 != bar) {
        bar.style.pointerEvents = "none";
      } else {
        delay.set(1000, maybeDisable);
      }
    }
    delay.set(1000, maybeDisable);
  };
  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };
  var NullScrollbars = function () {};
  NullScrollbars.prototype.update = function () {
    return {
      bottom: 0,
      right: 0
    };
  };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};
  function updateScrollbars(cm, measure) {
    if (!measure) {
      measure = measureForScrollbars(cm);
    }
    var startWidth = cm.display.barWidth,
      startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
        updateHeightsInViewport(cm);
      }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth;
      startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);
    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else {
      d.scrollbarFiller.style.display = "";
    }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else {
      d.gutterFiller.style.display = "";
    }
  }
  var scrollbarModel = {
    "native": NativeScrollbars,
    "null": NullScrollbars
  };
  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass) {
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }
    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) {
          setTimeout(function () {
            return cm.display.input.focus();
          }, 0);
        }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") {
        setScrollLeft(cm, pos);
      } else {
        updateScrollTop(cm, pos);
      }
    }, cm);
    if (cm.display.scrollbars.addClass) {
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,
      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height,
      // Used to detect need to update scrollbar
      forceUpdate: false,
      // Used to force a redraw
      updateInput: null,
      // Whether to reset the input textarea
      typing: false,
      // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,
      // Accumulated changes, for firing change events
      cursorActivityHandlers: null,
      // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0,
      // Tracks which cursorActivity handlers have been called already
      selectionChanged: false,
      // Whether the selection needs to be redrawn
      updateMaxLine: false,
      // Set when the widest line needs to be determined anew
      scrollLeft: null,
      scrollTop: null,
      // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,
      // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId // Unique ID
    };

    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++) {
        group.ops[i].cm.curOp = null;
      }
      endOperations(group);
    });
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++)
    // Read DOM
    {
      endOperation_R1(ops[i]);
    }
    for (var i$1 = 0; i$1 < ops.length; i$1++)
    // Write DOM (maybe)
    {
      endOperation_W1(ops[i$1]);
    }
    for (var i$2 = 0; i$2 < ops.length; i$2++)
    // Read DOM
    {
      endOperation_R2(ops[i$2]);
    }
    for (var i$3 = 0; i$3 < ops.length; i$3++)
    // Write DOM (maybe)
    {
      endOperation_W2(ops[i$3]);
    }
    for (var i$4 = 0; i$4 < ops.length; i$4++)
    // Read DOM
    {
      endOperation_finish(ops[i$4]);
    }
  }
  function endOperation_R1(op) {
    var cm = op.cm,
      display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) {
      findMaxLine(cm);
    }
    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
      top: op.scrollTop,
      ensure: op.scrollToPos
    }, op.forceUpdate);
  }
  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }
  function endOperation_R2(op) {
    var cm = op.cm,
      display = cm.display;
    if (op.updatedDisplay) {
      updateHeightsInViewport(cm);
    }
    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }
    if (op.updatedDisplay || op.selectionChanged) {
      op.preparedSelection = display.input.prepareSelection();
    }
  }
  function endOperation_W2(op) {
    var cm = op.cm;
    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft) {
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      }
      cm.display.maxLineChanged = false;
    }
    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection) {
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    }
    if (op.updatedDisplay || op.startHeight != cm.doc.height) {
      updateScrollbars(cm, op.barMeasure);
    }
    if (op.updatedDisplay) {
      setDocumentHeight(cm, op.barMeasure);
    }
    if (op.selectionChanged) {
      restartBlink(cm);
    }
    if (cm.state.focused && op.updateInput) {
      cm.display.input.reset(op.typing);
    }
    if (takeFocus) {
      ensureFocus(op.cm);
    }
  }
  function endOperation_finish(op) {
    var cm = op.cm,
      display = cm.display,
      doc = cm.doc;
    if (op.updatedDisplay) {
      postUpdateDisplay(cm, op.update);
    }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
      display.wheelStartX = display.wheelStartY = null;
    }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) {
      setScrollTop(cm, op.scrollTop, op.forceScroll);
    }
    if (op.scrollLeft != null) {
      setScrollLeft(cm, op.scrollLeft, true, true);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers,
      unhidden = op.maybeUnhiddenMarkers;
    if (hidden) {
      for (var i = 0; i < hidden.length; ++i) {
        if (!hidden[i].lines.length) {
          signal(hidden[i], "hide");
        }
      }
    }
    if (unhidden) {
      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
        if (unhidden[i$1].lines.length) {
          signal(unhidden[i$1], "unhide");
        }
      }
    }
    if (display.wrapper.offsetHeight) {
      doc.scrollTop = cm.display.scroller.scrollTop;
    }

    // Fire change events, and delayed event handlers
    if (op.changeObjs) {
      signal(cm, "changes", cm, op.changeObjs);
    }
    if (op.update) {
      op.update.finish();
    }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) {
      return f();
    }
    startOperation(cm);
    try {
      return f();
    } finally {
      endOperation(cm);
    }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function () {
      if (cm.curOp) {
        return f.apply(cm, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(cm, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function () {
      if (this.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(this);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(this);
      }
    };
  }
  function docMethodOp(f) {
    return function () {
      var cm = this.cm;
      if (!cm || cm.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) {
      from = cm.doc.first;
    }
    if (to == null) {
      to = cm.doc.first + cm.doc.size;
    }
    if (!lendiff) {
      lendiff = 0;
    }
    var display = cm.display;
    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
      display.updateLineNumbers = from;
    }
    cm.curOp.viewChanged = true;
    if (from >= display.viewTo) {
      // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
        resetView(cm);
      }
    } else if (to <= display.viewFrom) {
      // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) {
      // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) {
      // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) {
      // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else {
      // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }
    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN) {
        ext.lineN += lendiff;
      } else if (from < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display,
      ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
      display.externalMeasured = null;
    }
    if (line < display.viewFrom || line >= display.viewTo) {
      return;
    }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) {
      return;
    }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) {
      arr.push(type);
    }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }
  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN),
      diff,
      view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
      return {
        index: index,
        lineN: newN
      };
    }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++) {
      n += view[i].size;
    }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) {
          return null;
        }
        diff = n + view[index].size - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff;
      newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) {
        return null;
      }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {
      index: index,
      lineN: newN
    };
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display,
      view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from) {
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      } else if (display.viewFrom < from) {
        display.view = display.view.slice(findViewIndex(cm, from));
      }
      display.viewFrom = from;
      if (display.viewTo < to) {
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      } else if (display.viewTo > to) {
        display.view = display.view.slice(0, findViewIndex(cm, to));
      }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view,
      dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) {
        ++dirty;
      }
    }
    return dirty;
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo) {
      cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
  }
  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) {
      return;
    }
    var end = +new Date() + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];
    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) {
        // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) {
          context.state = resetState;
        }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses,
          newCls = highlighted.classes;
        if (newCls) {
          line.styleClasses = newCls;
        } else if (oldCls) {
          line.styleClasses = null;
        }
        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) {
          ischange = oldStyles[i] != line.styles[i];
        }
        if (ischange) {
          changedLines.push(context.line);
        }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength) {
          processLine(cm, line.text, context);
        }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) {
      runInOp(cm, function () {
        for (var i = 0; i < changedLines.length; i++) {
          regLineChange(cm, changedLines[i], "text");
        }
      });
    }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function (cm, viewport, force) {
    var display = cm.display;
    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };
  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type)) {
      this.events.push(arguments);
    }
  };
  DisplayUpdate.prototype.finish = function () {
    var this$1 = this;
    for (var i = 0; i < this.events.length; i++) {
      signal.apply(null, this$1.events[i]);
    }
  };
  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }
  function selectionSnapshot(cm) {
    if (cm.hasFocus()) {
      return null;
    }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) {
      return null;
    }
    var result = {
      activeElt: active
    };
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result;
  }
  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
      return;
    }
    snapshot.activeElt.focus();
    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(),
        range$$1 = document.createRange();
      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range$$1.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range$$1);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display,
      doc = cm.doc;
    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
      return false;
    }
    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) {
      from = Math.max(doc.first, display.viewFrom);
    }
    if (display.viewTo > to && display.viewTo - to < 20) {
      to = Math.min(end, display.viewTo);
    }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }
    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);
    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";
    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
      return false;
    }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "none";
    }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "";
    }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;
    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }
    display.updateLineNumbers = null;
    return true;
  }
  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;
    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null) {
          viewport = {
            top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
          };
        }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
          break;
        }
      }
      if (!updateDisplayIfNeeded(cm, update)) {
        break;
      }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }
    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom;
      cm.display.reportedViewTo = cm.display.viewTo;
    }
  }
  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display,
      lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv,
      cur = container.firstChild;
    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }
    var view = display.view,
      lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {} else if (!lineView.node || lineView.node.parentNode != container) {
        // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else {
        // Already drawn
        while (cur != lineView.node) {
          cur = rm(cur);
        }
        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) {
            updateNumber = false;
          }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) {
      cur = rm(cur);
    }
  }
  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }
  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters,
      specs = cm.options.gutters;
    removeChildren(gutters);
    var i = 0;
    for (; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0;
  var wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) {
    wheelPixelsPerUnit = -.53;
  } else if (gecko) {
    wheelPixelsPerUnit = 15;
  } else if (chrome) {
    wheelPixelsPerUnit = -.7;
  } else if (safari) {
    wheelPixelsPerUnit = -1 / 3;
  }
  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX,
      dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
      dx = e.detail;
    }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
      dy = e.detail;
    } else if (dy == null) {
      dy = e.wheelDelta;
    }
    return {
      x: dx,
      y: dy
    };
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  }
  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e),
      dx = delta.x,
      dy = delta.y;
    var display = cm.display,
      scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) {
      return;
    }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY) {
        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
      }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || dy && canScrollY) {
        e_preventDefault(e);
      }
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop,
        bot = top + display.wrapper.clientHeight;
      if (pixels < 0) {
        top = Math.max(0, top + pixels - 50);
      } else {
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      }
      updateDisplaySimple(cm, {
        top: top,
        bottom: bot
      });
    }
    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) {
            return;
          }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) {
            return;
          }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function (ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };
  Selection.prototype.primary = function () {
    return this.ranges[this.primIndex];
  };
  Selection.prototype.equals = function (other) {
    var this$1 = this;
    if (other == this) {
      return true;
    }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
      return false;
    }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this$1.ranges[i],
        there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
        return false;
      }
    }
    return true;
  };
  Selection.prototype.deepCopy = function () {
    var this$1 = this;
    var out = [];
    for (var i = 0; i < this.ranges.length; i++) {
      out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
    }
    return new Selection(out, this.primIndex);
  };
  Selection.prototype.somethingSelected = function () {
    var this$1 = this;
    for (var i = 0; i < this.ranges.length; i++) {
      if (!this$1.ranges[i].empty()) {
        return true;
      }
    }
    return false;
  };
  Selection.prototype.contains = function (pos, end) {
    var this$1 = this;
    if (!end) {
      end = pos;
    }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this$1.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
        return i;
      }
    }
    return -1;
  };
  var Range = function (anchor, head) {
    this.anchor = anchor;
    this.head = head;
  };
  Range.prototype.from = function () {
    return minPos(this.anchor, this.head);
  };
  Range.prototype.to = function () {
    return maxPos(this.anchor, this.head);
  };
  Range.prototype.empty = function () {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) {
      return cmp(a.from(), b.from());
    });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i],
        prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()),
          to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) {
          --primIndex;
        }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }
  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) {
      return change.to;
    }
    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) {
      return pos;
    }
    if (cmp(pos, change.to) <= 0) {
      return changeEnd(change);
    }
    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
      ch = pos.ch;
    if (pos.line == change.to.line) {
      ch += changeEnd(change).ch - change.to.ch;
    }
    return Pos(line, ch);
  }
  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }
  function offsetPos(pos, old, nw) {
    if (pos.line == old.line) {
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    } else {
      return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0),
      newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i],
          inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }
  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) {
      regChange(cm);
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i) {
        result.push(new Line(text[i], spansFor(i), estimateHeight$$1));
      }
      return result;
    }
    var from = change.from,
      to = change.to,
      text = change.text;
    var firstLine = getLine(doc, from.line),
      lastLine = getLine(doc, to.line);
    var lastText = lst(text),
      lastSpans = spansFor(text.length - 1),
      nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) {
        doc.remove(from.line, nlines);
      }
      if (added.length) {
        doc.insert(from.line, added);
      }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) {
        doc.remove(from.line + 1, nlines - 1);
      }
      doc.insert(from.line + 1, added$2);
    }
    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) {
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip) {
            continue;
          }
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared) {
            continue;
          }
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) {
      throw new Error("This document is already in use.");
    }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) {
      findMaxLine(cm);
    }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }
  function setDirectionClass(cm) {
    (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }
  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }
  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = [];
    this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {
      from: copyPos(change.from),
      to: changeEnd(change),
      text: getBetween(doc, change.from, change.to)
    };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) {
        array.pop();
      } else {
        break;
      }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(),
      cur;
    var last;
    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges) {
        pushSelectionToHistory(doc.sel, hist.done);
      }
      cur = {
        changes: [historyChangeFromChange(doc, change)],
        generation: hist.generation
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) {
          hist.done.shift();
        }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;
    if (!last) {
      signal(doc, "historyAdded");
    }
  }
  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history,
      origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
      hist.done[hist.done.length - 1] = sel;
    } else {
      pushSelectionToHistory(sel, hist.done);
    }
    hist.lastSelTime = +new Date();
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false) {
      clearSelectionEvents(hist.undone);
    }
  }
  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel))) {
      dest.push(sel);
    }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id],
      n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans) {
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) {
      return null;
    }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out) {
          out = spans.slice(0, i);
        }
      } else if (out) {
        out.push(spans[i]);
      }
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) {
      return null;
    }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i) {
      nw.push(removeClearedSpans(found[i]));
    }
    return nw;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) {
      return stretched;
    }
    if (!stretched) {
      return old;
    }
    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i],
        stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k) {
            if (oldCur[k].marker == span.marker) {
              continue spans;
            }
          }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes,
        newChanges = [];
      copy.push({
        changes: newChanges
      });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j],
          m = void 0;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });
        if (newGroup) {
          for (var prop in change) {
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
          }
        }
      }
    }
    return copy;
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != cmp(other, anchor) < 0) {
          anchor = head;
          head = other;
        } else if (posBefore != cmp(head, other) < 0) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) {
      extend = doc.cm && (doc.cm.display.shift || doc.extend);
    }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
    }
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function (ranges) {
        var this$1 = this;
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++) {
          this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
        }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) {
      signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    }
    if (obj.ranges != sel.ranges) {
      return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    } else {
      return sel;
    }
  }
  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done,
      last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }
  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      sel = filterSelectionChange(doc, sel, options);
    }
    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
    if (!(options && options.scroll === false) && doc.cm) {
      ensureCursorVisible(doc.cm);
    }
  }
  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) {
      return;
    }
    doc.sel = sel;
    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) {
          out = sel.ranges.slice(0, i);
        }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }
  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) {
      for (var i = 0; i < line.markedSpans.length; ++i) {
        var sp = line.markedSpans[i],
          m = sp.marker;
        if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");
            if (m.explicitlyCleared) {
              if (!line.markedSpans) {
                break;
              } else {
                --i;
                continue;
              }
            }
          }
          if (!m.atomic) {
            continue;
          }
          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1),
              diff = void 0;
            if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) {
              near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
            }
            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
              return skipAtomicInner(doc, near, pos, dir, mayClear);
            }
          }
          var far = m.find(dir < 0 ? -1 : 1);
          if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) {
            far = movePos(doc, far, dir, far.line == pos.line ? line : null);
          }
          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
        }
      }
    }
    return pos;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }
    return found;
  }
  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) {
        return clipPos(doc, Pos(pos.line - 1));
      } else {
        return null;
      }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) {
        return Pos(pos.line + 1, 0);
      } else {
        return null;
      }
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }
  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () {
        return obj.canceled = true;
      }
    };
    if (update) {
      obj.update = function (from, to, text, origin) {
        if (from) {
          obj.from = clipPos(doc, from);
        }
        if (to) {
          obj.to = clipPos(doc, to);
        }
        if (text) {
          obj.text = text;
        }
        if (origin !== undefined) {
          obj.origin = origin;
        }
      };
    }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) {
      signal(doc.cm, "beforeChange", doc.cm, obj);
    }
    if (obj.canceled) {
      return null;
    }
    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) {
        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      }
      if (doc.cm.state.suppressEdits) {
        return;
      }
    }
    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) {
        return;
      }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i) {
        makeChangeInner(doc, {
          from: split[i].from,
          to: split[i].to,
          text: i ? [""] : change.text,
          origin: change.origin
        });
      }
    } else {
      makeChangeInner(doc, change);
    }
  }
  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
      return;
    }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) {
      return;
    }
    var hist = doc.history,
      event,
      selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone,
      dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
        break;
      }
    }
    if (i == source.length) {
      return;
    }
    hist.lastOrigin = hist.lastSelOrigin = null;
    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {
            clearRedo: false
          });
          return;
        }
        selAfter = event;
      } else {
        break;
      }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({
      changes: antiChanges,
      generation: hist.generation
    });
    hist.generation = event.generation || ++hist.maxGeneration;
    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
    var loop = function (i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {};
      }
      antiChanges.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) {
        doc.cm.scrollIntoView({
          from: change.from,
          to: changeEnd(change)
        });
      }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };
    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop(i$1);
      if (returned) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) {
      return;
    }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
        regLineChange(doc.cm, l, "gutter");
      }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    }
    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) {
      return;
    }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc, change.from, change.to);
    if (!selAfter) {
      selAfter = computeSelAfterChange(doc, change);
    }
    if (doc.cm) {
      makeChangeSingleDocInEditor(doc.cm, change, spans);
    } else {
      updateDoc(doc, change, spans);
    }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc,
      display = cm.display,
      from = change.from,
      to = change.to;
    var recomputeMaxLength = false,
      checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (doc.sel.contains(change.from, change.to) > -1) {
      signalCursorActivity(cm);
    }
    updateDoc(doc, change, spans, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) {
        cm.curOp.updateMaxLine = true;
      }
    }
    retreatFrontier(doc, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full) {
      regChange(cm);
    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
      regLineChange(cm, from.line, "text");
    } else {
      regChange(cm, from.line, to.line + 1, lendiff);
    }
    var changesHandler = hasHandler(cm, "changes"),
      changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from,
        to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) {
        signalLater(cm, "change", cm, obj);
      }
      if (changesHandler) {
        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
      }
    }
    cm.display.selForContextMenu = null;
  }
  function replaceRange(doc, code, from, to, origin) {
    if (!to) {
      to = from;
    }
    if (cmp(to, from) < 0) {
      var assign;
      assign = [to, from], from = assign[0], to = assign[1], assign;
    }
    if (typeof code == "string") {
      code = doc.splitLines(code);
    }
    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    });
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i],
        ok = true;
      if (sub.ranges) {
        if (!sub.copied) {
          sub = array[i] = sub.deepCopy();
          sub.copied = true;
        }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line,
      to = change.to.line,
      diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle,
      line = handle;
    if (typeof handle == "number") {
      line = getLine(doc, clipLine(doc, handle));
    } else {
      no = lineNo(handle);
    }
    if (no == null) {
      return null;
    }
    if (op(line, no) && doc.cm) {
      regLineChange(doc.cm, no, changeType);
    }
    return line;
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    var this$1 = this;
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.lines.length;
    },
    // Remove the n lines at offset 'at'.
    removeInner: function removeInner(at, n) {
      var this$1 = this;
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function collapse(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function insertInner(at, lines, height) {
      var this$1 = this;
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) {
        lines[i].parent = this$1;
      }
    },
    // Used to iterate over a part of the tree.
    iterN: function iterN(at, n, op) {
      var this$1 = this;
      for (var e = at + n; at < e; ++at) {
        if (op(this$1.lines[at])) {
          return true;
        }
      }
    }
  };
  function BranchChunk(children) {
    var this$1 = this;
    this.children = children;
    var size = 0,
      height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this$1;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.size;
    },
    removeInner: function removeInner(at, n) {
      var this$1 = this;
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
          sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at),
            oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;
          if (sz == rm) {
            this$1.children.splice(i--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function collapse(lines) {
      var this$1 = this;
      for (var i = 0; i < this.children.length; ++i) {
        this$1.children[i].collapse(lines);
      }
    },
    insertInner: function insertInner(at, lines, height) {
      var this$1 = this;
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
          sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }
            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function maybeSpill() {
      if (this.children.length <= 10) {
        return;
      }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function iterN(at, n, op) {
      var this$1 = this;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
          sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) {
            return true;
          }
          if ((n -= used) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function (doc, node, options) {
    var this$1 = this;
    if (options) {
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          this$1[opt] = options[opt];
        }
      }
    }
    this.doc = doc;
    this.node = node;
  };
  LineWidget.prototype.clear = function () {
    var this$1 = this;
    var cm = this.doc.cm,
      ws = this.line.widgets,
      line = this.line,
      no = lineNo(line);
    if (no == null || !ws) {
      return;
    }
    for (var i = 0; i < ws.length; ++i) {
      if (ws[i] == this$1) {
        ws.splice(i--, 1);
      }
    }
    if (!ws.length) {
      line.widgets = null;
    }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };
  LineWidget.prototype.changed = function () {
    var this$1 = this;
    var oldH = this.height,
      cm = this.doc.cm,
      line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) {
      return;
    }
    updateLineHeight(line, line.height + diff);
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);
  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
      addToScrollTop(cm, diff);
    }
  }
  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) {
      cm.display.alignWidgets = true;
    }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) {
        widgets.push(widget);
      } else {
        widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) {
          addToScrollTop(cm, widget.height);
        }
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
    return widget;
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;
  var TextMarker = function (doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    var this$1 = this;
    if (this.explicitlyCleared) {
      return;
    }
    var cm = this.doc.cm,
      withOp = cm && !cm.curOp;
    if (withOp) {
      startOperation(cm);
    }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) {
        signalLater(this, "clear", found.from, found.to);
      }
    }
    var min = null,
      max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (cm && !this$1.collapsed) {
        regLineChange(cm, lineNo(line), "text");
      } else if (cm) {
        if (span.to != null) {
          max = lineNo(line);
        }
        if (span.from != null) {
          min = lineNo(line);
        }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm) {
        updateLineHeight(line, textHeight(cm.display));
      }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) {
      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
        var visual = visualLine(this$1.lines[i$1]),
          len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (min != null && cm && this.collapsed) {
      regChange(cm, min, max + 1);
    }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) {
        reCheckSelection(cm.doc);
      }
    }
    if (cm) {
      signalLater(cm, "markerCleared", cm, this, min, max);
    }
    if (withOp) {
      endOperation(cm);
    }
    if (this.parent) {
      this.parent.clear();
    }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    var this$1 = this;
    if (side == null && this.type == "bookmark") {
      side = 1;
    }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) {
          return from;
        }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) {
          return to;
        }
      }
    }
    return from && {
      from: from,
      to: to
    };
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
    var this$1 = this;
    var pos = this.find(-1, true),
      widget = this,
      cm = this.doc.cm;
    if (!pos || !cm) {
      return;
    }
    runInOp(cm, function () {
      var line = pos.line,
        lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight) {
          updateLineHeight(line, line.height + dHeight);
        }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };
  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
      }
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) {
      return markTextShared(doc, from, to, options, type);
    }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, markText)(doc, from, to, options, type);
    }
    var marker = new TextMarker(doc, type),
      diff = cmp(from, to);
    if (options) {
      copyObj(options, marker, false);
    }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
      return marker;
    }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) {
        marker.widgetNode.setAttribute("cm-ignore-events", "true");
      }
      if (options.insertLeft) {
        marker.widgetNode.insertLeft = true;
      }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      }
      seeCollapsedSpans();
    }
    if (marker.addToHistory) {
      addChangeToHistory(doc, {
        from: from,
        to: to,
        origin: "markText"
      }, doc.sel, NaN);
    }
    var curLine = from.line,
      cm = doc.cm,
      updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
        updateMaxLine = true;
      }
      if (marker.collapsed && curLine != from.line) {
        updateLineHeight(line, 0);
      }
      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) {
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line)) {
          updateLineHeight(line, 0);
        }
      });
    }
    if (marker.clearOnEnter) {
      on(marker, "beforeCursorEnter", function () {
        return marker.clear();
      });
    }
    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length) {
        doc.clearHistory();
      }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) {
        cm.curOp.updateMaxLine = true;
      }
      if (marker.collapsed) {
        regChange(cm, from.line, to.line + 1);
      } else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css) {
        for (var i = from.line; i <= to.line; i++) {
          regLineChange(cm, i, "text");
        }
      }
      if (marker.atomic) {
        reCheckSelection(cm.doc);
      }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function (markers, primary) {
    var this$1 = this;
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i) {
      markers[i].parent = this$1;
    }
  };
  SharedTextMarker.prototype.clear = function () {
    var this$1 = this;
    if (this.explicitlyCleared) {
      return;
    }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i) {
      this$1.markers[i].clear();
    }
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj);
  };
  eventMixin(SharedTextMarker);
  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)],
      primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) {
        options.widgetNode = widget.cloneNode(true);
      }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i) {
        if (doc.linked[i].isParent) {
          return;
        }
      }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
      return m.parent;
    });
  }
  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i],
        pos = marker.find();
      var mFrom = doc.clipPos(pos.from),
        mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }
  function detachSharedMarkers(markers) {
    var loop = function (i) {
      var marker = markers[i],
        linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) {
        return linked.push(d);
      });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };
    for (var i = 0; i < markers.length; i++) loop(i);
  }
  var nextDocId = 0;
  var Doc = function (text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) {
      return new Doc(text, mode, firstLine, lineSep, direction);
    }
    if (firstLine == null) {
      firstLine = 0;
    }
    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = direction == "rtl" ? "rtl" : "ltr";
    this.extend = false;
    if (typeof text == "string") {
      text = this.splitLines(text);
    }
    updateDoc(this, {
      from: start,
      to: start,
      text: text
    });
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };
  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function (from, to, op) {
      if (op) {
        this.iterN(from - this.first, to - from, op);
      } else {
        this.iterN(this.first, this.first + this.size, from);
      }
    },
    // Non-public interface for adding and removing lines.
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) {
        height += lines[i].height;
      }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) {
      this.removeInner(at - this.first, n);
    },
    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function (code) {
      var top = Pos(this.first, 0),
        last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: this.splitLines(code),
        origin: "setValue",
        full: true
      }, true);
      if (this.cm) {
        scrollToCoords(this.cm, 0, 0);
      }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    getLine: function (line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    getLineHandle: function (line) {
      if (isLine(this, line)) {
        return getLine(this, line);
      }
    },
    getLineNumber: function (line) {
      return lineNo(line);
    },
    getLineHandleVisualStart: function (line) {
      if (typeof line == "number") {
        line = getLine(this, line);
      }
      return visualLine(line);
    },
    lineCount: function () {
      return this.size;
    },
    firstLine: function () {
      return this.first;
    },
    lastLine: function () {
      return this.first + this.size - 1;
    },
    clipPos: function (pos) {
      return clipPos(this, pos);
    },
    getCursor: function (start) {
      var range$$1 = this.sel.primary(),
        pos;
      if (start == null || start == "head") {
        pos = range$$1.head;
      } else if (start == "anchor") {
        pos = range$$1.anchor;
      } else if (start == "end" || start == "to" || start === false) {
        pos = range$$1.to();
      } else {
        pos = range$$1.from();
      }
      return pos;
    },
    listSelections: function () {
      return this.sel.ranges;
    },
    somethingSelected: function () {
      return this.sel.somethingSelected();
    },
    setCursor: docMethodOp(function (line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function (anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function (head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function (heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function (f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function (ranges, primary, options) {
      var this$1 = this;
      if (!ranges.length) {
        return;
      }
      var out = [];
      for (var i = 0; i < ranges.length; i++) {
        out[i] = new Range(clipPos(this$1, ranges[i].anchor), clipPos(this$1, ranges[i].head));
      }
      if (primary == null) {
        primary = Math.min(ranges.length - 1, this.sel.primIndex);
      }
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function (anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),
    getSelection: function (lineSep) {
      var this$1 = this;
      var ranges = this.sel.ranges,
        lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) {
        return lines;
      } else {
        return lines.join(lineSep || this.lineSeparator());
      }
    },
    getSelections: function (lineSep) {
      var this$1 = this;
      var parts = [],
        ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) {
          sel = sel.join(lineSep || this$1.lineSeparator());
        }
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function (code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++) {
        dup[i] = code;
      }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function (code, collapse, origin) {
      var this$1 = this;
      var changes = [],
        sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = {
          from: range$$1.from(),
          to: range$$1.to(),
          text: this$1.splitLines(code[i]),
          origin: origin
        };
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
        makeChange(this$1, changes[i$1]);
      }
      if (newSel) {
        setSelectionReplaceHistory(this, newSel);
      } else if (this.cm) {
        ensureCursorVisible(this.cm);
      }
    }),
    undo: docMethodOp(function () {
      makeChangeFromHistory(this, "undo");
    }),
    redo: docMethodOp(function () {
      makeChangeFromHistory(this, "redo");
    }),
    undoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "undo", true);
    }),
    redoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "redo", true);
    }),
    setExtending: function (val) {
      this.extend = val;
    },
    getExtending: function () {
      return this.extend;
    },
    historySize: function () {
      var hist = this.history,
        done = 0,
        undone = 0;
      for (var i = 0; i < hist.done.length; i++) {
        if (!hist.done[i].ranges) {
          ++done;
        }
      }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
        if (!hist.undone[i$1].ranges) {
          ++undone;
        }
      }
      return {
        undo: done,
        redo: undone
      };
    },
    clearHistory: function () {
      this.history = new History(this.history.maxGeneration);
    },
    markClean: function () {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function (forceSplit) {
      if (forceSplit) {
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      }
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },
    getHistory: function () {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function (histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },
    setGutterMarker: docMethodOp(function (line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) {
          line.gutterMarkers = null;
        }
        return true;
      });
    }),
    clearGutter: docMethodOp(function (gutterID) {
      var this$1 = this;
      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) {
              line.gutterMarkers = null;
            }
            return true;
          });
        }
      });
    }),
    lineInfo: function (line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) {
          return null;
        }
        n = line;
        line = getLine(this, line);
        if (!line) {
          return null;
        }
      } else {
        n = lineNo(line);
        if (n == null) {
          return null;
        }
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    addLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) {
          line[prop] = cls;
        } else if (classTest(cls).test(line[prop])) {
          return false;
        } else {
          line[prop] += " " + cls;
        }
        return true;
      });
    }),
    removeLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) {
          return false;
        } else if (cls == null) {
          line[prop] = null;
        } else {
          var found = cur.match(classTest(cls));
          if (!found) {
            return false;
          }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),
    addLineWidget: docMethodOp(function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function (widget) {
      widget.clear();
    },
    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function (pos, options) {
      var realOpts = {
        replacedWith: options && (options.nodeType == null ? options.widget : options),
        insertLeft: options && options.insertLeft,
        clearWhenEmpty: false,
        shared: options && options.shared,
        handleMouseEvents: options && options.handleMouseEvents
      };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [],
        spans = getLine(this, pos.line).markedSpans;
      if (spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
            markers.push(span.marker.parent || span.marker);
          }
        }
      }
      return markers;
    },
    findMarks: function (from, to, filter) {
      from = clipPos(this, from);
      to = clipPos(this, to);
      var found = [],
        lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) {
          for (var i = 0; i < spans.length; i++) {
            var span = spans[i];
            if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to || span.from == null && lineNo$$1 != from.line || span.from != null && lineNo$$1 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
              found.push(span.marker.parent || span.marker);
            }
          }
        }
        ++lineNo$$1;
      });
      return found;
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            if (sps[i].from != null) {
              markers.push(sps[i].marker);
            }
          }
        }
      });
      return markers;
    },
    posFromIndex: function (off) {
      var ch,
        lineNo$$1 = this.first,
        sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) {
          ch = off;
          return true;
        }
        off -= sz;
        ++lineNo$$1;
      });
      return clipPos(this, Pos(lineNo$$1, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) {
        return 0;
      }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) {
        // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index;
    },
    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },
    linkedDoc: function (options) {
      if (!options) {
        options = {};
      }
      var from = this.first,
        to = this.first + this.size;
      if (options.from != null && options.from > from) {
        from = options.from;
      }
      if (options.to != null && options.to < to) {
        to = options.to;
      }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) {
        copy.history = this.history;
      }
      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
        doc: this,
        isParent: true,
        sharedHist: options.sharedHist
      }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function (other) {
      var this$1 = this;
      if (other instanceof CodeMirror$1) {
        other = other.doc;
      }
      if (this.linked) {
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this$1.linked[i];
          if (link.doc != other) {
            continue;
          }
          this$1.linked.splice(i, 1);
          other.unlinkDoc(this$1);
          detachSharedMarkers(findSharedMarkers(this$1));
          break;
        }
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          return splitIds.push(doc.id);
        }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) {
      linkedDocs(this, f);
    },
    getMode: function () {
      return this.mode;
    },
    getEditor: function () {
      return this.cm;
    },
    splitLines: function (str) {
      if (this.lineSep) {
        return str.split(this.lineSep);
      }
      return splitLinesAuto(str);
    },
    lineSeparator: function () {
      return this.lineSep || "\n";
    },
    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") {
        dir = "ltr";
      }
      if (dir == this.direction) {
        return;
      }
      this.direction = dir;
      this.iter(function (line) {
        return line.order = null;
      });
      if (this.cm) {
        directionChanged(this.cm);
      }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;
  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e_preventDefault(e);
    if (ie) {
      lastDrop = +new Date();
    }
    var pos = posFromMouse(cm, e, true),
      files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) {
      return;
    }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length,
        text = Array(n),
        read = 0;
      var loadFile = function (file, i) {
        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          return;
        }
        var reader = new FileReader();
        reader.onload = operation(cm, function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            content = "";
          }
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {
              from: pos,
              to: pos,
              text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
              origin: "paste"
            };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) {
        loadFile(files[i], i);
      }
    } else {
      // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () {
          return cm.display.input.focus();
        }, 20);
        return;
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy) {
            selected = cm.listSelections();
          }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) {
            for (var i$1 = 0; i$1 < selected.length; ++i$1) {
              replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
            }
          }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      } catch (e) {}
    }
  }
  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
      e_stop(e);
      return;
    }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) {
        img.parentNode.removeChild(img);
      }
    }
  }
  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) {
      return;
    }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }
  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) {
      return;
    }
    var byClass = document.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) {
        f(cm);
      }
    }
  }
  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) {
      return;
    }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) {
        resizeTimer = setTimeout(function () {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100);
      }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () {
      return forEachCodeMirror(onBlur);
    });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth) {
      return;
    }
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }
  var keyNames = {
    3: "Pause",
    8: "Backspace",
    9: "Tab",
    13: "Enter",
    16: "Shift",
    17: "Ctrl",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Esc",
    32: "Space",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    44: "PrintScrn",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Mod",
    92: "Mod",
    93: "Mod",
    106: "*",
    107: "=",
    109: "-",
    110: ".",
    111: "/",
    127: "Delete",
    145: "ScrollLock",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    63232: "Up",
    63233: "Down",
    63234: "Left",
    63235: "Right",
    63272: "Delete",
    63273: "Home",
    63275: "End",
    63276: "PageUp",
    63277: "PageDown",
    63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) {
    keyNames[i + 48] = keyNames[i + 96] = String(i);
  }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) {
    keyNames[i$1] = String.fromCharCode(i$1);
  }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) {
    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
  }
  var keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft",
    "Right": "goCharRight",
    "Up": "goLineUp",
    "Down": "goLineDown",
    "End": "goLineEnd",
    "Home": "goLineStartSmart",
    "PageUp": "goPageUp",
    "PageDown": "goPageDown",
    "Delete": "delCharAfter",
    "Backspace": "delCharBefore",
    "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab",
    "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent",
    "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll",
    "Ctrl-D": "deleteLine",
    "Ctrl-Z": "undo",
    "Shift-Ctrl-Z": "redo",
    "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart",
    "Ctrl-End": "goDocEnd",
    "Ctrl-Up": "goLineUp",
    "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft",
    "Ctrl-Right": "goGroupRight",
    "Alt-Left": "goLineStart",
    "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore",
    "Ctrl-Delete": "delGroupAfter",
    "Ctrl-S": "save",
    "Ctrl-F": "find",
    "Ctrl-G": "findNext",
    "Shift-Ctrl-G": "findPrev",
    "Shift-Ctrl-F": "replace",
    "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess",
    "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection",
    "Shift-Ctrl-U": "redoSelection",
    "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight",
    "Ctrl-B": "goCharLeft",
    "Ctrl-P": "goLineUp",
    "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight",
    "Alt-B": "goWordLeft",
    "Ctrl-A": "goLineStart",
    "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown",
    "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter",
    "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter",
    "Alt-Backspace": "delWordBefore",
    "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll",
    "Cmd-D": "deleteLine",
    "Cmd-Z": "undo",
    "Shift-Cmd-Z": "redo",
    "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart",
    "Cmd-Up": "goDocStart",
    "Cmd-End": "goDocEnd",
    "Cmd-Down": "goDocEnd",
    "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight",
    "Cmd-Left": "goLineLeft",
    "Cmd-Right": "goLineRight",
    "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter",
    "Alt-Delete": "delGroupAfter",
    "Cmd-S": "save",
    "Cmd-F": "find",
    "Cmd-G": "findNext",
    "Shift-Cmd-G": "findPrev",
    "Cmd-Alt-F": "replace",
    "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess",
    "Cmd-]": "indentMore",
    "Cmd-Backspace": "delWrappedLineLeft",
    "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection",
    "Shift-Cmd-U": "redoSelection",
    "Ctrl-Up": "goDocStart",
    "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        cmd = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift = true;
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }
    if (alt) {
      name = "Alt-" + name;
    }
    if (ctrl) {
      name = "Ctrl-" + name;
    }
    if (cmd) {
      name = "Cmd-" + name;
    }
    if (shift) {
      name = "Shift-" + name;
    }
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) {
      if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];
        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
          continue;
        }
        if (value == "...") {
          delete keymap[keyname];
          continue;
        }
        var keys = map(keyname.split(" "), normalizeKeyName);
        for (var i = 0; i < keys.length; i++) {
          var val = void 0,
            name = void 0;
          if (i == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i + 1).join(" ");
            val = "...";
          }
          var prev = copy[name];
          if (!prev) {
            copy[name] = val;
          } else if (prev != val) {
            throw new Error("Inconsistent bindings for " + name);
          }
        }
        delete keymap[keyname];
      }
    }
    for (var prop in copy) {
      keymap[prop] = copy[prop];
    }
    return keymap;
  }
  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
    if (found === false) {
      return "nothing";
    }
    if (found === "...") {
      return "multi";
    }
    if (found != null && handle(found)) {
      return "handled";
    }
    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]") {
        return lookupKey(key, map$$1.fallthrough, handle, context);
      }
      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
        if (result) {
          return result;
        }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }
  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") {
      name = "Alt-" + name;
    }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
      name = "Ctrl-" + name;
    }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") {
      name = "Cmd-" + name;
    }
    if (!noShift && event.shiftKey && base != "Shift") {
      name = "Shift-" + name;
    }
    return name;
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) {
      return false;
    }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) {
      return false;
    }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) {
      name = event.code;
    }
    return addModifierNames(name, event, noShift);
  }
  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges,
      kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--) {
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      }
      ensureCursorVisible(cm);
    });
  }
  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target;
  }
  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
  }
  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = dir < 0 == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) {
            return measureCharPrepared(cm, prep, ch).top == targetTop;
          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") {
            ch = moveCharLogically(lineObj, ch, 1);
          }
        } else {
          ch = dir < 0 ? part.to : part.from;
        }
        return new Pos(lineNo, ch, sticky);
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
  }
  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) {
      return moveLogically(line, start, dir);
    }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
      part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir);
    }
    var mv = function (pos, dir) {
      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
    };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) {
        return {
          begin: 0,
          end: line.text.length
        };
      }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch);
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = part.level == 1 == dir < 0;
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky);
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) {
        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
      };
      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = dir > 0 == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) {
          return getRes(ch, moveInStorageOrder);
        }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
          return getRes(ch, moveInStorageOrder);
        }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) {
      return res;
    }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) {
        return res;
      }
    }

    // Case 4: Nowhere to move
    return null;
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) {
      return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function (cm) {
      return deleteNearSelection(cm, function (range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine()) {
            return {
              from: range.head,
              to: Pos(range.head.line + 1, 0)
            };
          } else {
            return {
              from: range.head,
              to: Pos(range.head.line, len)
            };
          }
        } else {
          return {
            from: range.from(),
            to: range.to()
          };
        }
      });
    },
    deleteLine: function (cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
        };
      });
    },
    delLineLeft: function (cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: range.from()
        };
      });
    },
    delWrappedLineLeft: function (cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({
          left: 0,
          top: top
        }, "div");
        return {
          from: leftPos,
          to: range.from()
        };
      });
    },
    delWrappedLineRight: function (cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, "div");
        return {
          from: range.from(),
          to: rightPos
        };
      });
    },
    undo: function (cm) {
      return cm.undo();
    },
    redo: function (cm) {
      return cm.redo();
    },
    undoSelection: function (cm) {
      return cm.undoSelection();
    },
    redoSelection: function (cm) {
      return cm.redoSelection();
    },
    goDocStart: function (cm) {
      return cm.extendSelection(Pos(cm.firstLine(), 0));
    },
    goDocEnd: function (cm) {
      return cm.extendSelection(Pos(cm.lastLine()));
    },
    goLineStart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStart(cm, range.head.line);
      }, {
        origin: "+move",
        bias: 1
      });
    },
    goLineStartSmart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStartSmart(cm, range.head);
      }, {
        origin: "+move",
        bias: 1
      });
    },
    goLineEnd: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineEnd(cm, range.head.line);
      }, {
        origin: "+move",
        bias: -1
      });
    },
    goLineRight: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, "div");
      }, sel_move);
    },
    goLineLeft: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({
          left: 0,
          top: top
        }, "div");
      }, sel_move);
    },
    goLineLeftSmart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({
          left: 0,
          top: top
        }, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
          return lineStartSmart(cm, range.head);
        }
        return pos;
      }, sel_move);
    },
    goLineUp: function (cm) {
      return cm.moveV(-1, "line");
    },
    goLineDown: function (cm) {
      return cm.moveV(1, "line");
    },
    goPageUp: function (cm) {
      return cm.moveV(-1, "page");
    },
    goPageDown: function (cm) {
      return cm.moveV(1, "page");
    },
    goCharLeft: function (cm) {
      return cm.moveH(-1, "char");
    },
    goCharRight: function (cm) {
      return cm.moveH(1, "char");
    },
    goColumnLeft: function (cm) {
      return cm.moveH(-1, "column");
    },
    goColumnRight: function (cm) {
      return cm.moveH(1, "column");
    },
    goWordLeft: function (cm) {
      return cm.moveH(-1, "word");
    },
    goGroupRight: function (cm) {
      return cm.moveH(1, "group");
    },
    goGroupLeft: function (cm) {
      return cm.moveH(-1, "group");
    },
    goWordRight: function (cm) {
      return cm.moveH(1, "word");
    },
    delCharBefore: function (cm) {
      return cm.deleteH(-1, "char");
    },
    delCharAfter: function (cm) {
      return cm.deleteH(1, "char");
    },
    delWordBefore: function (cm) {
      return cm.deleteH(-1, "word");
    },
    delWordAfter: function (cm) {
      return cm.deleteH(1, "word");
    },
    delGroupBefore: function (cm) {
      return cm.deleteH(-1, "group");
    },
    delGroupAfter: function (cm) {
      return cm.deleteH(1, "group");
    },
    indentAuto: function (cm) {
      return cm.indentSelection("smart");
    },
    indentMore: function (cm) {
      return cm.indentSelection("add");
    },
    indentLess: function (cm) {
      return cm.indentSelection("subtract");
    },
    insertTab: function (cm) {
      return cm.replaceSelection("\t");
    },
    insertSoftTab: function (cm) {
      var spaces = [],
        ranges = cm.listSelections(),
        tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) {
        cm.indentSelection("add");
      } else {
        cm.execCommand("insertTab");
      }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) {
      return runInOp(cm, function () {
        var ranges = cm.listSelections(),
          newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) {
            continue;
          }
          var cur = ranges[i].head,
            line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) {
              cur = new Pos(cur.line, cur.ch - 1);
            }
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
              }
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function (cm) {
      return runInOp(cm, function () {
        var sels = cm.listSelections();
        for (var i = sels.length - 1; i >= 0; i--) {
          cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
        }
        sels = cm.listSelections();
        for (var i$1 = 0; i$1 < sels.length; i$1++) {
          cm.indentLine(sels[i$1].from().line, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    openLine: function (cm) {
      return cm.replaceSelection("\n", "start");
    },
    toggleOverwrite: function (cm) {
      return cm.toggleOverwrite();
    }
  };
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, visual, lineN, 1);
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, line, lineN, -1);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
    }
    return start;
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) {
        return false;
      }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift,
      done = false;
    try {
      if (cm.isReadOnly()) {
        cm.state.suppressEdits = true;
      }
      if (dropShift) {
        cm.display.shift = false;
      }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) {
        return result;
      }
    }
    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed();
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) {
        return "handled";
      }
      if (/\'$/.test(name)) {
        cm.state.keySeq = null;
      } else {
        stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        });
      }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
        return true;
      }
    }
    return dispatchKeyInner(cm, name, e, handle);
  }
  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);
    if (result == "multi") {
      cm.state.keySeq = name;
    }
    if (result == "handled") {
      signalLater(cm, "keyHandled", cm, name, e);
    }
    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) {
      return false;
    }
    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) {
        return doHandleBinding(cm, b, true);
      }) || dispatchKey(cm, name, e, function (b) {
        if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
          return doHandleBinding(cm, b);
        }
      });
    } else {
      return dispatchKey(cm, name, e, function (b) {
        return doHandleBinding(cm, b);
      });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) {
      return doHandleBinding(cm, b, true);
    });
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) {
      return;
    }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) {
      e.returnValue = false;
    }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
        cm.replaceSelection("", null, "cut");
      }
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
      showCrossHair(cm);
    }
  }
  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");
    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }
  function onKeyUp(e) {
    if (e.keyCode == 16) {
      this.doc.sel.shift = false;
    }
    signalDOMEvent(this, e);
  }
  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
      return;
    }
    var keyCode = e.keyCode,
      charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
      return;
    }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") {
      return;
    }
    if (handleCharBinding(cm, e, ch)) {
      return;
    }
    cm.display.input.onKeyPress(e);
  }
  var DOUBLECLICK_DELAY = 400;
  var PastClick = function (time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };
  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
  };
  var lastClick;
  var lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date();
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple";
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double";
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single";
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this,
      display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
      return;
    }
    display.input.ensurePolled();
    display.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () {
          return display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) {
      return;
    }
    var pos = posFromMouse(cm, e),
      button = e_button(e),
      repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText) {
      cm.state.selectingText(e);
    }
    if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
      return;
    }
    if (button == 1) {
      if (pos) {
        leftButtonDown(cm, pos, repeat, e);
      } else if (e_target(e) == display.scroller) {
        e_preventDefault(e);
      }
    } else if (button == 2) {
      if (pos) {
        extendSelection(cm.doc, pos);
      }
      setTimeout(function () {
        return display.input.focus();
      }, 20);
    } else if (button == 3) {
      if (captureRightClick) {
        onContextMenu(cm, e);
      } else {
        delayBlurEvent(cm);
      }
    }
  }
  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") {
      name = "Double" + name;
    } else if (repeat == "triple") {
      name = "Triple" + name;
    }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") {
        bound = commands[bound];
      }
      if (!bound) {
        return false;
      }
      var done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done;
    });
  }
  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) {
      value.extend = cm.doc.extend || event.shiftKey;
    }
    if (value.addNew == null) {
      value.addNew = mac ? event.metaKey : event.ctrlKey;
    }
    if (value.moveOnDrag == null) {
      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
    }
    return value;
  }
  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) {
      setTimeout(bind(ensureFocus, cm), 0);
    } else {
      cm.curOp.focus = activeElt();
    }
    var behavior = configureMouse(cm, repeat, event);
    var sel = cm.doc.sel,
      contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
      leftButtonStartDrag(cm, event, pos, behavior);
    } else {
      leftButtonSelect(cm, event, pos, behavior);
    }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display,
      moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) {
        display.scroller.draggable = false;
      }
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(document, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew) {
          extendSelection(cm.doc, pos, null, null, behavior.extend);
        }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9) {
          setTimeout(function () {
            document.body.focus();
            display.input.focus();
          }, 20);
        } else {
          display.input.focus();
        }
      }
    });
    var mouseMove = function (e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () {
      return moved = true;
    };
    // Let the drag handler handle this.
    if (webkit) {
      display.scroller.draggable = true;
    }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    // IE's approach to draggable
    if (display.scroller.dragDrop) {
      display.scroller.dragDrop();
    }
    on(document, "mouseup", dragEnd);
    on(document, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);
    delayBlurEvent(cm);
    setTimeout(function () {
      return display.input.focus();
    }, 20);
  }
  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") {
      return new Range(pos, pos);
    }
    if (unit == "word") {
      return cm.findWordAt(pos);
    }
    if (unit == "line") {
      return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
    }
    var result = unit(cm, pos);
    return new Range(result.from, result.to);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display,
      doc = cm.doc;
    e_preventDefault(event);
    var ourRange,
      ourIndex,
      startSel = doc.sel,
      ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1) {
        ourRange = ranges[ourIndex];
      } else {
        ourRange = new Range(start, start);
      }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }
    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) {
        ourRange = new Range(start, start);
      }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range$$1 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend) {
        ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend);
      } else {
        ourRange = range$$1;
      }
    }
    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), {
        scroll: false,
        origin: "*mouse"
      });
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
        scroll: false,
        origin: "*mouse"
      });
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }
    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) {
        return;
      }
      lastPos = pos;
      if (behavior.unit == "rectangle") {
        var ranges = [],
          tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol),
          right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
          var text = getLine(doc, line).text,
            leftPos = findColumn(text, left, tabSize);
          if (left == right) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          } else if (text.length > leftPos) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
          }
        }
        if (!ranges.length) {
          ranges.push(new Range(start, start));
        }
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
          origin: "*mouse",
          scroll: false
        });
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range$$1 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor,
          head;
        if (cmp(range$$1.anchor, anchor) > 0) {
          head = range$$1.head;
          anchor = minPos(oldRange.from(), range$$1.anchor);
        } else {
          head = range$$1.anchor;
          anchor = maxPos(oldRange.to(), range$$1.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
      }
    }
    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) {
        return;
      }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from) {
          setTimeout(operation(cm, function () {
            if (counter == curCount) {
              extend(e);
            }
          }), 150);
        }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) {
          setTimeout(operation(cm, function () {
            if (counter != curCount) {
              return;
            }
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }
    }
    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }
    var move = operation(cm, function (e) {
      if (!e_button(e)) {
        done(e);
      } else {
        extend(e);
      }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range$$1) {
    var anchor = range$$1.anchor;
    var head = range$$1.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
      return range$$1;
    }
    var order = getOrder(anchorLine);
    if (!order) {
      return range$$1;
    }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
      part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) {
      return range$$1;
    }
    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) {
      return range$$1;
    }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary) {
        leftSide = dir < 0;
      } else {
        leftSide = dir > 0;
      }
    }
    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to,
      sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try {
        mX = e.clientX;
        mY = e.clientY;
      } catch (e) {
        return false;
      }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
      return false;
    }
    if (prevent) {
      e_preventDefault(e);
    }
    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();
    if (mY > lineBox.bottom || !hasHandler(cm, type)) {
      return e_defaultPrevented(e);
    }
    mY -= lineBox.top - display.viewOffset;
    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }
  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
      return;
    }
    if (signalDOMEvent(cm, e, "contextmenu")) {
      return;
    }
    cm.display.input.onContextMenu(e);
  }
  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) {
      return false;
    }
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }
  var Init = {
    toString: function () {
      return "CodeMirror.Init";
    }
  };
  var defaults = {};
  var optionHandlers = {};
  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;
    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) {
        optionHandlers[name] = notOnInit ? function (cm, val, old) {
          if (old != Init) {
            handle(cm, val, old);
          }
        } : handle;
      }
    }
    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) {
      return cm.setValue(val);
    }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);
    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);
    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) {
        return;
      }
      var newBreaks = [],
        lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) {
            break;
          }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--) {
        replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
      }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) {
        cm.refresh();
      }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
      return cm.refresh();
    }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) {
      return cm.getInputField().spellcheck = val;
    }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);
    option("theme", "default", function (cm) {
      themeChanged(cm);
      guttersChanged(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) {
        prev.detach(cm, next);
      }
      if (next.attach) {
        next.attach(cm, prev || null);
      }
    });
    option("extraKeys", null);
    option("configureMouse", null);
    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) {
      return updateScrollbars(cm);
    }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("firstLineNumber", 1, guttersChanged, true);
    option("lineNumberFormatter", function (integer) {
      return integer;
    }, guttersChanged, true);
    option("showCursorWhenSelecting", false, updateSelection, true);
    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {
      if (!val) {
        cm.display.input.reset();
      }
    }, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);
    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) {
      return cm.doc.history.undoDepth = val;
    });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) {
      return cm.refresh();
    }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) {
        cm.display.input.resetPosition();
      }
    });
    option("tabindex", null, function (cm, val) {
      return cm.display.input.getField().tabIndex = val || "";
    });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) {
      return cm.doc.setDirection(val);
    }, true);
  }
  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    alignHorizontally(cm);
  }
  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      return updateScrollbars(cm);
    }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror$1(place, options) {
    var this$1 = this;
    if (!(this instanceof CodeMirror$1)) {
      return new CodeMirror$1(place, options);
    }
    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);
    var doc = options.value;
    if (typeof doc == "string") {
      doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
    }
    this.doc = doc;
    var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping) {
      this.display.wrapper.className += " CodeMirror-wrap";
    }
    initScrollbars(this);
    this.state = {
      keyMaps: [],
      // stores maps added by addKeyMap
      overlays: [],
      // highlighting overlays, as added by addOverlay
      modeGen: 0,
      // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false,
      // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false,
      cutIncoming: false,
      // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(),
      // stores highlight worker timeout
      keySeq: null,
      // Unfinished key sequence
      specialChars: null
    };
    if (options.autofocus && !mobile) {
      display.input.focus();
    }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) {
      setTimeout(function () {
        return this$1.display.input.reset(true);
      }, 20);
    }
    registerEventHandlers(this);
    ensureGlobalHandlers();
    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);
    if (options.autofocus && !mobile || this.hasFocus()) {
      setTimeout(bind(onFocus, this), 20);
    } else {
      onBlur(this);
    }
    for (var opt in optionHandlers) {
      if (optionHandlers.hasOwnProperty(opt)) {
        optionHandlers[opt](this$1, options[opt], Init);
      }
    }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) {
      options.finishInit(this);
    }
    for (var i = 0; i < initHooks.length; ++i) {
      initHooks[i](this$1);
    }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
      display.lineDiv.style.textRendering = "auto";
    }
  }

  // The default configuration options.
  CodeMirror$1.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror$1.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11) {
      on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    } else {
      on(d.scroller, "dblclick", function (e) {
        return signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) {
      on(d.scroller, "contextmenu", function (e) {
        return onContextMenu(cm, e);
      });
    }

    // Used to suppress mouse event handling when a touch happens
    var touchFinished,
      prevTouch = {
        end: 0
      };
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () {
          return d.activeTouch = null;
        }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date();
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) {
        return false;
      }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) {
        return true;
      }
      var dx = other.left - touch.left,
        dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date();
        d.activeTouch = {
          start: now,
          moved: false,
          prev: now - prevTouch.end <= 300 ? prevTouch : null
        };
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) {
        d.activeTouch.moved = true;
      }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"),
          range;
        if (!touch.prev || farAway(touch, touch.prev))
          // Single tap
          {
            range = new Range(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev))
          // Double tap
          {
            range = cm.findWordAt(pos);
          } else
          // Triple tap
          {
            range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) {
      return onScrollWheel(cm, e);
    });
    on(d.scroller, "DOMMouseScroll", function (e) {
      return onScrollWheel(cm, e);
    });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () {
      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    d.dragFunctions = {
      enter: function (e) {
        if (!signalDOMEvent(cm, e)) {
          e_stop(e);
        }
      },
      over: function (e) {
        if (!signalDOMEvent(cm, e)) {
          onDragOver(cm, e);
          e_stop(e);
        }
      },
      start: function (e) {
        return onDragStart(cm, e);
      },
      drop: operation(cm, onDrop),
      leave: function (e) {
        if (!signalDOMEvent(cm, e)) {
          clearDragCursor(cm);
        }
      }
    };
    var inp = d.input.getField();
    on(inp, "keyup", function (e) {
      return onKeyUp.call(cm, e);
    });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) {
      return onFocus(cm, e);
    });
    on(inp, "blur", function (e) {
      return onBlur(cm, e);
    });
  }
  var initHooks = [];
  CodeMirror$1.defineInitHook = function (f) {
    return initHooks.push(f);
  };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc,
      state;
    if (how == null) {
      how = "add";
    }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) {
        how = "prev";
      } else {
        state = getContextBefore(cm, n).state;
      }
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n),
      curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    var curSpaceString = line.text.match(/^\s*/)[0],
      indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) {
          return;
        }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) {
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      } else {
        indentation = 0;
      }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);
    var indentString = "",
      pos = 0;
    if (cm.options.indentWithTabs) {
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += "\t";
      }
    }
    if (pos < indentation) {
      indentString += spaceStr(indentation - pos);
    }
    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break;
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;
  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }
  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) {
      sel = doc.sel;
    }
    var paste = cm.state.pasteIncoming || origin == "paste";
    var textLines = splitLinesAuto(inserted),
      multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++) {
            multiPaste.push(doc.splitLines(lastCopied.text[i]));
          }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) {
          return [l];
        });
      }
    }
    var updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(),
        to = range$$1.to();
      if (range$$1.empty()) {
        if (deleted && deleted > 0)
          // Handle deletion
          {
            from = Pos(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste)
          // Handle overwrite
          {
            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          } else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted) {
          from = to = Pos(from.line, 0);
        }
      }
      updateInput = cm.curOp.updateInput;
      var changeEvent = {
        from: from,
        to: to,
        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
        origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
      };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste) {
      triggerElectric(cm, inserted);
    }
    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }
  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput) {
        runInOp(cm, function () {
          return applyTextInput(cm, pasted, 0, null, "paste");
        });
      }
      return true;
    }
  }
  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) {
      return;
    }
    var sel = cm.doc.sel;
    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];
      if (range$$1.head.ch > 100 || i && sel.ranges[i - 1].head.line == range$$1.head.line) {
        continue;
      }
      var mode = cm.getModeAt(range$$1.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++) {
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break;
          }
        }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch))) {
          indented = indentLine(cm, range$$1.head.line, "smart");
        }
      }
      if (indented) {
        signalLater(cm, "electricInput", cm, range$$1.head.line);
      }
    }
  }
  function copyableRanges(cm) {
    var text = [],
      ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {
        anchor: Pos(line, 0),
        head: Pos(line + 1, 0)
      };
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {
      text: text,
      ranges: ranges
    };
  }
  function disableBrowserMagic(field, spellcheck) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }
  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) {
      te.style.width = "1000px";
    } else {
      te.setAttribute("wrap", "off");
    }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) {
      te.style.border = "1px solid black";
    }
    disableBrowserMagic(te);
    return div;
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  var addEditorMethods = function (CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;
    var helpers = CodeMirror.helpers = {};
    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function () {
        window.focus();
        this.display.input.focus();
      },
      setOption: function (option, value) {
        var options = this.options,
          old = options[option];
        if (options[option] == value && option != "mode") {
          return;
        }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option)) {
          operation(this, optionHandlers[option])(this, value, old);
        }
        signal(this, "optionChange", this, option);
      },
      getOption: function (option) {
        return this.options[option];
      },
      getDoc: function () {
        return this.doc;
      },
      addKeyMap: function (map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function (map$$1) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i) {
          if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true;
          }
        }
      },
      addOverlay: methodOp(function (spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) {
          throw new Error("Overlays may not be stateful.");
        }
        insertSorted(this.state.overlays, {
          mode: mode,
          modeSpec: spec,
          opaque: options && options.opaque,
          priority: options && options.priority || 0
        }, function (overlay) {
          return overlay.priority;
        });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function (spec) {
        var this$1 = this;
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return;
          }
        }
      }),
      indentLine: methodOp(function (n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) {
            dir = this.options.smartIndent ? "smart" : "prev";
          } else {
            dir = dir ? "add" : "subtract";
          }
        }
        if (isLine(this.doc, n)) {
          indentLine(this, n, dir, aggressive);
        }
      }),
      indentSelection: methodOp(function (how) {
        var this$1 = this;
        var ranges = this.doc.sel.ranges,
          end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];
          if (!range$$1.empty()) {
            var from = range$$1.from(),
              to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j) {
              indentLine(this$1, j, how);
            }
            var newRanges = this$1.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
              replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
            }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;
            if (i == this$1.doc.sel.primIndex) {
              ensureCursorVisible(this$1);
            }
          }
        }
      }),
      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function (pos, precise) {
        return takeToken(this, pos, precise);
      },
      getLineTokens: function (line, precise) {
        return takeToken(this, Pos(line), precise, true);
      },
      getTokenTypeAt: function (pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0,
          after = (styles.length - 1) / 2,
          ch = pos.ch;
        var type;
        if (ch == 0) {
          type = styles[2];
        } else {
          for (;;) {
            var mid = before + after >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
              after = mid;
            } else if (styles[mid * 2 + 1] < ch) {
              before = mid + 1;
            } else {
              type = styles[mid * 2 + 2];
              break;
            }
          }
        }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
      },
      getModeAt: function (pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) {
          return mode;
        }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
      },
      getHelper: function (pos, type) {
        return this.getHelpers(pos, type)[0];
      },
      getHelpers: function (pos, type) {
        var this$1 = this;
        var found = [];
        if (!helpers.hasOwnProperty(type)) {
          return found;
        }
        var help = helpers[type],
          mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) {
            found.push(help[mode[type]]);
          }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) {
              found.push(val);
            }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1) {
            found.push(cur.val);
          }
        }
        return found;
      },
      getStateAfter: function (line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
        return getContextBefore(this, line + 1, precise).state;
      },
      cursorCoords: function (start, mode) {
        var pos,
          range$$1 = this.doc.sel.primary();
        if (start == null) {
          pos = range$$1.head;
        } else if (typeof start == "object") {
          pos = clipPos(this.doc, start);
        } else {
          pos = start ? range$$1.from() : range$$1.to();
        }
        return cursorCoords(this, pos, mode || "page");
      },
      charCoords: function (pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page");
      },
      coordsChar: function (coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top);
      },
      lineAtHeight: function (height, mode) {
        height = fromCoordSystem(this, {
          top: height,
          left: 0
        }, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset);
      },
      heightAtLine: function (line, mode, includeWidgets) {
        var end = false,
          lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) {
            line = this.doc.first;
          } else if (line > last) {
            line = last;
            end = true;
          }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {
          top: 0,
          left: 0
        }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
      },
      defaultTextHeight: function () {
        return textHeight(this.display);
      },
      defaultCharWidth: function () {
        return charWidth(this.display);
      },
      getViewport: function () {
        return {
          from: this.display.viewFrom,
          to: this.display.viewTo
        };
      },
      addWidget: function (pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom,
          left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
            hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
            top = pos.top - node.offsetHeight;
          } else if (pos.bottom + node.offsetHeight <= vspace) {
            top = pos.bottom;
          }
          if (left + node.offsetWidth > hspace) {
            left = hspace - node.offsetWidth;
          }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") {
            left = 0;
          } else if (horiz == "middle") {
            left = (display.sizer.clientWidth - node.offsetWidth) / 2;
          }
          node.style.left = left + "px";
        }
        if (scroll) {
          scrollIntoView(this, {
            left: left,
            top: top,
            right: left + node.offsetWidth,
            bottom: top + node.offsetHeight
          });
        }
      },
      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),
      execCommand: function (cmd) {
        if (commands.hasOwnProperty(cmd)) {
          return commands[cmd].call(null, this);
        }
      },
      triggerElectric: methodOp(function (text) {
        triggerElectric(this, text);
      }),
      findPosH: function (from, amount, unit, visually) {
        var this$1 = this;
        var dir = 1;
        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this$1.doc, cur, dir, unit, visually);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },
      moveH: methodOp(function (dir, unit) {
        var this$1 = this;
        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty()) {
            return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually);
          } else {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }
        }, sel_move);
      }),
      deleteH: methodOp(function (dir, unit) {
        var sel = this.doc.sel,
          doc = this.doc;
        if (sel.somethingSelected()) {
          doc.replaceSelection("", null, "+delete");
        } else {
          deleteNearSelection(this, function (range$$1) {
            var other = findPosH(doc, range$$1.head, dir, unit, false);
            return dir < 0 ? {
              from: other,
              to: range$$1.head
            } : {
              from: range$$1.head,
              to: other
            };
          });
        }
      }),
      findPosV: function (from, amount, unit, goalColumn) {
        var this$1 = this;
        var dir = 1,
          x = goalColumn;
        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this$1, cur, "div");
          if (x == null) {
            x = coords.left;
          } else {
            coords.left = x;
          }
          cur = findPosV(this$1, coords, dir, unit);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },
      moveV: methodOp(function (dir, unit) {
        var this$1 = this;
        var doc = this.doc,
          goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse) {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }
          var headPos = cursorCoords(this$1, range$$1.head, "div");
          if (range$$1.goalColumn != null) {
            headPos.left = range$$1.goalColumn;
          }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range$$1 == doc.sel.primary()) {
            addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
          }
          return pos;
        }, sel_move);
        if (goals.length) {
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            doc.sel.ranges[i].goalColumn = goals[i];
          }
        }
      }),
      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function (pos) {
        var doc = this.doc,
          line = getLine(doc, pos.line).text;
        var start = pos.ch,
          end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) {
            --start;
          } else {
            ++end;
          }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper) ? function (ch) {
            return isWordChar(ch, helper);
          } : /\s/.test(startChar) ? function (ch) {
            return /\s/.test(ch);
          } : function (ch) {
            return !/\s/.test(ch) && !isWordChar(ch);
          };
          while (start > 0 && check(line.charAt(start - 1))) {
            --start;
          }
          while (end < line.length && check(line.charAt(end))) {
            ++end;
          }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end));
      },
      toggleOverwrite: function (value) {
        if (value != null && value == this.state.overwrite) {
          return;
        }
        if (this.state.overwrite = !this.state.overwrite) {
          addClass(this.display.cursorDiv, "CodeMirror-overwrite");
        } else {
          rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
        }
        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function () {
        return this.display.input.getField() == activeElt();
      },
      isReadOnly: function () {
        return !!(this.options.readOnly || this.doc.cantEdit);
      },
      scrollTo: methodOp(function (x, y) {
        scrollToCoords(this, x, y);
      }),
      getScrollInfo: function () {
        var scroller = this.display.scroller;
        return {
          left: scroller.scrollLeft,
          top: scroller.scrollTop,
          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
          clientHeight: displayHeight(this),
          clientWidth: displayWidth(this)
        };
      },
      scrollIntoView: methodOp(function (range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = {
            from: this.doc.sel.primary().head,
            to: null
          };
          if (margin == null) {
            margin = this.options.cursorScrollMargin;
          }
        } else if (typeof range$$1 == "number") {
          range$$1 = {
            from: Pos(range$$1, 0),
            to: null
          };
        } else if (range$$1.from == null) {
          range$$1 = {
            from: range$$1,
            to: null
          };
        }
        if (!range$$1.to) {
          range$$1.to = range$$1.from;
        }
        range$$1.margin = margin || 0;
        if (range$$1.from.line != null) {
          scrollToRange(this, range$$1);
        } else {
          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
        }
      }),
      setSize: methodOp(function (width, height) {
        var this$1 = this;
        var interpret = function (val) {
          return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
        };
        if (width != null) {
          this.display.wrapper.style.width = interpret(width);
        }
        if (height != null) {
          this.display.wrapper.style.height = interpret(height);
        }
        if (this.options.lineWrapping) {
          clearLineMeasurementCache(this);
        }
        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].noHScroll) {
                regLineChange(this$1, lineNo$$1, "widget");
                break;
              }
            }
          }
          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),
      operation: function (f) {
        return runInOp(this, f);
      },
      startOperation: function () {
        return startOperation(this);
      },
      endOperation: function () {
        return endOperation(this);
      },
      refresh: methodOp(function () {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5) {
          estimateLineHeights(this);
        }
        signal(this, "refresh", this);
      }),
      swapDoc: methodOp(function (doc) {
        var old = this.doc;
        old.cm = null;
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old;
      }),
      getInputField: function () {
        return this.display.input.getField();
      },
      getWrapperElement: function () {
        return this.display.wrapper;
      },
      getScrollerElement: function () {
        return this.display.scroller;
      },
      getGutterElement: function () {
        return this.display.gutters;
      }
    };
    eventMixin(CodeMirror);
    CodeMirror.registerHelper = function (type, name, value) {
      if (!helpers.hasOwnProperty(type)) {
        helpers[type] = CodeMirror[type] = {
          _global: []
        };
      }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({
        pred: predicate,
        val: value
      });
    };
  };

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    function findNextLine() {
      var l = pos.line + dir;
      if (l < doc.first || l >= doc.first + doc.size) {
        return false;
      }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next;
      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir);
        } else {
          return false;
        }
      } else {
        pos = next;
      }
      return true;
    }
    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null,
        group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) {
          break;
        }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
        if (group && !first && !type) {
          type = "s";
        }
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
            pos.sticky = "after";
          }
          break;
        }
        if (type) {
          sawType = type;
        }
        if (dir > 0 && !moveOnce(!first)) {
          break;
        }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) {
      result.hitSide = true;
    }
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc,
      x = pos.left,
      y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) {
        break;
      }
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function (cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };
  ContentEditableInput.prototype.init = function (display) {
    var this$1 = this;
    var input = this,
      cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck);
    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) {
        setTimeout(operation(cm, function () {
          return this$1.updateFromDOM();
        }), 20);
      }
    });
    on(div, "compositionstart", function (e) {
      this$1.composing = {
        data: e.data,
        done: false
      };
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) {
        this$1.composing = {
          data: e.data,
          done: false
        };
      }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) {
          this$1.readFromDOMSoon();
        }
        this$1.composing.done = true;
      }
    });
    on(div, "touchstart", function () {
      return input.forceCompositionEnd();
    });
    on(div, "input", function () {
      if (!this$1.composing) {
        this$1.readFromDOMSoon();
      }
    });
    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({
          lineWise: false,
          text: cm.getSelections()
        });
        if (e.type == "cut") {
          cm.replaceSelection("", null, "cut");
        }
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({
          lineWise: true,
          text: ranges.text
        });
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return;
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(),
        te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) {
          input.showPrimarySelection();
        }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };
  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = this.cm.state.focused;
    return result;
  };
  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) {
      return;
    }
    if (info.focus || takeFocus) {
      this.showPrimarySelection();
    }
    this.showMultipleSelections(info);
  };
  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = window.getSelection(),
      cm = this.cm,
      prim = cm.doc.sel.primary();
    var from = prim.from(),
      to = prim.to();
    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return;
    }
    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
      return;
    }
    var view = cm.display.view;
    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
      node: view[0].measure.map[2],
      offset: 0
    };
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {
        node: map$$1[map$$1.length - 1],
        offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]
      };
    }
    if (!start || !end) {
      sel.removeAllRanges();
      return;
    }
    var old = sel.rangeCount && sel.getRangeAt(0),
      rng;
    try {
      rng = range(start.node, start.offset, end.offset, end.node);
    } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) {
        sel.addRange(old);
      } else if (gecko) {
        this.startGracePeriod();
      }
    }
    this.rememberSelection();
  };
  ContentEditableInput.prototype.startGracePeriod = function () {
    var this$1 = this;
    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged()) {
        this$1.cm.operation(function () {
          return this$1.cm.curOp.selectionChanged = true;
        });
      }
    }, 20);
  };
  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };
  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = window.getSelection();
    this.lastAnchorNode = sel.anchorNode;
    this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode;
    this.lastFocusOffset = sel.focusOffset;
  };
  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = window.getSelection();
    if (!sel.rangeCount) {
      return false;
    }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node);
  };
  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor()) {
        this.showSelection(this.prepareSelection(), true);
      }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () {
    this.div.blur();
  };
  ContentEditableInput.prototype.getField = function () {
    return this.div;
  };
  ContentEditableInput.prototype.supportsTouch = function () {
    return true;
  };
  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor()) {
      this.pollSelection();
    } else {
      runInOp(this.cm, function () {
        return input.cm.curOp.selectionChanged = true;
      });
    }
    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };
  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = window.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
  };
  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
      return;
    }
    var sel = window.getSelection(),
      cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({
        type: "keydown",
        keyCode: 8,
        preventDefault: Math.abs
      });
      this.blur();
      this.focus();
      return;
    }
    if (this.composing) {
      return;
    }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) {
      runInOp(cm, function () {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
        if (anchor.bad || head.bad) {
          cm.curOp.selectionChanged = true;
        }
      });
    }
  };
  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }
    var cm = this.cm,
      display = cm.display,
      sel = cm.doc.sel.primary();
    var from = sel.from(),
      to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine()) {
      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
    }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
      to = Pos(to.line + 1, 0);
    }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
      return false;
    }
    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }
    if (!fromNode) {
      return false;
    }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) {
        newText.pop();
        oldText.pop();
        toLine--;
      } else if (newText[0] == oldText[0]) {
        newText.shift();
        oldText.shift();
        fromLine++;
      } else {
        break;
      }
    }
    var cutFront = 0,
      cutEnd = 0;
    var newTop = newText[0],
      oldTop = oldText[0],
      maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
      ++cutFront;
    }
    var newBot = lst(newText),
      oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      ++cutEnd;
    }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }
    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true;
    }
  };
  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) {
      return;
    }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
    var this$1 = this;
    if (this.readDOMTimeout != null) {
      return;
    }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) {
          this$1.composing = null;
        } else {
          return;
        }
      }
      this$1.updateFromDOM();
    }, 80);
  };
  ContentEditableInput.prototype.updateFromDOM = function () {
    var this$1 = this;
    if (this.cm.isReadOnly() || !this.pollContent()) {
      runInOp(this.cm, function () {
        return regChange(this$1.cm);
      });
    }
  };
  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };
  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0) {
      return;
    }
    e.preventDefault();
    if (!this.cm.isReadOnly()) {
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    }
  };
  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };
  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};
  ContentEditableInput.prototype.needsContentAttribute = true;
  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) {
      return null;
    }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);
    var order = getOrder(line, cm.doc.direction),
      side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }
  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode) {
      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
        return true;
      }
    }
    return false;
  }
  function badPos(pos, bad) {
    if (bad) {
      pos.bad = true;
    }
    return pos;
  }
  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "",
      closing = false,
      lineSep = cm.doc.lineSeparator();
    function recognizeMarker(id) {
      return function (marker) {
        return marker.id == id;
      };
    }
    function close() {
      if (closing) {
        text += lineSep;
        closing = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          addText(cmText || node.textContent.replace(/\u200b/g, ""));
          return;
        }
        var markerID = node.getAttribute("cm-marker"),
          range$$1;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range$$1 = found[0].find(0))) {
            addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep));
          }
          return;
        }
        if (node.getAttribute("contenteditable") == "false") {
          return;
        }
        var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
        if (isBlock) {
          close();
        }
        for (var i = 0; i < node.childNodes.length; i++) {
          walk(node.childNodes[i]);
        }
        if (isBlock) {
          closing = true;
        }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue);
      }
    }
    for (;;) {
      walk(from);
      if (from == to) {
        break;
      }
      from = from.nextSibling;
    }
    return text;
  }
  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) {
        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      }
      node = null;
      offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) {
          return null;
        }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
          break;
        }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode) {
        return locateNodeInLineView(lineView, node, offset);
      }
    }
  }
  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild,
      bad = false;
    if (!node || !contains(wrapper, node)) {
      return badPos(Pos(lineNo(lineView.line), 0), true);
    }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }
    var textNode = node.nodeType == 3 ? node : null,
      topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) {
        offset = textNode.nodeValue.length;
      }
    }
    while (topNode.parentNode != wrapper) {
      topNode = topNode.parentNode;
    }
    var measure = lineView.measure,
      maps = measure.maps;
    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;
            if (offset < 0 || curNode != textNode) {
              ch = map$$1[j + (offset ? 1 : 0)];
            }
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) {
      return badPos(found, bad);
    }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found) {
        return badPos(Pos(found.line, found.ch - dist), bad);
      } else {
        dist += after.textContent.length;
      }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found) {
        return badPos(Pos(found.line, found.ch + dist$1), bad);
      } else {
        dist$1 += before.textContent.length;
      }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function (cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };
  TextareaInput.prototype.init = function (display) {
    var this$1 = this;
    var input = this,
      cm = this.cm;

    // Wraps and hides input textarea
    var div = this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    var te = this.textarea = div.firstChild;
    display.wrapper.insertBefore(div, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) {
      te.style.width = "0px";
    }
    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) {
        this$1.hasSelection = null;
      }
      input.poll();
    });
    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }
      cm.state.pasteIncoming = true;
      input.fastPoll();
    });
    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({
          lineWise: false,
          text: cm.getSelections()
        });
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({
          lineWise: true,
          text: ranges.text
        });
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") {
        cm.state.cutIncoming = true;
      }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);
    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
        return;
      }
      cm.state.pasteIncoming = true;
      input.focus();
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) {
        e_preventDefault(e);
      }
    });
    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) {
        input.composing.range.clear();
      }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {
          className: "CodeMirror-composing"
        })
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };
  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm,
      display = cm.display,
      doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(),
        lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
    }
    return result;
  };
  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm,
      display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) {
      return;
    }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) {
        selectInput(this.textarea);
      }
      if (ie && ie_version >= 9) {
        this.hasSelection = content;
      }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
    }
  };
  TextareaInput.prototype.getField = function () {
    return this.textarea;
  };
  TextareaInput.prototype.supportsTouch = function () {
    return false;
  };
  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try {
        this.textarea.focus();
      } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () {
    this.textarea.blur();
  };
  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };
  TextareaInput.prototype.receivedFocus = function () {
    this.slowPoll();
  };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
    var this$1 = this;
    if (this.pollingFast) {
      return;
    }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) {
        this$1.slowPoll();
      }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false,
      input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {
        missed = true;
        input.polling.set(60, p);
      } else {
        input.pollingFast = false;
        input.slowPoll();
      }
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
    var this$1 = this;
    var cm = this.cm,
      input = this.textarea,
      prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
      return false;
    }
    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) {
      return false;
    }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false;
    }
    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) {
        prevInput = "\u200b";
      }
      if (first == 0x21da) {
        this.reset();
        return this.cm.execCommand("undo");
      }
    }
    // Find the part of the input that is actually new
    var same = 0,
      l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
      ++same;
    }
    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) {
        input.value = this$1.prevInput = "";
      } else {
        this$1.prevInput = text;
      }
      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
          className: "CodeMirror-composing"
        });
      }
    });
    return true;
  };
  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) {
      this.pollingFast = false;
    }
  };
  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) {
      this.hasSelection = null;
    }
    this.fastPoll();
  };
  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this,
      cm = input.cm,
      display = cm.display,
      te = input.textarea;
    var pos = posFromMouse(cm, e),
      scrollPos = display.scroller.scrollTop;
    if (!pos || presto) {
      return;
    } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1) {
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
    }
    var oldCSS = te.style.cssText,
      oldWrapperCSS = input.wrapper.style.cssText;
    input.wrapper.style.cssText = "position: absolute";
    var wrapperBox = input.wrapper.getBoundingClientRect();
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) {
      oldScrollY = window.scrollY;
    } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) {
      window.scrollTo(null, oldScrollY);
    }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) {
      te.value = input.prevInput = " ";
    }
    input.contextMenuPending = true;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1;
        te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) {
        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
      }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || ie && ie_version < 9) {
          prepareSelectAllHack();
        }
        var i = 0,
          poll = function () {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b") {
              operation(cm, selectAll)(cm);
            } else if (i++ < 10) {
              display.detectingSelectAll = setTimeout(poll, 500);
            } else {
              display.selForContextMenu = null;
              display.input.reset();
            }
          };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (ie && ie_version >= 9) {
      prepareSelectAllHack();
    }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };
  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) {
      this.reset();
    }
    this.textarea.disabled = val == "nocursor";
  };
  TextareaInput.prototype.setUneditable = function () {};
  TextareaInput.prototype.needsContentAttribute = false;
  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex) {
      options.tabindex = textarea.tabIndex;
    }
    if (!options.placeholder && textarea.placeholder) {
      options.placeholder = textarea.placeholder;
    }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch (e) {}
      }
    }
    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () {
        return textarea;
      };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function") {
            textarea.form.submit = realSubmit;
          }
        }
      };
    };
    textarea.style.display = "none";
    var cm = CodeMirror$1(function (node) {
      return textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  }
  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror$1);
  addEditorMethods(CodeMirror$1);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) {
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
      CodeMirror$1.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
    }
  }
  eventMixin(Doc);

  // INPUT HANDLING

  CodeMirror$1.inputStyles = {
    "textarea": TextareaInput,
    "contenteditable": ContentEditableInput
  };

  // MODE DEFINITION AND QUERYING

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror$1.defineMode = function (name /*, mode, …*/) {
    if (!CodeMirror$1.defaults.mode && name != "null") {
      CodeMirror$1.defaults.mode = name;
    }
    defineMode.apply(this, arguments);
  };
  CodeMirror$1.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror$1.defineMode("null", function () {
    return {
      token: function (stream) {
        return stream.skipToEnd();
      }
    };
  });
  CodeMirror$1.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror$1.defineExtension = function (name, func) {
    CodeMirror$1.prototype[name] = func;
  };
  CodeMirror$1.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror$1.fromTextArea = fromTextArea;
  addLegacyProps(CodeMirror$1);
  CodeMirror$1.version = "5.34.0";
  return CodeMirror$1;
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/keymap/sublime.js":
/*!*******************************************************!*\
  !*** ./scripts/3rdparty/codemirror/keymap/sublime.js ***!
  \*******************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// A rough approximation of Sublime Text's keybindings
// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../lib/codemirror"), require("../addon/search/searchcursor"), require("../addon/edit/matchbrackets"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../lib/codemirror", "../addon/search/searchcursor", "../addon/edit/matchbrackets"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var cmds = CodeMirror.commands;
  var Pos = CodeMirror.Pos;

  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.
  function findPosSubword(doc, start, dir) {
    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));
    var line = doc.getLine(start.line);
    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));
    var state = "start",
      type;
    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {
      var next = line.charAt(dir < 0 ? pos - 1 : pos);
      var cat = next != "_" && CodeMirror.isWordChar(next) ? "w" : "o";
      if (cat == "w" && next.toUpperCase() == next) cat = "W";
      if (state == "start") {
        if (cat != "o") {
          state = "in";
          type = cat;
        }
      } else if (state == "in") {
        if (type != cat) {
          if (type == "w" && cat == "W" && dir < 0) pos--;
          if (type == "W" && cat == "w" && dir > 0) {
            type = "w";
            continue;
          }
          break;
        }
      }
    }
    return Pos(start.line, pos);
  }
  function moveSubword(cm, dir) {
    cm.extendSelectionsBy(function (range) {
      if (cm.display.shift || cm.doc.extend || range.empty()) return findPosSubword(cm.doc, range.head, dir);else return dir < 0 ? range.from() : range.to();
    });
  }
  cmds.goSubwordLeft = function (cm) {
    moveSubword(cm, -1);
  };
  cmds.goSubwordRight = function (cm) {
    moveSubword(cm, 1);
  };
  cmds.scrollLineUp = function (cm) {
    var info = cm.getScrollInfo();
    if (!cm.somethingSelected()) {
      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, "local");
      if (cm.getCursor().line >= visibleBottomLine) cm.execCommand("goLineUp");
    }
    cm.scrollTo(null, info.top - cm.defaultTextHeight());
  };
  cmds.scrollLineDown = function (cm) {
    var info = cm.getScrollInfo();
    if (!cm.somethingSelected()) {
      var visibleTopLine = cm.lineAtHeight(info.top, "local") + 1;
      if (cm.getCursor().line <= visibleTopLine) cm.execCommand("goLineDown");
    }
    cm.scrollTo(null, info.top + cm.defaultTextHeight());
  };
  cmds.splitSelectionByLine = function (cm) {
    var ranges = cm.listSelections(),
      lineRanges = [];
    for (var i = 0; i < ranges.length; i++) {
      var from = ranges[i].from(),
        to = ranges[i].to();
      for (var line = from.line; line <= to.line; ++line) if (!(to.line > from.line && line == to.line && to.ch == 0)) lineRanges.push({
        anchor: line == from.line ? from : Pos(line, 0),
        head: line == to.line ? to : Pos(line)
      });
    }
    cm.setSelections(lineRanges, 0);
  };
  cmds.singleSelectionTop = function (cm) {
    var range = cm.listSelections()[0];
    cm.setSelection(range.anchor, range.head, {
      scroll: false
    });
  };
  cmds.selectLine = function (cm) {
    var ranges = cm.listSelections(),
      extended = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      extended.push({
        anchor: Pos(range.from().line, 0),
        head: Pos(range.to().line + 1, 0)
      });
    }
    cm.setSelections(extended);
  };
  function insertLine(cm, above) {
    if (cm.isReadOnly()) return CodeMirror.Pass;
    cm.operation(function () {
      var len = cm.listSelections().length,
        newSelection = [],
        last = -1;
      for (var i = 0; i < len; i++) {
        var head = cm.listSelections()[i].head;
        if (head.line <= last) continue;
        var at = Pos(head.line + (above ? 0 : 1), 0);
        cm.replaceRange("\n", at, null, "+insertLine");
        cm.indentLine(at.line, null, true);
        newSelection.push({
          head: at,
          anchor: at
        });
        last = head.line + 1;
      }
      cm.setSelections(newSelection);
    });
    cm.execCommand("indentAuto");
  }
  cmds.insertLineAfter = function (cm) {
    return insertLine(cm, false);
  };
  cmds.insertLineBefore = function (cm) {
    return insertLine(cm, true);
  };
  function wordAt(cm, pos) {
    var start = pos.ch,
      end = start,
      line = cm.getLine(pos.line);
    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;
    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;
    return {
      from: Pos(pos.line, start),
      to: Pos(pos.line, end),
      word: line.slice(start, end)
    };
  }
  cmds.selectNextOccurrence = function (cm) {
    var from = cm.getCursor("from"),
      to = cm.getCursor("to");
    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;
    if (CodeMirror.cmpPos(from, to) == 0) {
      var word = wordAt(cm, from);
      if (!word.word) return;
      cm.setSelection(word.from, word.to);
      fullWord = true;
    } else {
      var text = cm.getRange(from, to);
      var query = fullWord ? new RegExp("\\b" + text + "\\b") : text;
      var cur = cm.getSearchCursor(query, to);
      var found = cur.findNext();
      if (!found) {
        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));
        found = cur.findNext();
      }
      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return CodeMirror.Pass;
      cm.addSelection(cur.from(), cur.to());
    }
    if (fullWord) cm.state.sublimeFindFullWord = cm.doc.sel;
  };
  function addCursorToSelection(cm, dir) {
    var ranges = cm.listSelections(),
      newRanges = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var newAnchor = cm.findPosV(range.anchor, dir, "line");
      var newHead = cm.findPosV(range.head, dir, "line");
      var newRange = {
        anchor: newAnchor,
        head: newHead
      };
      newRanges.push(range);
      newRanges.push(newRange);
    }
    cm.setSelections(newRanges);
  }
  cmds.addCursorToPrevLine = function (cm) {
    addCursorToSelection(cm, -1);
  };
  cmds.addCursorToNextLine = function (cm) {
    addCursorToSelection(cm, 1);
  };
  function isSelectedRange(ranges, from, to) {
    for (var i = 0; i < ranges.length; i++) if (ranges[i].from() == from && ranges[i].to() == to) return true;
    return false;
  }
  var mirror = "(){}[]";
  function selectBetweenBrackets(cm) {
    var ranges = cm.listSelections(),
      newRanges = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i],
        pos = range.head,
        opening = cm.scanForBracket(pos, -1);
      if (!opening) return false;
      for (;;) {
        var closing = cm.scanForBracket(pos, 1);
        if (!closing) return false;
        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {
          var startPos = Pos(opening.pos.line, opening.pos.ch + 1);
          if (CodeMirror.cmpPos(startPos, range.from()) == 0 && CodeMirror.cmpPos(closing.pos, range.to()) == 0) {
            opening = cm.scanForBracket(opening.pos, -1);
            if (!opening) return false;
          } else {
            newRanges.push({
              anchor: startPos,
              head: closing.pos
            });
            break;
          }
        }
        pos = Pos(closing.pos.line, closing.pos.ch + 1);
      }
    }
    cm.setSelections(newRanges);
    return true;
  }
  cmds.selectScope = function (cm) {
    selectBetweenBrackets(cm) || cm.execCommand("selectAll");
  };
  cmds.selectBetweenBrackets = function (cm) {
    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;
  };
  cmds.goToBracket = function (cm) {
    cm.extendSelectionsBy(function (range) {
      var next = cm.scanForBracket(range.head, 1);
      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;
      var prev = cm.scanForBracket(range.head, -1);
      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;
    });
  };
  cmds.swapLineUp = function (cm) {
    if (cm.isReadOnly()) return CodeMirror.Pass;
    var ranges = cm.listSelections(),
      linesToMove = [],
      at = cm.firstLine() - 1,
      newSels = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i],
        from = range.from().line - 1,
        to = range.to().line;
      newSels.push({
        anchor: Pos(range.anchor.line - 1, range.anchor.ch),
        head: Pos(range.head.line - 1, range.head.ch)
      });
      if (range.to().ch == 0 && !range.empty()) --to;
      if (from > at) linesToMove.push(from, to);else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
      at = to;
    }
    cm.operation(function () {
      for (var i = 0; i < linesToMove.length; i += 2) {
        var from = linesToMove[i],
          to = linesToMove[i + 1];
        var line = cm.getLine(from);
        cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
        if (to > cm.lastLine()) cm.replaceRange("\n" + line, Pos(cm.lastLine()), null, "+swapLine");else cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
      }
      cm.setSelections(newSels);
      cm.scrollIntoView();
    });
  };
  cmds.swapLineDown = function (cm) {
    if (cm.isReadOnly()) return CodeMirror.Pass;
    var ranges = cm.listSelections(),
      linesToMove = [],
      at = cm.lastLine() + 1;
    for (var i = ranges.length - 1; i >= 0; i--) {
      var range = ranges[i],
        from = range.to().line + 1,
        to = range.from().line;
      if (range.to().ch == 0 && !range.empty()) from--;
      if (from < at) linesToMove.push(from, to);else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
      at = to;
    }
    cm.operation(function () {
      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {
        var from = linesToMove[i],
          to = linesToMove[i + 1];
        var line = cm.getLine(from);
        if (from == cm.lastLine()) cm.replaceRange("", Pos(from - 1), Pos(from), "+swapLine");else cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
        cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
      }
      cm.scrollIntoView();
    });
  };
  cmds.toggleCommentIndented = function (cm) {
    cm.toggleComment({
      indent: true
    });
  };
  cmds.joinLines = function (cm) {
    var ranges = cm.listSelections(),
      joined = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i],
        from = range.from();
      var start = from.line,
        end = range.to().line;
      while (i < ranges.length - 1 && ranges[i + 1].from().line == end) end = ranges[++i].to().line;
      joined.push({
        start: start,
        end: end,
        anchor: !range.empty() && from
      });
    }
    cm.operation(function () {
      var offset = 0,
        ranges = [];
      for (var i = 0; i < joined.length; i++) {
        var obj = joined[i];
        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch),
          head;
        for (var line = obj.start; line <= obj.end; line++) {
          var actual = line - offset;
          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);
          if (actual < cm.lastLine()) {
            cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\s*/.exec(cm.getLine(actual + 1))[0].length));
            ++offset;
          }
        }
        ranges.push({
          anchor: anchor || head,
          head: head
        });
      }
      cm.setSelections(ranges, 0);
    });
  };
  cmds.duplicateLine = function (cm) {
    cm.operation(function () {
      var rangeCount = cm.listSelections().length;
      for (var i = 0; i < rangeCount; i++) {
        var range = cm.listSelections()[i];
        if (range.empty()) cm.replaceRange(cm.getLine(range.head.line) + "\n", Pos(range.head.line, 0));else cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());
      }
      cm.scrollIntoView();
    });
  };
  function sortLines(cm, caseSensitive) {
    if (cm.isReadOnly()) return CodeMirror.Pass;
    var ranges = cm.listSelections(),
      toSort = [],
      selected;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      if (range.empty()) continue;
      var from = range.from().line,
        to = range.to().line;
      while (i < ranges.length - 1 && ranges[i + 1].from().line == to) to = ranges[++i].to().line;
      if (!ranges[i].to().ch) to--;
      toSort.push(from, to);
    }
    if (toSort.length) selected = true;else toSort.push(cm.firstLine(), cm.lastLine());
    cm.operation(function () {
      var ranges = [];
      for (var i = 0; i < toSort.length; i += 2) {
        var from = toSort[i],
          to = toSort[i + 1];
        var start = Pos(from, 0),
          end = Pos(to);
        var lines = cm.getRange(start, end, false);
        if (caseSensitive) lines.sort();else lines.sort(function (a, b) {
          var au = a.toUpperCase(),
            bu = b.toUpperCase();
          if (au != bu) {
            a = au;
            b = bu;
          }
          return a < b ? -1 : a == b ? 0 : 1;
        });
        cm.replaceRange(lines, start, end);
        if (selected) ranges.push({
          anchor: start,
          head: Pos(to + 1, 0)
        });
      }
      if (selected) cm.setSelections(ranges, 0);
    });
  }
  cmds.sortLines = function (cm) {
    sortLines(cm, true);
  };
  cmds.sortLinesInsensitive = function (cm) {
    sortLines(cm, false);
  };
  cmds.nextBookmark = function (cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) while (marks.length) {
      var current = marks.shift();
      var found = current.find();
      if (found) {
        marks.push(current);
        return cm.setSelection(found.from, found.to);
      }
    }
  };
  cmds.prevBookmark = function (cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) while (marks.length) {
      marks.unshift(marks.pop());
      var found = marks[marks.length - 1].find();
      if (!found) marks.pop();else return cm.setSelection(found.from, found.to);
    }
  };
  cmds.toggleBookmark = function (cm) {
    var ranges = cm.listSelections();
    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);
    for (var i = 0; i < ranges.length; i++) {
      var from = ranges[i].from(),
        to = ranges[i].to();
      var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);
      for (var j = 0; j < found.length; j++) {
        if (found[j].sublimeBookmark) {
          found[j].clear();
          for (var k = 0; k < marks.length; k++) if (marks[k] == found[j]) marks.splice(k--, 1);
          break;
        }
      }
      if (j == found.length) marks.push(cm.markText(from, to, {
        sublimeBookmark: true,
        clearWhenEmpty: false
      }));
    }
  };
  cmds.clearBookmarks = function (cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();
    marks.length = 0;
  };
  cmds.selectBookmarks = function (cm) {
    var marks = cm.state.sublimeBookmarks,
      ranges = [];
    if (marks) for (var i = 0; i < marks.length; i++) {
      var found = marks[i].find();
      if (!found) marks.splice(i--, 0);else ranges.push({
        anchor: found.from,
        head: found.to
      });
    }
    if (ranges.length) cm.setSelections(ranges, 0);
  };
  function modifyWordOrSelection(cm, mod) {
    cm.operation(function () {
      var ranges = cm.listSelections(),
        indices = [],
        replacements = [];
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (range.empty()) {
          indices.push(i);
          replacements.push("");
        } else replacements.push(mod(cm.getRange(range.from(), range.to())));
      }
      cm.replaceSelections(replacements, "around", "case");
      for (var i = indices.length - 1, at; i >= 0; i--) {
        var range = ranges[indices[i]];
        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;
        var word = wordAt(cm, range.head);
        at = word.from;
        cm.replaceRange(mod(word.word), word.from, word.to);
      }
    });
  }
  cmds.smartBackspace = function (cm) {
    if (cm.somethingSelected()) return CodeMirror.Pass;
    cm.operation(function () {
      var cursors = cm.listSelections();
      var indentUnit = cm.getOption("indentUnit");
      for (var i = cursors.length - 1; i >= 0; i--) {
        var cursor = cursors[i].head;
        var toStartOfLine = cm.getRange({
          line: cursor.line,
          ch: 0
        }, cursor);
        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption("tabSize"));

        // Delete by one character by default
        var deletePos = cm.findPosH(cursor, -1, "char", false);
        if (toStartOfLine && !/\S/.test(toStartOfLine) && column % indentUnit == 0) {
          var prevIndent = new Pos(cursor.line, CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));

          // Smart delete only if we found a valid prevIndent location
          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;
        }
        cm.replaceRange("", deletePos, cursor, "+delete");
      }
    });
  };
  cmds.delLineRight = function (cm) {
    cm.operation(function () {
      var ranges = cm.listSelections();
      for (var i = ranges.length - 1; i >= 0; i--) cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");
      cm.scrollIntoView();
    });
  };
  cmds.upcaseAtCursor = function (cm) {
    modifyWordOrSelection(cm, function (str) {
      return str.toUpperCase();
    });
  };
  cmds.downcaseAtCursor = function (cm) {
    modifyWordOrSelection(cm, function (str) {
      return str.toLowerCase();
    });
  };
  cmds.setSublimeMark = function (cm) {
    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();
    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
  };
  cmds.selectToSublimeMark = function (cm) {
    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
    if (found) cm.setSelection(cm.getCursor(), found);
  };
  cmds.deleteToSublimeMark = function (cm) {
    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
    if (found) {
      var from = cm.getCursor(),
        to = found;
      if (CodeMirror.cmpPos(from, to) > 0) {
        var tmp = to;
        to = from;
        from = tmp;
      }
      cm.state.sublimeKilled = cm.getRange(from, to);
      cm.replaceRange("", from, to);
    }
  };
  cmds.swapWithSublimeMark = function (cm) {
    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
    if (found) {
      cm.state.sublimeMark.clear();
      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
      cm.setCursor(found);
    }
  };
  cmds.sublimeYank = function (cm) {
    if (cm.state.sublimeKilled != null) cm.replaceSelection(cm.state.sublimeKilled, null, "paste");
  };
  cmds.showInCenter = function (cm) {
    var pos = cm.cursorCoords(null, "local");
    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);
  };
  function getTarget(cm) {
    var from = cm.getCursor("from"),
      to = cm.getCursor("to");
    if (CodeMirror.cmpPos(from, to) == 0) {
      var word = wordAt(cm, from);
      if (!word.word) return;
      from = word.from;
      to = word.to;
    }
    return {
      from: from,
      to: to,
      query: cm.getRange(from, to),
      word: word
    };
  }
  function findAndGoTo(cm, forward) {
    var target = getTarget(cm);
    if (!target) return;
    var query = target.query;
    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);
    if (forward ? cur.findNext() : cur.findPrevious()) {
      cm.setSelection(cur.from(), cur.to());
    } else {
      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0) : cm.clipPos(Pos(cm.lastLine())));
      if (forward ? cur.findNext() : cur.findPrevious()) cm.setSelection(cur.from(), cur.to());else if (target.word) cm.setSelection(target.from, target.to);
    }
  }
  ;
  cmds.findUnder = function (cm) {
    findAndGoTo(cm, true);
  };
  cmds.findUnderPrevious = function (cm) {
    findAndGoTo(cm, false);
  };
  cmds.findAllUnder = function (cm) {
    var target = getTarget(cm);
    if (!target) return;
    var cur = cm.getSearchCursor(target.query);
    var matches = [];
    var primaryIndex = -1;
    while (cur.findNext()) {
      matches.push({
        anchor: cur.from(),
        head: cur.to()
      });
      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch) primaryIndex++;
    }
    cm.setSelections(matches, primaryIndex);
  };
  var keyMap = CodeMirror.keyMap;
  keyMap.macSublime = {
    "Cmd-Left": "goLineStartSmart",
    "Shift-Tab": "indentLess",
    "Shift-Ctrl-K": "deleteLine",
    "Alt-Q": "wrapLines",
    "Ctrl-Left": "goSubwordLeft",
    "Ctrl-Right": "goSubwordRight",
    "Ctrl-Alt-Up": "scrollLineUp",
    "Ctrl-Alt-Down": "scrollLineDown",
    "Cmd-L": "selectLine",
    "Shift-Cmd-L": "splitSelectionByLine",
    "Esc": "singleSelectionTop",
    "Cmd-Enter": "insertLineAfter",
    "Shift-Cmd-Enter": "insertLineBefore",
    "Cmd-D": "selectNextOccurrence",
    "Shift-Cmd-Space": "selectScope",
    "Shift-Cmd-M": "selectBetweenBrackets",
    "Cmd-M": "goToBracket",
    "Cmd-Ctrl-Up": "swapLineUp",
    "Cmd-Ctrl-Down": "swapLineDown",
    "Cmd-/": "toggleCommentIndented",
    "Cmd-J": "joinLines",
    "Shift-Cmd-D": "duplicateLine",
    "F9": "sortLines",
    "Cmd-F9": "sortLinesInsensitive",
    "F2": "nextBookmark",
    "Shift-F2": "prevBookmark",
    "Cmd-F2": "toggleBookmark",
    "Shift-Cmd-F2": "clearBookmarks",
    "Alt-F2": "selectBookmarks",
    "Backspace": "smartBackspace",
    "Cmd-K Cmd-K": "delLineRight",
    "Cmd-K Cmd-U": "upcaseAtCursor",
    "Cmd-K Cmd-L": "downcaseAtCursor",
    "Cmd-K Cmd-Space": "setSublimeMark",
    "Cmd-K Cmd-A": "selectToSublimeMark",
    "Cmd-K Cmd-W": "deleteToSublimeMark",
    "Cmd-K Cmd-X": "swapWithSublimeMark",
    "Cmd-K Cmd-Y": "sublimeYank",
    "Cmd-K Cmd-C": "showInCenter",
    "Cmd-K Cmd-G": "clearBookmarks",
    "Cmd-K Cmd-Backspace": "delLineLeft",
    "Cmd-K Cmd-0": "unfoldAll",
    "Cmd-K Cmd-J": "unfoldAll",
    "Ctrl-Shift-Up": "addCursorToPrevLine",
    "Ctrl-Shift-Down": "addCursorToNextLine",
    "Cmd-F3": "findUnder",
    "Shift-Cmd-F3": "findUnderPrevious",
    "Alt-F3": "findAllUnder",
    "Shift-Cmd-[": "fold",
    "Shift-Cmd-]": "unfold",
    "Cmd-I": "findIncremental",
    "Shift-Cmd-I": "findIncrementalReverse",
    "Cmd-H": "replace",
    "F3": "findNext",
    "Shift-F3": "findPrev",
    "fallthrough": "macDefault"
  };
  CodeMirror.normalizeKeyMap(keyMap.macSublime);
  keyMap.pcSublime = {
    "Shift-Tab": "indentLess",
    "Shift-Ctrl-K": "deleteLine",
    "Alt-Q": "wrapLines",
    "Ctrl-T": "transposeChars",
    "Alt-Left": "goSubwordLeft",
    "Alt-Right": "goSubwordRight",
    "Ctrl-Up": "scrollLineUp",
    "Ctrl-Down": "scrollLineDown",
    "Ctrl-L": "selectLine",
    "Shift-Ctrl-L": "splitSelectionByLine",
    "Esc": "singleSelectionTop",
    "Ctrl-Enter": "insertLineAfter",
    "Shift-Ctrl-Enter": "insertLineBefore",
    "Ctrl-D": "selectNextOccurrence",
    "Shift-Ctrl-Space": "selectScope",
    "Shift-Ctrl-M": "selectBetweenBrackets",
    "Ctrl-M": "goToBracket",
    "Shift-Ctrl-Up": "swapLineUp",
    "Shift-Ctrl-Down": "swapLineDown",
    "Ctrl-/": "toggleCommentIndented",
    "Ctrl-J": "joinLines",
    "Shift-Ctrl-D": "duplicateLine",
    "F9": "sortLines",
    "Ctrl-F9": "sortLinesInsensitive",
    "F2": "nextBookmark",
    "Shift-F2": "prevBookmark",
    "Ctrl-F2": "toggleBookmark",
    "Shift-Ctrl-F2": "clearBookmarks",
    "Alt-F2": "selectBookmarks",
    "Backspace": "smartBackspace",
    "Ctrl-K Ctrl-K": "delLineRight",
    "Ctrl-K Ctrl-U": "upcaseAtCursor",
    "Ctrl-K Ctrl-L": "downcaseAtCursor",
    "Ctrl-K Ctrl-Space": "setSublimeMark",
    "Ctrl-K Ctrl-A": "selectToSublimeMark",
    "Ctrl-K Ctrl-W": "deleteToSublimeMark",
    "Ctrl-K Ctrl-X": "swapWithSublimeMark",
    "Ctrl-K Ctrl-Y": "sublimeYank",
    "Ctrl-K Ctrl-C": "showInCenter",
    "Ctrl-K Ctrl-G": "clearBookmarks",
    "Ctrl-K Ctrl-Backspace": "delLineLeft",
    "Ctrl-K Ctrl-0": "unfoldAll",
    "Ctrl-K Ctrl-J": "unfoldAll",
    "Ctrl-Alt-Up": "addCursorToPrevLine",
    "Ctrl-Alt-Down": "addCursorToNextLine",
    "Ctrl-F3": "findUnder",
    "Shift-Ctrl-F3": "findUnderPrevious",
    "Alt-F3": "findAllUnder",
    "Shift-Ctrl-[": "fold",
    "Shift-Ctrl-]": "unfold",
    "Ctrl-I": "findIncremental",
    "Shift-Ctrl-I": "findIncrementalReverse",
    "Ctrl-H": "replace",
    "F3": "findNext",
    "Shift-F3": "findPrev",
    "fallthrough": "pcDefault"
  };
  CodeMirror.normalizeKeyMap(keyMap.pcSublime);
  var mac = keyMap.default == keyMap.macDefault;
  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;
});

/***/ }),

/***/ "./scripts/3rdparty/codemirror/mode/css.js":
/*!*************************************************!*\
  !*** ./scripts/3rdparty/codemirror/mode/css.js ***!
  \*************************************************/
/***/ (() => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  // if (typeof exports == "object" && typeof module == "object") // CommonJS
  //   mod(require("../../lib/codemirror"));
  // else if (typeof define == "function" && define.amd) // AMD
  //   define(["../../lib/codemirror"], mod);
  // else // Plain browser env
  mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("css", function (config, parserConfig) {
    var inline = parserConfig.inline;
    if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");
    var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      documentTypes = parserConfig.documentTypes || {},
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      counterDescriptors = parserConfig.counterDescriptors || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = parserConfig.allowNested,
      lineComment = parserConfig.lineComment,
      supportsAtComponent = parserConfig.supportsAtComponent === true;
    var type, override;
    function ret(style, tp) {
      type = tp;
      return style;
    }

    // Tokenizers

    function tokenBase(stream, state) {
      var ch = stream.next();
      if (tokenHooks[ch]) {
        var result = tokenHooks[ch](stream, state);
        if (result !== false) return result;
      }
      if (ch == "@") {
        stream.eatWhile(/[\w\\\-]/);
        return ret("def", stream.current());
      } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
        return ret(null, "compare");
      } else if (ch == "\"" || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "#") {
        stream.eatWhile(/[\w\\\-]/);
        return ret("atom", "hash");
      } else if (ch == "!") {
        stream.match(/^\s*\w*/);
        return ret("keyword", "important");
      } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (ch === "-") {
        if (/[\d.]/.test(stream.peek())) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        } else if (stream.match(/^-[\w\\\-]+/)) {
          stream.eatWhile(/[\w\\\-]/);
          if (stream.match(/^\s*:/, false)) return ret("variable-2", "variable-definition");
          return ret("variable-2", "variable");
        } else if (stream.match(/^\w+-/)) {
          return ret("meta", "meta");
        }
      } else if (/[,+>*\/]/.test(ch)) {
        return ret(null, "select-op");
      } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
        return ret("qualifier", "qualifier");
      } else if (/[:;{}\[\]\(\)]/.test(ch)) {
        return ret(null, ch);
      } else if ((ch == "u" || ch == "U") && stream.match(/rl(-prefix)?\(/i) || (ch == "d" || ch == "D") && stream.match("omain(", true, true) || (ch == "r" || ch == "R") && stream.match("egexp(", true, true)) {
        stream.backUp(1);
        state.tokenize = tokenParenthesized;
        return ret("property", "word");
      } else if (/[\w\\\-]/.test(ch)) {
        stream.eatWhile(/[\w\\\-]/);
        return ret("property", "word");
      } else {
        return ret(null, null);
      }
    }
    function tokenString(quote) {
      return function (stream, state) {
        var escaped = false,
          ch;
        while ((ch = stream.next()) != null) {
          if (ch == quote && !escaped) {
            if (quote == ")") stream.backUp(1);
            break;
          }
          escaped = !escaped && ch == "\\";
        }
        if (ch == quote || !escaped && quote != ")") state.tokenize = null;
        return ret("string", "string");
      };
    }
    function tokenParenthesized(stream, state) {
      stream.next(); // Must be '('
      if (!stream.match(/\s*[\"\')]/, false)) state.tokenize = tokenString(")");else state.tokenize = null;
      return ret(null, "(");
    }

    // Context management

    function Context(type, indent, prev) {
      this.type = type;
      this.indent = indent;
      this.prev = prev;
    }
    function pushContext(state, stream, type, indent) {
      state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
      return type;
    }
    function popContext(state) {
      if (state.context.prev) state.context = state.context.prev;
      return state.context.type;
    }
    function pass(type, stream, state) {
      return states[state.context.type](type, stream, state);
    }
    function popAndPass(type, stream, state, n) {
      for (var i = n || 1; i > 0; i--) state.context = state.context.prev;
      return pass(type, stream, state);
    }

    // Parser

    function wordAsValue(stream) {
      var word = stream.current().toLowerCase();
      if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "variable";
    }
    var states = {};
    states.top = function (type, stream, state) {
      if (type == "{") {
        return pushContext(state, stream, "block");
      } else if (type == "}" && state.context.prev) {
        return popContext(state);
      } else if (supportsAtComponent && /@component/i.test(type)) {
        return pushContext(state, stream, "atComponentBlock");
      } else if (/^@(-moz-)?document$/i.test(type)) {
        return pushContext(state, stream, "documentTypes");
      } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
        return pushContext(state, stream, "atBlock");
      } else if (/^@(font-face|counter-style)/i.test(type)) {
        state.stateArg = type;
        return "restricted_atBlock_before";
      } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
        return "keyframes";
      } else if (type && type.charAt(0) == "@") {
        return pushContext(state, stream, "at");
      } else if (type == "hash") {
        override = "builtin";
      } else if (type == "word") {
        override = "tag";
      } else if (type == "variable-definition") {
        return "maybeprop";
      } else if (type == "interpolation") {
        return pushContext(state, stream, "interpolation");
      } else if (type == ":") {
        return "pseudo";
      } else if (allowNested && type == "(") {
        return pushContext(state, stream, "parens");
      }
      return state.context.type;
    };
    states.block = function (type, stream, state) {
      if (type == "word") {
        var word = stream.current().toLowerCase();
        if (propertyKeywords.hasOwnProperty(word)) {
          override = "property";
          return "maybeprop";
        } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
          override = "string-2";
          return "maybeprop";
        } else if (allowNested) {
          override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
          return "block";
        } else {
          override += " error";
          return "maybeprop";
        }
      } else if (type == "meta") {
        return "block";
      } else if (!allowNested && (type == "hash" || type == "qualifier")) {
        override = "error";
        return "block";
      } else {
        return states.top(type, stream, state);
      }
    };
    states.maybeprop = function (type, stream, state) {
      if (type == ":") return pushContext(state, stream, "prop");
      return pass(type, stream, state);
    };
    states.prop = function (type, stream, state) {
      if (type == ";") return popContext(state);
      if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
      if (type == "}" || type == "{") return popAndPass(type, stream, state);
      if (type == "(") return pushContext(state, stream, "parens");
      if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
        override += " error";
      } else if (type == "word") {
        wordAsValue(stream);
      } else if (type == "interpolation") {
        return pushContext(state, stream, "interpolation");
      }
      return "prop";
    };
    states.propBlock = function (type, _stream, state) {
      if (type == "}") return popContext(state);
      if (type == "word") {
        override = "property";
        return "maybeprop";
      }
      return state.context.type;
    };
    states.parens = function (type, stream, state) {
      if (type == "{" || type == "}") return popAndPass(type, stream, state);
      if (type == ")") return popContext(state);
      if (type == "(") return pushContext(state, stream, "parens");
      if (type == "interpolation") return pushContext(state, stream, "interpolation");
      if (type == "word") wordAsValue(stream);
      return "parens";
    };
    states.pseudo = function (type, stream, state) {
      if (type == "meta") return "pseudo";
      if (type == "word") {
        override = "variable-3";
        return state.context.type;
      }
      return pass(type, stream, state);
    };
    states.documentTypes = function (type, stream, state) {
      if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
        override = "tag";
        return state.context.type;
      } else {
        return states.atBlock(type, stream, state);
      }
    };
    states.atBlock = function (type, stream, state) {
      if (type == "(") return pushContext(state, stream, "atBlock_parens");
      if (type == "}" || type == ";") return popAndPass(type, stream, state);
      if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
      if (type == "interpolation") return pushContext(state, stream, "interpolation");
      if (type == "word") {
        var word = stream.current().toLowerCase();
        if (word == "only" || word == "not" || word == "and" || word == "or") override = "keyword";else if (mediaTypes.hasOwnProperty(word)) override = "attribute";else if (mediaFeatures.hasOwnProperty(word)) override = "property";else if (mediaValueKeywords.hasOwnProperty(word)) override = "keyword";else if (propertyKeywords.hasOwnProperty(word)) override = "property";else if (nonStandardPropertyKeywords.hasOwnProperty(word)) override = "string-2";else if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "error";
      }
      return state.context.type;
    };
    states.atComponentBlock = function (type, stream, state) {
      if (type == "}") return popAndPass(type, stream, state);
      if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
      if (type == "word") override = "error";
      return state.context.type;
    };
    states.atBlock_parens = function (type, stream, state) {
      if (type == ")") return popContext(state);
      if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
      return states.atBlock(type, stream, state);
    };
    states.restricted_atBlock_before = function (type, stream, state) {
      if (type == "{") return pushContext(state, stream, "restricted_atBlock");
      if (type == "word" && state.stateArg == "@counter-style") {
        override = "variable";
        return "restricted_atBlock_before";
      }
      return pass(type, stream, state);
    };
    states.restricted_atBlock = function (type, stream, state) {
      if (type == "}") {
        state.stateArg = null;
        return popContext(state);
      }
      if (type == "word") {
        if (state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())) override = "error";else override = "property";
        return "maybeprop";
      }
      return "restricted_atBlock";
    };
    states.keyframes = function (type, stream, state) {
      if (type == "word") {
        override = "variable";
        return "keyframes";
      }
      if (type == "{") return pushContext(state, stream, "top");
      return pass(type, stream, state);
    };
    states.at = function (type, stream, state) {
      if (type == ";") return popContext(state);
      if (type == "{" || type == "}") return popAndPass(type, stream, state);
      if (type == "word") override = "tag";else if (type == "hash") override = "builtin";
      return "at";
    };
    states.interpolation = function (type, stream, state) {
      if (type == "}") return popContext(state);
      if (type == "{" || type == ";") return popAndPass(type, stream, state);
      if (type == "word") override = "variable";else if (type != "variable" && type != "(" && type != ")") override = "error";
      return "interpolation";
    };
    return {
      startState: function (base) {
        return {
          tokenize: null,
          state: inline ? "block" : "top",
          stateArg: null,
          context: new Context(inline ? "block" : "top", base || 0, null)
        };
      },
      token: function (stream, state) {
        if (!state.tokenize && stream.eatSpace()) return null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style && typeof style == "object") {
          type = style[1];
          style = style[0];
        }
        override = style;
        if (type != "comment") state.state = states[state.state](type, stream, state);
        return override;
      },
      indent: function (state, textAfter) {
        var cx = state.context,
          ch = textAfter && textAfter.charAt(0);
        var indent = cx.indent;
        if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
        if (cx.prev) {
          if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
            // Resume indentation from parent context.
            cx = cx.prev;
            indent = cx.indent;
          } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
            // Dedent relative to current context.
            indent = Math.max(0, cx.indent - indentUnit);
          }
        }
        return indent;
      },
      electricChars: "}",
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      blockCommentContinue: " * ",
      lineComment: lineComment,
      fold: "brace"
    };
  });
  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i].toLowerCase()] = true;
    }
    return keys;
  }
  var documentTypes_ = ["domain", "regexp", "url", "url-prefix"],
    documentTypes = keySet(documentTypes_);
  var mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"],
    mediaTypes = keySet(mediaTypes_);
  var mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid", "orientation", "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio", "pointer", "any-pointer", "hover", "any-hover"],
    mediaFeatures = keySet(mediaFeatures_);
  var mediaValueKeywords_ = ["landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover", "interlace", "progressive"],
    mediaValueKeywords = keySet(mediaValueKeywords_);
  var propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"],
    propertyKeywords = keySet(propertyKeywords_);
  var nonStandardPropertyKeywords_ = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"],
    nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);
  var fontProperties_ = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"],
    fontProperties = keySet(fontProperties_);
  var counterDescriptors_ = ["additive-symbols", "fallback", "negative", "pad", "prefix", "range", "speak-as", "suffix", "symbols", "system"],
    counterDescriptors = keySet(counterDescriptors_);
  var colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"],
    colorKeywords = keySet(colorKeywords_);
  var valueKeywords_ = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"],
    valueKeywords = keySet(valueKeywords_);
  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);
  function tokenCComment(stream, state) {
    var maybeEnd = false,
      ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = ch == "*";
    }
    return ["comment", "comment"];
  }
  CodeMirror.defineMIME("text/css", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    tokenHooks: {
      "/": function (stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });
  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function (stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function (stream) {
        if (stream.match(/\s*\{/, false)) return [null, null];
        return false;
      },
      "$": function (stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false)) return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function (stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });
  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function (stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function (stream) {
        if (stream.eat("{")) return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false)) return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function () {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });
  CodeMirror.defineMIME("text/x-gss", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function (stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });
});

/***/ }),

/***/ "./scripts/3rdparty/css.escape.js":
/*!****************************************!*\
  !*** ./scripts/3rdparty/css.escape.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
;
(function (root, factory) {
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if (true) {
    // For Node.js.
    module.exports = factory(root);
  } else {}
})(typeof __webpack_require__.g != 'undefined' ? __webpack_require__.g : this, function (root) {
  if (root.CSS && root.CSS.escape) {
    return root.CSS.escape;
  }

  // https://drafts.csswg.org/cssom/#serialize-an-identifier
  var cssEscape = function (value) {
    if (arguments.length == 0) {
      throw new TypeError('`CSS.escape` requires an argument.');
    }
    var string = String(value);
    var length = string.length;
    var index = -1;
    var codeUnit;
    var result = '';
    var firstCodeUnit = string.charCodeAt(0);
    while (++index < length) {
      codeUnit = string.charCodeAt(index);
      // Note: there’s no need to special-case astral symbols, surrogate
      // pairs, or lone surrogates.

      // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
      // (U+FFFD).
      if (codeUnit == 0x0000) {
        result += '\uFFFD';
        continue;
      }
      if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
      // U+007F, […]
      codeUnit >= 0x0001 && codeUnit <= 0x001F || codeUnit == 0x007F ||
      // If the character is the first character and is in the range [0-9]
      // (U+0030 to U+0039), […]
      index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
      // If the character is the second character and is in the range [0-9]
      // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]

      index == 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit == 0x002D) {
        // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
        result += '\\' + codeUnit.toString(16) + ' ';
        continue;
      }
      if (
      // If the character is the first character and is a `-` (U+002D), and
      // there is no second character, […]
      index == 0 && length == 1 && codeUnit == 0x002D) {
        result += '\\' + string.charAt(index);
        continue;
      }

      // If the character is not handled by one of the above rules and is
      // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
      // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
      // U+005A), or [a-z] (U+0061 to U+007A), […]
      if (codeUnit >= 0x0080 || codeUnit == 0x002D || codeUnit == 0x005F || codeUnit >= 0x0030 && codeUnit <= 0x0039 || codeUnit >= 0x0041 && codeUnit <= 0x005A || codeUnit >= 0x0061 && codeUnit <= 0x007A) {
        // the character itself
        result += string.charAt(index);
        continue;
      }

      // Otherwise, the escaped character.
      // https://drafts.csswg.org/cssom/#escape-a-character
      result += '\\' + string.charAt(index);
    }
    return result;
  };
  if (!root.CSS) {
    root.CSS = {};
  }
  root.CSS.escape = cssEscape;
  return cssEscape;
});

/***/ }),

/***/ "./scripts/3rdparty/csslint/csslint.js":
/*!*********************************************!*\
  !*** ./scripts/3rdparty/csslint/csslint.js ***!
  \*********************************************/
/***/ (() => {

/*!
CSSLint v1.0.4
Copyright (c) 2016 Nicole Sullivan and Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var CSSLint = function () {
  var module = module || {},
    exports = exports || {};

  /*!
  Parser-Lib
  Copyright (c) 2009-2016 Nicholas C. Zakas. All rights reserved.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  */
  /* Version v1.1.0, Build time: 6-December-2016 10:31:29 */
  var parserlib = function () {
    var require;
    require = function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == "function" && require;
            if (!u && a) return a(o, !0);
            if (i) return i(o, !0);
            var f = new Error("Cannot find module '" + o + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var l = n[o] = {
            exports: {}
          };
          t[o][0].call(l.exports, function (e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
      }
      var i = typeof require == "function" && require;
      for (var o = 0; o < r.length; o++) s(r[o]);
      return s;
    }({
      1: [function (require, module, exports) {
        "use strict";

        /* exported Colors */
        var Colors = module.exports = {
          __proto__: null,
          aliceblue: "#f0f8ff",
          antiquewhite: "#faebd7",
          aqua: "#00ffff",
          aquamarine: "#7fffd4",
          azure: "#f0ffff",
          beige: "#f5f5dc",
          bisque: "#ffe4c4",
          black: "#000000",
          blanchedalmond: "#ffebcd",
          blue: "#0000ff",
          blueviolet: "#8a2be2",
          brown: "#a52a2a",
          burlywood: "#deb887",
          cadetblue: "#5f9ea0",
          chartreuse: "#7fff00",
          chocolate: "#d2691e",
          coral: "#ff7f50",
          cornflowerblue: "#6495ed",
          cornsilk: "#fff8dc",
          crimson: "#dc143c",
          cyan: "#00ffff",
          darkblue: "#00008b",
          darkcyan: "#008b8b",
          darkgoldenrod: "#b8860b",
          darkgray: "#a9a9a9",
          darkgrey: "#a9a9a9",
          darkgreen: "#006400",
          darkkhaki: "#bdb76b",
          darkmagenta: "#8b008b",
          darkolivegreen: "#556b2f",
          darkorange: "#ff8c00",
          darkorchid: "#9932cc",
          darkred: "#8b0000",
          darksalmon: "#e9967a",
          darkseagreen: "#8fbc8f",
          darkslateblue: "#483d8b",
          darkslategray: "#2f4f4f",
          darkslategrey: "#2f4f4f",
          darkturquoise: "#00ced1",
          darkviolet: "#9400d3",
          deeppink: "#ff1493",
          deepskyblue: "#00bfff",
          dimgray: "#696969",
          dimgrey: "#696969",
          dodgerblue: "#1e90ff",
          firebrick: "#b22222",
          floralwhite: "#fffaf0",
          forestgreen: "#228b22",
          fuchsia: "#ff00ff",
          gainsboro: "#dcdcdc",
          ghostwhite: "#f8f8ff",
          gold: "#ffd700",
          goldenrod: "#daa520",
          gray: "#808080",
          grey: "#808080",
          green: "#008000",
          greenyellow: "#adff2f",
          honeydew: "#f0fff0",
          hotpink: "#ff69b4",
          indianred: "#cd5c5c",
          indigo: "#4b0082",
          ivory: "#fffff0",
          khaki: "#f0e68c",
          lavender: "#e6e6fa",
          lavenderblush: "#fff0f5",
          lawngreen: "#7cfc00",
          lemonchiffon: "#fffacd",
          lightblue: "#add8e6",
          lightcoral: "#f08080",
          lightcyan: "#e0ffff",
          lightgoldenrodyellow: "#fafad2",
          lightgray: "#d3d3d3",
          lightgrey: "#d3d3d3",
          lightgreen: "#90ee90",
          lightpink: "#ffb6c1",
          lightsalmon: "#ffa07a",
          lightseagreen: "#20b2aa",
          lightskyblue: "#87cefa",
          lightslategray: "#778899",
          lightslategrey: "#778899",
          lightsteelblue: "#b0c4de",
          lightyellow: "#ffffe0",
          lime: "#00ff00",
          limegreen: "#32cd32",
          linen: "#faf0e6",
          magenta: "#ff00ff",
          maroon: "#800000",
          mediumaquamarine: "#66cdaa",
          mediumblue: "#0000cd",
          mediumorchid: "#ba55d3",
          mediumpurple: "#9370d8",
          mediumseagreen: "#3cb371",
          mediumslateblue: "#7b68ee",
          mediumspringgreen: "#00fa9a",
          mediumturquoise: "#48d1cc",
          mediumvioletred: "#c71585",
          midnightblue: "#191970",
          mintcream: "#f5fffa",
          mistyrose: "#ffe4e1",
          moccasin: "#ffe4b5",
          navajowhite: "#ffdead",
          navy: "#000080",
          oldlace: "#fdf5e6",
          olive: "#808000",
          olivedrab: "#6b8e23",
          orange: "#ffa500",
          orangered: "#ff4500",
          orchid: "#da70d6",
          palegoldenrod: "#eee8aa",
          palegreen: "#98fb98",
          paleturquoise: "#afeeee",
          palevioletred: "#d87093",
          papayawhip: "#ffefd5",
          peachpuff: "#ffdab9",
          peru: "#cd853f",
          pink: "#ffc0cb",
          plum: "#dda0dd",
          powderblue: "#b0e0e6",
          purple: "#800080",
          red: "#ff0000",
          rosybrown: "#bc8f8f",
          royalblue: "#4169e1",
          saddlebrown: "#8b4513",
          salmon: "#fa8072",
          sandybrown: "#f4a460",
          seagreen: "#2e8b57",
          seashell: "#fff5ee",
          sienna: "#a0522d",
          silver: "#c0c0c0",
          skyblue: "#87ceeb",
          slateblue: "#6a5acd",
          slategray: "#708090",
          slategrey: "#708090",
          snow: "#fffafa",
          springgreen: "#00ff7f",
          steelblue: "#4682b4",
          tan: "#d2b48c",
          teal: "#008080",
          thistle: "#d8bfd8",
          tomato: "#ff6347",
          turquoise: "#40e0d0",
          violet: "#ee82ee",
          wheat: "#f5deb3",
          white: "#ffffff",
          whitesmoke: "#f5f5f5",
          yellow: "#ffff00",
          yellowgreen: "#9acd32",
          //'currentColor' color keyword https://www.w3.org/TR/css3-color/#currentcolor
          currentColor: "The value of the 'color' property.",
          //CSS2 system colors https://www.w3.org/TR/css3-color/#css2-system
          activeBorder: "Active window border.",
          activecaption: "Active window caption.",
          appworkspace: "Background color of multiple document interface.",
          background: "Desktop background.",
          buttonface: "The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
          buttonhighlight: "The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
          buttonshadow: "The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
          buttontext: "Text on push buttons.",
          captiontext: "Text in caption, size box, and scrollbar arrow box.",
          graytext: "Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
          greytext: "Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
          highlight: "Item(s) selected in a control.",
          highlighttext: "Text of item(s) selected in a control.",
          inactiveborder: "Inactive window border.",
          inactivecaption: "Inactive window caption.",
          inactivecaptiontext: "Color of text in an inactive caption.",
          infobackground: "Background color for tooltip controls.",
          infotext: "Text color for tooltip controls.",
          menu: "Menu background.",
          menutext: "Text in menus.",
          scrollbar: "Scroll bar gray area.",
          threeddarkshadow: "The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
          threedface: "The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
          threedhighlight: "The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
          threedlightshadow: "The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
          threedshadow: "The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
          window: "Window background.",
          windowframe: "Window frame.",
          windowtext: "Text in windows."
        };
      }, {}],
      2: [function (require, module, exports) {
        "use strict";

        module.exports = Combinator;
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Parser = require("./Parser");

        /**
         * Represents a selector combinator (whitespace, +, >).
         * @namespace parserlib.css
         * @class Combinator
         * @extends parserlib.util.SyntaxUnit
         * @constructor
         * @param {String} text The text representation of the unit.
         * @param {int} line The line of text on which the unit resides.
         * @param {int} col The column of text on which the unit resides.
         */
        function Combinator(text, line, col) {
          SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

          /**
           * The type of modifier.
           * @type String
           * @property type
           */
          this.type = "unknown";

          //pretty simple
          if (/^\s+$/.test(text)) {
            this.type = "descendant";
          } else if (text === ">") {
            this.type = "child";
          } else if (text === "+") {
            this.type = "adjacent-sibling";
          } else if (text === "~") {
            this.type = "sibling";
          }
        }
        Combinator.prototype = new SyntaxUnit();
        Combinator.prototype.constructor = Combinator;
      }, {
        "../util/SyntaxUnit": 26,
        "./Parser": 6
      }],
      3: [function (require, module, exports) {
        "use strict";

        module.exports = Matcher;
        var StringReader = require("../util/StringReader");
        var SyntaxError = require("../util/SyntaxError");

        /**
         * This class implements a combinator library for matcher functions.
         * The combinators are described at:
         * https://developer.mozilla.org/en-US/docs/Web/CSS/Value_definition_syntax#Component_value_combinators
         */
        function Matcher(matchFunc, toString) {
          this.match = function (expression) {
            // Save/restore marks to ensure that failed matches always restore
            // the original location in the expression.
            var result;
            expression.mark();
            result = matchFunc(expression);
            if (result) {
              expression.drop();
            } else {
              expression.restore();
            }
            return result;
          };
          this.toString = typeof toString === "function" ? toString : function () {
            return toString;
          };
        }

        /** Precedence table of combinators. */
        Matcher.prec = {
          MOD: 5,
          SEQ: 4,
          ANDAND: 3,
          OROR: 2,
          ALT: 1
        };

        /** Simple recursive-descent grammar to build matchers from strings. */
        Matcher.parse = function (str) {
          var reader, eat, expr, oror, andand, seq, mod, term, result;
          reader = new StringReader(str);
          eat = function (matcher) {
            var result = reader.readMatch(matcher);
            if (result === null) {
              throw new SyntaxError("Expected " + matcher, reader.getLine(), reader.getCol());
            }
            return result;
          };
          expr = function () {
            // expr = oror (" | " oror)*
            var m = [oror()];
            while (reader.readMatch(" | ") !== null) {
              m.push(oror());
            }
            return m.length === 1 ? m[0] : Matcher.alt.apply(Matcher, m);
          };
          oror = function () {
            // oror = andand ( " || " andand)*
            var m = [andand()];
            while (reader.readMatch(" || ") !== null) {
              m.push(andand());
            }
            return m.length === 1 ? m[0] : Matcher.oror.apply(Matcher, m);
          };
          andand = function () {
            // andand = seq ( " && " seq)*
            var m = [seq()];
            while (reader.readMatch(" && ") !== null) {
              m.push(seq());
            }
            return m.length === 1 ? m[0] : Matcher.andand.apply(Matcher, m);
          };
          seq = function () {
            // seq = mod ( " " mod)*
            var m = [mod()];
            while (reader.readMatch(/^ (?![&|\]])/) !== null) {
              m.push(mod());
            }
            return m.length === 1 ? m[0] : Matcher.seq.apply(Matcher, m);
          };
          mod = function () {
            // mod = term ( "?" | "*" | "+" | "#" | "{<num>,<num>}" )?
            var m = term();
            if (reader.readMatch("?") !== null) {
              return m.question();
            } else if (reader.readMatch("*") !== null) {
              return m.star();
            } else if (reader.readMatch("+") !== null) {
              return m.plus();
            } else if (reader.readMatch("#") !== null) {
              return m.hash();
            } else if (reader.readMatch(/^\{\s*/) !== null) {
              var min = eat(/^\d+/);
              eat(/^\s*,\s*/);
              var max = eat(/^\d+/);
              eat(/^\s*\}/);
              return m.braces(+min, +max);
            }
            return m;
          };
          term = function () {
            // term = <nt> | literal | "[ " expression " ]"
            if (reader.readMatch("[ ") !== null) {
              var m = expr();
              eat(" ]");
              return m;
            }
            return Matcher.fromType(eat(/^[^ ?*+#{]+/));
          };
          result = expr();
          if (!reader.eof()) {
            throw new SyntaxError("Expected end of string", reader.getLine(), reader.getCol());
          }
          return result;
        };

        /**
         * Convert a string to a matcher (parsing simple alternations),
         * or do nothing if the argument is already a matcher.
         */
        Matcher.cast = function (m) {
          if (m instanceof Matcher) {
            return m;
          }
          return Matcher.parse(m);
        };

        /**
         * Create a matcher for a single type.
         */
        Matcher.fromType = function (type) {
          // Late require of ValidationTypes to break a dependency cycle.
          var ValidationTypes = require("./ValidationTypes");
          return new Matcher(function (expression) {
            return expression.hasNext() && ValidationTypes.isType(expression, type);
          }, type);
        };

        /**
         * Create a matcher for one or more juxtaposed words, which all must
         * occur, in the given order.
         */
        Matcher.seq = function () {
          var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
          if (ms.length === 1) {
            return ms[0];
          }
          return new Matcher(function (expression) {
            var i,
              result = true;
            for (i = 0; result && i < ms.length; i++) {
              result = ms[i].match(expression);
            }
            return result;
          }, function (prec) {
            var p = Matcher.prec.SEQ;
            var s = ms.map(function (m) {
              return m.toString(p);
            }).join(" ");
            if (prec > p) {
              s = "[ " + s + " ]";
            }
            return s;
          });
        };

        /**
         * Create a matcher for one or more alternatives, where exactly one
         * must occur.
         */
        Matcher.alt = function () {
          var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);
          if (ms.length === 1) {
            return ms[0];
          }
          return new Matcher(function (expression) {
            var i,
              result = false;
            for (i = 0; !result && i < ms.length; i++) {
              result = ms[i].match(expression);
            }
            return result;
          }, function (prec) {
            var p = Matcher.prec.ALT;
            var s = ms.map(function (m) {
              return m.toString(p);
            }).join(" | ");
            if (prec > p) {
              s = "[ " + s + " ]";
            }
            return s;
          });
        };

        /**
         * Create a matcher for two or more options.  This implements the
         * double bar (||) and double ampersand (&&) operators, as well as
         * variants of && where some of the alternatives are optional.
         * This will backtrack through even successful matches to try to
         * maximize the number of items matched.
         */
        Matcher.many = function (required) {
          var ms = Array.prototype.slice.call(arguments, 1).reduce(function (acc, v) {
            if (v.expand) {
              // Insert all of the options for the given complex rule as
              // individual options.
              var ValidationTypes = require("./ValidationTypes");
              acc.push.apply(acc, ValidationTypes.complex[v.expand].options);
            } else {
              acc.push(Matcher.cast(v));
            }
            return acc;
          }, []);
          if (required === true) {
            required = ms.map(function () {
              return true;
            });
          }
          var result = new Matcher(function (expression) {
            var seen = [],
              max = 0,
              pass = 0;
            var success = function (matchCount) {
              if (pass === 0) {
                max = Math.max(matchCount, max);
                return matchCount === ms.length;
              } else {
                return matchCount === max;
              }
            };
            var tryMatch = function (matchCount) {
              for (var i = 0; i < ms.length; i++) {
                if (seen[i]) {
                  continue;
                }
                expression.mark();
                if (ms[i].match(expression)) {
                  seen[i] = true;
                  // Increase matchCount iff this was a required element
                  // (or if all the elements are optional)
                  if (tryMatch(matchCount + (required === false || required[i] ? 1 : 0))) {
                    expression.drop();
                    return true;
                  }
                  // Backtrack: try *not* matching using this rule, and
                  // let's see if it leads to a better overall match.
                  expression.restore();
                  seen[i] = false;
                } else {
                  expression.drop();
                }
              }
              return success(matchCount);
            };
            if (!tryMatch(0)) {
              // Couldn't get a complete match, retrace our steps to make the
              // match with the maximum # of required elements.
              pass++;
              tryMatch(0);
            }
            if (required === false) {
              return max > 0;
            }
            // Use finer-grained specification of which matchers are required.
            for (var i = 0; i < ms.length; i++) {
              if (required[i] && !seen[i]) {
                return false;
              }
            }
            return true;
          }, function (prec) {
            var p = required === false ? Matcher.prec.OROR : Matcher.prec.ANDAND;
            var s = ms.map(function (m, i) {
              if (required !== false && !required[i]) {
                return m.toString(Matcher.prec.MOD) + "?";
              }
              return m.toString(p);
            }).join(required === false ? " || " : " && ");
            if (prec > p) {
              s = "[ " + s + " ]";
            }
            return s;
          });
          result.options = ms;
          return result;
        };

        /**
         * Create a matcher for two or more options, where all options are
         * mandatory but they may appear in any order.
         */
        Matcher.andand = function () {
          var args = Array.prototype.slice.call(arguments);
          args.unshift(true);
          return Matcher.many.apply(Matcher, args);
        };

        /**
         * Create a matcher for two or more options, where options are
         * optional and may appear in any order, but at least one must be
         * present.
         */
        Matcher.oror = function () {
          var args = Array.prototype.slice.call(arguments);
          args.unshift(false);
          return Matcher.many.apply(Matcher, args);
        };

        /** Instance methods on Matchers. */
        Matcher.prototype = {
          constructor: Matcher,
          // These are expected to be overridden in every instance.
          match: function () {
            throw new Error("unimplemented");
          },
          toString: function () {
            throw new Error("unimplemented");
          },
          // This returns a standalone function to do the matching.
          func: function () {
            return this.match.bind(this);
          },
          // Basic combinators
          then: function (m) {
            return Matcher.seq(this, m);
          },
          or: function (m) {
            return Matcher.alt(this, m);
          },
          andand: function (m) {
            return Matcher.many(true, this, m);
          },
          oror: function (m) {
            return Matcher.many(false, this, m);
          },
          // Component value multipliers
          star: function () {
            return this.braces(0, Infinity, "*");
          },
          plus: function () {
            return this.braces(1, Infinity, "+");
          },
          question: function () {
            return this.braces(0, 1, "?");
          },
          hash: function () {
            return this.braces(1, Infinity, "#", Matcher.cast(","));
          },
          braces: function (min, max, marker, optSep) {
            var m1 = this,
              m2 = optSep ? optSep.then(this) : this;
            if (!marker) {
              marker = "{" + min + "," + max + "}";
            }
            return new Matcher(function (expression) {
              var result = true,
                i;
              for (i = 0; i < max; i++) {
                if (i > 0 && optSep) {
                  result = m2.match(expression);
                } else {
                  result = m1.match(expression);
                }
                if (!result) {
                  break;
                }
              }
              return i >= min;
            }, function () {
              return m1.toString(Matcher.prec.MOD) + marker;
            });
          }
        };
      }, {
        "../util/StringReader": 24,
        "../util/SyntaxError": 25,
        "./ValidationTypes": 21
      }],
      4: [function (require, module, exports) {
        "use strict";

        module.exports = MediaFeature;
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Parser = require("./Parser");

        /**
         * Represents a media feature, such as max-width:500.
         * @namespace parserlib.css
         * @class MediaFeature
         * @extends parserlib.util.SyntaxUnit
         * @constructor
         * @param {SyntaxUnit} name The name of the feature.
         * @param {SyntaxUnit} value The value of the feature or null if none.
         */
        function MediaFeature(name, value) {
          SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);

          /**
           * The name of the media feature
           * @type String
           * @property name
           */
          this.name = name;

          /**
           * The value for the feature or null if there is none.
           * @type SyntaxUnit
           * @property value
           */
          this.value = value;
        }
        MediaFeature.prototype = new SyntaxUnit();
        MediaFeature.prototype.constructor = MediaFeature;
      }, {
        "../util/SyntaxUnit": 26,
        "./Parser": 6
      }],
      5: [function (require, module, exports) {
        "use strict";

        module.exports = MediaQuery;
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Parser = require("./Parser");

        /**
         * Represents an individual media query.
         * @namespace parserlib.css
         * @class MediaQuery
         * @extends parserlib.util.SyntaxUnit
         * @constructor
         * @param {String} modifier The modifier "not" or "only" (or null).
         * @param {String} mediaType The type of media (i.e., "print").
         * @param {Array} parts Array of selectors parts making up this selector.
         * @param {int} line The line of text on which the unit resides.
         * @param {int} col The column of text on which the unit resides.
         */
        function MediaQuery(modifier, mediaType, features, line, col) {
          SyntaxUnit.call(this, (modifier ? modifier + " " : "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);

          /**
           * The media modifier ("not" or "only")
           * @type String
           * @property modifier
           */
          this.modifier = modifier;

          /**
           * The mediaType (i.e., "print")
           * @type String
           * @property mediaType
           */
          this.mediaType = mediaType;

          /**
           * The parts that make up the selector.
           * @type Array
           * @property features
           */
          this.features = features;
        }
        MediaQuery.prototype = new SyntaxUnit();
        MediaQuery.prototype.constructor = MediaQuery;
      }, {
        "../util/SyntaxUnit": 26,
        "./Parser": 6
      }],
      6: [function (require, module, exports) {
        "use strict";

        module.exports = Parser;
        var EventTarget = require("../util/EventTarget");
        var SyntaxError = require("../util/SyntaxError");
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Combinator = require("./Combinator");
        var MediaFeature = require("./MediaFeature");
        var MediaQuery = require("./MediaQuery");
        var PropertyName = require("./PropertyName");
        var PropertyValue = require("./PropertyValue");
        var PropertyValuePart = require("./PropertyValuePart");
        var Selector = require("./Selector");
        var SelectorPart = require("./SelectorPart");
        var SelectorSubPart = require("./SelectorSubPart");
        var TokenStream = require("./TokenStream");
        var Tokens = require("./Tokens");
        var Validation = require("./Validation");

        /**
         * A CSS3 parser.
         * @namespace parserlib.css
         * @class Parser
         * @constructor
         * @param {Object} options (Optional) Various options for the parser:
         *      starHack (true|false) to allow IE6 star hack as valid,
         *      underscoreHack (true|false) to interpret leading underscores
         *      as IE6-7 targeting for known properties, ieFilters (true|false)
         *      to indicate that IE < 8 filters should be accepted and not throw
         *      syntax errors.
         */
        function Parser(options) {
          //inherit event functionality
          EventTarget.call(this);
          this.options = options || {};
          this._tokenStream = null;
        }

        //Static constants
        Parser.DEFAULT_TYPE = 0;
        Parser.COMBINATOR_TYPE = 1;
        Parser.MEDIA_FEATURE_TYPE = 2;
        Parser.MEDIA_QUERY_TYPE = 3;
        Parser.PROPERTY_NAME_TYPE = 4;
        Parser.PROPERTY_VALUE_TYPE = 5;
        Parser.PROPERTY_VALUE_PART_TYPE = 6;
        Parser.SELECTOR_TYPE = 7;
        Parser.SELECTOR_PART_TYPE = 8;
        Parser.SELECTOR_SUB_PART_TYPE = 9;
        Parser.prototype = function () {
          var proto = new EventTarget(),
            //new prototype
            prop,
            additions = {
              __proto__: null,
              //restore constructor
              constructor: Parser,
              //instance constants - yuck
              DEFAULT_TYPE: 0,
              COMBINATOR_TYPE: 1,
              MEDIA_FEATURE_TYPE: 2,
              MEDIA_QUERY_TYPE: 3,
              PROPERTY_NAME_TYPE: 4,
              PROPERTY_VALUE_TYPE: 5,
              PROPERTY_VALUE_PART_TYPE: 6,
              SELECTOR_TYPE: 7,
              SELECTOR_PART_TYPE: 8,
              SELECTOR_SUB_PART_TYPE: 9,
              //-----------------------------------------------------------------
              // Grammar
              //-----------------------------------------------------------------

              _stylesheet: function () {
                /*
                 * stylesheet
                 *  : [ CHARSET_SYM S* STRING S* ';' ]?
                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
                 *    [ namespace [S|CDO|CDC]* ]*
                 *    [ [ ruleset | media | page | font_face | keyframes_rule | supports_rule ] [S|CDO|CDC]* ]*
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                  count,
                  token,
                  tt;
                this.fire("startstylesheet");

                //try to read character set
                this._charset();
                this._skipCruft();

                //try to read imports - may be more than one
                while (tokenStream.peek() === Tokens.IMPORT_SYM) {
                  this._import();
                  this._skipCruft();
                }

                //try to read namespaces - may be more than one
                while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
                  this._namespace();
                  this._skipCruft();
                }

                //get the next token
                tt = tokenStream.peek();

                //try to read the rest
                while (tt > Tokens.EOF) {
                  try {
                    switch (tt) {
                      case Tokens.MEDIA_SYM:
                        this._media();
                        this._skipCruft();
                        break;
                      case Tokens.PAGE_SYM:
                        this._page();
                        this._skipCruft();
                        break;
                      case Tokens.FONT_FACE_SYM:
                        this._font_face();
                        this._skipCruft();
                        break;
                      case Tokens.KEYFRAMES_SYM:
                        this._keyframes();
                        this._skipCruft();
                        break;
                      case Tokens.VIEWPORT_SYM:
                        this._viewport();
                        this._skipCruft();
                        break;
                      case Tokens.DOCUMENT_SYM:
                        this._document();
                        this._skipCruft();
                        break;
                      case Tokens.SUPPORTS_SYM:
                        this._supports();
                        this._skipCruft();
                        break;
                      case Tokens.UNKNOWN_SYM:
                        //unknown @ rule
                        tokenStream.get();
                        if (!this.options.strict) {
                          //fire error event
                          this.fire({
                            type: "error",
                            error: null,
                            message: "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                            line: tokenStream.LT(0).startLine,
                            col: tokenStream.LT(0).startCol
                          });

                          //skip braces
                          count = 0;
                          while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {
                            count++; //keep track of nesting depth
                          }

                          while (count) {
                            tokenStream.advance([Tokens.RBRACE]);
                            count--;
                          }
                        } else {
                          //not a syntax error, rethrow it
                          throw new SyntaxError("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                        }
                        break;
                      case Tokens.S:
                        this._readWhitespace();
                        break;
                      default:
                        if (!this._ruleset()) {
                          //error handling for known issues
                          switch (tt) {
                            case Tokens.CHARSET_SYM:
                              token = tokenStream.LT(1);
                              this._charset(false);
                              throw new SyntaxError("@charset not allowed here.", token.startLine, token.startCol);
                            case Tokens.IMPORT_SYM:
                              token = tokenStream.LT(1);
                              this._import(false);
                              throw new SyntaxError("@import not allowed here.", token.startLine, token.startCol);
                            case Tokens.NAMESPACE_SYM:
                              token = tokenStream.LT(1);
                              this._namespace(false);
                              throw new SyntaxError("@namespace not allowed here.", token.startLine, token.startCol);
                            default:
                              tokenStream.get(); //get the last token
                              this._unexpectedToken(tokenStream.token());
                          }
                        }
                    }
                  } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict) {
                      this.fire({
                        type: "error",
                        error: ex,
                        message: ex.message,
                        line: ex.line,
                        col: ex.col
                      });
                    } else {
                      throw ex;
                    }
                  }
                  tt = tokenStream.peek();
                }
                if (tt !== Tokens.EOF) {
                  this._unexpectedToken(tokenStream.token());
                }
                this.fire("endstylesheet");
              },
              _charset: function (emit) {
                var tokenStream = this._tokenStream,
                  charset,
                  token,
                  line,
                  col;
                if (tokenStream.match(Tokens.CHARSET_SYM)) {
                  line = tokenStream.token().startLine;
                  col = tokenStream.token().startCol;
                  this._readWhitespace();
                  tokenStream.mustMatch(Tokens.STRING);
                  token = tokenStream.token();
                  charset = token.value;
                  this._readWhitespace();
                  tokenStream.mustMatch(Tokens.SEMICOLON);
                  if (emit !== false) {
                    this.fire({
                      type: "charset",
                      charset: charset,
                      line: line,
                      col: col
                    });
                  }
                }
              },
              _import: function (emit) {
                /*
                 * import
                 *   : IMPORT_SYM S*
                 *    [STRING|URI] S* media_query_list? ';' S*
                 */

                var tokenStream = this._tokenStream,
                  uri,
                  importToken,
                  mediaList = [];

                //read import symbol
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();
                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);

                //grab the URI value
                uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");
                this._readWhitespace();
                mediaList = this._media_query_list();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();
                if (emit !== false) {
                  this.fire({
                    type: "import",
                    uri: uri,
                    media: mediaList,
                    line: importToken.startLine,
                    col: importToken.startCol
                  });
                }
              },
              _namespace: function (emit) {
                /*
                 * namespace
                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*
                 */

                var tokenStream = this._tokenStream,
                  line,
                  col,
                  prefix,
                  uri;

                //read import symbol
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();

                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT
                if (tokenStream.match(Tokens.IDENT)) {
                  prefix = tokenStream.token().value;
                  this._readWhitespace();
                }
                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                /*if (!tokenStream.match(Tokens.STRING)){
                    tokenStream.mustMatch(Tokens.URI);
                }*/

                //grab the URI value
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");
                this._readWhitespace();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();
                if (emit !== false) {
                  this.fire({
                    type: "namespace",
                    prefix: prefix,
                    uri: uri,
                    line: line,
                    col: col
                  });
                }
              },
              _supports: function (emit) {
                /*
                 * supports_rule
                 *  : SUPPORTS_SYM S* supports_condition S* group_rule_body
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                  line,
                  col;
                if (tokenStream.match(Tokens.SUPPORTS_SYM)) {
                  line = tokenStream.token().startLine;
                  col = tokenStream.token().startCol;
                  this._readWhitespace();
                  this._supports_condition();
                  this._readWhitespace();
                  tokenStream.mustMatch(Tokens.LBRACE);
                  this._readWhitespace();
                  if (emit !== false) {
                    this.fire({
                      type: "startsupports",
                      line: line,
                      col: col
                    });
                  }
                  while (true) {
                    if (!this._ruleset()) {
                      break;
                    }
                  }
                  tokenStream.mustMatch(Tokens.RBRACE);
                  this._readWhitespace();
                  this.fire({
                    type: "endsupports",
                    line: line,
                    col: col
                  });
                }
              },
              _supports_condition: function () {
                /*
                 * supports_condition
                 *  : supports_negation | supports_conjunction | supports_disjunction |
                 *    supports_condition_in_parens
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                  ident;
                if (tokenStream.match(Tokens.IDENT)) {
                  ident = tokenStream.token().value.toLowerCase();
                  if (ident === "not") {
                    tokenStream.mustMatch(Tokens.S);
                    this._supports_condition_in_parens();
                  } else {
                    tokenStream.unget();
                  }
                } else {
                  this._supports_condition_in_parens();
                  this._readWhitespace();
                  while (tokenStream.peek() === Tokens.IDENT) {
                    ident = tokenStream.LT(1).value.toLowerCase();
                    if (ident === "and" || ident === "or") {
                      tokenStream.mustMatch(Tokens.IDENT);
                      this._readWhitespace();
                      this._supports_condition_in_parens();
                      this._readWhitespace();
                    }
                  }
                }
              },
              _supports_condition_in_parens: function () {
                /*
                 * supports_condition_in_parens
                 *  : ( '(' S* supports_condition S* ')' ) | supports_declaration_condition |
                 *    general_enclosed
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                  ident;
                if (tokenStream.match(Tokens.LPAREN)) {
                  this._readWhitespace();
                  if (tokenStream.match(Tokens.IDENT)) {
                    // look ahead for not keyword, if not given, continue with declaration condition.
                    ident = tokenStream.token().value.toLowerCase();
                    if (ident === "not") {
                      this._readWhitespace();
                      this._supports_condition();
                      this._readWhitespace();
                      tokenStream.mustMatch(Tokens.RPAREN);
                    } else {
                      tokenStream.unget();
                      this._supports_declaration_condition(false);
                    }
                  } else {
                    this._supports_condition();
                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.RPAREN);
                  }
                } else {
                  this._supports_declaration_condition();
                }
              },
              _supports_declaration_condition: function (requireStartParen) {
                /*
                 * supports_declaration_condition
                 *  : '(' S* declaration ')'
                 *  ;
                 */
                var tokenStream = this._tokenStream;
                if (requireStartParen !== false) {
                  tokenStream.mustMatch(Tokens.LPAREN);
                }
                this._readWhitespace();
                this._declaration();
                tokenStream.mustMatch(Tokens.RPAREN);
              },
              _media: function () {
                /*
                 * media
                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  line,
                  col,
                  mediaList; //       = [];

                //look for @media
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();
                mediaList = this._media_query_list();
                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();
                this.fire({
                  type: "startmedia",
                  media: mediaList,
                  line: line,
                  col: col
                });
                while (true) {
                  if (tokenStream.peek() === Tokens.PAGE_SYM) {
                    this._page();
                  } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
                    this._font_face();
                  } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
                    this._viewport();
                  } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {
                    this._document();
                  } else if (tokenStream.peek() === Tokens.SUPPORTS_SYM) {
                    this._supports();
                  } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {
                    this._media();
                  } else if (!this._ruleset()) {
                    break;
                  }
                }
                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();
                this.fire({
                  type: "endmedia",
                  media: mediaList,
                  line: line,
                  col: col
                });
              },
              //CSS3 Media Queries
              _media_query_list: function () {
                /*
                 * media_query_list
                 *   : S* [media_query [ ',' S* media_query ]* ]?
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  mediaList = [];
                this._readWhitespace();
                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {
                  mediaList.push(this._media_query());
                }
                while (tokenStream.match(Tokens.COMMA)) {
                  this._readWhitespace();
                  mediaList.push(this._media_query());
                }
                return mediaList;
              },
              /*
               * Note: "expression" in the grammar maps to the _media_expression
               * method.
                */
              _media_query: function () {
                /*
                 * media_query
                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*
                 *   | expression [ AND S* expression ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  type = null,
                  ident = null,
                  token = null,
                  expressions = [];
                if (tokenStream.match(Tokens.IDENT)) {
                  ident = tokenStream.token().value.toLowerCase();

                  //since there's no custom tokens for these, need to manually check
                  if (ident !== "only" && ident !== "not") {
                    tokenStream.unget();
                    ident = null;
                  } else {
                    token = tokenStream.token();
                  }
                }
                this._readWhitespace();
                if (tokenStream.peek() === Tokens.IDENT) {
                  type = this._media_type();
                  if (token === null) {
                    token = tokenStream.token();
                  }
                } else if (tokenStream.peek() === Tokens.LPAREN) {
                  if (token === null) {
                    token = tokenStream.LT(1);
                  }
                  expressions.push(this._media_expression());
                }
                if (type === null && expressions.length === 0) {
                  return null;
                } else {
                  this._readWhitespace();
                  while (tokenStream.match(Tokens.IDENT)) {
                    if (tokenStream.token().value.toLowerCase() !== "and") {
                      this._unexpectedToken(tokenStream.token());
                    }
                    this._readWhitespace();
                    expressions.push(this._media_expression());
                  }
                }
                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
              },
              //CSS3 Media Queries
              _media_type: function () {
                /*
                 * media_type
                 *   : IDENT
                 *   ;
                 */
                return this._media_feature();
              },
              /**
               * Note: in CSS3 Media Queries, this is called "expression".
               * Renamed here to avoid conflict with CSS3 Selectors
               * definition of "expression". Also note that "expr" in the
               * grammar now maps to "expression" from CSS3 selectors.
               * @method _media_expression
               * @private
               */
              _media_expression: function () {
                /*
                 * expression
                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                  feature = null,
                  token,
                  expression = null;
                tokenStream.mustMatch(Tokens.LPAREN);
                feature = this._media_feature();
                this._readWhitespace();
                if (tokenStream.match(Tokens.COLON)) {
                  this._readWhitespace();
                  token = tokenStream.LT(1);
                  expression = this._expression();
                }
                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();
                return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);
              },
              //CSS3 Media Queries
              _media_feature: function () {
                /*
                 * media_feature
                 *   : IDENT
                 *   ;
                 */
                var tokenStream = this._tokenStream;
                this._readWhitespace();
                tokenStream.mustMatch(Tokens.IDENT);
                return SyntaxUnit.fromToken(tokenStream.token());
              },
              //CSS3 Paged Media
              _page: function () {
                /*
                 * page:
                 *    PAGE_SYM S* IDENT? pseudo_page? S*
                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                  line,
                  col,
                  identifier = null,
                  pseudoPage = null;

                //look for @page
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();
                if (tokenStream.match(Tokens.IDENT)) {
                  identifier = tokenStream.token().value;

                  //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.
                  if (identifier.toLowerCase() === "auto") {
                    this._unexpectedToken(tokenStream.token());
                  }
                }

                //see if there's a colon upcoming
                if (tokenStream.peek() === Tokens.COLON) {
                  pseudoPage = this._pseudo_page();
                }
                this._readWhitespace();
                this.fire({
                  type: "startpage",
                  id: identifier,
                  pseudo: pseudoPage,
                  line: line,
                  col: col
                });
                this._readDeclarations(true, true);
                this.fire({
                  type: "endpage",
                  id: identifier,
                  pseudo: pseudoPage,
                  line: line,
                  col: col
                });
              },
              //CSS3 Paged Media
              _margin: function () {
                /*
                 * margin :
                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                  line,
                  col,
                  marginSym = this._margin_sym();
                if (marginSym) {
                  line = tokenStream.token().startLine;
                  col = tokenStream.token().startCol;
                  this.fire({
                    type: "startpagemargin",
                    margin: marginSym,
                    line: line,
                    col: col
                  });
                  this._readDeclarations(true);
                  this.fire({
                    type: "endpagemargin",
                    margin: marginSym,
                    line: line,
                    col: col
                  });
                  return true;
                } else {
                  return false;
                }
              },
              //CSS3 Paged Media
              _margin_sym: function () {
                /*
                 * margin_sym :
                 *    TOPLEFTCORNER_SYM |
                 *    TOPLEFT_SYM |
                 *    TOPCENTER_SYM |
                 *    TOPRIGHT_SYM |
                 *    TOPRIGHTCORNER_SYM |
                 *    BOTTOMLEFTCORNER_SYM |
                 *    BOTTOMLEFT_SYM |
                 *    BOTTOMCENTER_SYM |
                 *    BOTTOMRIGHT_SYM |
                 *    BOTTOMRIGHTCORNER_SYM |
                 *    LEFTTOP_SYM |
                 *    LEFTMIDDLE_SYM |
                 *    LEFTBOTTOM_SYM |
                 *    RIGHTTOP_SYM |
                 *    RIGHTMIDDLE_SYM |
                 *    RIGHTBOTTOM_SYM
                 *    ;
                 */

                var tokenStream = this._tokenStream;
                if (tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM, Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM, Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM, Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM, Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM, Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM, Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM])) {
                  return SyntaxUnit.fromToken(tokenStream.token());
                } else {
                  return null;
                }
              },
              _pseudo_page: function () {
                /*
                 * pseudo_page
                 *   : ':' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream;
                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);

                //TODO: CSS3 Paged Media says only "left", "center", and "right" are allowed

                return tokenStream.token().value;
              },
              _font_face: function () {
                /*
                 * font_face
                 *   : FONT_FACE_SYM S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  line,
                  col;

                //look for @page
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();
                this.fire({
                  type: "startfontface",
                  line: line,
                  col: col
                });
                this._readDeclarations(true);
                this.fire({
                  type: "endfontface",
                  line: line,
                  col: col
                });
              },
              _viewport: function () {
                /*
                 * viewport
                 *   : VIEWPORT_SYM S*
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  line,
                  col;
                tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();
                this.fire({
                  type: "startviewport",
                  line: line,
                  col: col
                });
                this._readDeclarations(true);
                this.fire({
                  type: "endviewport",
                  line: line,
                  col: col
                });
              },
              _document: function () {
                /*
                 * document
                 *   : DOCUMENT_SYM S*
                 *     _document_function [ ',' S* _document_function ]* S*
                 *     '{' S* ruleset* '}'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  token,
                  functions = [],
                  prefix = "";
                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                  prefix = RegExp.$1;
                }
                this._readWhitespace();
                functions.push(this._document_function());
                while (tokenStream.match(Tokens.COMMA)) {
                  this._readWhitespace();
                  functions.push(this._document_function());
                }
                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();
                this.fire({
                  type: "startdocument",
                  functions: functions,
                  prefix: prefix,
                  line: token.startLine,
                  col: token.startCol
                });
                var ok = true;
                while (ok) {
                  switch (tokenStream.peek()) {
                    case Tokens.PAGE_SYM:
                      this._page();
                      break;
                    case Tokens.FONT_FACE_SYM:
                      this._font_face();
                      break;
                    case Tokens.VIEWPORT_SYM:
                      this._viewport();
                      break;
                    case Tokens.MEDIA_SYM:
                      this._media();
                      break;
                    case Tokens.KEYFRAMES_SYM:
                      this._keyframes();
                      break;
                    case Tokens.DOCUMENT_SYM:
                      this._document();
                      break;
                    default:
                      ok = Boolean(this._ruleset());
                  }
                }
                tokenStream.mustMatch(Tokens.RBRACE);
                token = tokenStream.token();
                this._readWhitespace();
                this.fire({
                  type: "enddocument",
                  functions: functions,
                  prefix: prefix,
                  line: token.startLine,
                  col: token.startCol
                });
              },
              _document_function: function () {
                /*
                 * document_function
                 *   : function | URI S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  value;
                if (tokenStream.match(Tokens.URI)) {
                  value = tokenStream.token().value;
                  this._readWhitespace();
                } else {
                  value = this._function();
                }
                return value;
              },
              _operator: function (inFunction) {
                /*
                 * operator (outside function)
                 *  : '/' S* | ',' S* | /( empty )/
                 * operator (inside function)
                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                  token = null;
                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) || inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS])) {
                  token = tokenStream.token();
                  this._readWhitespace();
                }
                return token ? PropertyValuePart.fromToken(token) : null;
              },
              _combinator: function () {
                /*
                 * combinator
                 *  : PLUS S* | GREATER S* | TILDE S* | S+
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                  value = null,
                  token;
                if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {
                  token = tokenStream.token();
                  value = new Combinator(token.value, token.startLine, token.startCol);
                  this._readWhitespace();
                }
                return value;
              },
              _unary_operator: function () {
                /*
                 * unary_operator
                 *  : '-' | '+'
                 *  ;
                 */

                var tokenStream = this._tokenStream;
                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {
                  return tokenStream.token().value;
                } else {
                  return null;
                }
              },
              _property: function () {
                /*
                 * property
                 *   : IDENT S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  value = null,
                  hack = null,
                  tokenValue,
                  token,
                  line,
                  col;

                //check for star hack - throws error if not allowed
                if (tokenStream.peek() === Tokens.STAR && this.options.starHack) {
                  tokenStream.get();
                  token = tokenStream.token();
                  hack = token.value;
                  line = token.startLine;
                  col = token.startCol;
                }
                if (tokenStream.match(Tokens.IDENT)) {
                  token = tokenStream.token();
                  tokenValue = token.value;

                  //check for underscore hack - no error if not allowed because it's valid CSS syntax
                  if (tokenValue.charAt(0) === "_" && this.options.underscoreHack) {
                    hack = "_";
                    tokenValue = tokenValue.substring(1);
                  }
                  value = new PropertyName(tokenValue, hack, line || token.startLine, col || token.startCol);
                  this._readWhitespace();
                }
                return value;
              },
              //Augmented with CSS3 Selectors
              _ruleset: function () {
                /*
                 * ruleset
                 *   : selectors_group
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  tt,
                  selectors;

                /*
                 * Error Recovery: If even a single selector fails to parse,
                 * then the entire ruleset should be thrown away.
                 */
                try {
                  selectors = this._selectors_group();
                } catch (ex) {
                  if (ex instanceof SyntaxError && !this.options.strict) {
                    //fire error event
                    this.fire({
                      type: "error",
                      error: ex,
                      message: ex.message,
                      line: ex.line,
                      col: ex.col
                    });

                    //skip over everything until closing brace
                    tt = tokenStream.advance([Tokens.RBRACE]);
                    if (tt === Tokens.RBRACE) {
                      //if there's a right brace, the rule is finished so don't do anything
                    } else {
                      //otherwise, rethrow the error because it wasn't handled properly
                      throw ex;
                    }
                  } else {
                    //not a syntax error, rethrow it
                    throw ex;
                  }

                  //trigger parser to continue
                  return true;
                }

                //if it got here, all selectors parsed
                if (selectors) {
                  this.fire({
                    type: "startrule",
                    selectors: selectors,
                    line: selectors[0].line,
                    col: selectors[0].col
                  });
                  this._readDeclarations(true);
                  this.fire({
                    type: "endrule",
                    selectors: selectors,
                    line: selectors[0].line,
                    col: selectors[0].col
                  });
                }
                return selectors;
              },
              //CSS3 Selectors
              _selectors_group: function () {
                /*
                 * selectors_group
                 *   : selector [ COMMA S* selector ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  selectors = [],
                  selector;
                selector = this._selector();
                if (selector !== null) {
                  selectors.push(selector);
                  while (tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    selector = this._selector();
                    if (selector !== null) {
                      selectors.push(selector);
                    } else {
                      this._unexpectedToken(tokenStream.LT(1));
                    }
                  }
                }
                return selectors.length ? selectors : null;
              },
              //CSS3 Selectors
              _selector: function () {
                /*
                 * selector
                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  selector = [],
                  nextSelector = null,
                  combinator = null,
                  ws = null;

                //if there's no simple selector, then there's no selector
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null) {
                  return null;
                }
                selector.push(nextSelector);
                do {
                  //look for a combinator
                  combinator = this._combinator();
                  if (combinator !== null) {
                    selector.push(combinator);
                    nextSelector = this._simple_selector_sequence();

                    //there must be a next selector
                    if (nextSelector === null) {
                      this._unexpectedToken(tokenStream.LT(1));
                    } else {
                      //nextSelector is an instance of SelectorPart
                      selector.push(nextSelector);
                    }
                  } else {
                    //if there's not whitespace, we're done
                    if (this._readWhitespace()) {
                      //add whitespace separator
                      ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);

                      //combinator is not required
                      combinator = this._combinator();

                      //selector is required if there's a combinator
                      nextSelector = this._simple_selector_sequence();
                      if (nextSelector === null) {
                        if (combinator !== null) {
                          this._unexpectedToken(tokenStream.LT(1));
                        }
                      } else {
                        if (combinator !== null) {
                          selector.push(combinator);
                        } else {
                          selector.push(ws);
                        }
                        selector.push(nextSelector);
                      }
                    } else {
                      break;
                    }
                  }
                } while (true);
                return new Selector(selector, selector[0].line, selector[0].col);
              },
              //CSS3 Selectors
              _simple_selector_sequence: function () {
                /*
                 * simple_selector_sequence
                 *   : [ type_selector | universal ]
                 *     [ HASH | class | attrib | pseudo | negation ]*
                 *   | [ HASH | class | attrib | pseudo | negation ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  //parts of a simple selector
                  elementName = null,
                  modifiers = [],
                  //complete selector text
                  selectorText = "",
                  //the different parts after the element name to search for
                  components = [
                  //HASH
                  function () {
                    return tokenStream.match(Tokens.HASH) ? new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) : null;
                  }, this._class, this._attrib, this._pseudo, this._negation],
                  i = 0,
                  len = components.length,
                  component = null,
                  line,
                  col;

                //get starting line and column for the selector
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;
                elementName = this._type_selector();
                if (!elementName) {
                  elementName = this._universal();
                }
                if (elementName !== null) {
                  selectorText += elementName;
                }
                while (true) {
                  //whitespace means we're done
                  if (tokenStream.peek() === Tokens.S) {
                    break;
                  }

                  //check for each component
                  while (i < len && component === null) {
                    component = components[i++].call(this);
                  }
                  if (component === null) {
                    //we don't have a selector
                    if (selectorText === "") {
                      return null;
                    } else {
                      break;
                    }
                  } else {
                    i = 0;
                    modifiers.push(component);
                    selectorText += component.toString();
                    component = null;
                  }
                }
                return selectorText !== "" ? new SelectorPart(elementName, modifiers, selectorText, line, col) : null;
              },
              //CSS3 Selectors
              _type_selector: function () {
                /*
                 * type_selector
                 *   : [ namespace_prefix ]? element_name
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  ns = this._namespace_prefix(),
                  elementName = this._element_name();
                if (!elementName) {
                  /*
                   * Need to back out the namespace that was read due to both
                   * type_selector and universal reading namespace_prefix
                   * first. Kind of hacky, but only way I can figure out
                   * right now how to not change the grammar.
                   */
                  if (ns) {
                    tokenStream.unget();
                    if (ns.length > 1) {
                      tokenStream.unget();
                    }
                  }
                  return null;
                } else {
                  if (ns) {
                    elementName.text = ns + elementName.text;
                    elementName.col -= ns.length;
                  }
                  return elementName;
                }
              },
              //CSS3 Selectors
              _class: function () {
                /*
                 * class
                 *   : '.' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  token;
                if (tokenStream.match(Tokens.DOT)) {
                  tokenStream.mustMatch(Tokens.IDENT);
                  token = tokenStream.token();
                  return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
                } else {
                  return null;
                }
              },
              //CSS3 Selectors
              _element_name: function () {
                /*
                 * element_name
                 *   : IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  token;
                if (tokenStream.match(Tokens.IDENT)) {
                  token = tokenStream.token();
                  return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);
                } else {
                  return null;
                }
              },
              //CSS3 Selectors
              _namespace_prefix: function () {
                /*
                 * namespace_prefix
                 *   : [ IDENT | '*' ]? '|'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  value = "";

                //verify that this is a namespace prefix
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {
                  if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {
                    value += tokenStream.token().value;
                  }
                  tokenStream.mustMatch(Tokens.PIPE);
                  value += "|";
                }
                return value.length ? value : null;
              },
              //CSS3 Selectors
              _universal: function () {
                /*
                 * universal
                 *   : [ namespace_prefix ]? '*'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  value = "",
                  ns;
                ns = this._namespace_prefix();
                if (ns) {
                  value += ns;
                }
                if (tokenStream.match(Tokens.STAR)) {
                  value += "*";
                }
                return value.length ? value : null;
              },
              //CSS3 Selectors
              _attrib: function () {
                /*
                 * attrib
                 *   : '[' S* [ namespace_prefix ]? IDENT S*
                 *         [ [ PREFIXMATCH |
                 *             SUFFIXMATCH |
                 *             SUBSTRINGMATCH |
                 *             '=' |
                 *             INCLUDES |
                 *             DASHMATCH ] S* [ IDENT | STRING ] S*
                 *         ]? ']'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  value = null,
                  ns,
                  token;
                if (tokenStream.match(Tokens.LBRACKET)) {
                  token = tokenStream.token();
                  value = token.value;
                  value += this._readWhitespace();
                  ns = this._namespace_prefix();
                  if (ns) {
                    value += ns;
                  }
                  tokenStream.mustMatch(Tokens.IDENT);
                  value += tokenStream.token().value;
                  value += this._readWhitespace();
                  if (tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH, Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])) {
                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                    tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                  }
                  tokenStream.mustMatch(Tokens.RBRACKET);
                  return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
                } else {
                  return null;
                }
              },
              //CSS3 Selectors
              _pseudo: function () {
                /*
                 * pseudo
                 *   : ':' ':'? [ IDENT | functional_pseudo ]
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  pseudo = null,
                  colons = ":",
                  line,
                  col;
                if (tokenStream.match(Tokens.COLON)) {
                  if (tokenStream.match(Tokens.COLON)) {
                    colons += ":";
                  }
                  if (tokenStream.match(Tokens.IDENT)) {
                    pseudo = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol - colons.length;
                  } else if (tokenStream.peek() === Tokens.FUNCTION) {
                    line = tokenStream.LT(1).startLine;
                    col = tokenStream.LT(1).startCol - colons.length;
                    pseudo = this._functional_pseudo();
                  }
                  if (pseudo) {
                    pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
                  } else {
                    var startLine = tokenStream.LT(1).startLine,
                      startCol = tokenStream.LT(0).startCol;
                    throw new SyntaxError("Expected a `FUNCTION` or `IDENT` after colon at line " + startLine + ", col " + startCol + ".", startLine, startCol);
                  }
                }
                return pseudo;
              },
              //CSS3 Selectors
              _functional_pseudo: function () {
                /*
                 * functional_pseudo
                 *   : FUNCTION S* expression ')'
                 *   ;
                */

                var tokenStream = this._tokenStream,
                  value = null;
                if (tokenStream.match(Tokens.FUNCTION)) {
                  value = tokenStream.token().value;
                  value += this._readWhitespace();
                  value += this._expression();
                  tokenStream.mustMatch(Tokens.RPAREN);
                  value += ")";
                }
                return value;
              },
              //CSS3 Selectors
              _expression: function () {
                /*
                 * expression
                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  value = "";
                while (tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION, Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH, Tokens.FREQ, Tokens.ANGLE, Tokens.TIME, Tokens.RESOLUTION, Tokens.SLASH])) {
                  value += tokenStream.token().value;
                  value += this._readWhitespace();
                }
                return value.length ? value : null;
              },
              //CSS3 Selectors
              _negation: function () {
                /*
                 * negation
                 *   : NOT S* negation_arg S* ')'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  line,
                  col,
                  value = "",
                  arg,
                  subpart = null;
                if (tokenStream.match(Tokens.NOT)) {
                  value = tokenStream.token().value;
                  line = tokenStream.token().startLine;
                  col = tokenStream.token().startCol;
                  value += this._readWhitespace();
                  arg = this._negation_arg();
                  value += arg;
                  value += this._readWhitespace();
                  tokenStream.match(Tokens.RPAREN);
                  value += tokenStream.token().value;
                  subpart = new SelectorSubPart(value, "not", line, col);
                  subpart.args.push(arg);
                }
                return subpart;
              },
              //CSS3 Selectors
              _negation_arg: function () {
                /*
                 * negation_arg
                 *   : type_selector | universal | HASH | class | attrib | pseudo
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  args = [this._type_selector, this._universal, function () {
                    return tokenStream.match(Tokens.HASH) ? new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) : null;
                  }, this._class, this._attrib, this._pseudo],
                  arg = null,
                  i = 0,
                  len = args.length,
                  line,
                  col,
                  part;
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;
                while (i < len && arg === null) {
                  arg = args[i].call(this);
                  i++;
                }

                //must be a negation arg
                if (arg === null) {
                  this._unexpectedToken(tokenStream.LT(1));
                }

                //it's an element name
                if (arg.type === "elementName") {
                  part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                  part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }
                return part;
              },
              _declaration: function () {
                /*
                 * declaration
                 *   : property ':' S* expr prio?
                 *   | /( empty )/
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  property = null,
                  expr = null,
                  prio = null,
                  invalid = null,
                  propertyName = "";
                property = this._property();
                if (property !== null) {
                  tokenStream.mustMatch(Tokens.COLON);
                  this._readWhitespace();
                  expr = this._expr();

                  //if there's no parts for the value, it's an error
                  if (!expr || expr.length === 0) {
                    this._unexpectedToken(tokenStream.LT(1));
                  }
                  prio = this._prio();

                  /*
                   * If hacks should be allowed, then only check the root
                   * property. If hacks should not be allowed, treat
                   * _property or *property as invalid properties.
                   */
                  propertyName = property.toString();
                  if (this.options.starHack && property.hack === "*" || this.options.underscoreHack && property.hack === "_") {
                    propertyName = property.text;
                  }
                  try {
                    this._validateProperty(propertyName, expr);
                  } catch (ex) {
                    invalid = ex;
                  }
                  this.fire({
                    type: "property",
                    property: property,
                    value: expr,
                    important: prio,
                    line: property.line,
                    col: property.col,
                    invalid: invalid
                  });
                  return true;
                } else {
                  return false;
                }
              },
              _prio: function () {
                /*
                 * prio
                 *   : IMPORTANT_SYM S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  result = tokenStream.match(Tokens.IMPORTANT_SYM);
                this._readWhitespace();
                return result;
              },
              _expr: function (inFunction) {
                /*
                 * expr
                 *   : term [ operator term ]*
                 *   ;
                 */

                var values = [],
                  //valueParts    = [],
                  value = null,
                  operator = null;
                value = this._term(inFunction);
                if (value !== null) {
                  values.push(value);
                  do {
                    operator = this._operator(inFunction);

                    //if there's an operator, keep building up the value parts
                    if (operator) {
                      values.push(operator);
                    } /*else {
                        //if there's not an operator, you have a full value
                        values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                        valueParts = [];
                      }*/

                    value = this._term(inFunction);
                    if (value === null) {
                      break;
                    } else {
                      values.push(value);
                    }
                  } while (true);
                }

                //cleanup
                /*if (valueParts.length) {
                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                }*/

                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
              },
              _term: function (inFunction) {
                /*
                 * term
                 *   : unary_operator?
                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |
                 *       TIME S* | FREQ S* | function | ie_function ]
                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  unary = null,
                  value = null,
                  endChar = null,
                  part = null,
                  token,
                  line,
                  col;

                //returns the operator or null
                unary = this._unary_operator();
                if (unary !== null) {
                  line = tokenStream.token().startLine;
                  col = tokenStream.token().startCol;
                }

                //exception for IE filters
                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters) {
                  value = this._ie_function();
                  if (unary === null) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                  }

                  //see if it's a simple block
                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {
                  token = tokenStream.token();
                  endChar = token.endChar;
                  value = token.value + this._expr(inFunction).text;
                  if (unary === null) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                  }
                  tokenStream.mustMatch(Tokens.type(endChar));
                  value += endChar;
                  this._readWhitespace();

                  //see if there's a simple match
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH, Tokens.ANGLE, Tokens.TIME, Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {
                  value = tokenStream.token().value;
                  if (unary === null) {
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    // Correct potentially-inaccurate IDENT parsing in
                    // PropertyValuePart constructor.
                    part = PropertyValuePart.fromToken(tokenStream.token());
                  }
                  this._readWhitespace();
                } else {
                  //see if it's a color
                  token = this._hexcolor();
                  if (token === null) {
                    //if there's no unary, get the start of the next token for line/col info
                    if (unary === null) {
                      line = tokenStream.LT(1).startLine;
                      col = tokenStream.LT(1).startCol;
                    }

                    //has to be a function
                    if (value === null) {
                      /*
                       * This checks for alpha(opacity=0) style of IE
                       * functions. IE_FUNCTION only presents progid: style.
                       */
                      if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters) {
                        value = this._ie_function();
                      } else {
                        value = this._function();
                      }
                    }

                    /*if (value === null) {
                        return null;
                        //throw new Error("Expected identifier at line " + tokenStream.token().startLine + ", character " +  tokenStream.token().startCol + ".");
                    }*/
                  } else {
                    value = token.value;
                    if (unary === null) {
                      line = token.startLine;
                      col = token.startCol;
                    }
                  }
                }
                return part !== null ? part : value !== null ? new PropertyValuePart(unary !== null ? unary + value : value, line, col) : null;
              },
              _function: function () {
                /*
                 * function
                 *   : FUNCTION S* expr ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  functionText = null,
                  expr = null,
                  lt;
                if (tokenStream.match(Tokens.FUNCTION)) {
                  functionText = tokenStream.token().value;
                  this._readWhitespace();
                  expr = this._expr(true);
                  functionText += expr;

                  //START: Horrible hack in case it's an IE filter
                  if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS) {
                    do {
                      if (this._readWhitespace()) {
                        functionText += tokenStream.token().value;
                      }

                      //might be second time in the loop
                      if (tokenStream.LA(0) === Tokens.COMMA) {
                        functionText += tokenStream.token().value;
                      }
                      tokenStream.match(Tokens.IDENT);
                      functionText += tokenStream.token().value;
                      tokenStream.match(Tokens.EQUALS);
                      functionText += tokenStream.token().value;

                      //functionText += this._term();
                      lt = tokenStream.peek();
                      while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                        tokenStream.get();
                        functionText += tokenStream.token().value;
                        lt = tokenStream.peek();
                      }
                    } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
                  }

                  //END: Horrible Hack

                  tokenStream.match(Tokens.RPAREN);
                  functionText += ")";
                  this._readWhitespace();
                }
                return functionText;
              },
              _ie_function: function () {
                /* (My own extension)
                 * ie_function
                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  functionText = null,
                  lt;

                //IE function can begin like a regular function, too
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {
                  functionText = tokenStream.token().value;
                  do {
                    if (this._readWhitespace()) {
                      functionText += tokenStream.token().value;
                    }

                    //might be second time in the loop
                    if (tokenStream.LA(0) === Tokens.COMMA) {
                      functionText += tokenStream.token().value;
                    }
                    tokenStream.match(Tokens.IDENT);
                    functionText += tokenStream.token().value;
                    tokenStream.match(Tokens.EQUALS);
                    functionText += tokenStream.token().value;

                    //functionText += this._term();
                    lt = tokenStream.peek();
                    while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                      tokenStream.get();
                      functionText += tokenStream.token().value;
                      lt = tokenStream.peek();
                    }
                  } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
                  tokenStream.match(Tokens.RPAREN);
                  functionText += ")";
                  this._readWhitespace();
                }
                return functionText;
              },
              _hexcolor: function () {
                /*
                 * There is a constraint on the color that it must
                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
                 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
                 *
                 * hexcolor
                 *   : HASH S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  token = null,
                  color;
                if (tokenStream.match(Tokens.HASH)) {
                  //need to do some validation here

                  token = tokenStream.token();
                  color = token.value;
                  if (!/#[a-f0-9]{3,6}/i.test(color)) {
                    throw new SyntaxError("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
                  }
                  this._readWhitespace();
                }
                return token;
              },
              //-----------------------------------------------------------------
              // Animations methods
              //-----------------------------------------------------------------

              _keyframes: function () {
                /*
                 * keyframes:
                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  token,
                  tt,
                  name,
                  prefix = "";
                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                  prefix = RegExp.$1;
                }
                this._readWhitespace();
                name = this._keyframe_name();
                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);
                this.fire({
                  type: "startkeyframes",
                  name: name,
                  prefix: prefix,
                  line: token.startLine,
                  col: token.startCol
                });
                this._readWhitespace();
                tt = tokenStream.peek();

                //check for key
                while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
                  this._keyframe_rule();
                  this._readWhitespace();
                  tt = tokenStream.peek();
                }
                this.fire({
                  type: "endkeyframes",
                  name: name,
                  prefix: prefix,
                  line: token.startLine,
                  col: token.startCol
                });
                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();
              },
              _keyframe_name: function () {
                /*
                 * keyframe_name:
                 *   : IDENT
                 *   | STRING
                 *   ;
                 */
                var tokenStream = this._tokenStream;
                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());
              },
              _keyframe_rule: function () {
                /*
                 * keyframe_rule:
                 *   : key_list S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var keyList = this._key_list();
                this.fire({
                  type: "startkeyframerule",
                  keys: keyList,
                  line: keyList[0].line,
                  col: keyList[0].col
                });
                this._readDeclarations(true);
                this.fire({
                  type: "endkeyframerule",
                  keys: keyList,
                  line: keyList[0].line,
                  col: keyList[0].col
                });
              },
              _key_list: function () {
                /*
                 * key_list:
                 *   : key [ S* ',' S* key]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                  keyList = [];

                //must be least one key
                keyList.push(this._key());
                this._readWhitespace();
                while (tokenStream.match(Tokens.COMMA)) {
                  this._readWhitespace();
                  keyList.push(this._key());
                  this._readWhitespace();
                }
                return keyList;
              },
              _key: function () {
                /*
                 * There is a restriction that IDENT can be only "from" or "to".
                 *
                 * key
                 *   : PERCENTAGE
                 *   | IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                  token;
                if (tokenStream.match(Tokens.PERCENTAGE)) {
                  return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)) {
                  token = tokenStream.token();
                  if (/from|to/i.test(token.value)) {
                    return SyntaxUnit.fromToken(token);
                  }
                  tokenStream.unget();
                }

                //if it gets here, there wasn't a valid token, so time to explode
                this._unexpectedToken(tokenStream.LT(1));
              },
              //-----------------------------------------------------------------
              // Helper methods
              //-----------------------------------------------------------------

              /**
               * Not part of CSS grammar, but useful for skipping over
               * combination of white space and HTML-style comments.
               * @return {void}
               * @method _skipCruft
               * @private
               */
              _skipCruft: function () {
                while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {
                  //noop
                }
              },
              /**
               * Not part of CSS grammar, but this pattern occurs frequently
               * in the official CSS grammar. Split out here to eliminate
               * duplicate code.
               * @param {Boolean} checkStart Indicates if the rule should check
               *      for the left brace at the beginning.
               * @param {Boolean} readMargins Indicates if the rule should check
               *      for margin patterns.
               * @return {void}
               * @method _readDeclarations
               * @private
               */
              _readDeclarations: function (checkStart, readMargins) {
                /*
                 * Reads the pattern
                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*
                 * or
                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.
                 * A semicolon is only necessary following a declaration if there's another declaration
                 * or margin afterwards.
                 */
                var tokenStream = this._tokenStream,
                  tt;
                this._readWhitespace();
                if (checkStart) {
                  tokenStream.mustMatch(Tokens.LBRACE);
                }
                this._readWhitespace();
                try {
                  while (true) {
                    if (tokenStream.match(Tokens.SEMICOLON) || readMargins && this._margin()) {
                      //noop
                    } else if (this._declaration()) {
                      if (!tokenStream.match(Tokens.SEMICOLON)) {
                        break;
                      }
                    } else {
                      break;
                    }

                    //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){
                    //    break;
                    //}
                    this._readWhitespace();
                  }
                  tokenStream.mustMatch(Tokens.RBRACE);
                  this._readWhitespace();
                } catch (ex) {
                  if (ex instanceof SyntaxError && !this.options.strict) {
                    //fire error event
                    this.fire({
                      type: "error",
                      error: ex,
                      message: ex.message,
                      line: ex.line,
                      col: ex.col
                    });

                    //see if there's another declaration
                    tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                    if (tt === Tokens.SEMICOLON) {
                      //if there's a semicolon, then there might be another declaration
                      this._readDeclarations(false, readMargins);
                    } else if (tt !== Tokens.RBRACE) {
                      //if there's a right brace, the rule is finished so don't do anything
                      //otherwise, rethrow the error because it wasn't handled properly
                      throw ex;
                    }
                  } else {
                    //not a syntax error, rethrow it
                    throw ex;
                  }
                }
              },
              /**
               * In some cases, you can end up with two white space tokens in a
               * row. Instead of making a change in every function that looks for
               * white space, this function is used to match as much white space
               * as necessary.
               * @method _readWhitespace
               * @return {String} The white space if found, empty string if not.
               * @private
               */
              _readWhitespace: function () {
                var tokenStream = this._tokenStream,
                  ws = "";
                while (tokenStream.match(Tokens.S)) {
                  ws += tokenStream.token().value;
                }
                return ws;
              },
              /**
               * Throws an error when an unexpected token is found.
               * @param {Object} token The token that was found.
               * @method _unexpectedToken
               * @return {void}
               * @private
               */
              _unexpectedToken: function (token) {
                throw new SyntaxError("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
              },
              /**
               * Helper method used for parsing subparts of a style sheet.
               * @return {void}
               * @method _verifyEnd
               * @private
               */
              _verifyEnd: function () {
                if (this._tokenStream.LA(1) !== Tokens.EOF) {
                  this._unexpectedToken(this._tokenStream.LT(1));
                }
              },
              //-----------------------------------------------------------------
              // Validation methods
              //-----------------------------------------------------------------
              _validateProperty: function (property, value) {
                Validation.validate(property, value);
              },
              //-----------------------------------------------------------------
              // Parsing methods
              //-----------------------------------------------------------------

              parse: function (input) {
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
              },
              parseStyleSheet: function (input) {
                //just passthrough
                return this.parse(input);
              },
              parseMediaQuery: function (input) {
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
              },
              /**
               * Parses a property value (everything after the semicolon).
               * @return {parserlib.css.PropertyValue} The property value.
               * @throws parserlib.util.SyntaxError If an unexpected token is found.
               * @method parserPropertyValue
               */
              parsePropertyValue: function (input) {
                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();
                var result = this._expr();

                //okay to have a trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
              },
              /**
               * Parses a complete CSS rule, including selectors and
               * properties.
               * @param {String} input The text to parser.
               * @return {Boolean} True if the parse completed successfully, false if not.
               * @method parseRule
               */
              parseRule: function (input) {
                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();
                var result = this._ruleset();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
              },
              /**
               * Parses a single CSS selector (no comma)
               * @param {String} input The text to parse as a CSS selector.
               * @return {Selector} An object representing the selector.
               * @throws parserlib.util.SyntaxError If an unexpected token is found.
               * @method parseSelector
               */
              parseSelector: function (input) {
                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();
                var result = this._selector();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
              },
              /**
               * Parses an HTML style attribute: a set of CSS declarations
               * separated by semicolons.
               * @param {String} input The text to parse as a style attribute
               * @return {void}
               * @method parseStyleAttribute
               */
              parseStyleAttribute: function (input) {
                input += "}"; // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
              }
            };

          //copy over onto prototype
          for (prop in additions) {
            if (Object.prototype.hasOwnProperty.call(additions, prop)) {
              proto[prop] = additions[prop];
            }
          }
          return proto;
        }();

        /*
        nth
          : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
                 ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
          ;
        */
      }, {
        "../util/EventTarget": 23,
        "../util/SyntaxError": 25,
        "../util/SyntaxUnit": 26,
        "./Combinator": 2,
        "./MediaFeature": 4,
        "./MediaQuery": 5,
        "./PropertyName": 8,
        "./PropertyValue": 9,
        "./PropertyValuePart": 11,
        "./Selector": 13,
        "./SelectorPart": 14,
        "./SelectorSubPart": 15,
        "./TokenStream": 17,
        "./Tokens": 18,
        "./Validation": 19
      }],
      7: [function (require, module, exports) {
        "use strict";

        /* exported Properties */
        var Properties = module.exports = {
          __proto__: null,
          //A
          "align-items": "flex-start | flex-end | center | baseline | stretch",
          "align-content": "flex-start | flex-end | center | space-between | space-around | stretch",
          "align-self": "auto | flex-start | flex-end | center | baseline | stretch",
          "all": "initial | inherit | unset",
          "-webkit-align-items": "flex-start | flex-end | center | baseline | stretch",
          "-webkit-align-content": "flex-start | flex-end | center | space-between | space-around | stretch",
          "-webkit-align-self": "auto | flex-start | flex-end | center | baseline | stretch",
          "alignment-adjust": "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
          "alignment-baseline": "auto | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
          "animation": 1,
          "animation-delay": "<time>#",
          "animation-direction": "<single-animation-direction>#",
          "animation-duration": "<time>#",
          "animation-fill-mode": "[ none | forwards | backwards | both ]#",
          "animation-iteration-count": "[ <number> | infinite ]#",
          "animation-name": "[ none | <single-animation-name> ]#",
          "animation-play-state": "[ running | paused ]#",
          "animation-timing-function": 1,
          //vendor prefixed
          "-moz-animation-delay": "<time>#",
          "-moz-animation-direction": "[ normal | alternate ]#",
          "-moz-animation-duration": "<time>#",
          "-moz-animation-iteration-count": "[ <number> | infinite ]#",
          "-moz-animation-name": "[ none | <single-animation-name> ]#",
          "-moz-animation-play-state": "[ running | paused ]#",
          "-ms-animation-delay": "<time>#",
          "-ms-animation-direction": "[ normal | alternate ]#",
          "-ms-animation-duration": "<time>#",
          "-ms-animation-iteration-count": "[ <number> | infinite ]#",
          "-ms-animation-name": "[ none | <single-animation-name> ]#",
          "-ms-animation-play-state": "[ running | paused ]#",
          "-webkit-animation-delay": "<time>#",
          "-webkit-animation-direction": "[ normal | alternate ]#",
          "-webkit-animation-duration": "<time>#",
          "-webkit-animation-fill-mode": "[ none | forwards | backwards | both ]#",
          "-webkit-animation-iteration-count": "[ <number> | infinite ]#",
          "-webkit-animation-name": "[ none | <single-animation-name> ]#",
          "-webkit-animation-play-state": "[ running | paused ]#",
          "-o-animation-delay": "<time>#",
          "-o-animation-direction": "[ normal | alternate ]#",
          "-o-animation-duration": "<time>#",
          "-o-animation-iteration-count": "[ <number> | infinite ]#",
          "-o-animation-name": "[ none | <single-animation-name> ]#",
          "-o-animation-play-state": "[ running | paused ]#",
          "appearance": "none | auto",
          "-moz-appearance": "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
          "-ms-appearance": "none | icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal",
          "-webkit-appearance": "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox	| listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button	| media-seek-forward-button	| media-slider | media-sliderthumb | menulist	| menulist-button	| menulist-text	| menulist-textfield | push-button	| radio	| searchfield	| searchfield-cancel-button	| searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical	| square-button	| textarea	| textfield	| scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical",
          "-o-appearance": "none | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal",
          "azimuth": "<azimuth>",
          //B
          "backface-visibility": "visible | hidden",
          "background": 1,
          "background-attachment": "<attachment>#",
          "background-clip": "<box>#",
          "background-color": "<color>",
          "background-image": "<bg-image>#",
          "background-origin": "<box>#",
          "background-position": "<bg-position>",
          "background-repeat": "<repeat-style>#",
          "background-size": "<bg-size>#",
          "baseline-shift": "baseline | sub | super | <percentage> | <length>",
          "behavior": 1,
          "binding": 1,
          "bleed": "<length>",
          "bookmark-label": "<content> | <attr> | <string>",
          "bookmark-level": "none | <integer>",
          "bookmark-state": "open | closed",
          "bookmark-target": "none | <uri> | <attr>",
          "border": "<border-width> || <border-style> || <color>",
          "border-bottom": "<border-width> || <border-style> || <color>",
          "border-bottom-color": "<color>",
          "border-bottom-left-radius": "<x-one-radius>",
          "border-bottom-right-radius": "<x-one-radius>",
          "border-bottom-style": "<border-style>",
          "border-bottom-width": "<border-width>",
          "border-collapse": "collapse | separate",
          "border-color": "<color>{1,4}",
          "border-image": 1,
          "border-image-outset": "[ <length> | <number> ]{1,4}",
          "border-image-repeat": "[ stretch | repeat | round ]{1,2}",
          "border-image-slice": "<border-image-slice>",
          "border-image-source": "<image> | none",
          "border-image-width": "[ <length> | <percentage> | <number> | auto ]{1,4}",
          "border-left": "<border-width> || <border-style> || <color>",
          "border-left-color": "<color>",
          "border-left-style": "<border-style>",
          "border-left-width": "<border-width>",
          "border-radius": "<border-radius>",
          "border-right": "<border-width> || <border-style> || <color>",
          "border-right-color": "<color>",
          "border-right-style": "<border-style>",
          "border-right-width": "<border-width>",
          "border-spacing": "<length>{1,2}",
          "border-style": "<border-style>{1,4}",
          "border-top": "<border-width> || <border-style> || <color>",
          "border-top-color": "<color>",
          "border-top-left-radius": "<x-one-radius>",
          "border-top-right-radius": "<x-one-radius>",
          "border-top-style": "<border-style>",
          "border-top-width": "<border-width>",
          "border-width": "<border-width>{1,4}",
          "bottom": "<margin-width>",
          "-moz-box-align": "start | end | center | baseline | stretch",
          "-moz-box-decoration-break": "slice | clone",
          "-moz-box-direction": "normal | reverse",
          "-moz-box-flex": "<number>",
          "-moz-box-flex-group": "<integer>",
          "-moz-box-lines": "single | multiple",
          "-moz-box-ordinal-group": "<integer>",
          "-moz-box-orient": "horizontal | vertical | inline-axis | block-axis",
          "-moz-box-pack": "start | end | center | justify",
          "-o-box-decoration-break": "slice | clone",
          "-webkit-box-align": "start | end | center | baseline | stretch",
          "-webkit-box-decoration-break": "slice | clone",
          "-webkit-box-direction": "normal | reverse",
          "-webkit-box-flex": "<number>",
          "-webkit-box-flex-group": "<integer>",
          "-webkit-box-lines": "single | multiple",
          "-webkit-box-ordinal-group": "<integer>",
          "-webkit-box-orient": "horizontal | vertical | inline-axis | block-axis",
          "-webkit-box-pack": "start | end | center | justify",
          "box-decoration-break": "slice | clone",
          "box-shadow": "<box-shadow>",
          "box-sizing": "content-box | border-box",
          "break-after": "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
          "break-before": "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
          "break-inside": "auto | avoid | avoid-page | avoid-column",
          //C
          "caption-side": "top | bottom",
          "clear": "none | right | left | both",
          "clip": "<shape> | auto",
          "-webkit-clip-path": "<clip-source> | <clip-path> | none",
          "clip-path": "<clip-source> | <clip-path> | none",
          "clip-rule": "nonzero | evenodd",
          "color": "<color>",
          "color-interpolation": "auto | sRGB | linearRGB",
          "color-interpolation-filters": "auto | sRGB | linearRGB",
          "color-profile": 1,
          "color-rendering": "auto | optimizeSpeed | optimizeQuality",
          "column-count": "<integer> | auto",
          //https://www.w3.org/TR/css3-multicol/
          "column-fill": "auto | balance",
          "column-gap": "<length> | normal",
          "column-rule": "<border-width> || <border-style> || <color>",
          "column-rule-color": "<color>",
          "column-rule-style": "<border-style>",
          "column-rule-width": "<border-width>",
          "column-span": "none | all",
          "column-width": "<length> | auto",
          "columns": 1,
          "content": 1,
          "counter-increment": 1,
          "counter-reset": 1,
          "crop": "<shape> | auto",
          "cue": "cue-after | cue-before",
          "cue-after": 1,
          "cue-before": 1,
          "cursor": 1,
          //D
          "direction": "ltr | rtl",
          "display": "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
          "dominant-baseline": "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge",
          "drop-initial-after-adjust": "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
          "drop-initial-after-align": "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
          "drop-initial-before-adjust": "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
          "drop-initial-before-align": "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
          "drop-initial-size": "auto | line | <length> | <percentage>",
          "drop-initial-value": "<integer>",
          //E
          "elevation": "<angle> | below | level | above | higher | lower",
          "empty-cells": "show | hide",
          "enable-background": 1,
          //F
          "fill": "<paint>",
          "fill-opacity": "<opacity-value>",
          "fill-rule": "nonzero | evenodd",
          "filter": "<filter-function-list> | none",
          "fit": "fill | hidden | meet | slice",
          "fit-position": 1,
          "flex": "<flex>",
          "flex-basis": "<width>",
          "flex-direction": "row | row-reverse | column | column-reverse",
          "flex-flow": "<flex-direction> || <flex-wrap>",
          "flex-grow": "<number>",
          "flex-shrink": "<number>",
          "flex-wrap": "nowrap | wrap | wrap-reverse",
          "-webkit-flex": "<flex>",
          "-webkit-flex-basis": "<width>",
          "-webkit-flex-direction": "row | row-reverse | column | column-reverse",
          "-webkit-flex-flow": "<flex-direction> || <flex-wrap>",
          "-webkit-flex-grow": "<number>",
          "-webkit-flex-shrink": "<number>",
          "-webkit-flex-wrap": "nowrap | wrap | wrap-reverse",
          "-ms-flex": "<flex>",
          "-ms-flex-align": "start | end | center | stretch | baseline",
          "-ms-flex-direction": "row | row-reverse | column | column-reverse",
          "-ms-flex-order": "<number>",
          "-ms-flex-pack": "start | end | center | justify",
          "-ms-flex-wrap": "nowrap | wrap | wrap-reverse",
          "float": "left | right | none",
          "float-offset": 1,
          "flood-color": 1,
          "flood-opacity": "<opacity-value>",
          "font": "<font-shorthand> | caption | icon | menu | message-box | small-caption | status-bar",
          "font-family": "<font-family>",
          "font-feature-settings": "<feature-tag-value> | normal",
          "font-kerning": "auto | normal | none",
          "font-size": "<font-size>",
          "font-size-adjust": "<number> | none",
          "font-stretch": "<font-stretch>",
          "font-style": "<font-style>",
          "font-variant": "<font-variant> | normal | none",
          "font-variant-alternates": "<font-variant-alternates> | normal",
          "font-variant-caps": "<font-variant-caps> | normal",
          "font-variant-east-asian": "<font-variant-east-asian> | normal",
          "font-variant-ligatures": "<font-variant-ligatures> | normal | none",
          "font-variant-numeric": "<font-variant-numeric> | normal",
          "font-variant-position": "normal | sub | super",
          "font-weight": "<font-weight>",
          //G
          "glyph-orientation-horizontal": "<glyph-angle>",
          "glyph-orientation-vertical": "auto | <glyph-angle>",
          "grid": 1,
          "grid-area": 1,
          "grid-auto-columns": 1,
          "grid-auto-flow": 1,
          "grid-auto-position": 1,
          "grid-auto-rows": 1,
          "grid-cell-stacking": "columns | rows | layer",
          "grid-column": 1,
          "grid-columns": 1,
          "grid-column-align": "start | end | center | stretch",
          "grid-column-sizing": 1,
          "grid-column-start": 1,
          "grid-column-end": 1,
          "grid-column-span": "<integer>",
          "grid-flow": "none | rows | columns",
          "grid-layer": "<integer>",
          "grid-row": 1,
          "grid-rows": 1,
          "grid-row-align": "start | end | center | stretch",
          "grid-row-start": 1,
          "grid-row-end": 1,
          "grid-row-span": "<integer>",
          "grid-row-sizing": 1,
          "grid-template": 1,
          "grid-template-areas": 1,
          "grid-template-columns": 1,
          "grid-template-rows": 1,
          //H
          "hanging-punctuation": 1,
          "height": "<margin-width> | <content-sizing>",
          "hyphenate-after": "<integer> | auto",
          "hyphenate-before": "<integer> | auto",
          "hyphenate-character": "<string> | auto",
          "hyphenate-lines": "no-limit | <integer>",
          "hyphenate-resource": 1,
          "hyphens": "none | manual | auto",
          //I
          "icon": 1,
          "image-orientation": "angle | auto",
          "image-rendering": "auto | optimizeSpeed | optimizeQuality",
          "image-resolution": 1,
          "ime-mode": "auto | normal | active | inactive | disabled",
          "inline-box-align": "last | <integer>",
          //J
          "justify-content": "flex-start | flex-end | center | space-between | space-around",
          "-webkit-justify-content": "flex-start | flex-end | center | space-between | space-around",
          //K
          "kerning": "auto | <length>",
          //L
          "left": "<margin-width>",
          "letter-spacing": "<length> | normal",
          "line-height": "<line-height>",
          "line-break": "auto | loose | normal | strict",
          "line-stacking": 1,
          "line-stacking-ruby": "exclude-ruby | include-ruby",
          "line-stacking-shift": "consider-shifts | disregard-shifts",
          "line-stacking-strategy": "inline-line-height | block-line-height | max-height | grid-height",
          "list-style": 1,
          "list-style-image": "<uri> | none",
          "list-style-position": "inside | outside",
          "list-style-type": "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none",
          //M
          "margin": "<margin-width>{1,4}",
          "margin-bottom": "<margin-width>",
          "margin-left": "<margin-width>",
          "margin-right": "<margin-width>",
          "margin-top": "<margin-width>",
          "mark": 1,
          "mark-after": 1,
          "mark-before": 1,
          "marker": 1,
          "marker-end": 1,
          "marker-mid": 1,
          "marker-start": 1,
          "marks": 1,
          "marquee-direction": 1,
          "marquee-play-count": 1,
          "marquee-speed": 1,
          "marquee-style": 1,
          "mask": 1,
          "max-height": "<length> | <percentage> | <content-sizing> | none",
          "max-width": "<length> | <percentage> | <content-sizing> | none",
          "min-height": "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats",
          "min-width": "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats",
          "move-to": 1,
          //N
          "nav-down": 1,
          "nav-index": 1,
          "nav-left": 1,
          "nav-right": 1,
          "nav-up": 1,
          //O
          "object-fit": "fill | contain | cover | none | scale-down",
          "object-position": "<position>",
          "opacity": "<opacity-value>",
          "order": "<integer>",
          "-webkit-order": "<integer>",
          "orphans": "<integer>",
          "outline": 1,
          "outline-color": "<color> | invert",
          "outline-offset": 1,
          "outline-style": "<border-style>",
          "outline-width": "<border-width>",
          "overflow": "visible | hidden | scroll | auto",
          "overflow-style": 1,
          "overflow-wrap": "normal | break-word",
          "overflow-x": 1,
          "overflow-y": 1,
          //P
          "padding": "<padding-width>{1,4}",
          "padding-bottom": "<padding-width>",
          "padding-left": "<padding-width>",
          "padding-right": "<padding-width>",
          "padding-top": "<padding-width>",
          "page": 1,
          "page-break-after": "auto | always | avoid | left | right",
          "page-break-before": "auto | always | avoid | left | right",
          "page-break-inside": "auto | avoid",
          "page-policy": 1,
          "pause": 1,
          "pause-after": 1,
          "pause-before": 1,
          "perspective": 1,
          "perspective-origin": 1,
          "phonemes": 1,
          "pitch": 1,
          "pitch-range": 1,
          "play-during": 1,
          "pointer-events": "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all",
          "position": "static | relative | absolute | fixed",
          "presentation-level": 1,
          "punctuation-trim": 1,
          //Q
          "quotes": 1,
          //R
          "rendering-intent": 1,
          "resize": 1,
          "rest": 1,
          "rest-after": 1,
          "rest-before": 1,
          "richness": 1,
          "right": "<margin-width>",
          "rotation": 1,
          "rotation-point": 1,
          "ruby-align": 1,
          "ruby-overhang": 1,
          "ruby-position": 1,
          "ruby-span": 1,
          //S
          "shape-rendering": "auto | optimizeSpeed | crispEdges | geometricPrecision",
          "size": 1,
          "speak": "normal | none | spell-out",
          "speak-header": "once | always",
          "speak-numeral": "digits | continuous",
          "speak-punctuation": "code | none",
          "speech-rate": 1,
          "src": 1,
          "stop-color": 1,
          "stop-opacity": "<opacity-value>",
          "stress": 1,
          "string-set": 1,
          "stroke": "<paint>",
          "stroke-dasharray": "none | <dasharray>",
          "stroke-dashoffset": "<percentage> | <length>",
          "stroke-linecap": "butt | round | square",
          "stroke-linejoin": "miter | round | bevel",
          "stroke-miterlimit": "<miterlimit>",
          "stroke-opacity": "<opacity-value>",
          "stroke-width": "<percentage> | <length>",
          "table-layout": "auto | fixed",
          "tab-size": "<integer> | <length>",
          "target": 1,
          "target-name": 1,
          "target-new": 1,
          "target-position": 1,
          "text-align": "left | right | center | justify | match-parent | start | end",
          "text-align-last": 1,
          "text-anchor": "start | middle | end",
          "text-decoration": "<text-decoration-line> || <text-decoration-style> || <text-decoration-color>",
          "text-decoration-color": "<text-decoration-color>",
          "text-decoration-line": "<text-decoration-line>",
          "text-decoration-style": "<text-decoration-style>",
          "text-emphasis": 1,
          "text-height": 1,
          "text-indent": "<length> | <percentage>",
          "text-justify": "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
          "text-outline": 1,
          "text-overflow": 1,
          "text-rendering": "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
          "text-shadow": 1,
          "text-transform": "capitalize | uppercase | lowercase | none",
          "text-wrap": "normal | none | avoid",
          "top": "<margin-width>",
          "-ms-touch-action": "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
          "touch-action": "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
          "transform": 1,
          "transform-origin": 1,
          "transform-style": 1,
          "transition": 1,
          "transition-delay": 1,
          "transition-duration": 1,
          "transition-property": 1,
          "transition-timing-function": 1,
          //U
          "unicode-bidi": "normal | embed | isolate | bidi-override | isolate-override | plaintext",
          "user-modify": "read-only | read-write | write-only",
          "user-select": "none | text | toggle | element | elements | all",
          //V
          "vertical-align": "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>",
          "visibility": "visible | hidden | collapse",
          "voice-balance": 1,
          "voice-duration": 1,
          "voice-family": 1,
          "voice-pitch": 1,
          "voice-pitch-range": 1,
          "voice-rate": 1,
          "voice-stress": 1,
          "voice-volume": 1,
          "volume": 1,
          //W
          "white-space": "normal | pre | nowrap | pre-wrap | pre-line | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap",
          // https://perishablepress.com/wrapping-content/
          "white-space-collapse": 1,
          "widows": "<integer>",
          "width": "<length> | <percentage> | <content-sizing> | auto",
          "will-change": "<will-change>",
          "word-break": "normal | keep-all | break-all",
          "word-spacing": "<length> | normal",
          "word-wrap": "normal | break-word",
          "writing-mode": "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb",
          //Z
          "z-index": "<integer> | auto",
          "zoom": "<number> | <percentage> | normal"
        };
      }, {}],
      8: [function (require, module, exports) {
        "use strict";

        module.exports = PropertyName;
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Parser = require("./Parser");

        /**
         * Represents a selector combinator (whitespace, +, >).
         * @namespace parserlib.css
         * @class PropertyName
         * @extends parserlib.util.SyntaxUnit
         * @constructor
         * @param {String} text The text representation of the unit.
         * @param {String} hack The type of IE hack applied ("*", "_", or null).
         * @param {int} line The line of text on which the unit resides.
         * @param {int} col The column of text on which the unit resides.
         */
        function PropertyName(text, hack, line, col) {
          SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

          /**
           * The type of IE hack applied ("*", "_", or null).
           * @type String
           * @property hack
           */
          this.hack = hack;
        }
        PropertyName.prototype = new SyntaxUnit();
        PropertyName.prototype.constructor = PropertyName;
        PropertyName.prototype.toString = function () {
          return (this.hack ? this.hack : "") + this.text;
        };
      }, {
        "../util/SyntaxUnit": 26,
        "./Parser": 6
      }],
      9: [function (require, module, exports) {
        "use strict";

        module.exports = PropertyValue;
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Parser = require("./Parser");

        /**
         * Represents a single part of a CSS property value, meaning that it represents
         * just everything single part between ":" and ";". If there are multiple values
         * separated by commas, this type represents just one of the values.
         * @param {String[]} parts An array of value parts making up this value.
         * @param {int} line The line of text on which the unit resides.
         * @param {int} col The column of text on which the unit resides.
         * @namespace parserlib.css
         * @class PropertyValue
         * @extends parserlib.util.SyntaxUnit
         * @constructor
         */
        function PropertyValue(parts, line, col) {
          SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);

          /**
           * The parts that make up the selector.
           * @type Array
           * @property parts
           */
          this.parts = parts;
        }
        PropertyValue.prototype = new SyntaxUnit();
        PropertyValue.prototype.constructor = PropertyValue;
      }, {
        "../util/SyntaxUnit": 26,
        "./Parser": 6
      }],
      10: [function (require, module, exports) {
        "use strict";

        module.exports = PropertyValueIterator;

        /**
         * A utility class that allows for easy iteration over the various parts of a
         * property value.
         * @param {parserlib.css.PropertyValue} value The property value to iterate over.
         * @namespace parserlib.css
         * @class PropertyValueIterator
         * @constructor
         */
        function PropertyValueIterator(value) {
          /**
           * Iterator value
           * @type int
           * @property _i
           * @private
           */
          this._i = 0;

          /**
           * The parts that make up the value.
           * @type Array
           * @property _parts
           * @private
           */
          this._parts = value.parts;

          /**
           * Keeps track of bookmarks along the way.
           * @type Array
           * @property _marks
           * @private
           */
          this._marks = [];

          /**
           * Holds the original property value.
           * @type parserlib.css.PropertyValue
           * @property value
           */
          this.value = value;
        }

        /**
         * Returns the total number of parts in the value.
         * @return {int} The total number of parts in the value.
         * @method count
         */
        PropertyValueIterator.prototype.count = function () {
          return this._parts.length;
        };

        /**
         * Indicates if the iterator is positioned at the first item.
         * @return {Boolean} True if positioned at first item, false if not.
         * @method isFirst
         */
        PropertyValueIterator.prototype.isFirst = function () {
          return this._i === 0;
        };

        /**
         * Indicates if there are more parts of the property value.
         * @return {Boolean} True if there are more parts, false if not.
         * @method hasNext
         */
        PropertyValueIterator.prototype.hasNext = function () {
          return this._i < this._parts.length;
        };

        /**
         * Marks the current spot in the iteration so it can be restored to
         * later on.
         * @return {void}
         * @method mark
         */
        PropertyValueIterator.prototype.mark = function () {
          this._marks.push(this._i);
        };

        /**
         * Returns the next part of the property value or null if there is no next
         * part. Does not move the internal counter forward.
         * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
         * part.
         * @method peek
         */
        PropertyValueIterator.prototype.peek = function (count) {
          return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
        };

        /**
         * Returns the next part of the property value or null if there is no next
         * part.
         * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
         * part.
         * @method next
         */
        PropertyValueIterator.prototype.next = function () {
          return this.hasNext() ? this._parts[this._i++] : null;
        };

        /**
         * Returns the previous part of the property value or null if there is no
         * previous part.
         * @return {parserlib.css.PropertyValuePart} The previous part of the
         * property value or null if there is no previous part.
         * @method previous
         */
        PropertyValueIterator.prototype.previous = function () {
          return this._i > 0 ? this._parts[--this._i] : null;
        };

        /**
         * Restores the last saved bookmark.
         * @return {void}
         * @method restore
         */
        PropertyValueIterator.prototype.restore = function () {
          if (this._marks.length) {
            this._i = this._marks.pop();
          }
        };

        /**
         * Drops the last saved bookmark.
         * @return {void}
         * @method drop
         */
        PropertyValueIterator.prototype.drop = function () {
          this._marks.pop();
        };
      }, {}],
      11: [function (require, module, exports) {
        "use strict";

        module.exports = PropertyValuePart;
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Colors = require("./Colors");
        var Parser = require("./Parser");
        var Tokens = require("./Tokens");

        /**
         * Represents a single part of a CSS property value, meaning that it represents
         * just one part of the data between ":" and ";".
         * @param {String} text The text representation of the unit.
         * @param {int} line The line of text on which the unit resides.
         * @param {int} col The column of text on which the unit resides.
         * @namespace parserlib.css
         * @class PropertyValuePart
         * @extends parserlib.util.SyntaxUnit
         * @constructor
         */
        function PropertyValuePart(text, line, col, optionalHint) {
          var hint = optionalHint || {};
          SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

          /**
           * Indicates the type of value unit.
           * @type String
           * @property type
           */
          this.type = "unknown";

          //figure out what type of data it is

          var temp;

          //it is a measurement?
          if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)) {
            //dimension
            this.type = "dimension";
            this.value = +RegExp.$1;
            this.units = RegExp.$2;

            //try to narrow down
            switch (this.units.toLowerCase()) {
              case "em":
              case "rem":
              case "ex":
              case "px":
              case "cm":
              case "mm":
              case "in":
              case "pt":
              case "pc":
              case "ch":
              case "vh":
              case "vw":
              case "vmax":
              case "vmin":
                this.type = "length";
                break;
              case "fr":
                this.type = "grid";
                break;
              case "deg":
              case "rad":
              case "grad":
              case "turn":
                this.type = "angle";
                break;
              case "ms":
              case "s":
                this.type = "time";
                break;
              case "hz":
              case "khz":
                this.type = "frequency";
                break;
              case "dpi":
              case "dpcm":
                this.type = "resolution";
                break;

              //default
            }
          } else if (/^([+\-]?[\d\.]+)%$/i.test(text)) {
            //percentage
            this.type = "percentage";
            this.value = +RegExp.$1;
          } else if (/^([+\-]?\d+)$/i.test(text)) {
            //integer
            this.type = "integer";
            this.value = +RegExp.$1;
          } else if (/^([+\-]?[\d\.]+)$/i.test(text)) {
            //number
            this.type = "number";
            this.value = +RegExp.$1;
          } else if (/^#([a-f0-9]{3,6})/i.test(text)) {
            //hexcolor
            this.type = "color";
            temp = RegExp.$1;
            if (temp.length === 3) {
              this.red = parseInt(temp.charAt(0) + temp.charAt(0), 16);
              this.green = parseInt(temp.charAt(1) + temp.charAt(1), 16);
              this.blue = parseInt(temp.charAt(2) + temp.charAt(2), 16);
            } else {
              this.red = parseInt(temp.substring(0, 2), 16);
              this.green = parseInt(temp.substring(2, 4), 16);
              this.blue = parseInt(temp.substring(4, 6), 16);
            }
          } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) {
            //rgb() color with absolute numbers
            this.type = "color";
            this.red = +RegExp.$1;
            this.green = +RegExp.$2;
            this.blue = +RegExp.$3;
          } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) {
            //rgb() color with percentages
            this.type = "color";
            this.red = +RegExp.$1 * 255 / 100;
            this.green = +RegExp.$2 * 255 / 100;
            this.blue = +RegExp.$3 * 255 / 100;
          } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
            //rgba() color with absolute numbers
            this.type = "color";
            this.red = +RegExp.$1;
            this.green = +RegExp.$2;
            this.blue = +RegExp.$3;
            this.alpha = +RegExp.$4;
          } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
            //rgba() color with percentages
            this.type = "color";
            this.red = +RegExp.$1 * 255 / 100;
            this.green = +RegExp.$2 * 255 / 100;
            this.blue = +RegExp.$3 * 255 / 100;
            this.alpha = +RegExp.$4;
          } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) {
            //hsl()
            this.type = "color";
            this.hue = +RegExp.$1;
            this.saturation = +RegExp.$2 / 100;
            this.lightness = +RegExp.$3 / 100;
          } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
            //hsla() color with percentages
            this.type = "color";
            this.hue = +RegExp.$1;
            this.saturation = +RegExp.$2 / 100;
            this.lightness = +RegExp.$3 / 100;
            this.alpha = +RegExp.$4;
          } else if (/^url\(("([^\\"]|\\.)*")\)/i.test(text)) {
            //URI
            // generated by TokenStream.readURI, so always double-quoted.
            this.type = "uri";
            this.uri = PropertyValuePart.parseString(RegExp.$1);
          } else if (/^([^\(]+)\(/i.test(text)) {
            this.type = "function";
            this.name = RegExp.$1;
            this.value = text;
          } else if (/^"([^\n\r\f\\"]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*"/i.test(text)) {
            //double-quoted string
            this.type = "string";
            this.value = PropertyValuePart.parseString(text);
          } else if (/^'([^\n\r\f\\']|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*'/i.test(text)) {
            //single-quoted string
            this.type = "string";
            this.value = PropertyValuePart.parseString(text);
          } else if (Colors[text.toLowerCase()]) {
            //named color
            this.type = "color";
            temp = Colors[text.toLowerCase()].substring(1);
            this.red = parseInt(temp.substring(0, 2), 16);
            this.green = parseInt(temp.substring(2, 4), 16);
            this.blue = parseInt(temp.substring(4, 6), 16);
          } else if (/^[,\/]$/.test(text)) {
            this.type = "operator";
            this.value = text;
          } else if (/^-?[a-z_\u00A0-\uFFFF][a-z0-9\-_\u00A0-\uFFFF]*$/i.test(text)) {
            this.type = "identifier";
            this.value = text;
          }

          // There can be ambiguity with escape sequences in identifiers, as
          // well as with "color" parts which are also "identifiers", so record
          // an explicit hint when the token generating this PropertyValuePart
          // was an identifier.
          this.wasIdent = Boolean(hint.ident);
        }
        PropertyValuePart.prototype = new SyntaxUnit();
        PropertyValuePart.prototype.constructor = PropertyValuePart;

        /**
         * Helper method to parse a CSS string.
         */
        PropertyValuePart.parseString = function (str) {
          str = str.slice(1, -1); // Strip surrounding single/double quotes
          var replacer = function (match, esc) {
            if (/^(\n|\r\n|\r|\f)$/.test(esc)) {
              return "";
            }
            var m = /^[0-9a-f]{1,6}/i.exec(esc);
            if (m) {
              var codePoint = parseInt(m[0], 16);
              if (String.fromCodePoint) {
                return String.fromCodePoint(codePoint);
              } else {
                // XXX No support for surrogates on old JavaScript engines.
                return String.fromCharCode(codePoint);
              }
            }
            return esc;
          };
          return str.replace(/\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig, replacer);
        };

        /**
         * Helper method to serialize a CSS string.
         */
        PropertyValuePart.serializeString = function (value) {
          var replacer = function (match, c) {
            if (c === "\"") {
              return "\\" + c;
            }
            var cp = String.codePointAt ? String.codePointAt(0) :
            // We only escape non-surrogate chars, so using charCodeAt
            // is harmless here.
            String.charCodeAt(0);
            return "\\" + cp.toString(16) + " ";
          };
          return "\"" + value.replace(/["\r\n\f]/g, replacer) + "\"";
        };

        /**
         * Create a new syntax unit based solely on the given token.
         * Convenience method for creating a new syntax unit when
         * it represents a single token instead of multiple.
         * @param {Object} token The token object to represent.
         * @return {parserlib.css.PropertyValuePart} The object representing the token.
         * @static
         * @method fromToken
         */
        PropertyValuePart.fromToken = function (token) {
          var part = new PropertyValuePart(token.value, token.startLine, token.startCol, {
            // Tokens can have escaped characters that would fool the type
            // identification in the PropertyValuePart constructor, so pass
            // in a hint if this was an identifier.
            ident: token.type === Tokens.IDENT
          });
          return part;
        };
      }, {
        "../util/SyntaxUnit": 26,
        "./Colors": 1,
        "./Parser": 6,
        "./Tokens": 18
      }],
      12: [function (require, module, exports) {
        "use strict";

        var Pseudos = module.exports = {
          __proto__: null,
          ":first-letter": 1,
          ":first-line": 1,
          ":before": 1,
          ":after": 1
        };
        Pseudos.ELEMENT = 1;
        Pseudos.CLASS = 2;
        Pseudos.isElement = function (pseudo) {
          return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
        };
      }, {}],
      13: [function (require, module, exports) {
        "use strict";

        module.exports = Selector;
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Parser = require("./Parser");
        var Specificity = require("./Specificity");

        /**
         * Represents an entire single selector, including all parts but not
         * including multiple selectors (those separated by commas).
         * @namespace parserlib.css
         * @class Selector
         * @extends parserlib.util.SyntaxUnit
         * @constructor
         * @param {Array} parts Array of selectors parts making up this selector.
         * @param {int} line The line of text on which the unit resides.
         * @param {int} col The column of text on which the unit resides.
         */
        function Selector(parts, line, col) {
          SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);

          /**
           * The parts that make up the selector.
           * @type Array
           * @property parts
           */
          this.parts = parts;

          /**
           * The specificity of the selector.
           * @type parserlib.css.Specificity
           * @property specificity
           */
          this.specificity = Specificity.calculate(this);
        }
        Selector.prototype = new SyntaxUnit();
        Selector.prototype.constructor = Selector;
      }, {
        "../util/SyntaxUnit": 26,
        "./Parser": 6,
        "./Specificity": 16
      }],
      14: [function (require, module, exports) {
        "use strict";

        module.exports = SelectorPart;
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Parser = require("./Parser");

        /**
         * Represents a single part of a selector string, meaning a single set of
         * element name and modifiers. This does not include combinators such as
         * spaces, +, >, etc.
         * @namespace parserlib.css
         * @class SelectorPart
         * @extends parserlib.util.SyntaxUnit
         * @constructor
         * @param {String} elementName The element name in the selector or null
         *      if there is no element name.
         * @param {Array} modifiers Array of individual modifiers for the element.
         *      May be empty if there are none.
         * @param {String} text The text representation of the unit.
         * @param {int} line The line of text on which the unit resides.
         * @param {int} col The column of text on which the unit resides.
         */
        function SelectorPart(elementName, modifiers, text, line, col) {
          SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

          /**
           * The tag name of the element to which this part
           * of the selector affects.
           * @type String
           * @property elementName
           */
          this.elementName = elementName;

          /**
           * The parts that come after the element name, such as class names, IDs,
           * pseudo classes/elements, etc.
           * @type Array
           * @property modifiers
           */
          this.modifiers = modifiers;
        }
        SelectorPart.prototype = new SyntaxUnit();
        SelectorPart.prototype.constructor = SelectorPart;
      }, {
        "../util/SyntaxUnit": 26,
        "./Parser": 6
      }],
      15: [function (require, module, exports) {
        "use strict";

        module.exports = SelectorSubPart;
        var SyntaxUnit = require("../util/SyntaxUnit");
        var Parser = require("./Parser");

        /**
         * Represents a selector modifier string, meaning a class name, element name,
         * element ID, pseudo rule, etc.
         * @namespace parserlib.css
         * @class SelectorSubPart
         * @extends parserlib.util.SyntaxUnit
         * @constructor
         * @param {String} text The text representation of the unit.
         * @param {String} type The type of selector modifier.
         * @param {int} line The line of text on which the unit resides.
         * @param {int} col The column of text on which the unit resides.
         */
        function SelectorSubPart(text, type, line, col) {
          SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

          /**
           * The type of modifier.
           * @type String
           * @property type
           */
          this.type = type;

          /**
           * Some subparts have arguments, this represents them.
           * @type Array
           * @property args
           */
          this.args = [];
        }
        SelectorSubPart.prototype = new SyntaxUnit();
        SelectorSubPart.prototype.constructor = SelectorSubPart;
      }, {
        "../util/SyntaxUnit": 26,
        "./Parser": 6
      }],
      16: [function (require, module, exports) {
        "use strict";

        module.exports = Specificity;
        var Pseudos = require("./Pseudos");
        var SelectorPart = require("./SelectorPart");

        /**
         * Represents a selector's specificity.
         * @namespace parserlib.css
         * @class Specificity
         * @constructor
         * @param {int} a Should be 1 for inline styles, zero for stylesheet styles
         * @param {int} b Number of ID selectors
         * @param {int} c Number of classes and pseudo classes
         * @param {int} d Number of element names and pseudo elements
         */
        function Specificity(a, b, c, d) {
          this.a = a;
          this.b = b;
          this.c = c;
          this.d = d;
        }
        Specificity.prototype = {
          constructor: Specificity,
          /**
           * Compare this specificity to another.
           * @param {Specificity} other The other specificity to compare to.
           * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.
           * @method compare
           */
          compare: function (other) {
            var comps = ["a", "b", "c", "d"],
              i,
              len;
            for (i = 0, len = comps.length; i < len; i++) {
              if (this[comps[i]] < other[comps[i]]) {
                return -1;
              } else if (this[comps[i]] > other[comps[i]]) {
                return 1;
              }
            }
            return 0;
          },
          /**
           * Creates a numeric value for the specificity.
           * @return {int} The numeric value for the specificity.
           * @method valueOf
           */
          valueOf: function () {
            return this.a * 1000 + this.b * 100 + this.c * 10 + this.d;
          },
          /**
           * Returns a string representation for specificity.
           * @return {String} The string representation of specificity.
           * @method toString
           */
          toString: function () {
            return this.a + "," + this.b + "," + this.c + "," + this.d;
          }
        };

        /**
         * Calculates the specificity of the given selector.
         * @param {parserlib.css.Selector} The selector to calculate specificity for.
         * @return {parserlib.css.Specificity} The specificity of the selector.
         * @static
         * @method calculate
         */
        Specificity.calculate = function (selector) {
          var i,
            len,
            part,
            b = 0,
            c = 0,
            d = 0;
          function updateValues(part) {
            var i,
              j,
              len,
              num,
              elementName = part.elementName ? part.elementName.text : "",
              modifier;
            if (elementName && elementName.charAt(elementName.length - 1) !== "*") {
              d++;
            }
            for (i = 0, len = part.modifiers.length; i < len; i++) {
              modifier = part.modifiers[i];
              switch (modifier.type) {
                case "class":
                case "attribute":
                  c++;
                  break;
                case "id":
                  b++;
                  break;
                case "pseudo":
                  if (Pseudos.isElement(modifier.text)) {
                    d++;
                  } else {
                    c++;
                  }
                  break;
                case "not":
                  for (j = 0, num = modifier.args.length; j < num; j++) {
                    updateValues(modifier.args[j]);
                  }
              }
            }
          }
          for (i = 0, len = selector.parts.length; i < len; i++) {
            part = selector.parts[i];
            if (part instanceof SelectorPart) {
              updateValues(part);
            }
          }
          return new Specificity(0, b, c, d);
        };
      }, {
        "./Pseudos": 12,
        "./SelectorPart": 14
      }],
      17: [function (require, module, exports) {
        "use strict";

        module.exports = TokenStream;
        var TokenStreamBase = require("../util/TokenStreamBase");
        var PropertyValuePart = require("./PropertyValuePart");
        var Tokens = require("./Tokens");
        var h = /^[0-9a-fA-F]$/,
          nonascii = /^[\u00A0-\uFFFF]$/,
          nl = /\n|\r\n|\r|\f/,
          whitespace = /\u0009|\u000a|\u000c|\u000d|\u0020/;

        //-----------------------------------------------------------------------------
        // Helper functions
        //-----------------------------------------------------------------------------

        function isHexDigit(c) {
          return c !== null && h.test(c);
        }
        function isDigit(c) {
          return c !== null && /\d/.test(c);
        }
        function isWhitespace(c) {
          return c !== null && whitespace.test(c);
        }
        function isNewLine(c) {
          return c !== null && nl.test(c);
        }
        function isNameStart(c) {
          return c !== null && /[a-z_\u00A0-\uFFFF\\]/i.test(c);
        }
        function isNameChar(c) {
          return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
        }
        function isIdentStart(c) {
          return c !== null && (isNameStart(c) || /\-\\/.test(c));
        }
        function mix(receiver, supplier) {
          for (var prop in supplier) {
            if (Object.prototype.hasOwnProperty.call(supplier, prop)) {
              receiver[prop] = supplier[prop];
            }
          }
          return receiver;
        }

        //-----------------------------------------------------------------------------
        // CSS Token Stream
        //-----------------------------------------------------------------------------

        /**
         * A token stream that produces CSS tokens.
         * @param {String|Reader} input The source of text to tokenize.
         * @constructor
         * @class TokenStream
         * @namespace parserlib.css
         */
        function TokenStream(input) {
          TokenStreamBase.call(this, input, Tokens);
        }
        TokenStream.prototype = mix(new TokenStreamBase(), {
          /**
           * Overrides the TokenStreamBase method of the same name
           * to produce CSS tokens.
           * @return {Object} A token object representing the next token.
           * @method _getToken
           * @private
           */
          _getToken: function () {
            var c,
              reader = this._reader,
              token = null,
              startLine = reader.getLine(),
              startCol = reader.getCol();
            c = reader.read();
            while (c) {
              switch (c) {
                /*
                 * Potential tokens:
                 * - COMMENT
                 * - SLASH
                 * - CHAR
                 */
                case "/":
                  if (reader.peek() === "*") {
                    token = this.commentToken(c, startLine, startCol);
                  } else {
                    token = this.charToken(c, startLine, startCol);
                  }
                  break;

                /*
                 * Potential tokens:
                 * - DASHMATCH
                 * - INCLUDES
                 * - PREFIXMATCH
                 * - SUFFIXMATCH
                 * - SUBSTRINGMATCH
                 * - CHAR
                 */
                case "|":
                case "~":
                case "^":
                case "$":
                case "*":
                  if (reader.peek() === "=") {
                    token = this.comparisonToken(c, startLine, startCol);
                  } else {
                    token = this.charToken(c, startLine, startCol);
                  }
                  break;

                /*
                 * Potential tokens:
                 * - STRING
                 * - INVALID
                 */
                case "\"":
                case "'":
                  token = this.stringToken(c, startLine, startCol);
                  break;

                /*
                 * Potential tokens:
                 * - HASH
                 * - CHAR
                 */
                case "#":
                  if (isNameChar(reader.peek())) {
                    token = this.hashToken(c, startLine, startCol);
                  } else {
                    token = this.charToken(c, startLine, startCol);
                  }
                  break;

                /*
                 * Potential tokens:
                 * - DOT
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case ".":
                  if (isDigit(reader.peek())) {
                    token = this.numberToken(c, startLine, startCol);
                  } else {
                    token = this.charToken(c, startLine, startCol);
                  }
                  break;

                /*
                 * Potential tokens:
                 * - CDC
                 * - MINUS
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case "-":
                  if (reader.peek() === "-") {
                    //could be closing HTML-style comment
                    token = this.htmlCommentEndToken(c, startLine, startCol);
                  } else if (isNameStart(reader.peek())) {
                    token = this.identOrFunctionToken(c, startLine, startCol);
                  } else {
                    token = this.charToken(c, startLine, startCol);
                  }
                  break;

                /*
                 * Potential tokens:
                 * - IMPORTANT_SYM
                 * - CHAR
                 */
                case "!":
                  token = this.importantToken(c, startLine, startCol);
                  break;

                /*
                 * Any at-keyword or CHAR
                 */
                case "@":
                  token = this.atRuleToken(c, startLine, startCol);
                  break;

                /*
                 * Potential tokens:
                 * - NOT
                 * - CHAR
                 */
                case ":":
                  token = this.notToken(c, startLine, startCol);
                  break;

                /*
                 * Potential tokens:
                 * - CDO
                 * - CHAR
                 */
                case "<":
                  token = this.htmlCommentStartToken(c, startLine, startCol);
                  break;

                /*
                 * Potential tokens:
                 * - IDENT
                 * - CHAR
                 */
                case "\\":
                  if (/[^\r\n\f]/.test(reader.peek())) {
                    token = this.identOrFunctionToken(this.readEscape(c, true), startLine, startCol);
                  } else {
                    token = this.charToken(c, startLine, startCol);
                  }
                  break;

                /*
                 * Potential tokens:
                 * - UNICODE_RANGE
                 * - URL
                 * - CHAR
                 */
                case "U":
                case "u":
                  if (reader.peek() === "+") {
                    token = this.unicodeRangeToken(c, startLine, startCol);
                    break;
                  }
                /* falls through */
                default:
                  /*
                   * Potential tokens:
                   * - NUMBER
                   * - DIMENSION
                   * - LENGTH
                   * - FREQ
                   * - TIME
                   * - EMS
                   * - EXS
                   * - ANGLE
                   */
                  if (isDigit(c)) {
                    token = this.numberToken(c, startLine, startCol);
                  } else
                    /*
                     * Potential tokens:
                     * - S
                     */
                    if (isWhitespace(c)) {
                      token = this.whitespaceToken(c, startLine, startCol);
                    } else
                      /*
                       * Potential tokens:
                       * - IDENT
                       */
                      if (isIdentStart(c)) {
                        token = this.identOrFunctionToken(c, startLine, startCol);
                      } else {
                        /*
                         * Potential tokens:
                         * - CHAR
                         * - PLUS
                         */
                        token = this.charToken(c, startLine, startCol);
                      }
              }

              //make sure this token is wanted
              //TODO: check channel
              break;
            }
            if (!token && c === null) {
              token = this.createToken(Tokens.EOF, null, startLine, startCol);
            }
            return token;
          },
          //-------------------------------------------------------------------------
          // Methods to create tokens
          //-------------------------------------------------------------------------

          /**
           * Produces a token based on available data and the current
           * reader position information. This method is called by other
           * private methods to create tokens and is never called directly.
           * @param {int} tt The token type.
           * @param {String} value The text value of the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @param {Object} options (Optional) Specifies a channel property
           *      to indicate that a different channel should be scanned
           *      and/or a hide property indicating that the token should
           *      be hidden.
           * @return {Object} A token object.
           * @method createToken
           */
          createToken: function (tt, value, startLine, startCol, options) {
            var reader = this._reader;
            options = options || {};
            return {
              value: value,
              type: tt,
              channel: options.channel,
              endChar: options.endChar,
              hide: options.hide || false,
              startLine: startLine,
              startCol: startCol,
              endLine: reader.getLine(),
              endCol: reader.getCol()
            };
          },
          //-------------------------------------------------------------------------
          // Methods to create specific tokens
          //-------------------------------------------------------------------------

          /**
           * Produces a token for any at-rule. If the at-rule is unknown, then
           * the token is for a single "@" character.
           * @param {String} first The first character for the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method atRuleToken
           */
          atRuleToken: function (first, startLine, startCol) {
            var rule = first,
              reader = this._reader,
              tt = Tokens.CHAR,
              ident;

            /*
             * First, mark where we are. There are only four @ rules,
             * so anything else is really just an invalid token.
             * Basically, if this doesn't match one of the known @
             * rules, just return '@' as an unknown token and allow
             * parsing to continue after that point.
             */
            reader.mark();

            //try to find the at-keyword
            ident = this.readName();
            rule = first + ident;
            tt = Tokens.type(rule.toLowerCase());

            //if it's not valid, use the first character only and reset the reader
            if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {
              if (rule.length > 1) {
                tt = Tokens.UNKNOWN_SYM;
              } else {
                tt = Tokens.CHAR;
                rule = first;
                reader.reset();
              }
            }
            return this.createToken(tt, rule, startLine, startCol);
          },
          /**
           * Produces a character token based on the given character
           * and location in the stream. If there's a special (non-standard)
           * token name, this is used; otherwise CHAR is used.
           * @param {String} c The character for the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method charToken
           */
          charToken: function (c, startLine, startCol) {
            var tt = Tokens.type(c);
            var opts = {};
            if (tt === -1) {
              tt = Tokens.CHAR;
            } else {
              opts.endChar = Tokens[tt].endChar;
            }
            return this.createToken(tt, c, startLine, startCol, opts);
          },
          /**
           * Produces a character token based on the given character
           * and location in the stream. If there's a special (non-standard)
           * token name, this is used; otherwise CHAR is used.
           * @param {String} first The first character for the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method commentToken
           */
          commentToken: function (first, startLine, startCol) {
            var comment = this.readComment(first);
            return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
          },
          /**
           * Produces a comparison token based on the given character
           * and location in the stream. The next character must be
           * read and is already known to be an equals sign.
           * @param {String} c The character for the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method comparisonToken
           */
          comparisonToken: function (c, startLine, startCol) {
            var reader = this._reader,
              comparison = c + reader.read(),
              tt = Tokens.type(comparison) || Tokens.CHAR;
            return this.createToken(tt, comparison, startLine, startCol);
          },
          /**
           * Produces a hash token based on the specified information. The
           * first character provided is the pound sign (#) and then this
           * method reads a name afterward.
           * @param {String} first The first character (#) in the hash name.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method hashToken
           */
          hashToken: function (first, startLine, startCol) {
            var name = this.readName(first);
            return this.createToken(Tokens.HASH, name, startLine, startCol);
          },
          /**
           * Produces a CDO or CHAR token based on the specified information. The
           * first character is provided and the rest is read by the function to determine
           * the correct token to create.
           * @param {String} first The first character in the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method htmlCommentStartToken
           */
          htmlCommentStartToken: function (first, startLine, startCol) {
            var reader = this._reader,
              text = first;
            reader.mark();
            text += reader.readCount(3);
            if (text === "<!--") {
              return this.createToken(Tokens.CDO, text, startLine, startCol);
            } else {
              reader.reset();
              return this.charToken(first, startLine, startCol);
            }
          },
          /**
           * Produces a CDC or CHAR token based on the specified information. The
           * first character is provided and the rest is read by the function to determine
           * the correct token to create.
           * @param {String} first The first character in the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method htmlCommentEndToken
           */
          htmlCommentEndToken: function (first, startLine, startCol) {
            var reader = this._reader,
              text = first;
            reader.mark();
            text += reader.readCount(2);
            if (text === "-->") {
              return this.createToken(Tokens.CDC, text, startLine, startCol);
            } else {
              reader.reset();
              return this.charToken(first, startLine, startCol);
            }
          },
          /**
           * Produces an IDENT or FUNCTION token based on the specified information. The
           * first character is provided and the rest is read by the function to determine
           * the correct token to create.
           * @param {String} first The first character in the identifier.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method identOrFunctionToken
           */
          identOrFunctionToken: function (first, startLine, startCol) {
            var reader = this._reader,
              ident = this.readName(first),
              tt = Tokens.IDENT,
              uriFns = ["url(", "url-prefix(", "domain("],
              uri;

            //if there's a left paren immediately after, it's a URI or function
            if (reader.peek() === "(") {
              ident += reader.read();
              if (uriFns.indexOf(ident.toLowerCase()) > -1) {
                reader.mark();
                uri = this.readURI(ident);
                if (uri === null) {
                  //didn't find a valid URL or there's no closing paren
                  reader.reset();
                  tt = Tokens.FUNCTION;
                } else {
                  tt = Tokens.URI;
                  ident = uri;
                }
              } else {
                tt = Tokens.FUNCTION;
              }
            } else if (reader.peek() === ":") {
              //might be an IE function

              //IE-specific functions always being with progid:
              if (ident.toLowerCase() === "progid") {
                ident += reader.readTo("(");
                tt = Tokens.IE_FUNCTION;
              }
            }
            return this.createToken(tt, ident, startLine, startCol);
          },
          /**
           * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The
           * first character is provided and the rest is read by the function to determine
           * the correct token to create.
           * @param {String} first The first character in the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method importantToken
           */
          importantToken: function (first, startLine, startCol) {
            var reader = this._reader,
              important = first,
              tt = Tokens.CHAR,
              temp,
              c;
            reader.mark();
            c = reader.read();
            while (c) {
              //there can be a comment in here
              if (c === "/") {
                //if the next character isn't a star, then this isn't a valid !important token
                if (reader.peek() !== "*") {
                  break;
                } else {
                  temp = this.readComment(c);
                  if (temp === "") {
                    //broken!
                    break;
                  }
                }
              } else if (isWhitespace(c)) {
                important += c + this.readWhitespace();
              } else if (/i/i.test(c)) {
                temp = reader.readCount(8);
                if (/mportant/i.test(temp)) {
                  important += c + temp;
                  tt = Tokens.IMPORTANT_SYM;
                }
                break; //we're done
              } else {
                break;
              }
              c = reader.read();
            }
            if (tt === Tokens.CHAR) {
              reader.reset();
              return this.charToken(first, startLine, startCol);
            } else {
              return this.createToken(tt, important, startLine, startCol);
            }
          },
          /**
           * Produces a NOT or CHAR token based on the specified information. The
           * first character is provided and the rest is read by the function to determine
           * the correct token to create.
           * @param {String} first The first character in the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method notToken
           */
          notToken: function (first, startLine, startCol) {
            var reader = this._reader,
              text = first;
            reader.mark();
            text += reader.readCount(4);
            if (text.toLowerCase() === ":not(") {
              return this.createToken(Tokens.NOT, text, startLine, startCol);
            } else {
              reader.reset();
              return this.charToken(first, startLine, startCol);
            }
          },
          /**
           * Produces a number token based on the given character
           * and location in the stream. This may return a token of
           * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,
           * or PERCENTAGE.
           * @param {String} first The first character for the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method numberToken
           */
          numberToken: function (first, startLine, startCol) {
            var reader = this._reader,
              value = this.readNumber(first),
              ident,
              tt = Tokens.NUMBER,
              c = reader.peek();
            if (isIdentStart(c)) {
              ident = this.readName(reader.read());
              value += ident;
              if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {
                tt = Tokens.LENGTH;
              } else if (/^deg|^rad$|^grad$|^turn$/i.test(ident)) {
                tt = Tokens.ANGLE;
              } else if (/^ms$|^s$/i.test(ident)) {
                tt = Tokens.TIME;
              } else if (/^hz$|^khz$/i.test(ident)) {
                tt = Tokens.FREQ;
              } else if (/^dpi$|^dpcm$/i.test(ident)) {
                tt = Tokens.RESOLUTION;
              } else {
                tt = Tokens.DIMENSION;
              }
            } else if (c === "%") {
              value += reader.read();
              tt = Tokens.PERCENTAGE;
            }
            return this.createToken(tt, value, startLine, startCol);
          },
          /**
           * Produces a string token based on the given character
           * and location in the stream. Since strings may be indicated
           * by single or double quotes, a failure to match starting
           * and ending quotes results in an INVALID token being generated.
           * The first character in the string is passed in and then
           * the rest are read up to and including the final quotation mark.
           * @param {String} first The first character in the string.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method stringToken
           */
          stringToken: function (first, startLine, startCol) {
            var delim = first,
              string = first,
              reader = this._reader,
              tt = Tokens.STRING,
              c = reader.read(),
              i;
            while (c) {
              string += c;
              if (c === "\\") {
                c = reader.read();
                if (c === null) {
                  break; // premature EOF after backslash
                } else if (/[^\r\n\f0-9a-f]/i.test(c)) {
                  // single-character escape
                  string += c;
                } else {
                  // read up to six hex digits
                  for (i = 0; isHexDigit(c) && i < 6; i++) {
                    string += c;
                    c = reader.read();
                  }
                  // swallow trailing newline or space
                  if (c === "\r" && reader.peek() === "\n") {
                    string += c;
                    c = reader.read();
                  }
                  if (isWhitespace(c)) {
                    string += c;
                  } else {
                    // This character is null or not part of the escape;
                    // jump back to the top to process it.
                    continue;
                  }
                }
              } else if (c === delim) {
                break; // delimiter found.
              } else if (isNewLine(reader.peek())) {
                // newline without an escapement: it's an invalid string
                tt = Tokens.INVALID;
                break;
              }
              c = reader.read();
            }

            //if c is null, that means we're out of input and the string was never closed
            if (c === null) {
              tt = Tokens.INVALID;
            }
            return this.createToken(tt, string, startLine, startCol);
          },
          unicodeRangeToken: function (first, startLine, startCol) {
            var reader = this._reader,
              value = first,
              temp,
              tt = Tokens.CHAR;

            //then it should be a unicode range
            if (reader.peek() === "+") {
              reader.mark();
              value += reader.read();
              value += this.readUnicodeRangePart(true);

              //ensure there's an actual unicode range here
              if (value.length === 2) {
                reader.reset();
              } else {
                tt = Tokens.UNICODE_RANGE;

                //if there's a ? in the first part, there can't be a second part
                if (value.indexOf("?") === -1) {
                  if (reader.peek() === "-") {
                    reader.mark();
                    temp = reader.read();
                    temp += this.readUnicodeRangePart(false);

                    //if there's not another value, back up and just take the first
                    if (temp.length === 1) {
                      reader.reset();
                    } else {
                      value += temp;
                    }
                  }
                }
              }
            }
            return this.createToken(tt, value, startLine, startCol);
          },
          /**
           * Produces a S token based on the specified information. Since whitespace
           * may have multiple characters, this consumes all whitespace characters
           * into a single token.
           * @param {String} first The first character in the token.
           * @param {int} startLine The beginning line for the character.
           * @param {int} startCol The beginning column for the character.
           * @return {Object} A token object.
           * @method whitespaceToken
           */
          whitespaceToken: function (first, startLine, startCol) {
            var value = first + this.readWhitespace();
            return this.createToken(Tokens.S, value, startLine, startCol);
          },
          //-------------------------------------------------------------------------
          // Methods to read values from the string stream
          //-------------------------------------------------------------------------

          readUnicodeRangePart: function (allowQuestionMark) {
            var reader = this._reader,
              part = "",
              c = reader.peek();

            //first read hex digits
            while (isHexDigit(c) && part.length < 6) {
              reader.read();
              part += c;
              c = reader.peek();
            }

            //then read question marks if allowed
            if (allowQuestionMark) {
              while (c === "?" && part.length < 6) {
                reader.read();
                part += c;
                c = reader.peek();
              }
            }

            //there can't be any other characters after this point

            return part;
          },
          readWhitespace: function () {
            var reader = this._reader,
              whitespace = "",
              c = reader.peek();
            while (isWhitespace(c)) {
              reader.read();
              whitespace += c;
              c = reader.peek();
            }
            return whitespace;
          },
          readNumber: function (first) {
            var reader = this._reader,
              number = first,
              hasDot = first === ".",
              c = reader.peek();
            while (c) {
              if (isDigit(c)) {
                number += reader.read();
              } else if (c === ".") {
                if (hasDot) {
                  break;
                } else {
                  hasDot = true;
                  number += reader.read();
                }
              } else {
                break;
              }
              c = reader.peek();
            }
            return number;
          },
          // returns null w/o resetting reader if string is invalid.
          readString: function () {
            var token = this.stringToken(this._reader.read(), 0, 0);
            return token.type === Tokens.INVALID ? null : token.value;
          },
          // returns null w/o resetting reader if URI is invalid.
          readURI: function (first) {
            var reader = this._reader,
              uri = first,
              inner = "",
              c = reader.peek();

            //skip whitespace before
            while (c && isWhitespace(c)) {
              reader.read();
              c = reader.peek();
            }

            //it's a string
            if (c === "'" || c === "\"") {
              inner = this.readString();
              if (inner !== null) {
                inner = PropertyValuePart.parseString(inner);
              }
            } else {
              inner = this.readUnquotedURL();
            }
            c = reader.peek();

            //skip whitespace after
            while (c && isWhitespace(c)) {
              reader.read();
              c = reader.peek();
            }

            //if there was no inner value or the next character isn't closing paren, it's not a URI
            if (inner === null || c !== ")") {
              uri = null;
            } else {
              // Ensure argument to URL is always double-quoted
              // (This simplifies later processing in PropertyValuePart.)
              uri += PropertyValuePart.serializeString(inner) + reader.read();
            }
            return uri;
          },
          // This method never fails, although it may return an empty string.
          readUnquotedURL: function (first) {
            var reader = this._reader,
              url = first || "",
              c;
            for (c = reader.peek(); c; c = reader.peek()) {
              // Note that the grammar at
              // https://www.w3.org/TR/CSS2/grammar.html#scanner
              // incorrectly includes the backslash character in the
              // `url` production, although it is correctly omitted in
              // the `baduri1` production.
              if (nonascii.test(c) || /^[\-!#$%&*-\[\]-~]$/.test(c)) {
                url += c;
                reader.read();
              } else if (c === "\\") {
                if (/^[^\r\n\f]$/.test(reader.peek(2))) {
                  url += this.readEscape(reader.read(), true);
                } else {
                  break; // bad escape sequence.
                }
              } else {
                break; // bad character
              }
            }

            return url;
          },
          readName: function (first) {
            var reader = this._reader,
              ident = first || "",
              c;
            for (c = reader.peek(); c; c = reader.peek()) {
              if (c === "\\") {
                if (/^[^\r\n\f]$/.test(reader.peek(2))) {
                  ident += this.readEscape(reader.read(), true);
                } else {
                  // Bad escape sequence.
                  break;
                }
              } else if (isNameChar(c)) {
                ident += reader.read();
              } else {
                break;
              }
            }
            return ident;
          },
          readEscape: function (first, unescape) {
            var reader = this._reader,
              cssEscape = first || "",
              i = 0,
              c = reader.peek();
            if (isHexDigit(c)) {
              do {
                cssEscape += reader.read();
                c = reader.peek();
              } while (c && isHexDigit(c) && ++i < 6);
            }
            if (cssEscape.length === 1) {
              if (/^[^\r\n\f0-9a-f]$/.test(c)) {
                reader.read();
                if (unescape) {
                  return c;
                }
              } else {
                // We should never get here (readName won't call readEscape
                // if the escape sequence is bad).
                throw new Error("Bad escape sequence.");
              }
            } else if (c === "\r") {
              reader.read();
              if (reader.peek() === "\n") {
                c += reader.read();
              }
            } else if (/^[ \t\n\f]$/.test(c)) {
              reader.read();
            } else {
              c = "";
            }
            if (unescape) {
              var cp = parseInt(cssEscape.slice(first.length), 16);
              return String.fromCodePoint ? String.fromCodePoint(cp) : String.fromCharCode(cp);
            }
            return cssEscape + c;
          },
          readComment: function (first) {
            var reader = this._reader,
              comment = first || "",
              c = reader.read();
            if (c === "*") {
              while (c) {
                comment += c;

                //look for end of comment
                if (comment.length > 2 && c === "*" && reader.peek() === "/") {
                  comment += reader.read();
                  break;
                }
                c = reader.read();
              }
              return comment;
            } else {
              return "";
            }
          }
        });
      }, {
        "../util/TokenStreamBase": 27,
        "./PropertyValuePart": 11,
        "./Tokens": 18
      }],
      18: [function (require, module, exports) {
        "use strict";

        var Tokens = module.exports = [
        /*
         * The following token names are defined in CSS3 Grammar: https://www.w3.org/TR/css3-syntax/#lexical
         */

        // HTML-style comments
        {
          name: "CDO"
        }, {
          name: "CDC"
        },
        // ignorables
        {
          name: "S",
          whitespace: true /*, channel: "ws"*/
        }, {
          name: "COMMENT",
          comment: true,
          hide: true,
          channel: "comment"
        },
        // attribute equality
        {
          name: "INCLUDES",
          text: "~="
        }, {
          name: "DASHMATCH",
          text: "|="
        }, {
          name: "PREFIXMATCH",
          text: "^="
        }, {
          name: "SUFFIXMATCH",
          text: "$="
        }, {
          name: "SUBSTRINGMATCH",
          text: "*="
        },
        // identifier types
        {
          name: "STRING"
        }, {
          name: "IDENT"
        }, {
          name: "HASH"
        },
        // at-keywords
        {
          name: "IMPORT_SYM",
          text: "@import"
        }, {
          name: "PAGE_SYM",
          text: "@page"
        }, {
          name: "MEDIA_SYM",
          text: "@media"
        }, {
          name: "FONT_FACE_SYM",
          text: "@font-face"
        }, {
          name: "CHARSET_SYM",
          text: "@charset"
        }, {
          name: "NAMESPACE_SYM",
          text: "@namespace"
        }, {
          name: "SUPPORTS_SYM",
          text: "@supports"
        }, {
          name: "VIEWPORT_SYM",
          text: ["@viewport", "@-ms-viewport", "@-o-viewport"]
        }, {
          name: "DOCUMENT_SYM",
          text: ["@document", "@-moz-document"]
        }, {
          name: "UNKNOWN_SYM"
        },
        //{ name: "ATKEYWORD"},

        // CSS3 animations
        {
          name: "KEYFRAMES_SYM",
          text: ["@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes"]
        },
        // important symbol
        {
          name: "IMPORTANT_SYM"
        },
        // measurements
        {
          name: "LENGTH"
        }, {
          name: "ANGLE"
        }, {
          name: "TIME"
        }, {
          name: "FREQ"
        }, {
          name: "DIMENSION"
        }, {
          name: "PERCENTAGE"
        }, {
          name: "NUMBER"
        },
        // functions
        {
          name: "URI"
        }, {
          name: "FUNCTION"
        },
        // Unicode ranges
        {
          name: "UNICODE_RANGE"
        },
        /*
         * The following token names are defined in CSS3 Selectors: https://www.w3.org/TR/css3-selectors/#selector-syntax
         */

        // invalid string
        {
          name: "INVALID"
        },
        // combinators
        {
          name: "PLUS",
          text: "+"
        }, {
          name: "GREATER",
          text: ">"
        }, {
          name: "COMMA",
          text: ","
        }, {
          name: "TILDE",
          text: "~"
        },
        // modifier
        {
          name: "NOT"
        },
        /*
         * Defined in CSS3 Paged Media
         */
        {
          name: "TOPLEFTCORNER_SYM",
          text: "@top-left-corner"
        }, {
          name: "TOPLEFT_SYM",
          text: "@top-left"
        }, {
          name: "TOPCENTER_SYM",
          text: "@top-center"
        }, {
          name: "TOPRIGHT_SYM",
          text: "@top-right"
        }, {
          name: "TOPRIGHTCORNER_SYM",
          text: "@top-right-corner"
        }, {
          name: "BOTTOMLEFTCORNER_SYM",
          text: "@bottom-left-corner"
        }, {
          name: "BOTTOMLEFT_SYM",
          text: "@bottom-left"
        }, {
          name: "BOTTOMCENTER_SYM",
          text: "@bottom-center"
        }, {
          name: "BOTTOMRIGHT_SYM",
          text: "@bottom-right"
        }, {
          name: "BOTTOMRIGHTCORNER_SYM",
          text: "@bottom-right-corner"
        }, {
          name: "LEFTTOP_SYM",
          text: "@left-top"
        }, {
          name: "LEFTMIDDLE_SYM",
          text: "@left-middle"
        }, {
          name: "LEFTBOTTOM_SYM",
          text: "@left-bottom"
        }, {
          name: "RIGHTTOP_SYM",
          text: "@right-top"
        }, {
          name: "RIGHTMIDDLE_SYM",
          text: "@right-middle"
        }, {
          name: "RIGHTBOTTOM_SYM",
          text: "@right-bottom"
        },
        /*
         * The following token names are defined in CSS3 Media Queries: https://www.w3.org/TR/css3-mediaqueries/#syntax
         */
        /*{ name: "MEDIA_ONLY", state: "media"},
        { name: "MEDIA_NOT", state: "media"},
        { name: "MEDIA_AND", state: "media"},*/
        {
          name: "RESOLUTION",
          state: "media"
        },
        /*
         * The following token names are not defined in any CSS specification but are used by the lexer.
         */

        // not a real token, but useful for stupid IE filters
        {
          name: "IE_FUNCTION"
        },
        // part of CSS3 grammar but not the Flex code
        {
          name: "CHAR"
        },
        // TODO: Needed?
        // Not defined as tokens, but might as well be
        {
          name: "PIPE",
          text: "|"
        }, {
          name: "SLASH",
          text: "/"
        }, {
          name: "MINUS",
          text: "-"
        }, {
          name: "STAR",
          text: "*"
        }, {
          name: "LBRACE",
          endChar: "}",
          text: "{"
        }, {
          name: "RBRACE",
          text: "}"
        }, {
          name: "LBRACKET",
          endChar: "]",
          text: "["
        }, {
          name: "RBRACKET",
          text: "]"
        }, {
          name: "EQUALS",
          text: "="
        }, {
          name: "COLON",
          text: ":"
        }, {
          name: "SEMICOLON",
          text: ";"
        }, {
          name: "LPAREN",
          endChar: ")",
          text: "("
        }, {
          name: "RPAREN",
          text: ")"
        }, {
          name: "DOT",
          text: "."
        }];
        (function () {
          var nameMap = [],
            typeMap = Object.create(null);
          Tokens.UNKNOWN = -1;
          Tokens.unshift({
            name: "EOF"
          });
          for (var i = 0, len = Tokens.length; i < len; i++) {
            nameMap.push(Tokens[i].name);
            Tokens[Tokens[i].name] = i;
            if (Tokens[i].text) {
              if (Tokens[i].text instanceof Array) {
                for (var j = 0; j < Tokens[i].text.length; j++) {
                  typeMap[Tokens[i].text[j]] = i;
                }
              } else {
                typeMap[Tokens[i].text] = i;
              }
            }
          }
          Tokens.name = function (tt) {
            return nameMap[tt];
          };
          Tokens.type = function (c) {
            return typeMap[c] || -1;
          };
        })();
      }, {}],
      19: [function (require, module, exports) {
        "use strict";

        /* exported Validation */
        var Matcher = require("./Matcher");
        var Properties = require("./Properties");
        var ValidationTypes = require("./ValidationTypes");
        var ValidationError = require("./ValidationError");
        var PropertyValueIterator = require("./PropertyValueIterator");
        var Validation = module.exports = {
          validate: function (property, value) {
            //normalize name
            var name = property.toString().toLowerCase(),
              expression = new PropertyValueIterator(value),
              spec = Properties[name],
              part;
            if (!spec) {
              if (name.indexOf("-") !== 0) {
                //vendor prefixed are ok
                throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
              }
            } else if (typeof spec !== "number") {
              // All properties accept some CSS-wide values.
              // https://drafts.csswg.org/css-values-3/#common-keywords
              if (ValidationTypes.isAny(expression, "inherit | initial | unset")) {
                if (expression.hasNext()) {
                  part = expression.next();
                  throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                }
                return;
              }

              // Property-specific validation.
              this.singleProperty(spec, expression);
            }
          },
          singleProperty: function (types, expression) {
            var result = false,
              value = expression.value,
              part;
            result = Matcher.parse(types).match(expression);
            if (!result) {
              if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
              } else {
                throw new ValidationError("Expected (" + ValidationTypes.describe(types) + ") but found '" + value + "'.", value.line, value.col);
              }
            } else if (expression.hasNext()) {
              part = expression.next();
              throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
          }
        };
      }, {
        "./Matcher": 3,
        "./Properties": 7,
        "./PropertyValueIterator": 10,
        "./ValidationError": 20,
        "./ValidationTypes": 21
      }],
      20: [function (require, module, exports) {
        "use strict";

        module.exports = ValidationError;

        /**
         * Type to use when a validation error occurs.
         * @class ValidationError
         * @namespace parserlib.util
         * @constructor
         * @param {String} message The error message.
         * @param {int} line The line at which the error occurred.
         * @param {int} col The column at which the error occurred.
         */
        function ValidationError(message, line, col) {
          /**
           * The column at which the error occurred.
           * @type int
           * @property col
           */
          this.col = col;

          /**
           * The line at which the error occurred.
           * @type int
           * @property line
           */
          this.line = line;

          /**
           * The text representation of the unit.
           * @type String
           * @property text
           */
          this.message = message;
        }

        //inherit from Error
        ValidationError.prototype = new Error();
      }, {}],
      21: [function (require, module, exports) {
        "use strict";

        var ValidationTypes = module.exports;
        var Matcher = require("./Matcher");
        function copy(to, from) {
          Object.keys(from).forEach(function (prop) {
            to[prop] = from[prop];
          });
        }
        copy(ValidationTypes, {
          isLiteral: function (part, literals) {
            var text = part.text.toString().toLowerCase(),
              args = literals.split(" | "),
              i,
              len,
              found = false;
            for (i = 0, len = args.length; i < len && !found; i++) {
              if (args[i].charAt(0) === "<") {
                found = this.simple[args[i]](part);
              } else if (args[i].slice(-2) === "()") {
                found = part.type === "function" && part.name === args[i].slice(0, -2);
              } else if (text === args[i].toLowerCase()) {
                found = true;
              }
            }
            return found;
          },
          isSimple: function (type) {
            return Boolean(this.simple[type]);
          },
          isComplex: function (type) {
            return Boolean(this.complex[type]);
          },
          describe: function (type) {
            if (this.complex[type] instanceof Matcher) {
              return this.complex[type].toString(0);
            }
            return type;
          },
          /**
           * Determines if the next part(s) of the given expression
           * are any of the given types.
           */
          isAny: function (expression, types) {
            var args = types.split(" | "),
              i,
              len,
              found = false;
            for (i = 0, len = args.length; i < len && !found && expression.hasNext(); i++) {
              found = this.isType(expression, args[i]);
            }
            return found;
          },
          /**
           * Determines if the next part(s) of the given expression
           * are one of a group.
           */
          isAnyOfGroup: function (expression, types) {
            var args = types.split(" || "),
              i,
              len,
              found = false;
            for (i = 0, len = args.length; i < len && !found; i++) {
              found = this.isType(expression, args[i]);
            }
            return found ? args[i - 1] : false;
          },
          /**
           * Determines if the next part(s) of the given expression
           * are of a given type.
           */
          isType: function (expression, type) {
            var part = expression.peek(),
              result = false;
            if (type.charAt(0) !== "<") {
              result = this.isLiteral(part, type);
              if (result) {
                expression.next();
              }
            } else if (this.simple[type]) {
              result = this.simple[type](part);
              if (result) {
                expression.next();
              }
            } else if (this.complex[type] instanceof Matcher) {
              result = this.complex[type].match(expression);
            } else {
              result = this.complex[type](expression);
            }
            return result;
          },
          simple: {
            __proto__: null,
            "<absolute-size>": "xx-small | x-small | small | medium | large | x-large | xx-large",
            "<animateable-feature>": "scroll-position | contents | <animateable-feature-name>",
            "<animateable-feature-name>": function (part) {
              return this["<ident>"](part) && !/^(unset|initial|inherit|will-change|auto|scroll-position|contents)$/i.test(part);
            },
            "<angle>": function (part) {
              return part.type === "angle";
            },
            "<attachment>": "scroll | fixed | local",
            "<attr>": "attr()",
            // inset() = inset( <shape-arg>{1,4} [round <border-radius>]? )
            // circle() = circle( [<shape-radius>]? [at <position>]? )
            // ellipse() = ellipse( [<shape-radius>{2}]? [at <position>]? )
            // polygon() = polygon( [<fill-rule>,]? [<shape-arg> <shape-arg>]# )
            "<basic-shape>": "inset() | circle() | ellipse() | polygon()",
            "<bg-image>": "<image> | <gradient> | none",
            "<border-style>": "none | hidden | dotted | dashed | solid | double | groove | " + "ridge | inset | outset",
            "<border-width>": "<length> | thin | medium | thick",
            "<box>": "padding-box | border-box | content-box",
            "<clip-source>": "<uri>",
            "<color>": function (part) {
              return part.type === "color" || String(part) === "transparent" || String(part) === "currentColor";
            },
            // The SVG <color> spec doesn't include "currentColor" or "transparent" as a color.
            "<color-svg>": function (part) {
              return part.type === "color";
            },
            "<content>": "content()",
            // https://www.w3.org/TR/css3-sizing/#width-height-keywords
            "<content-sizing>": "fill-available | -moz-available | -webkit-fill-available | " + "max-content | -moz-max-content | -webkit-max-content | " + "min-content | -moz-min-content | -webkit-min-content | " + "fit-content | -moz-fit-content | -webkit-fit-content",
            "<feature-tag-value>": function (part) {
              return part.type === "function" && /^[A-Z0-9]{4}$/i.test(part);
            },
            // custom() isn't actually in the spec
            "<filter-function>": "blur() | brightness() | contrast() | custom() | " + "drop-shadow() | grayscale() | hue-rotate() | invert() | " + "opacity() | saturate() | sepia()",
            "<flex-basis>": "<width>",
            "<flex-direction>": "row | row-reverse | column | column-reverse",
            "<flex-grow>": "<number>",
            "<flex-shrink>": "<number>",
            "<flex-wrap>": "nowrap | wrap | wrap-reverse",
            "<font-size>": "<absolute-size> | <relative-size> | <length> | <percentage>",
            "<font-stretch>": "normal | ultra-condensed | extra-condensed | condensed | " + "semi-condensed | semi-expanded | expanded | extra-expanded | " + "ultra-expanded",
            "<font-style>": "normal | italic | oblique",
            "<font-variant-caps>": "small-caps | all-small-caps | petite-caps | all-petite-caps | " + "unicase | titling-caps",
            "<font-variant-css21>": "normal | small-caps",
            "<font-weight>": "normal | bold | bolder | lighter | " + "100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900",
            "<generic-family>": "serif | sans-serif | cursive | fantasy | monospace",
            "<geometry-box>": "<shape-box> | fill-box | stroke-box | view-box",
            "<glyph-angle>": function (part) {
              return part.type === "angle" && part.units === "deg";
            },
            "<gradient>": function (part) {
              return part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
            },
            "<icccolor>": "cielab() | cielch() | cielchab() | " + "icc-color() | icc-named-color()",
            //any identifier
            "<ident>": function (part) {
              return part.type === "identifier" || part.wasIdent;
            },
            "<ident-not-generic-family>": function (part) {
              return this["<ident>"](part) && !this["<generic-family>"](part);
            },
            "<image>": "<uri>",
            "<integer>": function (part) {
              return part.type === "integer";
            },
            "<length>": function (part) {
              if (part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)) {
                return true;
              } else {
                return part.type === "length" || part.type === "number" || part.type === "integer" || String(part) === "0";
              }
            },
            "<line>": function (part) {
              return part.type === "integer";
            },
            "<line-height>": "<number> | <length> | <percentage> | normal",
            "<margin-width>": "<length> | <percentage> | auto",
            "<miterlimit>": function (part) {
              return this["<number>"](part) && part.value >= 1;
            },
            "<nonnegative-length-or-percentage>": function (part) {
              return (this["<length>"](part) || this["<percentage>"](part)) && (String(part) === "0" || part.type === "function" || part.value >= 0);
            },
            "<nonnegative-number-or-percentage>": function (part) {
              return (this["<number>"](part) || this["<percentage>"](part)) && (String(part) === "0" || part.type === "function" || part.value >= 0);
            },
            "<number>": function (part) {
              return part.type === "number" || this["<integer>"](part);
            },
            "<opacity-value>": function (part) {
              return this["<number>"](part) && part.value >= 0 && part.value <= 1;
            },
            "<padding-width>": "<nonnegative-length-or-percentage>",
            "<percentage>": function (part) {
              return part.type === "percentage" || String(part) === "0";
            },
            "<relative-size>": "smaller | larger",
            "<shape>": "rect() | inset-rect()",
            "<shape-box>": "<box> | margin-box",
            "<single-animation-direction>": "normal | reverse | alternate | alternate-reverse",
            "<single-animation-name>": function (part) {
              return this["<ident>"](part) && /^-?[a-z_][-a-z0-9_]+$/i.test(part) && !/^(none|unset|initial|inherit)$/i.test(part);
            },
            "<string>": function (part) {
              return part.type === "string";
            },
            "<time>": function (part) {
              return part.type === "time";
            },
            "<uri>": function (part) {
              return part.type === "uri";
            },
            "<width>": "<margin-width>"
          },
          complex: {
            __proto__: null,
            "<azimuth>": "<angle>" + " | " + "[ [ left-side | far-left | left | center-left | center | " + "center-right | right | far-right | right-side ] || behind ]" + " | " + "leftwards | rightwards",
            "<bg-position>": "<position>#",
            "<bg-size>": "[ <length> | <percentage> | auto ]{1,2} | cover | contain",
            "<border-image-slice>":
            // [<number> | <percentage>]{1,4} && fill?
            // *but* fill can appear between any of the numbers
            Matcher.many([true /* first element is required */], Matcher.cast("<nonnegative-number-or-percentage>"), Matcher.cast("<nonnegative-number-or-percentage>"), Matcher.cast("<nonnegative-number-or-percentage>"), Matcher.cast("<nonnegative-number-or-percentage>"), "fill"),
            "<border-radius>": "<nonnegative-length-or-percentage>{1,4} " + "[ / <nonnegative-length-or-percentage>{1,4} ]?",
            "<box-shadow>": "none | <shadow>#",
            "<clip-path>": "<basic-shape> || <geometry-box>",
            "<dasharray>":
            // "list of comma and/or white space separated <length>s and
            // <percentage>s".  There is a non-negative constraint.
            Matcher.cast("<nonnegative-length-or-percentage>").braces(1, Infinity, "#", Matcher.cast(",").question()),
            "<family-name>":
            // <string> | <IDENT>+
            "<string> | <ident-not-generic-family> <ident>*",
            "<filter-function-list>": "[ <filter-function> | <uri> ]+",
            // https://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property
            "<flex>": "none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]",
            "<font-family>": "[ <generic-family> | <family-name> ]#",
            "<font-shorthand>": "[ <font-style> || <font-variant-css21> || " + "<font-weight> || <font-stretch> ]? <font-size> " + "[ / <line-height> ]? <font-family>",
            "<font-variant-alternates>":
            // stylistic(<feature-value-name>)
            "stylistic() || " + "historical-forms || " +
            // styleset(<feature-value-name> #)
            "styleset() || " +
            // character-variant(<feature-value-name> #)
            "character-variant() || " +
            // swash(<feature-value-name>)
            "swash() || " +
            // ornaments(<feature-value-name>)
            "ornaments() || " +
            // annotation(<feature-value-name>)
            "annotation()",
            "<font-variant-ligatures>":
            // <common-lig-values>
            "[ common-ligatures | no-common-ligatures ] || " +
            // <discretionary-lig-values>
            "[ discretionary-ligatures | no-discretionary-ligatures ] || " +
            // <historical-lig-values>
            "[ historical-ligatures | no-historical-ligatures ] || " +
            // <contextual-alt-values>
            "[ contextual | no-contextual ]",
            "<font-variant-numeric>":
            // <numeric-figure-values>
            "[ lining-nums | oldstyle-nums ] || " +
            // <numeric-spacing-values>
            "[ proportional-nums | tabular-nums ] || " +
            // <numeric-fraction-values>
            "[ diagonal-fractions | stacked-fractions ] || " + "ordinal || slashed-zero",
            "<font-variant-east-asian>":
            // <east-asian-variant-values>
            "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ] || " +
            // <east-asian-width-values>
            "[ full-width | proportional-width ] || " + "ruby",
            // Note that <color> here is "as defined in the SVG spec", which
            // is more restrictive that the <color> defined in the CSS spec.
            // none | currentColor | <color> [<icccolor>]? |
            // <funciri> [ none | currentColor | <color> [<icccolor>]? ]?
            "<paint>": "<paint-basic> | <uri> <paint-basic>?",
            // Helper definition for <paint> above.
            "<paint-basic>": "none | currentColor | <color-svg> <icccolor>?",
            "<position>":
            // Because our `alt` combinator is ordered, we need to test these
            // in order from longest possible match to shortest.
            "[ center | [ left | right ] [ <percentage> | <length> ]? ] && " + "[ center | [ top | bottom ] [ <percentage> | <length> ]? ]" + " | " + "[ left | center | right | <percentage> | <length> ] " + "[ top | center | bottom | <percentage> | <length> ]" + " | " + "[ left | center | right | top | bottom | <percentage> | <length> ]",
            "<repeat-style>": "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}",
            "<shadow>":
            //inset? && [ <length>{2,4} && <color>? ]
            Matcher.many([true /* length is required */], Matcher.cast("<length>").braces(2, 4), "inset", "<color>"),
            "<text-decoration-color>": "<color>",
            "<text-decoration-line>": "none | [ underline || overline || line-through || blink ]",
            "<text-decoration-style>": "solid | double | dotted | dashed | wavy",
            "<will-change>": "auto | <animateable-feature>#",
            "<x-one-radius>":
            //[ <length> | <percentage> ] [ <length> | <percentage> ]?
            "[ <length> | <percentage> ]{1,2}"
          }
        });
        Object.keys(ValidationTypes.simple).forEach(function (nt) {
          var rule = ValidationTypes.simple[nt];
          if (typeof rule === "string") {
            ValidationTypes.simple[nt] = function (part) {
              return ValidationTypes.isLiteral(part, rule);
            };
          }
        });
        Object.keys(ValidationTypes.complex).forEach(function (nt) {
          var rule = ValidationTypes.complex[nt];
          if (typeof rule === "string") {
            ValidationTypes.complex[nt] = Matcher.parse(rule);
          }
        });

        // Because this is defined relative to other complex validation types,
        // we need to define it *after* the rest of the types are initialized.
        ValidationTypes.complex["<font-variant>"] = Matcher.oror({
          expand: "<font-variant-ligatures>"
        }, {
          expand: "<font-variant-alternates>"
        }, "<font-variant-caps>", {
          expand: "<font-variant-numeric>"
        }, {
          expand: "<font-variant-east-asian>"
        });
      }, {
        "./Matcher": 3
      }],
      22: [function (require, module, exports) {
        "use strict";

        module.exports = {
          Colors: require("./Colors"),
          Combinator: require("./Combinator"),
          Parser: require("./Parser"),
          PropertyName: require("./PropertyName"),
          PropertyValue: require("./PropertyValue"),
          PropertyValuePart: require("./PropertyValuePart"),
          Matcher: require("./Matcher"),
          MediaFeature: require("./MediaFeature"),
          MediaQuery: require("./MediaQuery"),
          Selector: require("./Selector"),
          SelectorPart: require("./SelectorPart"),
          SelectorSubPart: require("./SelectorSubPart"),
          Specificity: require("./Specificity"),
          TokenStream: require("./TokenStream"),
          Tokens: require("./Tokens"),
          ValidationError: require("./ValidationError")
        };
      }, {
        "./Colors": 1,
        "./Combinator": 2,
        "./Matcher": 3,
        "./MediaFeature": 4,
        "./MediaQuery": 5,
        "./Parser": 6,
        "./PropertyName": 8,
        "./PropertyValue": 9,
        "./PropertyValuePart": 11,
        "./Selector": 13,
        "./SelectorPart": 14,
        "./SelectorSubPart": 15,
        "./Specificity": 16,
        "./TokenStream": 17,
        "./Tokens": 18,
        "./ValidationError": 20
      }],
      23: [function (require, module, exports) {
        "use strict";

        module.exports = EventTarget;

        /**
         * A generic base to inherit from for any object
         * that needs event handling.
         * @class EventTarget
         * @constructor
         */
        function EventTarget() {
          /**
           * The array of listeners for various events.
           * @type Object
           * @property _listeners
           * @private
           */
          this._listeners = Object.create(null);
        }
        EventTarget.prototype = {
          //restore constructor
          constructor: EventTarget,
          /**
           * Adds a listener for a given event type.
           * @param {String} type The type of event to add a listener for.
           * @param {Function} listener The function to call when the event occurs.
           * @return {void}
           * @method addListener
           */
          addListener: function (type, listener) {
            if (!this._listeners[type]) {
              this._listeners[type] = [];
            }
            this._listeners[type].push(listener);
          },
          /**
           * Fires an event based on the passed-in object.
           * @param {Object|String} event An object with at least a 'type' attribute
           *      or a string indicating the event name.
           * @return {void}
           * @method fire
           */
          fire: function (event) {
            if (typeof event === "string") {
              event = {
                type: event
              };
            }
            if (typeof event.target !== "undefined") {
              event.target = this;
            }
            if (typeof event.type === "undefined") {
              throw new Error("Event object missing 'type' property.");
            }
            if (this._listeners[event.type]) {
              //create a copy of the array and use that so listeners can't chane
              var listeners = this._listeners[event.type].concat();
              for (var i = 0, len = listeners.length; i < len; i++) {
                listeners[i].call(this, event);
              }
            }
          },
          /**
           * Removes a listener for a given event type.
           * @param {String} type The type of event to remove a listener from.
           * @param {Function} listener The function to remove from the event.
           * @return {void}
           * @method removeListener
           */
          removeListener: function (type, listener) {
            if (this._listeners[type]) {
              var listeners = this._listeners[type];
              for (var i = 0, len = listeners.length; i < len; i++) {
                if (listeners[i] === listener) {
                  listeners.splice(i, 1);
                  break;
                }
              }
            }
          }
        };
      }, {}],
      24: [function (require, module, exports) {
        "use strict";

        module.exports = StringReader;

        /**
         * Convenient way to read through strings.
         * @namespace parserlib.util
         * @class StringReader
         * @constructor
         * @param {String} text The text to read.
         */
        function StringReader(text) {
          /**
           * The input text with line endings normalized.
           * @property _input
           * @type String
           * @private
           */
          this._input = text.replace(/(\r\n?|\n)/g, "\n");

          /**
           * The row for the character to be read next.
           * @property _line
           * @type int
           * @private
           */
          this._line = 1;

          /**
           * The column for the character to be read next.
           * @property _col
           * @type int
           * @private
           */
          this._col = 1;

          /**
           * The index of the character in the input to be read next.
           * @property _cursor
           * @type int
           * @private
           */
          this._cursor = 0;
        }
        StringReader.prototype = {
          // restore constructor
          constructor: StringReader,
          //-------------------------------------------------------------------------
          // Position info
          //-------------------------------------------------------------------------

          /**
           * Returns the column of the character to be read next.
           * @return {int} The column of the character to be read next.
           * @method getCol
           */
          getCol: function () {
            return this._col;
          },
          /**
           * Returns the row of the character to be read next.
           * @return {int} The row of the character to be read next.
           * @method getLine
           */
          getLine: function () {
            return this._line;
          },
          /**
           * Determines if you're at the end of the input.
           * @return {Boolean} True if there's no more input, false otherwise.
           * @method eof
           */
          eof: function () {
            return this._cursor === this._input.length;
          },
          //-------------------------------------------------------------------------
          // Basic reading
          //-------------------------------------------------------------------------

          /**
           * Reads the next character without advancing the cursor.
           * @param {int} count How many characters to look ahead (default is 1).
           * @return {String} The next character or null if there is no next character.
           * @method peek
           */
          peek: function (count) {
            var c = null;
            count = typeof count === "undefined" ? 1 : count;

            // if we're not at the end of the input...
            if (this._cursor < this._input.length) {
              // get character and increment cursor and column
              c = this._input.charAt(this._cursor + count - 1);
            }
            return c;
          },
          /**
           * Reads the next character from the input and adjusts the row and column
           * accordingly.
           * @return {String} The next character or null if there is no next character.
           * @method read
           */
          read: function () {
            var c = null;

            // if we're not at the end of the input...
            if (this._cursor < this._input.length) {
              // if the last character was a newline, increment row count
              // and reset column count
              if (this._input.charAt(this._cursor) === "\n") {
                this._line++;
                this._col = 1;
              } else {
                this._col++;
              }

              // get character and increment cursor and column
              c = this._input.charAt(this._cursor++);
            }
            return c;
          },
          //-------------------------------------------------------------------------
          // Misc
          //-------------------------------------------------------------------------

          /**
           * Saves the current location so it can be returned to later.
           * @method mark
           * @return {void}
           */
          mark: function () {
            this._bookmark = {
              cursor: this._cursor,
              line: this._line,
              col: this._col
            };
          },
          reset: function () {
            if (this._bookmark) {
              this._cursor = this._bookmark.cursor;
              this._line = this._bookmark.line;
              this._col = this._bookmark.col;
              delete this._bookmark;
            }
          },
          //-------------------------------------------------------------------------
          // Advanced reading
          //-------------------------------------------------------------------------

          /**
           * Reads up to and including the given string. Throws an error if that
           * string is not found.
           * @param {String} pattern The string to read.
           * @return {String} The string when it is found.
           * @throws Error when the string pattern is not found.
           * @method readTo
           */
          readTo: function (pattern) {
            var buffer = "",
              c;

            /*
             * First, buffer must be the same length as the pattern.
             * Then, buffer must end with the pattern or else reach the
             * end of the input.
             */
            while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {
              c = this.read();
              if (c) {
                buffer += c;
              } else {
                throw new Error("Expected \"" + pattern + "\" at line " + this._line + ", col " + this._col + ".");
              }
            }
            return buffer;
          },
          /**
           * Reads characters while each character causes the given
           * filter function to return true. The function is passed
           * in each character and either returns true to continue
           * reading or false to stop.
           * @param {Function} filter The function to read on each character.
           * @return {String} The string made up of all characters that passed the
           *      filter check.
           * @method readWhile
           */
          readWhile: function (filter) {
            var buffer = "",
              c = this.peek();
            while (c !== null && filter(c)) {
              buffer += this.read();
              c = this.peek();
            }
            return buffer;
          },
          /**
           * Reads characters that match either text or a regular expression and
           * returns those characters. If a match is found, the row and column
           * are adjusted; if no match is found, the reader's state is unchanged.
           * reading or false to stop.
           * @param {String|RegExp} matcher If a string, then the literal string
           *      value is searched for. If a regular expression, then any string
           *      matching the pattern is search for.
           * @return {String} The string made up of all characters that matched or
           *      null if there was no match.
           * @method readMatch
           */
          readMatch: function (matcher) {
            var source = this._input.substring(this._cursor),
              value = null;

            // if it's a string, just do a straight match
            if (typeof matcher === "string") {
              if (source.slice(0, matcher.length) === matcher) {
                value = this.readCount(matcher.length);
              }
            } else if (matcher instanceof RegExp) {
              if (matcher.test(source)) {
                value = this.readCount(RegExp.lastMatch.length);
              }
            }
            return value;
          },
          /**
           * Reads a given number of characters. If the end of the input is reached,
           * it reads only the remaining characters and does not throw an error.
           * @param {int} count The number of characters to read.
           * @return {String} The string made up the read characters.
           * @method readCount
           */
          readCount: function (count) {
            var buffer = "";
            while (count--) {
              buffer += this.read();
            }
            return buffer;
          }
        };
      }, {}],
      25: [function (require, module, exports) {
        "use strict";

        module.exports = SyntaxError;

        /**
         * Type to use when a syntax error occurs.
         * @class SyntaxError
         * @namespace parserlib.util
         * @constructor
         * @param {String} message The error message.
         * @param {int} line The line at which the error occurred.
         * @param {int} col The column at which the error occurred.
         */
        function SyntaxError(message, line, col) {
          Error.call(this);
          this.name = this.constructor.name;

          /**
           * The column at which the error occurred.
           * @type int
           * @property col
           */
          this.col = col;

          /**
           * The line at which the error occurred.
           * @type int
           * @property line
           */
          this.line = line;

          /**
           * The text representation of the unit.
           * @type String
           * @property text
           */
          this.message = message;
        }

        //inherit from Error
        SyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line
        SyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line
      }, {}],
      26: [function (require, module, exports) {
        "use strict";

        module.exports = SyntaxUnit;

        /**
         * Base type to represent a single syntactic unit.
         * @class SyntaxUnit
         * @namespace parserlib.util
         * @constructor
         * @param {String} text The text of the unit.
         * @param {int} line The line of text on which the unit resides.
         * @param {int} col The column of text on which the unit resides.
         */
        function SyntaxUnit(text, line, col, type) {
          /**
           * The column of text on which the unit resides.
           * @type int
           * @property col
           */
          this.col = col;

          /**
           * The line of text on which the unit resides.
           * @type int
           * @property line
           */
          this.line = line;

          /**
           * The text representation of the unit.
           * @type String
           * @property text
           */
          this.text = text;

          /**
           * The type of syntax unit.
           * @type int
           * @property type
           */
          this.type = type;
        }

        /**
         * Create a new syntax unit based solely on the given token.
         * Convenience method for creating a new syntax unit when
         * it represents a single token instead of multiple.
         * @param {Object} token The token object to represent.
         * @return {parserlib.util.SyntaxUnit} The object representing the token.
         * @static
         * @method fromToken
         */
        SyntaxUnit.fromToken = function (token) {
          return new SyntaxUnit(token.value, token.startLine, token.startCol);
        };
        SyntaxUnit.prototype = {
          //restore constructor
          constructor: SyntaxUnit,
          /**
           * Returns the text representation of the unit.
           * @return {String} The text representation of the unit.
           * @method valueOf
           */
          valueOf: function () {
            return this.toString();
          },
          /**
           * Returns the text representation of the unit.
           * @return {String} The text representation of the unit.
           * @method toString
           */
          toString: function () {
            return this.text;
          }
        };
      }, {}],
      27: [function (require, module, exports) {
        "use strict";

        module.exports = TokenStreamBase;
        var StringReader = require("./StringReader");
        var SyntaxError = require("./SyntaxError");

        /**
         * Generic TokenStream providing base functionality.
         * @class TokenStreamBase
         * @namespace parserlib.util
         * @constructor
         * @param {String|StringReader} input The text to tokenize or a reader from
         *      which to read the input.
         */
        function TokenStreamBase(input, tokenData) {
          /**
           * The string reader for easy access to the text.
           * @type StringReader
           * @property _reader
           * @private
           */
          this._reader = new StringReader(input ? input.toString() : "");

          /**
           * Token object for the last consumed token.
           * @type Token
           * @property _token
           * @private
           */
          this._token = null;

          /**
           * The array of token information.
           * @type Array
           * @property _tokenData
           * @private
           */
          this._tokenData = tokenData;

          /**
           * Lookahead token buffer.
           * @type Array
           * @property _lt
           * @private
           */
          this._lt = [];

          /**
           * Lookahead token buffer index.
           * @type int
           * @property _ltIndex
           * @private
           */
          this._ltIndex = 0;
          this._ltIndexCache = [];
        }

        /**
         * Accepts an array of token information and outputs
         * an array of token data containing key-value mappings
         * and matching functions that the TokenStream needs.
         * @param {Array} tokens An array of token descriptors.
         * @return {Array} An array of processed token data.
         * @method createTokenData
         * @static
         */
        TokenStreamBase.createTokenData = function (tokens) {
          var nameMap = [],
            typeMap = Object.create(null),
            tokenData = tokens.concat([]),
            i = 0,
            len = tokenData.length + 1;
          tokenData.UNKNOWN = -1;
          tokenData.unshift({
            name: "EOF"
          });
          for (; i < len; i++) {
            nameMap.push(tokenData[i].name);
            tokenData[tokenData[i].name] = i;
            if (tokenData[i].text) {
              typeMap[tokenData[i].text] = i;
            }
          }
          tokenData.name = function (tt) {
            return nameMap[tt];
          };
          tokenData.type = function (c) {
            return typeMap[c];
          };
          return tokenData;
        };
        TokenStreamBase.prototype = {
          //restore constructor
          constructor: TokenStreamBase,
          //-------------------------------------------------------------------------
          // Matching methods
          //-------------------------------------------------------------------------

          /**
           * Determines if the next token matches the given token type.
           * If so, that token is consumed; if not, the token is placed
           * back onto the token stream. You can pass in any number of
           * token types and this will return true if any of the token
           * types is found.
           * @param {int|int[]} tokenTypes Either a single token type or an array of
           *      token types that the next token might be. If an array is passed,
           *      it's assumed that the token can be any of these.
           * @param {variant} channel (Optional) The channel to read from. If not
           *      provided, reads from the default (unnamed) channel.
           * @return {Boolean} True if the token type matches, false if not.
           * @method match
           */
          match: function (tokenTypes, channel) {
            //always convert to an array, makes things easier
            if (!(tokenTypes instanceof Array)) {
              tokenTypes = [tokenTypes];
            }
            var tt = this.get(channel),
              i = 0,
              len = tokenTypes.length;
            while (i < len) {
              if (tt === tokenTypes[i++]) {
                return true;
              }
            }

            //no match found, put the token back
            this.unget();
            return false;
          },
          /**
           * Determines if the next token matches the given token type.
           * If so, that token is consumed; if not, an error is thrown.
           * @param {int|int[]} tokenTypes Either a single token type or an array of
           *      token types that the next token should be. If an array is passed,
           *      it's assumed that the token must be one of these.
           * @return {void}
           * @method mustMatch
           */
          mustMatch: function (tokenTypes) {
            var token;

            //always convert to an array, makes things easier
            if (!(tokenTypes instanceof Array)) {
              tokenTypes = [tokenTypes];
            }
            if (!this.match.apply(this, arguments)) {
              token = this.LT(1);
              throw new SyntaxError("Expected " + this._tokenData[tokenTypes[0]].name + " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            }
          },
          //-------------------------------------------------------------------------
          // Consuming methods
          //-------------------------------------------------------------------------

          /**
           * Keeps reading from the token stream until either one of the specified
           * token types is found or until the end of the input is reached.
           * @param {int|int[]} tokenTypes Either a single token type or an array of
           *      token types that the next token should be. If an array is passed,
           *      it's assumed that the token must be one of these.
           * @param {variant} channel (Optional) The channel to read from. If not
           *      provided, reads from the default (unnamed) channel.
           * @return {void}
           * @method advance
           */
          advance: function (tokenTypes, channel) {
            while (this.LA(0) !== 0 && !this.match(tokenTypes, channel)) {
              this.get();
            }
            return this.LA(0);
          },
          /**
           * Consumes the next token from the token stream.
           * @return {int} The token type of the token that was just consumed.
           * @method get
           */
          get: function (channel) {
            var tokenInfo = this._tokenData,
              i = 0,
              token,
              info;

            //check the lookahead buffer first
            if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length) {
              i++;
              this._token = this._lt[this._ltIndex++];
              info = tokenInfo[this._token.type];

              //obey channels logic
              while (info.channel !== undefined && channel !== info.channel && this._ltIndex < this._lt.length) {
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];
                i++;
              }

              //here be dragons
              if ((info.channel === undefined || channel === info.channel) && this._ltIndex <= this._lt.length) {
                this._ltIndexCache.push(i);
                return this._token.type;
              }
            }

            //call token retriever method
            token = this._getToken();

            //if it should be hidden, don't save a token
            if (token.type > -1 && !tokenInfo[token.type].hide) {
              //apply token channel
              token.channel = tokenInfo[token.type].channel;

              //save for later
              this._token = token;
              this._lt.push(token);

              //save space that will be moved (must be done before array is truncated)
              this._ltIndexCache.push(this._lt.length - this._ltIndex + i);

              //keep the buffer under 5 items
              if (this._lt.length > 5) {
                this._lt.shift();
              }

              //also keep the shift buffer under 5 items
              if (this._ltIndexCache.length > 5) {
                this._ltIndexCache.shift();
              }

              //update lookahead index
              this._ltIndex = this._lt.length;
            }

            /*
             * Skip to the next token if:
             * 1. The token type is marked as hidden.
             * 2. The token type has a channel specified and it isn't the current channel.
             */
            info = tokenInfo[token.type];
            if (info && (info.hide || info.channel !== undefined && channel !== info.channel)) {
              return this.get(channel);
            } else {
              //return just the type
              return token.type;
            }
          },
          /**
           * Looks ahead a certain number of tokens and returns the token type at
           * that position. This will throw an error if you lookahead past the
           * end of input, past the size of the lookahead buffer, or back past
           * the first token in the lookahead buffer.
           * @param {int} The index of the token type to retrieve. 0 for the
           *      current token, 1 for the next, -1 for the previous, etc.
           * @return {int} The token type of the token in the given position.
           * @method LA
           */
          LA: function (index) {
            var total = index,
              tt;
            if (index > 0) {
              //TODO: Store 5 somewhere
              if (index > 5) {
                throw new Error("Too much lookahead.");
              }

              //get all those tokens
              while (total) {
                tt = this.get();
                total--;
              }

              //unget all those tokens
              while (total < index) {
                this.unget();
                total++;
              }
            } else if (index < 0) {
              if (this._lt[this._ltIndex + index]) {
                tt = this._lt[this._ltIndex + index].type;
              } else {
                throw new Error("Too much lookbehind.");
              }
            } else {
              tt = this._token.type;
            }
            return tt;
          },
          /**
           * Looks ahead a certain number of tokens and returns the token at
           * that position. This will throw an error if you lookahead past the
           * end of input, past the size of the lookahead buffer, or back past
           * the first token in the lookahead buffer.
           * @param {int} The index of the token type to retrieve. 0 for the
           *      current token, 1 for the next, -1 for the previous, etc.
           * @return {Object} The token of the token in the given position.
           * @method LA
           */
          LT: function (index) {
            //lookahead first to prime the token buffer
            this.LA(index);

            //now find the token, subtract one because _ltIndex is already at the next index
            return this._lt[this._ltIndex + index - 1];
          },
          /**
           * Returns the token type for the next token in the stream without
           * consuming it.
           * @return {int} The token type of the next token in the stream.
           * @method peek
           */
          peek: function () {
            return this.LA(1);
          },
          /**
           * Returns the actual token object for the last consumed token.
           * @return {Token} The token object for the last consumed token.
           * @method token
           */
          token: function () {
            return this._token;
          },
          /**
           * Returns the name of the token for the given token type.
           * @param {int} tokenType The type of token to get the name of.
           * @return {String} The name of the token or "UNKNOWN_TOKEN" for any
           *      invalid token type.
           * @method tokenName
           */
          tokenName: function (tokenType) {
            if (tokenType < 0 || tokenType > this._tokenData.length) {
              return "UNKNOWN_TOKEN";
            } else {
              return this._tokenData[tokenType].name;
            }
          },
          /**
           * Returns the token type value for the given token name.
           * @param {String} tokenName The name of the token whose value should be returned.
           * @return {int} The token type value for the given token name or -1
           *      for an unknown token.
           * @method tokenName
           */
          tokenType: function (tokenName) {
            return this._tokenData[tokenName] || -1;
          },
          /**
           * Returns the last consumed token to the token stream.
           * @method unget
           */
          unget: function () {
            //if (this._ltIndex > -1) {
            if (this._ltIndexCache.length) {
              this._ltIndex -= this._ltIndexCache.pop(); //--;
              this._token = this._lt[this._ltIndex - 1];
            } else {
              throw new Error("Too much lookahead.");
            }
          }
        };
      }, {
        "./StringReader": 24,
        "./SyntaxError": 25
      }],
      28: [function (require, module, exports) {
        "use strict";

        module.exports = {
          StringReader: require("./StringReader"),
          SyntaxError: require("./SyntaxError"),
          SyntaxUnit: require("./SyntaxUnit"),
          EventTarget: require("./EventTarget"),
          TokenStreamBase: require("./TokenStreamBase")
        };
      }, {
        "./EventTarget": 23,
        "./StringReader": 24,
        "./SyntaxError": 25,
        "./SyntaxUnit": 26,
        "./TokenStreamBase": 27
      }],
      "parserlib": [function (require, module, exports) {
        "use strict";

        module.exports = {
          css: require("./css"),
          util: require("./util")
        };
      }, {
        "./css": 22,
        "./util": 28
      }]
    }, {}, []);
    return require('parserlib');
  }();
  var clone = function () {
    'use strict';

    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_) {
      // maybe a reference error because no `Map`. Give it a dummy value that no
      // value will ever be an instanceof.
      nativeMap = function () {};
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_) {
      nativeSet = function () {};
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_) {
      nativePromise = function () {};
    }

    /**
     * Clones (copies) an Object using deep copying.
     *
     * This function supports circular references by default, but if you are certain
     * there are no circular references in your object, you can save some CPU time
     * by calling clone(obj, false).
     *
     * Caution: if `circular` is false and `parent` contains circular references,
     * your program may enter an infinite loop and crash.
     *
     * @param `parent` - the object to be cloned
     * @param `circular` - set to true if the object to be cloned may contain
     *    circular references. (optional - true by default)
     * @param `depth` - set to a number if the object is only to be cloned to
     *    a particular depth. (optional - defaults to Infinity)
     * @param `prototype` - sets the prototype to be used when cloning an object.
     *    (optional - defaults to parent prototype).
     * @param `includeNonEnumerable` - set to true if the non-enumerable properties
     *    should be cloned as well. Non-enumerable properties on the prototype
     *    chain will be ignored. (optional - false by default)
    */
    function clone(parent, circular, depth, prototype, includeNonEnumerable) {
      if (typeof circular === 'object') {
        depth = circular.depth;
        prototype = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      // maintain two arrays for circular references, where corresponding parents
      // and children have the same index
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != 'undefined';
      if (typeof circular == 'undefined') circular = true;
      if (typeof depth == 'undefined') depth = Infinity;

      // recurse this function so we don't reset allParents and allChildren
      function _clone(parent, depth) {
        // cloning null always returns null
        if (parent === null) return null;
        if (depth === 0) return parent;
        var child;
        var proto;
        if (typeof parent != 'object') {
          return parent;
        }
        if (parent instanceof nativeMap) {
          child = new nativeMap();
        } else if (parent instanceof nativeSet) {
          child = new nativeSet();
        } else if (parent instanceof nativePromise) {
          child = new nativePromise(function (resolve, reject) {
            parent.then(function (value) {
              resolve(_clone(value, depth - 1));
            }, function (err) {
              reject(_clone(err, depth - 1));
            });
          });
        } else if (clone.__isArray(parent)) {
          child = [];
        } else if (clone.__isRegExp(parent)) {
          child = new RegExp(parent.source, __getRegExpFlags(parent));
          if (parent.lastIndex) child.lastIndex = parent.lastIndex;
        } else if (clone.__isDate(parent)) {
          child = new Date(parent.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent)) {
          child = new Buffer(parent.length);
          parent.copy(child);
          return child;
        } else if (parent instanceof Error) {
          child = Object.create(parent);
        } else {
          if (typeof prototype == 'undefined') {
            proto = Object.getPrototypeOf(parent);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }
        if (circular) {
          var index = allParents.indexOf(parent);
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent);
          allChildren.push(child);
        }
        if (parent instanceof nativeMap) {
          var keyIterator = parent.keys();
          while (true) {
            var next = keyIterator.next();
            if (next.done) {
              break;
            }
            var keyChild = _clone(next.value, depth - 1);
            var valueChild = _clone(parent.get(next.value), depth - 1);
            child.set(keyChild, valueChild);
          }
        }
        if (parent instanceof nativeSet) {
          var iterator = parent.keys();
          while (true) {
            var next = iterator.next();
            if (next.done) {
              break;
            }
            var entryChild = _clone(next.value, depth - 1);
            child.add(entryChild);
          }
        }
        for (var i in parent) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent[i], depth - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(parent);
          for (var i = 0; i < symbols.length; i++) {
            // Don't need to worry about cloning a symbol because it is a primitive,
            // like a number or string.
            var symbol = symbols[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol] = _clone(parent[symbol], depth - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol, {
                enumerable: false
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent);
          for (var i = 0; i < allPropertyNames.length; i++) {
            var propertyName = allPropertyNames[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent[propertyName], depth - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }
        return child;
      }
      return _clone(parent, depth);
    }

    /**
     * Simple flat clone using prototype, accepts only objects, usefull for property
     * override on FLAT configuration object (no nested props).
     *
     * USE WITH CAUTION! This may not behave as you wish if you do not know how this
     * works.
     */
    clone.clonePrototype = function clonePrototype(parent) {
      if (parent === null) return null;
      var c = function () {};
      c.prototype = parent;
      return new c();
    };

    // private utility functions

    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Date]';
    }
    clone.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Array]';
    }
    clone.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
    }
    clone.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
      var flags = '';
      if (re.global) flags += 'g';
      if (re.ignoreCase) flags += 'i';
      if (re.multiline) flags += 'm';
      return flags;
    }
    clone.__getRegExpFlags = __getRegExpFlags;
    return clone;
  }();
  if (typeof module === 'object' && module.exports) {
    module.exports = clone;
  }

  /**
   * Main CSSLint object.
   * @class CSSLint
   * @static
   * @extends parserlib.util.EventTarget
   */

  /* global parserlib, clone, Reporter */
  /* exported CSSLint */

  var CSSLint = function () {
    "use strict";

    var rules = [],
      formatters = [],
      embeddedRuleset = /\/\*\s*csslint([^\*]*)\*\//,
      api = new parserlib.util.EventTarget();
    api.version = "1.0.4";

    //-------------------------------------------------------------------------
    // Rule Management
    //-------------------------------------------------------------------------

    /**
     * Adds a new rule to the engine.
     * @param {Object} rule The rule to add.
     * @method addRule
     */
    api.addRule = function (rule) {
      rules.push(rule);
      rules[rule.id] = rule;
    };

    /**
     * Clears all rule from the engine.
     * @method clearRules
     */
    api.clearRules = function () {
      rules = [];
    };

    /**
     * Returns the rule objects.
     * @return An array of rule objects.
     * @method getRules
     */
    api.getRules = function () {
      return [].concat(rules).sort(function (a, b) {
        return a.id > b.id ? 1 : 0;
      });
    };

    /**
     * Returns a ruleset configuration object with all current rules.
     * @return A ruleset object.
     * @method getRuleset
     */
    api.getRuleset = function () {
      var ruleset = {},
        i = 0,
        len = rules.length;
      while (i < len) {
        ruleset[rules[i++].id] = 1; // by default, everything is a warning
      }

      return ruleset;
    };

    /**
     * Returns a ruleset object based on embedded rules.
     * @param {String} text A string of css containing embedded rules.
     * @param {Object} ruleset A ruleset object to modify.
     * @return {Object} A ruleset object.
     * @method getEmbeddedRuleset
     */
    function applyEmbeddedRuleset(text, ruleset) {
      var valueMap,
        embedded = text && text.match(embeddedRuleset),
        rules = embedded && embedded[1];
      if (rules) {
        valueMap = {
          "true": 2,
          // true is error
          "": 1,
          // blank is warning
          "false": 0,
          // false is ignore

          "2": 2,
          // explicit error
          "1": 1,
          // explicit warning
          "0": 0 // explicit ignore
        };

        rules.toLowerCase().split(",").forEach(function (rule) {
          var pair = rule.split(":"),
            property = pair[0] || "",
            value = pair[1] || "";
          ruleset[property.trim()] = valueMap[value.trim()];
        });
      }
      return ruleset;
    }

    //-------------------------------------------------------------------------
    // Formatters
    //-------------------------------------------------------------------------

    /**
     * Adds a new formatter to the engine.
     * @param {Object} formatter The formatter to add.
     * @method addFormatter
     */
    api.addFormatter = function (formatter) {
      // formatters.push(formatter);
      formatters[formatter.id] = formatter;
    };

    /**
     * Retrieves a formatter for use.
     * @param {String} formatId The name of the format to retrieve.
     * @return {Object} The formatter or undefined.
     * @method getFormatter
     */
    api.getFormatter = function (formatId) {
      return formatters[formatId];
    };

    /**
     * Formats the results in a particular format for a single file.
     * @param {Object} result The results returned from CSSLint.verify().
     * @param {String} filename The filename for which the results apply.
     * @param {String} formatId The name of the formatter to use.
     * @param {Object} options (Optional) for special output handling.
     * @return {String} A formatted string for the results.
     * @method format
     */
    api.format = function (results, filename, formatId, options) {
      var formatter = this.getFormatter(formatId),
        result = null;
      if (formatter) {
        result = formatter.startFormat();
        result += formatter.formatResults(results, filename, options || {});
        result += formatter.endFormat();
      }
      return result;
    };

    /**
     * Indicates if the given format is supported.
     * @param {String} formatId The ID of the format to check.
     * @return {Boolean} True if the format exists, false if not.
     * @method hasFormat
     */
    api.hasFormat = function (formatId) {
      return formatters.hasOwnProperty(formatId);
    };

    //-------------------------------------------------------------------------
    // Verification
    //-------------------------------------------------------------------------

    /**
     * Starts the verification process for the given CSS text.
     * @param {String} text The CSS text to verify.
     * @param {Object} ruleset (Optional) List of rules to apply. If null, then
     *      all rules are used. If a rule has a value of 1 then it's a warning,
     *      a value of 2 means it's an error.
     * @return {Object} Results of the verification.
     * @method verify
     */
    api.verify = function (text, ruleset) {
      var i = 0,
        reporter,
        lines,
        allow = {},
        ignore = [],
        report,
        parser = new parserlib.css.Parser({
          starHack: true,
          ieFilters: true,
          underscoreHack: true,
          strict: false
        });

      // normalize line endings
      lines = text.replace(/\n\r?/g, "$split$").split("$split$");

      // find 'allow' comments
      CSSLint.Util.forEach(lines, function (line, lineno) {
        var allowLine = line && line.match(/\/\*[ \t]*csslint[ \t]+allow:[ \t]*([^\*]*)\*\//i),
          allowRules = allowLine && allowLine[1],
          allowRuleset = {};
        if (allowRules) {
          allowRules.toLowerCase().split(",").forEach(function (allowRule) {
            allowRuleset[allowRule.trim()] = true;
          });
          if (Object.keys(allowRuleset).length > 0) {
            allow[lineno + 1] = allowRuleset;
          }
        }
      });
      var ignoreStart = null,
        ignoreEnd = null;
      CSSLint.Util.forEach(lines, function (line, lineno) {
        // Keep oldest, "unclosest" ignore:start
        if (ignoreStart === null && line.match(/\/\*[ \t]*csslint[ \t]+ignore:start[ \t]*\*\//i)) {
          ignoreStart = lineno;
        }
        if (line.match(/\/\*[ \t]*csslint[ \t]+ignore:end[ \t]*\*\//i)) {
          ignoreEnd = lineno;
        }
        if (ignoreStart !== null && ignoreEnd !== null) {
          ignore.push([ignoreStart, ignoreEnd]);
          ignoreStart = ignoreEnd = null;
        }
      });

      // Close remaining ignore block, if any
      if (ignoreStart !== null) {
        ignore.push([ignoreStart, lines.length]);
      }
      if (!ruleset) {
        ruleset = this.getRuleset();
      }
      if (embeddedRuleset.test(text)) {
        // defensively copy so that caller's version does not get modified
        ruleset = clone(ruleset);
        ruleset = applyEmbeddedRuleset(text, ruleset);
      }
      reporter = new Reporter(lines, ruleset, allow, ignore);
      ruleset.errors = 2; // always report parsing errors as errors
      for (i in ruleset) {
        if (ruleset.hasOwnProperty(i) && ruleset[i]) {
          if (rules[i]) {
            rules[i].init(parser, reporter);
          }
        }
      }

      // capture most horrible error type
      try {
        parser.parse(text);
      } catch (ex) {
        reporter.error("Fatal error, cannot continue: " + ex.message, ex.line, ex.col, {});
      }
      report = {
        messages: reporter.messages,
        stats: reporter.stats,
        ruleset: reporter.ruleset,
        allow: reporter.allow,
        ignore: reporter.ignore
      };

      // sort by line numbers, rollups at the bottom
      report.messages.sort(function (a, b) {
        if (a.rollup && !b.rollup) {
          return 1;
        } else if (!a.rollup && b.rollup) {
          return -1;
        } else {
          return a.line - b.line;
        }
      });
      return report;
    };

    //-------------------------------------------------------------------------
    // Publish the API
    //-------------------------------------------------------------------------

    return api;
  }();

  /**
   * An instance of Report is used to report results of the
   * verification back to the main API.
   * @class Reporter
   * @constructor
   * @param {String[]} lines The text lines of the source.
   * @param {Object} ruleset The set of rules to work with, including if
   *      they are errors or warnings.
   * @param {Object} explicitly allowed lines
   * @param {[][]} ingore list of line ranges to be ignored
   */
  function Reporter(lines, ruleset, allow, ignore) {
    "use strict";

    /**
     * List of messages being reported.
     * @property messages
     * @type String[]
     */
    this.messages = [];

    /**
     * List of statistics being reported.
     * @property stats
     * @type String[]
     */
    this.stats = [];

    /**
     * Lines of code being reported on. Used to provide contextual information
     * for messages.
     * @property lines
     * @type String[]
     */
    this.lines = lines;

    /**
     * Information about the rules. Used to determine whether an issue is an
     * error or warning.
     * @property ruleset
     * @type Object
     */
    this.ruleset = ruleset;

    /**
     * Lines with specific rule messages to leave out of the report.
     * @property allow
     * @type Object
     */
    this.allow = allow;
    if (!this.allow) {
      this.allow = {};
    }

    /**
     * Linesets not to include in the report.
     * @property ignore
     * @type [][]
     */
    this.ignore = ignore;
    if (!this.ignore) {
      this.ignore = [];
    }
  }
  Reporter.prototype = {
    // restore constructor
    constructor: Reporter,
    /**
     * Report an error.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method error
     */
    error: function (message, line, col, rule) {
      "use strict";

      this.messages.push({
        type: "error",
        line: line,
        col: col,
        message: message,
        evidence: this.lines[line - 1],
        rule: rule || {}
      });
    },
    /**
     * Report an warning.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method warn
     * @deprecated Use report instead.
     */
    warn: function (message, line, col, rule) {
      "use strict";

      this.report(message, line, col, rule);
    },
    /**
     * Report an issue.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method report
     */
    report: function (message, line, col, rule) {
      "use strict";

      // Check if rule violation should be allowed
      if (this.allow.hasOwnProperty(line) && this.allow[line].hasOwnProperty(rule.id)) {
        return;
      }
      var ignore = false;
      CSSLint.Util.forEach(this.ignore, function (range) {
        if (range[0] <= line && line <= range[1]) {
          ignore = true;
        }
      });
      if (ignore) {
        return;
      }
      this.messages.push({
        type: this.ruleset[rule.id] === 2 ? "error" : "warning",
        line: line,
        col: col,
        message: message,
        evidence: this.lines[line - 1],
        rule: rule
      });
    },
    /**
     * Report some informational text.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method info
     */
    info: function (message, line, col, rule) {
      "use strict";

      this.messages.push({
        type: "info",
        line: line,
        col: col,
        message: message,
        evidence: this.lines[line - 1],
        rule: rule
      });
    },
    /**
     * Report some rollup error information.
     * @param {String} message The message to store.
     * @param {Object} rule The rule this message relates to.
     * @method rollupError
     */
    rollupError: function (message, rule) {
      "use strict";

      this.messages.push({
        type: "error",
        rollup: true,
        message: message,
        rule: rule
      });
    },
    /**
     * Report some rollup warning information.
     * @param {String} message The message to store.
     * @param {Object} rule The rule this message relates to.
     * @method rollupWarn
     */
    rollupWarn: function (message, rule) {
      "use strict";

      this.messages.push({
        type: "warning",
        rollup: true,
        message: message,
        rule: rule
      });
    },
    /**
     * Report a statistic.
     * @param {String} name The name of the stat to store.
     * @param {Variant} value The value of the stat.
     * @method stat
     */
    stat: function (name, value) {
      "use strict";

      this.stats[name] = value;
    }
  };

  // expose for testing purposes
  CSSLint._Reporter = Reporter;

  /*
   * Utility functions that make life easier.
   */
  CSSLint.Util = {
    /*
     * Adds all properties from supplier onto receiver,
     * overwriting if the same name already exists on
     * receiver.
     * @param {Object} The object to receive the properties.
     * @param {Object} The object to provide the properties.
     * @return {Object} The receiver
     */
    mix: function (receiver, supplier) {
      "use strict";

      var prop;
      for (prop in supplier) {
        if (supplier.hasOwnProperty(prop)) {
          receiver[prop] = supplier[prop];
        }
      }
      return prop;
    },
    /*
     * Polyfill for array indexOf() method.
     * @param {Array} values The array to search.
     * @param {Variant} value The value to search for.
     * @return {int} The index of the value if found, -1 if not.
     */
    indexOf: function (values, value) {
      "use strict";

      if (values.indexOf) {
        return values.indexOf(value);
      } else {
        for (var i = 0, len = values.length; i < len; i++) {
          if (values[i] === value) {
            return i;
          }
        }
        return -1;
      }
    },
    /*
     * Polyfill for array forEach() method.
     * @param {Array} values The array to operate on.
     * @param {Function} func The function to call on each item.
     * @return {void}
     */
    forEach: function (values, func) {
      "use strict";

      if (values.forEach) {
        return values.forEach(func);
      } else {
        for (var i = 0, len = values.length; i < len; i++) {
          func(values[i], i, values);
        }
      }
    }
  };

  /*
   * Rule: Don't use adjoining classes (.foo.bar).
   */

  CSSLint.addRule({
    // rule information
    id: "adjoining-classes",
    name: "Disallow adjoining classes",
    desc: "Don't use adjoining classes.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-adjoining-classes",
    browsers: "IE6",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("startrule", function (event) {
        var selectors = event.selectors,
          selector,
          part,
          modifier,
          classCount,
          i,
          j,
          k;
        for (i = 0; i < selectors.length; i++) {
          selector = selectors[i];
          for (j = 0; j < selector.parts.length; j++) {
            part = selector.parts[j];
            if (part.type === parser.SELECTOR_PART_TYPE) {
              classCount = 0;
              for (k = 0; k < part.modifiers.length; k++) {
                modifier = part.modifiers[k];
                if (modifier.type === "class") {
                  classCount++;
                }
                if (classCount > 1) {
                  reporter.report("Adjoining classes: " + selectors[i].text, part.line, part.col, rule);
                }
              }
            }
          }
        }
      });
    }
  });

  /*
   * Rule: Don't use width or height when using padding or border.
   */
  CSSLint.addRule({
    // rule information
    id: "box-model",
    name: "Beware of broken box size",
    desc: "Don't use width or height when using padding or border.",
    url: "https://github.com/CSSLint/csslint/wiki/Beware-of-box-model-size",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        widthProperties = {
          border: 1,
          "border-left": 1,
          "border-right": 1,
          padding: 1,
          "padding-left": 1,
          "padding-right": 1
        },
        heightProperties = {
          border: 1,
          "border-bottom": 1,
          "border-top": 1,
          padding: 1,
          "padding-bottom": 1,
          "padding-top": 1
        },
        properties,
        boxSizing = false;
      function startRule() {
        properties = {};
        boxSizing = false;
      }
      function endRule() {
        var prop, value;
        if (!boxSizing) {
          if (properties.height) {
            for (prop in heightProperties) {
              if (heightProperties.hasOwnProperty(prop) && properties[prop]) {
                value = properties[prop].value;
                // special case for padding
                if (!(prop === "padding" && value.parts.length === 2 && value.parts[0].value === 0)) {
                  reporter.report("Using height with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                }
              }
            }
          }
          if (properties.width) {
            for (prop in widthProperties) {
              if (widthProperties.hasOwnProperty(prop) && properties[prop]) {
                value = properties[prop].value;
                if (!(prop === "padding" && value.parts.length === 2 && value.parts[1].value === 0)) {
                  reporter.report("Using width with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                }
              }
            }
          }
        }
      }
      parser.addListener("startrule", startRule);
      parser.addListener("startfontface", startRule);
      parser.addListener("startpage", startRule);
      parser.addListener("startpagemargin", startRule);
      parser.addListener("startkeyframerule", startRule);
      parser.addListener("startviewport", startRule);
      parser.addListener("property", function (event) {
        var name = event.property.text.toLowerCase();
        if (heightProperties[name] || widthProperties[name]) {
          if (!/^0\S*$/.test(event.value) && !(name === "border" && event.value.toString() === "none")) {
            properties[name] = {
              line: event.property.line,
              col: event.property.col,
              value: event.value
            };
          }
        } else {
          if (/^(width|height)/i.test(name) && /^(length|percentage)/.test(event.value.parts[0].type)) {
            properties[name] = 1;
          } else if (name === "box-sizing") {
            boxSizing = true;
          }
        }
      });
      parser.addListener("endrule", endRule);
      parser.addListener("endfontface", endRule);
      parser.addListener("endpage", endRule);
      parser.addListener("endpagemargin", endRule);
      parser.addListener("endkeyframerule", endRule);
      parser.addListener("endviewport", endRule);
    }
  });

  /*
   * Rule: box-sizing doesn't work in IE6 and IE7.
   */

  CSSLint.addRule({
    // rule information
    id: "box-sizing",
    name: "Disallow use of box-sizing",
    desc: "The box-sizing properties isn't supported in IE6 and IE7.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-box-sizing",
    browsers: "IE6, IE7",
    tags: ["Compatibility"],
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("property", function (event) {
        var name = event.property.text.toLowerCase();
        if (name === "box-sizing") {
          reporter.report("The box-sizing property isn't supported in IE6 and IE7.", event.line, event.col, rule);
        }
      });
    }
  });

  /*
   * Rule: Use the bulletproof @font-face syntax to avoid 404's in old IE
   * (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax)
   */

  CSSLint.addRule({
    // rule information
    id: "bulletproof-font-face",
    name: "Use the bulletproof @font-face syntax",
    desc: "Use the bulletproof @font-face syntax to avoid 404's in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).",
    url: "https://github.com/CSSLint/csslint/wiki/Bulletproof-font-face",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        fontFaceRule = false,
        firstSrc = true,
        ruleFailed = false,
        line,
        col;

      // Mark the start of a @font-face declaration so we only test properties inside it
      parser.addListener("startfontface", function () {
        fontFaceRule = true;
      });
      parser.addListener("property", function (event) {
        // If we aren't inside an @font-face declaration then just return
        if (!fontFaceRule) {
          return;
        }
        var propertyName = event.property.toString().toLowerCase(),
          value = event.value.toString();

        // Set the line and col numbers for use in the endfontface listener
        line = event.line;
        col = event.col;

        // This is the property that we care about, we can ignore the rest
        if (propertyName === "src") {
          var regex = /^\s?url\(['"].+\.eot\?.*['"]\)\s*format\(['"]embedded-opentype['"]\).*$/i;

          // We need to handle the advanced syntax with two src properties
          if (!value.match(regex) && firstSrc) {
            ruleFailed = true;
            firstSrc = false;
          } else if (value.match(regex) && !firstSrc) {
            ruleFailed = false;
          }
        }
      });

      // Back to normal rules that we don't need to test
      parser.addListener("endfontface", function () {
        fontFaceRule = false;
        if (ruleFailed) {
          reporter.report("@font-face declaration doesn't follow the fontspring bulletproof syntax.", line, col, rule);
        }
      });
    }
  });

  /*
   * Rule: Include all compatible vendor prefixes to reach a wider
   * range of users.
   */

  CSSLint.addRule({
    // rule information
    id: "compatible-vendor-prefixes",
    name: "Require compatible vendor prefixes",
    desc: "Include all compatible vendor prefixes to reach a wider range of users.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-compatible-vendor-prefixes",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        compatiblePrefixes,
        properties,
        prop,
        variations,
        prefixed,
        i,
        len,
        inKeyFrame = false,
        arrayPush = Array.prototype.push,
        applyTo = [];

      // See http://peter.sh/experiments/vendor-prefixed-css-property-overview/ for details
      compatiblePrefixes = {
        "animation": "webkit",
        "animation-delay": "webkit",
        "animation-direction": "webkit",
        "animation-duration": "webkit",
        "animation-fill-mode": "webkit",
        "animation-iteration-count": "webkit",
        "animation-name": "webkit",
        "animation-play-state": "webkit",
        "animation-timing-function": "webkit",
        "appearance": "webkit moz",
        "border-end": "webkit moz",
        "border-end-color": "webkit moz",
        "border-end-style": "webkit moz",
        "border-end-width": "webkit moz",
        "border-image": "webkit moz o",
        "border-radius": "webkit",
        "border-start": "webkit moz",
        "border-start-color": "webkit moz",
        "border-start-style": "webkit moz",
        "border-start-width": "webkit moz",
        "box-align": "webkit moz ms",
        "box-direction": "webkit moz ms",
        "box-flex": "webkit moz ms",
        "box-lines": "webkit ms",
        "box-ordinal-group": "webkit moz ms",
        "box-orient": "webkit moz ms",
        "box-pack": "webkit moz ms",
        "box-sizing": "",
        "box-shadow": "",
        "column-count": "webkit moz ms",
        "column-gap": "webkit moz ms",
        "column-rule": "webkit moz ms",
        "column-rule-color": "webkit moz ms",
        "column-rule-style": "webkit moz ms",
        "column-rule-width": "webkit moz ms",
        "column-width": "webkit moz ms",
        "hyphens": "epub moz",
        "line-break": "webkit ms",
        "margin-end": "webkit moz",
        "margin-start": "webkit moz",
        "marquee-speed": "webkit wap",
        "marquee-style": "webkit wap",
        "padding-end": "webkit moz",
        "padding-start": "webkit moz",
        "tab-size": "moz o",
        "text-size-adjust": "webkit ms",
        "transform": "webkit ms",
        "transform-origin": "webkit ms",
        "transition": "",
        "transition-delay": "",
        "transition-duration": "",
        "transition-property": "",
        "transition-timing-function": "",
        "user-modify": "webkit moz",
        "user-select": "webkit moz ms",
        "word-break": "epub ms",
        "writing-mode": "epub ms"
      };
      for (prop in compatiblePrefixes) {
        if (compatiblePrefixes.hasOwnProperty(prop)) {
          variations = [];
          prefixed = compatiblePrefixes[prop].split(" ");
          for (i = 0, len = prefixed.length; i < len; i++) {
            variations.push("-" + prefixed[i] + "-" + prop);
          }
          compatiblePrefixes[prop] = variations;
          arrayPush.apply(applyTo, variations);
        }
      }
      parser.addListener("startrule", function () {
        properties = [];
      });
      parser.addListener("startkeyframes", function (event) {
        inKeyFrame = event.prefix || true;
      });
      parser.addListener("endkeyframes", function () {
        inKeyFrame = false;
      });
      parser.addListener("property", function (event) {
        var name = event.property;
        if (CSSLint.Util.indexOf(applyTo, name.text) > -1) {
          // e.g., -moz-transform is okay to be alone in @-moz-keyframes
          if (!inKeyFrame || typeof inKeyFrame !== "string" || name.text.indexOf("-" + inKeyFrame + "-") !== 0) {
            properties.push(name);
          }
        }
      });
      parser.addListener("endrule", function () {
        if (!properties.length) {
          return;
        }
        var propertyGroups = {},
          i,
          len,
          name,
          prop,
          variations,
          value,
          full,
          actual,
          item,
          propertiesSpecified;
        for (i = 0, len = properties.length; i < len; i++) {
          name = properties[i];
          for (prop in compatiblePrefixes) {
            if (compatiblePrefixes.hasOwnProperty(prop)) {
              variations = compatiblePrefixes[prop];
              if (CSSLint.Util.indexOf(variations, name.text) > -1) {
                if (!propertyGroups[prop]) {
                  propertyGroups[prop] = {
                    full: variations.slice(0),
                    actual: [],
                    actualNodes: []
                  };
                }
                if (CSSLint.Util.indexOf(propertyGroups[prop].actual, name.text) === -1) {
                  propertyGroups[prop].actual.push(name.text);
                  propertyGroups[prop].actualNodes.push(name);
                }
              }
            }
          }
        }
        for (prop in propertyGroups) {
          if (propertyGroups.hasOwnProperty(prop)) {
            value = propertyGroups[prop];
            full = value.full;
            actual = value.actual;
            if (full.length > actual.length) {
              for (i = 0, len = full.length; i < len; i++) {
                item = full[i];
                if (CSSLint.Util.indexOf(actual, item) === -1) {
                  propertiesSpecified = actual.length === 1 ? actual[0] : actual.length === 2 ? actual.join(" and ") : actual.join(", ");
                  reporter.report("The property " + item + " is compatible with " + propertiesSpecified + " and should be included as well.", value.actualNodes[0].line, value.actualNodes[0].col, rule);
                }
              }
            }
          }
        }
      });
    }
  });

  /*
   * Rule: Certain properties don't play well with certain display values.
   * - float should not be used with inline-block
   * - height, width, margin-top, margin-bottom, float should not be used with inline
   * - vertical-align should not be used with block
   * - margin, float should not be used with table-*
   */

  CSSLint.addRule({
    // rule information
    id: "display-property-grouping",
    name: "Require properties appropriate for display",
    desc: "Certain properties shouldn't be used with certain display property values.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-properties-appropriate-for-display",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      var propertiesToCheck = {
          display: 1,
          "float": "none",
          height: 1,
          width: 1,
          margin: 1,
          "margin-left": 1,
          "margin-right": 1,
          "margin-bottom": 1,
          "margin-top": 1,
          padding: 1,
          "padding-left": 1,
          "padding-right": 1,
          "padding-bottom": 1,
          "padding-top": 1,
          "vertical-align": 1
        },
        properties;
      function reportProperty(name, display, msg) {
        if (properties[name]) {
          if (typeof propertiesToCheck[name] !== "string" || properties[name].value.toLowerCase() !== propertiesToCheck[name]) {
            reporter.report(msg || name + " can't be used with display: " + display + ".", properties[name].line, properties[name].col, rule);
          }
        }
      }
      function startRule() {
        properties = {};
      }
      function endRule() {
        var display = properties.display ? properties.display.value : null;
        if (display) {
          switch (display) {
            case "inline":
              // height, width, margin-top, margin-bottom, float should not be used with inline
              reportProperty("height", display);
              reportProperty("width", display);
              reportProperty("margin", display);
              reportProperty("margin-top", display);
              reportProperty("margin-bottom", display);
              reportProperty("float", display, "display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).");
              break;
            case "block":
              // vertical-align should not be used with block
              reportProperty("vertical-align", display);
              break;
            case "inline-block":
              // float should not be used with inline-block
              reportProperty("float", display);
              break;
            default:
              // margin, float should not be used with table
              if (display.indexOf("table-") === 0) {
                reportProperty("margin", display);
                reportProperty("margin-left", display);
                reportProperty("margin-right", display);
                reportProperty("margin-top", display);
                reportProperty("margin-bottom", display);
                reportProperty("float", display);
              }

            // otherwise do nothing
          }
        }
      }

      parser.addListener("startrule", startRule);
      parser.addListener("startfontface", startRule);
      parser.addListener("startkeyframerule", startRule);
      parser.addListener("startpagemargin", startRule);
      parser.addListener("startpage", startRule);
      parser.addListener("startviewport", startRule);
      parser.addListener("property", function (event) {
        var name = event.property.text.toLowerCase();
        if (propertiesToCheck[name]) {
          properties[name] = {
            value: event.value.text,
            line: event.property.line,
            col: event.property.col
          };
        }
      });
      parser.addListener("endrule", endRule);
      parser.addListener("endfontface", endRule);
      parser.addListener("endkeyframerule", endRule);
      parser.addListener("endpagemargin", endRule);
      parser.addListener("endpage", endRule);
      parser.addListener("endviewport", endRule);
    }
  });

  /*
   * Rule: Disallow duplicate background-images (using url).
   */

  CSSLint.addRule({
    // rule information
    id: "duplicate-background-images",
    name: "Disallow duplicate background images",
    desc: "Every background-image should be unique. Use a common class for e.g. sprites.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-background-images",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        stack = {};
      parser.addListener("property", function (event) {
        var name = event.property.text,
          value = event.value,
          i,
          len;
        if (name.match(/background/i)) {
          for (i = 0, len = value.parts.length; i < len; i++) {
            if (value.parts[i].type === "uri") {
              if (typeof stack[value.parts[i].uri] === "undefined") {
                stack[value.parts[i].uri] = event;
              } else {
                reporter.report("Background image '" + value.parts[i].uri + "' was used multiple times, first declared at line " + stack[value.parts[i].uri].line + ", col " + stack[value.parts[i].uri].col + ".", event.line, event.col, rule);
              }
            }
          }
        }
      });
    }
  });

  /*
   * Rule: Duplicate properties must appear one after the other. If an already-defined
   * property appears somewhere else in the rule, then it's likely an error.
   */

  CSSLint.addRule({
    // rule information
    id: "duplicate-properties",
    name: "Disallow duplicate properties",
    desc: "Duplicate properties must appear one after the other.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-properties",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        properties,
        lastProperty;
      function startRule() {
        properties = {};
      }
      parser.addListener("startrule", startRule);
      parser.addListener("startfontface", startRule);
      parser.addListener("startpage", startRule);
      parser.addListener("startpagemargin", startRule);
      parser.addListener("startkeyframerule", startRule);
      parser.addListener("startviewport", startRule);
      parser.addListener("property", function (event) {
        var property = event.property,
          name = property.text.toLowerCase();
        if (properties[name] && (lastProperty !== name || properties[name] === event.value.text)) {
          reporter.report("Duplicate property '" + event.property + "' found.", event.line, event.col, rule);
        }
        properties[name] = event.value.text;
        lastProperty = name;
      });
    }
  });

  /*
   * Rule: Style rules without any properties defined should be removed.
   */

  CSSLint.addRule({
    // rule information
    id: "empty-rules",
    name: "Disallow empty rules",
    desc: "Rules without any properties specified should be removed.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-empty-rules",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        count = 0;
      parser.addListener("startrule", function () {
        count = 0;
      });
      parser.addListener("property", function () {
        count++;
      });
      parser.addListener("endrule", function (event) {
        var selectors = event.selectors;
        if (count === 0) {
          reporter.report("Rule is empty.", selectors[0].line, selectors[0].col, rule);
        }
      });
    }
  });

  /*
   * Rule: There should be no syntax errors. (Duh.)
   */

  CSSLint.addRule({
    // rule information
    id: "errors",
    name: "Parsing Errors",
    desc: "This rule looks for recoverable syntax errors.",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("error", function (event) {
        reporter.error(event.message, event.line, event.col, rule);
      });
    }
  });
  CSSLint.addRule({
    // rule information
    id: "fallback-colors",
    name: "Require fallback colors",
    desc: "For older browsers that don't support RGBA, HSL, or HSLA, provide a fallback color.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-fallback-colors",
    browsers: "IE6,IE7,IE8",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        lastProperty,
        propertiesToCheck = {
          color: 1,
          background: 1,
          "border-color": 1,
          "border-top-color": 1,
          "border-right-color": 1,
          "border-bottom-color": 1,
          "border-left-color": 1,
          border: 1,
          "border-top": 1,
          "border-right": 1,
          "border-bottom": 1,
          "border-left": 1,
          "background-color": 1
        };
      function startRule() {
        lastProperty = null;
      }
      parser.addListener("startrule", startRule);
      parser.addListener("startfontface", startRule);
      parser.addListener("startpage", startRule);
      parser.addListener("startpagemargin", startRule);
      parser.addListener("startkeyframerule", startRule);
      parser.addListener("startviewport", startRule);
      parser.addListener("property", function (event) {
        var property = event.property,
          name = property.text.toLowerCase(),
          parts = event.value.parts,
          i = 0,
          colorType = "",
          len = parts.length;
        if (propertiesToCheck[name]) {
          while (i < len) {
            if (parts[i].type === "color") {
              if ("alpha" in parts[i] || "hue" in parts[i]) {
                if (/([^\)]+)\(/.test(parts[i])) {
                  colorType = RegExp.$1.toUpperCase();
                }
                if (!lastProperty || lastProperty.property.text.toLowerCase() !== name || lastProperty.colorType !== "compat") {
                  reporter.report("Fallback " + name + " (hex or RGB) should precede " + colorType + " " + name + ".", event.line, event.col, rule);
                }
              } else {
                event.colorType = "compat";
              }
            }
            i++;
          }
        }
        lastProperty = event;
      });
    }
  });

  /*
   * Rule: You shouldn't use more than 10 floats. If you do, there's probably
   * room for some abstraction.
   */

  CSSLint.addRule({
    // rule information
    id: "floats",
    name: "Disallow too many floats",
    desc: "This rule tests if the float property is used too many times",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-too-many-floats",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      var count = 0;

      // count how many times "float" is used
      parser.addListener("property", function (event) {
        if (event.property.text.toLowerCase() === "float" && event.value.text.toLowerCase() !== "none") {
          count++;
        }
      });

      // report the results
      parser.addListener("endstylesheet", function () {
        reporter.stat("floats", count);
        if (count >= 10) {
          reporter.rollupWarn("Too many floats (" + count + "), you're probably using them for layout. Consider using a grid system instead.", rule);
        }
      });
    }
  });

  /*
   * Rule: Avoid too many @font-face declarations in the same stylesheet.
   */

  CSSLint.addRule({
    // rule information
    id: "font-faces",
    name: "Don't use too many web fonts",
    desc: "Too many different web fonts in the same stylesheet.",
    url: "https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-web-fonts",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        count = 0;
      parser.addListener("startfontface", function () {
        count++;
      });
      parser.addListener("endstylesheet", function () {
        if (count > 5) {
          reporter.rollupWarn("Too many @font-face declarations (" + count + ").", rule);
        }
      });
    }
  });

  /*
   * Rule: You shouldn't need more than 9 font-size declarations.
   */

  CSSLint.addRule({
    // rule information
    id: "font-sizes",
    name: "Disallow too many font sizes",
    desc: "Checks the number of font-size declarations.",
    url: "https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-font-size-declarations",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        count = 0;

      // check for use of "font-size"
      parser.addListener("property", function (event) {
        if (event.property.toString() === "font-size") {
          count++;
        }
      });

      // report the results
      parser.addListener("endstylesheet", function () {
        reporter.stat("font-sizes", count);
        if (count >= 10) {
          reporter.rollupWarn("Too many font-size declarations (" + count + "), abstraction needed.", rule);
        }
      });
    }
  });

  /*
   * Rule: When using a vendor-prefixed gradient, make sure to use them all.
   */

  CSSLint.addRule({
    // rule information
    id: "gradients",
    name: "Require all gradient definitions",
    desc: "When using a vendor-prefixed gradient, make sure to use them all.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-all-gradient-definitions",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        gradients;
      parser.addListener("startrule", function () {
        gradients = {
          moz: 0,
          webkit: 0,
          oldWebkit: 0,
          o: 0
        };
      });
      parser.addListener("property", function (event) {
        if (/\-(moz|o|webkit)(?:\-(?:linear|radial))\-gradient/i.test(event.value)) {
          gradients[RegExp.$1] = 1;
        } else if (/\-webkit\-gradient/i.test(event.value)) {
          gradients.oldWebkit = 1;
        }
      });
      parser.addListener("endrule", function (event) {
        var missing = [];
        if (!gradients.moz) {
          missing.push("Firefox 3.6+");
        }
        if (!gradients.webkit) {
          missing.push("Webkit (Safari 5+, Chrome)");
        }
        if (!gradients.oldWebkit) {
          missing.push("Old Webkit (Safari 4+, Chrome)");
        }
        if (!gradients.o) {
          missing.push("Opera 11.1+");
        }
        if (missing.length && missing.length < 4) {
          reporter.report("Missing vendor-prefixed CSS gradients for " + missing.join(", ") + ".", event.selectors[0].line, event.selectors[0].col, rule);
        }
      });
    }
  });

  /*
   * Rule: Don't use IDs for selectors.
   */

  CSSLint.addRule({
    // rule information
    id: "ids",
    name: "Disallow IDs in selectors",
    desc: "Selectors should not contain IDs.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-IDs-in-selectors",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("startrule", function (event) {
        var selectors = event.selectors,
          selector,
          part,
          modifier,
          idCount,
          i,
          j,
          k;
        for (i = 0; i < selectors.length; i++) {
          selector = selectors[i];
          idCount = 0;
          for (j = 0; j < selector.parts.length; j++) {
            part = selector.parts[j];
            if (part.type === parser.SELECTOR_PART_TYPE) {
              for (k = 0; k < part.modifiers.length; k++) {
                modifier = part.modifiers[k];
                if (modifier.type === "id") {
                  idCount++;
                }
              }
            }
          }
          if (idCount === 1) {
            reporter.report("Don't use IDs in selectors.", selector.line, selector.col, rule);
          } else if (idCount > 1) {
            reporter.report(idCount + " IDs in the selector, really?", selector.line, selector.col, rule);
          }
        }
      });
    }
  });

  /*
   * Rule: IE6-9 supports up to 31 stylesheet import.
   * Reference:
   * http://blogs.msdn.com/b/ieinternals/archive/2011/05/14/internet-explorer-stylesheet-rule-selector-import-sheet-limit-maximum.aspx
   */

  CSSLint.addRule({
    // rule information
    id: "import-ie-limit",
    name: "@import limit on IE6-IE9",
    desc: "IE6-9 supports up to 31 @import per stylesheet",
    browsers: "IE6, IE7, IE8, IE9",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        MAX_IMPORT_COUNT = 31,
        count = 0;
      function startPage() {
        count = 0;
      }
      parser.addListener("startpage", startPage);
      parser.addListener("import", function () {
        count++;
      });
      parser.addListener("endstylesheet", function () {
        if (count > MAX_IMPORT_COUNT) {
          reporter.rollupError("Too many @import rules (" + count + "). IE6-9 supports up to 31 import per stylesheet.", rule);
        }
      });
    }
  });

  /*
   * Rule: Don't use @import, use <link> instead.
   */

  CSSLint.addRule({
    // rule information
    id: "import",
    name: "Disallow @import",
    desc: "Don't use @import, use <link> instead.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-%40import",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("import", function (event) {
        reporter.report("@import prevents parallel downloads, use <link> instead.", event.line, event.col, rule);
      });
    }
  });

  /*
   * Rule: Make sure !important is not overused, this could lead to specificity
   * war. Display a warning on !important declarations, an error if it's
   * used more at least 10 times.
   */

  CSSLint.addRule({
    // rule information
    id: "important",
    name: "Disallow !important",
    desc: "Be careful when using !important declaration",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-%21important",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        count = 0;

      // warn that important is used and increment the declaration counter
      parser.addListener("property", function (event) {
        if (event.important === true) {
          count++;
          reporter.report("Use of !important", event.line, event.col, rule);
        }
      });

      // if there are more than 10, show an error
      parser.addListener("endstylesheet", function () {
        reporter.stat("important", count);
        if (count >= 10) {
          reporter.rollupWarn("Too many !important declarations (" + count + "), try to use less than 10 to avoid specificity issues.", rule);
        }
      });
    }
  });

  /*
   * Rule: Properties should be known (listed in CSS3 specification) or
   * be a vendor-prefixed property.
   */

  CSSLint.addRule({
    // rule information
    id: "known-properties",
    name: "Require use of known properties",
    desc: "Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-use-of-known-properties",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("property", function (event) {
        // the check is handled entirely by the parser-lib (https://github.com/nzakas/parser-lib)
        if (event.invalid) {
          reporter.report(event.invalid.message, event.line, event.col, rule);
        }
      });
    }
  });

  /*
   * Rule: All properties should be in alphabetical order.
   */

  CSSLint.addRule({
    // rule information
    id: "order-alphabetical",
    name: "Alphabetical order",
    desc: "Assure properties are in alphabetical order",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        properties;
      var startRule = function () {
        properties = [];
      };
      var endRule = function (event) {
        var currentProperties = properties.join(","),
          expectedProperties = properties.sort().join(",");
        if (currentProperties !== expectedProperties) {
          reporter.report("Rule doesn't have all its properties in alphabetical order.", event.line, event.col, rule);
        }
      };
      parser.addListener("startrule", startRule);
      parser.addListener("startfontface", startRule);
      parser.addListener("startpage", startRule);
      parser.addListener("startpagemargin", startRule);
      parser.addListener("startkeyframerule", startRule);
      parser.addListener("startviewport", startRule);
      parser.addListener("property", function (event) {
        var name = event.property.text,
          lowerCasePrefixLessName = name.toLowerCase().replace(/^-.*?-/, "");
        properties.push(lowerCasePrefixLessName);
      });
      parser.addListener("endrule", endRule);
      parser.addListener("endfontface", endRule);
      parser.addListener("endpage", endRule);
      parser.addListener("endpagemargin", endRule);
      parser.addListener("endkeyframerule", endRule);
      parser.addListener("endviewport", endRule);
    }
  });

  /*
   * Rule: outline: none or outline: 0 should only be used in a :focus rule
   *       and only if there are other properties in the same rule.
   */

  CSSLint.addRule({
    // rule information
    id: "outline-none",
    name: "Disallow outline: none",
    desc: "Use of outline: none or outline: 0 should be limited to :focus rules.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-outline%3Anone",
    browsers: "All",
    tags: ["Accessibility"],
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        lastRule;
      function startRule(event) {
        if (event.selectors) {
          lastRule = {
            line: event.line,
            col: event.col,
            selectors: event.selectors,
            propCount: 0,
            outline: false
          };
        } else {
          lastRule = null;
        }
      }
      function endRule() {
        if (lastRule) {
          if (lastRule.outline) {
            if (lastRule.selectors.toString().toLowerCase().indexOf(":focus") === -1) {
              reporter.report("Outlines should only be modified using :focus.", lastRule.line, lastRule.col, rule);
            } else if (lastRule.propCount === 1) {
              reporter.report("Outlines shouldn't be hidden unless other visual changes are made.", lastRule.line, lastRule.col, rule);
            }
          }
        }
      }
      parser.addListener("startrule", startRule);
      parser.addListener("startfontface", startRule);
      parser.addListener("startpage", startRule);
      parser.addListener("startpagemargin", startRule);
      parser.addListener("startkeyframerule", startRule);
      parser.addListener("startviewport", startRule);
      parser.addListener("property", function (event) {
        var name = event.property.text.toLowerCase(),
          value = event.value;
        if (lastRule) {
          lastRule.propCount++;
          if (name === "outline" && (value.toString() === "none" || value.toString() === "0")) {
            lastRule.outline = true;
          }
        }
      });
      parser.addListener("endrule", endRule);
      parser.addListener("endfontface", endRule);
      parser.addListener("endpage", endRule);
      parser.addListener("endpagemargin", endRule);
      parser.addListener("endkeyframerule", endRule);
      parser.addListener("endviewport", endRule);
    }
  });

  /*
   * Rule: Don't use classes or IDs with elements (a.foo or a#foo).
   */

  CSSLint.addRule({
    // rule information
    id: "overqualified-elements",
    name: "Disallow overqualified elements",
    desc: "Don't use classes or IDs with elements (a.foo or a#foo).",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-overqualified-elements",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        classes = {};
      parser.addListener("startrule", function (event) {
        var selectors = event.selectors,
          selector,
          part,
          modifier,
          i,
          j,
          k;
        for (i = 0; i < selectors.length; i++) {
          selector = selectors[i];
          for (j = 0; j < selector.parts.length; j++) {
            part = selector.parts[j];
            if (part.type === parser.SELECTOR_PART_TYPE) {
              for (k = 0; k < part.modifiers.length; k++) {
                modifier = part.modifiers[k];
                if (part.elementName && modifier.type === "id") {
                  reporter.report("Element (" + part + ") is overqualified, just use " + modifier + " without element name.", part.line, part.col, rule);
                } else if (modifier.type === "class") {
                  if (!classes[modifier]) {
                    classes[modifier] = [];
                  }
                  classes[modifier].push({
                    modifier: modifier,
                    part: part
                  });
                }
              }
            }
          }
        }
      });
      parser.addListener("endstylesheet", function () {
        var prop;
        for (prop in classes) {
          if (classes.hasOwnProperty(prop)) {
            // one use means that this is overqualified
            if (classes[prop].length === 1 && classes[prop][0].part.elementName) {
              reporter.report("Element (" + classes[prop][0].part + ") is overqualified, just use " + classes[prop][0].modifier + " without element name.", classes[prop][0].part.line, classes[prop][0].part.col, rule);
            }
          }
        }
      });
    }
  });

  /*
   * Rule: Headings (h1-h6) should not be qualified (namespaced).
   */

  CSSLint.addRule({
    // rule information
    id: "qualified-headings",
    name: "Disallow qualified headings",
    desc: "Headings should not be qualified (namespaced).",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-qualified-headings",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("startrule", function (event) {
        var selectors = event.selectors,
          selector,
          part,
          i,
          j;
        for (i = 0; i < selectors.length; i++) {
          selector = selectors[i];
          for (j = 0; j < selector.parts.length; j++) {
            part = selector.parts[j];
            if (part.type === parser.SELECTOR_PART_TYPE) {
              if (part.elementName && /h[1-6]/.test(part.elementName.toString()) && j > 0) {
                reporter.report("Heading (" + part.elementName + ") should not be qualified.", part.line, part.col, rule);
              }
            }
          }
        }
      });
    }
  });

  /*
   * Rule: Selectors that look like regular expressions are slow and should be avoided.
   */

  CSSLint.addRule({
    // rule information
    id: "regex-selectors",
    name: "Disallow selectors that look like regexs",
    desc: "Selectors that look like regular expressions are slow and should be avoided.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-selectors-that-look-like-regular-expressions",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("startrule", function (event) {
        var selectors = event.selectors,
          selector,
          part,
          modifier,
          i,
          j,
          k;
        for (i = 0; i < selectors.length; i++) {
          selector = selectors[i];
          for (j = 0; j < selector.parts.length; j++) {
            part = selector.parts[j];
            if (part.type === parser.SELECTOR_PART_TYPE) {
              for (k = 0; k < part.modifiers.length; k++) {
                modifier = part.modifiers[k];
                if (modifier.type === "attribute") {
                  if (/([~\|\^\$\*]=)/.test(modifier)) {
                    reporter.report("Attribute selectors with " + RegExp.$1 + " are slow!", modifier.line, modifier.col, rule);
                  }
                }
              }
            }
          }
        }
      });
    }
  });

  /*
   * Rule: Total number of rules should not exceed x.
   */

  CSSLint.addRule({
    // rule information
    id: "rules-count",
    name: "Rules Count",
    desc: "Track how many rules there are.",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var count = 0;

      // count each rule
      parser.addListener("startrule", function () {
        count++;
      });
      parser.addListener("endstylesheet", function () {
        reporter.stat("rule-count", count);
      });
    }
  });

  /*
   * Rule: Warn people with approaching the IE 4095 limit
   */

  CSSLint.addRule({
    // rule information
    id: "selector-max-approaching",
    name: "Warn when approaching the 4095 selector limit for IE",
    desc: "Will warn when selector count is >= 3800 selectors.",
    browsers: "IE",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        count = 0;
      parser.addListener("startrule", function (event) {
        count += event.selectors.length;
      });
      parser.addListener("endstylesheet", function () {
        if (count >= 3800) {
          reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.", 0, 0, rule);
        }
      });
    }
  });

  /*
   * Rule: Warn people past the IE 4095 limit
   */

  CSSLint.addRule({
    // rule information
    id: "selector-max",
    name: "Error when past the 4095 selector limit for IE",
    desc: "Will error when selector count is > 4095.",
    browsers: "IE",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        count = 0;
      parser.addListener("startrule", function (event) {
        count += event.selectors.length;
      });
      parser.addListener("endstylesheet", function () {
        if (count > 4095) {
          reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.", 0, 0, rule);
        }
      });
    }
  });

  /*
   * Rule: Avoid new-line characters in selectors.
   */

  CSSLint.addRule({
    // rule information
    id: "selector-newline",
    name: "Disallow new-line characters in selectors",
    desc: "New-line characters in selectors are usually a forgotten comma and not a descendant combinator.",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      function startRule(event) {
        var i,
          len,
          selector,
          p,
          n,
          pLen,
          part,
          part2,
          type,
          currentLine,
          nextLine,
          selectors = event.selectors;
        for (i = 0, len = selectors.length; i < len; i++) {
          selector = selectors[i];
          for (p = 0, pLen = selector.parts.length; p < pLen; p++) {
            for (n = p + 1; n < pLen; n++) {
              part = selector.parts[p];
              part2 = selector.parts[n];
              type = part.type;
              currentLine = part.line;
              nextLine = part2.line;
              if (type === "descendant" && nextLine > currentLine) {
                reporter.report("newline character found in selector (forgot a comma?)", currentLine, selectors[i].parts[0].col, rule);
              }
            }
          }
        }
      }
      parser.addListener("startrule", startRule);
    }
  });

  /*
   * Rule: Use shorthand properties where possible.
   *
   */

  CSSLint.addRule({
    // rule information
    id: "shorthand",
    name: "Require shorthand properties",
    desc: "Use shorthand properties where possible.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-shorthand-properties",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        prop,
        i,
        len,
        propertiesToCheck = {},
        properties,
        mapping = {
          "margin": ["margin-top", "margin-bottom", "margin-left", "margin-right"],
          "padding": ["padding-top", "padding-bottom", "padding-left", "padding-right"]
        };

      // initialize propertiesToCheck
      for (prop in mapping) {
        if (mapping.hasOwnProperty(prop)) {
          for (i = 0, len = mapping[prop].length; i < len; i++) {
            propertiesToCheck[mapping[prop][i]] = prop;
          }
        }
      }
      function startRule() {
        properties = {};
      }

      // event handler for end of rules
      function endRule(event) {
        var prop, i, len, total;

        // check which properties this rule has
        for (prop in mapping) {
          if (mapping.hasOwnProperty(prop)) {
            total = 0;
            for (i = 0, len = mapping[prop].length; i < len; i++) {
              total += properties[mapping[prop][i]] ? 1 : 0;
            }
            if (total === mapping[prop].length) {
              reporter.report("The properties " + mapping[prop].join(", ") + " can be replaced by " + prop + ".", event.line, event.col, rule);
            }
          }
        }
      }
      parser.addListener("startrule", startRule);
      parser.addListener("startfontface", startRule);

      // check for use of "font-size"
      parser.addListener("property", function (event) {
        var name = event.property.toString().toLowerCase();
        if (propertiesToCheck[name]) {
          properties[name] = 1;
        }
      });
      parser.addListener("endrule", endRule);
      parser.addListener("endfontface", endRule);
    }
  });

  /*
   * Rule: Don't use properties with a star prefix.
   *
   */

  CSSLint.addRule({
    // rule information
    id: "star-property-hack",
    name: "Disallow properties with a star prefix",
    desc: "Checks for the star property hack (targets IE6/7)",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-star-hack",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;

      // check if property name starts with "*"
      parser.addListener("property", function (event) {
        var property = event.property;
        if (property.hack === "*") {
          reporter.report("Property with star prefix found.", event.property.line, event.property.col, rule);
        }
      });
    }
  });

  /*
   * Rule: Don't use text-indent for image replacement if you need to support rtl.
   *
   */

  CSSLint.addRule({
    // rule information
    id: "text-indent",
    name: "Disallow negative text-indent",
    desc: "Checks for text indent less than -99px",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-negative-text-indent",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        textIndent,
        direction;
      function startRule() {
        textIndent = false;
        direction = "inherit";
      }

      // event handler for end of rules
      function endRule() {
        if (textIndent && direction !== "ltr") {
          reporter.report("Negative text-indent doesn't work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.", textIndent.line, textIndent.col, rule);
        }
      }
      parser.addListener("startrule", startRule);
      parser.addListener("startfontface", startRule);

      // check for use of "font-size"
      parser.addListener("property", function (event) {
        var name = event.property.toString().toLowerCase(),
          value = event.value;
        if (name === "text-indent" && value.parts[0].value < -99) {
          textIndent = event.property;
        } else if (name === "direction" && value.toString() === "ltr") {
          direction = "ltr";
        }
      });
      parser.addListener("endrule", endRule);
      parser.addListener("endfontface", endRule);
    }
  });

  /*
   * Rule: Don't use properties with a underscore prefix.
   *
   */

  CSSLint.addRule({
    // rule information
    id: "underscore-property-hack",
    name: "Disallow properties with an underscore prefix",
    desc: "Checks for the underscore property hack (targets IE6)",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-underscore-hack",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;

      // check if property name starts with "_"
      parser.addListener("property", function (event) {
        var property = event.property;
        if (property.hack === "_") {
          reporter.report("Property with underscore prefix found.", event.property.line, event.property.col, rule);
        }
      });
    }
  });

  /*
   * Rule: Headings (h1-h6) should be defined only once.
   */

  CSSLint.addRule({
    // rule information
    id: "unique-headings",
    name: "Headings should only be defined once",
    desc: "Headings should be defined only once.",
    url: "https://github.com/CSSLint/csslint/wiki/Headings-should-only-be-defined-once",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      var headings = {
        h1: 0,
        h2: 0,
        h3: 0,
        h4: 0,
        h5: 0,
        h6: 0
      };
      parser.addListener("startrule", function (event) {
        var selectors = event.selectors,
          selector,
          part,
          pseudo,
          i,
          j;
        for (i = 0; i < selectors.length; i++) {
          selector = selectors[i];
          part = selector.parts[selector.parts.length - 1];
          if (part.elementName && /(h[1-6])/i.test(part.elementName.toString())) {
            for (j = 0; j < part.modifiers.length; j++) {
              if (part.modifiers[j].type === "pseudo") {
                pseudo = true;
                break;
              }
            }
            if (!pseudo) {
              headings[RegExp.$1]++;
              if (headings[RegExp.$1] > 1) {
                reporter.report("Heading (" + part.elementName + ") has already been defined.", part.line, part.col, rule);
              }
            }
          }
        }
      });
      parser.addListener("endstylesheet", function () {
        var prop,
          messages = [];
        for (prop in headings) {
          if (headings.hasOwnProperty(prop)) {
            if (headings[prop] > 1) {
              messages.push(headings[prop] + " " + prop + "s");
            }
          }
        }
        if (messages.length) {
          reporter.rollupWarn("You have " + messages.join(", ") + " defined in this stylesheet.", rule);
        }
      });
    }
  });

  /*
   * Rule: Don't use universal selector because it's slow.
   */

  CSSLint.addRule({
    // rule information
    id: "universal-selector",
    name: "Disallow universal selector",
    desc: "The universal selector (*) is known to be slow.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-universal-selector",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("startrule", function (event) {
        var selectors = event.selectors,
          selector,
          part,
          i;
        for (i = 0; i < selectors.length; i++) {
          selector = selectors[i];
          part = selector.parts[selector.parts.length - 1];
          if (part.elementName === "*") {
            reporter.report(rule.desc, part.line, part.col, rule);
          }
        }
      });
    }
  });

  /*
   * Rule: Don't use unqualified attribute selectors because they're just like universal selectors.
   */

  CSSLint.addRule({
    // rule information
    id: "unqualified-attributes",
    name: "Disallow unqualified attribute selectors",
    desc: "Unqualified attribute selectors are known to be slow.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-unqualified-attribute-selectors",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;
      parser.addListener("startrule", function (event) {
        var selectors = event.selectors,
          selectorContainsClassOrId = false,
          selector,
          part,
          modifier,
          i,
          k;
        for (i = 0; i < selectors.length; i++) {
          selector = selectors[i];
          part = selector.parts[selector.parts.length - 1];
          if (part.type === parser.SELECTOR_PART_TYPE) {
            for (k = 0; k < part.modifiers.length; k++) {
              modifier = part.modifiers[k];
              if (modifier.type === "class" || modifier.type === "id") {
                selectorContainsClassOrId = true;
                break;
              }
            }
            if (!selectorContainsClassOrId) {
              for (k = 0; k < part.modifiers.length; k++) {
                modifier = part.modifiers[k];
                if (modifier.type === "attribute" && (!part.elementName || part.elementName === "*")) {
                  reporter.report(rule.desc, part.line, part.col, rule);
                }
              }
            }
          }
        }
      });
    }
  });

  /*
   * Rule: When using a vendor-prefixed property, make sure to
   * include the standard one.
   */

  CSSLint.addRule({
    // rule information
    id: "vendor-prefix",
    name: "Require standard property with vendor prefix",
    desc: "When using a vendor-prefixed property, make sure to include the standard one.",
    url: "https://github.com/CSSLint/csslint/wiki/Require-standard-property-with-vendor-prefix",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this,
        properties,
        num,
        propertiesToCheck = {
          "-webkit-border-radius": "border-radius",
          "-webkit-border-top-left-radius": "border-top-left-radius",
          "-webkit-border-top-right-radius": "border-top-right-radius",
          "-webkit-border-bottom-left-radius": "border-bottom-left-radius",
          "-webkit-border-bottom-right-radius": "border-bottom-right-radius",
          "-o-border-radius": "border-radius",
          "-o-border-top-left-radius": "border-top-left-radius",
          "-o-border-top-right-radius": "border-top-right-radius",
          "-o-border-bottom-left-radius": "border-bottom-left-radius",
          "-o-border-bottom-right-radius": "border-bottom-right-radius",
          "-moz-border-radius": "border-radius",
          "-moz-border-radius-topleft": "border-top-left-radius",
          "-moz-border-radius-topright": "border-top-right-radius",
          "-moz-border-radius-bottomleft": "border-bottom-left-radius",
          "-moz-border-radius-bottomright": "border-bottom-right-radius",
          "-moz-column-count": "column-count",
          "-webkit-column-count": "column-count",
          "-moz-column-gap": "column-gap",
          "-webkit-column-gap": "column-gap",
          "-moz-column-rule": "column-rule",
          "-webkit-column-rule": "column-rule",
          "-moz-column-rule-style": "column-rule-style",
          "-webkit-column-rule-style": "column-rule-style",
          "-moz-column-rule-color": "column-rule-color",
          "-webkit-column-rule-color": "column-rule-color",
          "-moz-column-rule-width": "column-rule-width",
          "-webkit-column-rule-width": "column-rule-width",
          "-moz-column-width": "column-width",
          "-webkit-column-width": "column-width",
          "-webkit-column-span": "column-span",
          "-webkit-columns": "columns",
          "-moz-box-shadow": "box-shadow",
          "-webkit-box-shadow": "box-shadow",
          "-moz-transform": "transform",
          "-webkit-transform": "transform",
          "-o-transform": "transform",
          "-ms-transform": "transform",
          "-moz-transform-origin": "transform-origin",
          "-webkit-transform-origin": "transform-origin",
          "-o-transform-origin": "transform-origin",
          "-ms-transform-origin": "transform-origin",
          "-moz-box-sizing": "box-sizing",
          "-webkit-box-sizing": "box-sizing"
        };

      // event handler for beginning of rules
      function startRule() {
        properties = {};
        num = 1;
      }

      // event handler for end of rules
      function endRule() {
        var prop,
          i,
          len,
          needed,
          actual,
          needsStandard = [];
        for (prop in properties) {
          if (propertiesToCheck[prop]) {
            needsStandard.push({
              actual: prop,
              needed: propertiesToCheck[prop]
            });
          }
        }
        for (i = 0, len = needsStandard.length; i < len; i++) {
          needed = needsStandard[i].needed;
          actual = needsStandard[i].actual;
          if (!properties[needed]) {
            reporter.report("Missing standard property '" + needed + "' to go along with '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
          } else {
            // make sure standard property is last
            if (properties[needed][0].pos < properties[actual][0].pos) {
              reporter.report("Standard property '" + needed + "' should come after vendor-prefixed property '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
            }
          }
        }
      }
      parser.addListener("startrule", startRule);
      parser.addListener("startfontface", startRule);
      parser.addListener("startpage", startRule);
      parser.addListener("startpagemargin", startRule);
      parser.addListener("startkeyframerule", startRule);
      parser.addListener("startviewport", startRule);
      parser.addListener("property", function (event) {
        var name = event.property.text.toLowerCase();
        if (!properties[name]) {
          properties[name] = [];
        }
        properties[name].push({
          name: event.property,
          value: event.value,
          pos: num++
        });
      });
      parser.addListener("endrule", endRule);
      parser.addListener("endfontface", endRule);
      parser.addListener("endpage", endRule);
      parser.addListener("endpagemargin", endRule);
      parser.addListener("endkeyframerule", endRule);
      parser.addListener("endviewport", endRule);
    }
  });

  /*
   * Rule: You don't need to specify units when a value is 0.
   */

  CSSLint.addRule({
    // rule information
    id: "zero-units",
    name: "Disallow units for 0 values",
    desc: "You don't need to specify units when a value is 0.",
    url: "https://github.com/CSSLint/csslint/wiki/Disallow-units-for-zero-values",
    browsers: "All",
    // initialization
    init: function (parser, reporter) {
      "use strict";

      var rule = this;

      // count how many times "float" is used
      parser.addListener("property", function (event) {
        var parts = event.value.parts,
          i = 0,
          len = parts.length;
        while (i < len) {
          if ((parts[i].units || parts[i].type === "percentage") && parts[i].value === 0 && parts[i].type !== "time") {
            reporter.report("Values of 0 shouldn't have units specified.", parts[i].line, parts[i].col, rule);
          }
          i++;
        }
      });
    }
  });
  (function () {
    "use strict";

    /**
     * Replace special characters before write to output.
     *
     * Rules:
     *  - single quotes is the escape sequence for double-quotes
     *  - &amp; is the escape sequence for &
     *  - &lt; is the escape sequence for <
     *  - &gt; is the escape sequence for >
     *
     * @param {String} message to escape
     * @return escaped message as {String}
     */
    var xmlEscape = function (str) {
      if (!str || str.constructor !== String) {
        return "";
      }
      return str.replace(/["&><]/g, function (match) {
        switch (match) {
          case "\"":
            return "&quot;";
          case "&":
            return "&amp;";
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
        }
      });
    };
    CSSLint.addFormatter({
      // format information
      id: "checkstyle-xml",
      name: "Checkstyle XML format",
      /**
       * Return opening root XML tag.
       * @return {String} to prepend before all results
       */
      startFormat: function () {
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><checkstyle>";
      },
      /**
       * Return closing root XML tag.
       * @return {String} to append after all results
       */
      endFormat: function () {
        return "</checkstyle>";
      },
      /**
       * Returns message when there is a file read error.
       * @param {String} filename The name of the file that caused the error.
       * @param {String} message The error message
       * @return {String} The error message.
       */
      readError: function (filename, message) {
        return "<file name=\"" + xmlEscape(filename) + "\"><error line=\"0\" column=\"0\" severty=\"error\" message=\"" + xmlEscape(message) + "\"></error></file>";
      },
      /**
       * Given CSS Lint results for a file, return output for this format.
       * @param results {Object} with error and warning messages
       * @param filename {String} relative file path
       * @param options {Object} (UNUSED for now) specifies special handling of output
       * @return {String} output for results
       */
      formatResults: function (results, filename /*, options*/) {
        var messages = results.messages,
          output = [];

        /**
         * Generate a source string for a rule.
         * Checkstyle source strings usually resemble Java class names e.g
         * net.csslint.SomeRuleName
         * @param {Object} rule
         * @return rule source as {String}
         */
        var generateSource = function (rule) {
          if (!rule || !("name" in rule)) {
            return "";
          }
          return "net.csslint." + rule.name.replace(/\s/g, "");
        };
        if (messages.length > 0) {
          output.push("<file name=\"" + filename + "\">");
          CSSLint.Util.forEach(messages, function (message) {
            // ignore rollups for now
            if (!message.rollup) {
              output.push("<error line=\"" + message.line + "\" column=\"" + message.col + "\" severity=\"" + message.type + "\"" + " message=\"" + xmlEscape(message.message) + "\" source=\"" + generateSource(message.rule) + "\"/>");
            }
          });
          output.push("</file>");
        }
        return output.join("");
      }
    });
  })();
  CSSLint.addFormatter({
    // format information
    id: "compact",
    name: "Compact, 'porcelain' format",
    /**
     * Return content to be printed before all file results.
     * @return {String} to prepend before all results
     */
    startFormat: function () {
      "use strict";

      return "";
    },
    /**
     * Return content to be printed after all file results.
     * @return {String} to append after all results
     */
    endFormat: function () {
      "use strict";

      return "";
    },
    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (Optional) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function (results, filename, options) {
      "use strict";

      var messages = results.messages,
        output = "";
      options = options || {};

      /**
       * Capitalize and return given string.
       * @param str {String} to capitalize
       * @return {String} capitalized
       */
      var capitalize = function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      };
      if (messages.length === 0) {
        return options.quiet ? "" : filename + ": Lint Free!";
      }
      CSSLint.Util.forEach(messages, function (message) {
        if (message.rollup) {
          output += filename + ": " + capitalize(message.type) + " - " + message.message + " (" + message.rule.id + ")\n";
        } else {
          output += filename + ": line " + message.line + ", col " + message.col + ", " + capitalize(message.type) + " - " + message.message + " (" + message.rule.id + ")\n";
        }
      });
      return output;
    }
  });
  CSSLint.addFormatter({
    // format information
    id: "csslint-xml",
    name: "CSSLint XML format",
    /**
     * Return opening root XML tag.
     * @return {String} to prepend before all results
     */
    startFormat: function () {
      "use strict";

      return "<?xml version=\"1.0\" encoding=\"utf-8\"?><csslint>";
    },
    /**
     * Return closing root XML tag.
     * @return {String} to append after all results
     */
    endFormat: function () {
      "use strict";

      return "</csslint>";
    },
    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (UNUSED for now) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function (results, filename /*, options*/) {
      "use strict";

      var messages = results.messages,
        output = [];

      /**
       * Replace special characters before write to output.
       *
       * Rules:
       *  - single quotes is the escape sequence for double-quotes
       *  - &amp; is the escape sequence for &
       *  - &lt; is the escape sequence for <
       *  - &gt; is the escape sequence for >
       *
       * @param {String} message to escape
       * @return escaped message as {String}
       */
      var escapeSpecialCharacters = function (str) {
        if (!str || str.constructor !== String) {
          return "";
        }
        return str.replace(/"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      };
      if (messages.length > 0) {
        output.push("<file name=\"" + filename + "\">");
        CSSLint.Util.forEach(messages, function (message) {
          if (message.rollup) {
            output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
          } else {
            output.push("<issue line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" + " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
          }
        });
        output.push("</file>");
      }
      return output.join("");
    }
  });

  /* globals JSON: true */

  CSSLint.addFormatter({
    // format information
    id: "json",
    name: "JSON",
    /**
     * Return content to be printed before all file results.
     * @return {String} to prepend before all results
     */
    startFormat: function () {
      "use strict";

      this.json = [];
      return "";
    },
    /**
     * Return content to be printed after all file results.
     * @return {String} to append after all results
     */
    endFormat: function () {
      "use strict";

      var ret = "";
      if (this.json.length > 0) {
        if (this.json.length === 1) {
          ret = JSON.stringify(this.json[0]);
        } else {
          ret = JSON.stringify(this.json);
        }
      }
      return ret;
    },
    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path (Unused)
     * @return {String} output for results
     */
    formatResults: function (results, filename, options) {
      "use strict";

      if (results.messages.length > 0 || !options.quiet) {
        this.json.push({
          filename: filename,
          messages: results.messages,
          stats: results.stats
        });
      }
      return "";
    }
  });
  CSSLint.addFormatter({
    // format information
    id: "junit-xml",
    name: "JUNIT XML format",
    /**
     * Return opening root XML tag.
     * @return {String} to prepend before all results
     */
    startFormat: function () {
      "use strict";

      return "<?xml version=\"1.0\" encoding=\"utf-8\"?><testsuites>";
    },
    /**
     * Return closing root XML tag.
     * @return {String} to append after all results
     */
    endFormat: function () {
      "use strict";

      return "</testsuites>";
    },
    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (UNUSED for now) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function (results, filename /*, options*/) {
      "use strict";

      var messages = results.messages,
        output = [],
        tests = {
          "error": 0,
          "failure": 0
        };

      /**
       * Generate a source string for a rule.
       * JUNIT source strings usually resemble Java class names e.g
       * net.csslint.SomeRuleName
       * @param {Object} rule
       * @return rule source as {String}
       */
      var generateSource = function (rule) {
        if (!rule || !("name" in rule)) {
          return "";
        }
        return "net.csslint." + rule.name.replace(/\s/g, "");
      };

      /**
       * Replace special characters before write to output.
       *
       * Rules:
       *  - single quotes is the escape sequence for double-quotes
       *  - &lt; is the escape sequence for <
       *  - &gt; is the escape sequence for >
       *
       * @param {String} message to escape
       * @return escaped message as {String}
       */
      var escapeSpecialCharacters = function (str) {
        if (!str || str.constructor !== String) {
          return "";
        }
        return str.replace(/"/g, "'").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      };
      if (messages.length > 0) {
        messages.forEach(function (message) {
          // since junit has no warning class
          // all issues as errors
          var type = message.type === "warning" ? "error" : message.type;

          // ignore rollups for now
          if (!message.rollup) {
            // build the test case separately, once joined
            // we'll add it to a custom array filtered by type
            output.push("<testcase time=\"0\" name=\"" + generateSource(message.rule) + "\">");
            output.push("<" + type + " message=\"" + escapeSpecialCharacters(message.message) + "\"><![CDATA[" + message.line + ":" + message.col + ":" + escapeSpecialCharacters(message.evidence) + "]]></" + type + ">");
            output.push("</testcase>");
            tests[type] += 1;
          }
        });
        output.unshift("<testsuite time=\"0\" tests=\"" + messages.length + "\" skipped=\"0\" errors=\"" + tests.error + "\" failures=\"" + tests.failure + "\" package=\"net.csslint\" name=\"" + filename + "\">");
        output.push("</testsuite>");
      }
      return output.join("");
    }
  });
  CSSLint.addFormatter({
    // format information
    id: "lint-xml",
    name: "Lint XML format",
    /**
     * Return opening root XML tag.
     * @return {String} to prepend before all results
     */
    startFormat: function () {
      "use strict";

      return "<?xml version=\"1.0\" encoding=\"utf-8\"?><lint>";
    },
    /**
     * Return closing root XML tag.
     * @return {String} to append after all results
     */
    endFormat: function () {
      "use strict";

      return "</lint>";
    },
    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (UNUSED for now) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function (results, filename /*, options*/) {
      "use strict";

      var messages = results.messages,
        output = [];

      /**
       * Replace special characters before write to output.
       *
       * Rules:
       *  - single quotes is the escape sequence for double-quotes
       *  - &amp; is the escape sequence for &
       *  - &lt; is the escape sequence for <
       *  - &gt; is the escape sequence for >
       *
       * @param {String} message to escape
       * @return escaped message as {String}
       */
      var escapeSpecialCharacters = function (str) {
        if (!str || str.constructor !== String) {
          return "";
        }
        return str.replace(/"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      };
      if (messages.length > 0) {
        output.push("<file name=\"" + filename + "\">");
        CSSLint.Util.forEach(messages, function (message) {
          if (message.rollup) {
            output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
          } else {
            var rule = "";
            if (message.rule && message.rule.id) {
              rule = "rule=\"" + escapeSpecialCharacters(message.rule.id) + "\" ";
            }
            output.push("<issue " + rule + "line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" + " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
          }
        });
        output.push("</file>");
      }
      return output.join("");
    }
  });
  CSSLint.addFormatter({
    // format information
    id: "text",
    name: "Plain Text",
    /**
     * Return content to be printed before all file results.
     * @return {String} to prepend before all results
     */
    startFormat: function () {
      "use strict";

      return "";
    },
    /**
     * Return content to be printed after all file results.
     * @return {String} to append after all results
     */
    endFormat: function () {
      "use strict";

      return "";
    },
    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (Optional) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function (results, filename, options) {
      "use strict";

      var messages = results.messages,
        output = "";
      options = options || {};
      if (messages.length === 0) {
        return options.quiet ? "" : "\n\ncsslint: No errors in " + filename + ".";
      }
      output = "\n\ncsslint: There ";
      if (messages.length === 1) {
        output += "is 1 problem";
      } else {
        output += "are " + messages.length + " problems";
      }
      output += " in " + filename + ".";
      var pos = filename.lastIndexOf("/"),
        shortFilename = filename;
      if (pos === -1) {
        pos = filename.lastIndexOf("\\");
      }
      if (pos > -1) {
        shortFilename = filename.substring(pos + 1);
      }
      CSSLint.Util.forEach(messages, function (message, i) {
        output = output + "\n\n" + shortFilename;
        if (message.rollup) {
          output += "\n" + (i + 1) + ": " + message.type;
          output += "\n" + message.message;
        } else {
          output += "\n" + (i + 1) + ": " + message.type + " at line " + message.line + ", col " + message.col;
          output += "\n" + message.message;
          output += "\n" + message.evidence;
        }
      });
      return output;
    }
  });
  return CSSLint;
}();
window.CSSLint = CSSLint;

/***/ }),

/***/ "./scripts/3rdparty/csspretty/csspretty.js":
/*!*************************************************!*\
  !*** ./scripts/3rdparty/csspretty/csspretty.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;
/*prettydiff.com api.topcoms:true,api.insize:4,api.inchar:" ",api.vertical:true */
/*jshint laxbreak: true*/
/*global ace, define, exports, global*/
/***********************************************************************
 csspretty is written by Austin Cheney on 7 Aug 2014.  Anybody may use
 this code without permission so long as this comment exists verbatim in
 each instance of its use.

 http://mailmarkup.org/
 http://prettydiff.com/
 **********************************************************************/
/*
 This application beautifies CSS code as well as SCSS (Sass) and LESS
 variants. This application was written with extension in mind using the
 same array based architecture used for the markuppretty and jspretty
 libraries.  The architecture focuses on separation of roles.  The first
 area of the application reads the code and writes an array of tokens.
 The second area is the algorithm that determines what white space and
 indentation should be applied.  The final area is a report on the
 analysis of the code.
 -----------------------------------------------------------------------
 */
var csspretty = function csspretty_(options) {
  "use strict";

  var token = [],
    types = [],
    lines = [],
    uri = [],
    colors = [],
    output = "",
    endline = false,
    objsortop = false,
    verticalop = false,
    colorNames = {
      aliceblue: 0.9288006825347457,
      antiquewhite: 0.8464695170775405,
      aqua: 0.7874,
      aquamarine: 0.8078549208338043,
      azure: 0.9726526495416643,
      beige: 0.8988459998705021,
      bisque: 0.8073232737297876,
      black: 0,
      blanchedalmond: 0.8508443960815607,
      blue: 0.0722,
      blueviolet: 0.12622014321946043,
      brown: 0.09822428787651079,
      burlywood: 0.5155984453389335,
      cadetblue: 0.29424681085422044,
      chartreuse: 0.7603202590262282,
      chocolate: 0.23898526114557292,
      coral: 0.3701793087292368,
      cornflowerblue: 0.30318641994179363,
      cornsilk: 0.9356211037296492,
      crimson: 0.16042199953025577,
      cyan: 0.7874,
      darkblue: 0.018640801980939217,
      darkcyan: 0.2032931783904645,
      darkgoldenrod: 0.27264703559992554,
      darkgray: 0.39675523072562674,
      darkgreen: 0.09114342904757505,
      darkgrey: 0.39675523072562674,
      darkkhaki: 0.45747326349994155,
      darkmagenta: 0.07353047651207048,
      darkolivegreen: 0.12651920884889156,
      darkorange: 0.40016167026523863,
      darkorchid: 0.1341314217485677,
      darkred: 0.05488967453113126,
      darksalmon: 0.4054147156338075,
      darkseagreen: 0.43789249325969054,
      darkslateblue: 0.06579284622798763,
      darkslategray: 0.06760815192804355,
      darkslategrey: 0.06760815192804355,
      darkturquoise: 0.4874606277449034,
      darkviolet: 0.10999048339343433,
      deeppink: 0.2386689582827583,
      deepskyblue: 0.444816033955754,
      dimgray: 0.14126329114027164,
      dimgrey: 0.14126329114027164,
      dodgerblue: 0.2744253699145608,
      firebrick: 0.10724525535015225,
      floralwhite: 0.9592248482500424,
      forestgreen: 0.18920812076002244,
      fuchsia: 0.2848,
      gainsboro: 0.7156935005064806,
      ghostwhite: 0.9431126188632283,
      gold: 0.6986087742815887,
      goldenrod: 0.41919977809568404,
      gray: 0.21586050011389915,
      green: 0.15438342968146068,
      greenyellow: 0.8060947261145331,
      grey: 0.21586050011389915,
      honeydew: 0.9633653555478173,
      hotpink: 0.3465843816971475,
      indianred: 0.21406134963884,
      indigo: 0.031075614863369846,
      ivory: 0.9907127060061531,
      khaki: 0.7701234339412052,
      lavendar: 0.8031875051452125,
      lavendarblush: 0.9017274863104644,
      lawngreen: 0.7390589312496334,
      lemonchiffon: 0.9403899224562171,
      lightblue: 0.6370914128080659,
      lightcoral: 0.35522120733134843,
      lightcyan: 0.9458729349482863,
      lightgoldenrodyellow: 0.9334835101829635,
      lightgray: 0.651405637419824,
      lightgreen: 0.6909197995686475,
      lightgrey: 0.651405637419824,
      lightpink: 0.5856615273489745,
      lightsalmon: 0.47806752252059587,
      lightseagreen: 0.3505014511704197,
      lightskyblue: 0.5619563761833096,
      lightslategray: 0.23830165007286924,
      lightslategrey: 0.23830165007286924,
      lightyellow: 0.9816181839288161,
      lime: 0.7152,
      limegreen: 0.44571042246097864,
      linen: 0.8835734098437936,
      magenta: 0.2848,
      maroon: 0.04589194232421496,
      mediumaquamarine: 0.4938970331080111,
      mediumblue: 0.04407778021232784,
      mediumorchid: 0.21639251153773428,
      mediumpurple: 0.22905858091648004,
      mediumseagreen: 0.34393112338131226,
      mediumslateblue: 0.20284629471622434,
      mediumspringgreen: 0.7070430819418444,
      mediumturquois: 0.5133827926447991,
      mediumvioletred: 0.14371899849357186,
      midnightblue: 0.020717866350860484,
      mintcream: 0.9783460494758793,
      mistyrose: 0.8218304785918541,
      moccasin: 0.8008300099156694,
      navajowhite: 0.7651968234278562,
      navy: 0.015585128108223519,
      oldlace: 0.9190063340554899,
      olive: 0.20027537200567563,
      olivedrab: 0.2259315095192918,
      orange: 0.48170267036309605,
      orangered: 0.2551624375341641,
      orchid: 0.3134880676143873,
      palegoldenrod: 0.7879264788761452,
      palegreen: 0.7793675900635259,
      paleturquoise: 0.764360779217138,
      palevioletred: 0.2875499411788909,
      papayawhip: 0.8779710019983541,
      peachpuff: 0.7490558987825108,
      peru: 0.3011307487793569,
      pink: 0.6327107070246611,
      plum: 0.4573422158796909,
      powderblue: 0.6825458650060524,
      purple: 0.061477070432438476,
      red: 0.2126,
      rosyblue: 0.3231945764940708,
      royalblue: 0.16663210743188323,
      saddlebrown: 0.09792228502052071,
      salmon: 0.3697724152759545,
      sandybrown: 0.46628543696283414,
      seagreen: 0.1973419970627483,
      seashell: 0.927378622069223,
      sienna: 0.13697631337097677,
      silver: 0.527115125705813,
      skyblue: 0.5529166851818412,
      slateblue: 0.14784278062136097,
      slategray: 0.20896704076536138,
      slategrey: 0.20896704076536138,
      slightsteelblue: 0.5398388828466575,
      snow: 0.9653334183484877,
      springgreen: 0.7305230606852947,
      steelblue: 0.20562642207624846,
      tan: 0.48237604163921527,
      teal: 0.1699685577896842,
      thistle: 0.5681840109373312,
      tomato: 0.3063861271941505,
      turquoise: 0.5895536427577983,
      violet: 0.40315452986676303,
      wheat: 0.7490970282048214,
      white: 1,
      whitesmoke: 0.913098651793419,
      yellow: 0.9278,
      yellowgreen: 0.5076295720870697
    },
    stats = {
      braces: 0,
      colon: 0,
      comments: {
        chars: 0,
        count: 0
      },
      properties: {
        chars: 0,
        count: 0
      },
      selectors: {
        chars: 0,
        count: 0
      },
      semi: 0,
      space: 0,
      values: {
        chars: 0,
        count: 0
      },
      variables: {
        chars: 0,
        count: 0
      }
    },
    lf = options.crlf === true || options.crlf === "true" ? "\r\n" : "\n";
  (function csspretty__options() {
    objsortop = options.objsort === true || options.objsort === "true" || options.objsort === "all" || options.objsort === "css";
    options.accessibility = options.accessibility === true || options.accessibility === "true";
    options.braces = options.braces === true || options.braces === "allman";
    options.compressedcss = options.compressedcss === true || options.compressedcss === "true";
    options.cssinsertlines = options.cssinsertlines === true || options.cssinsertlines === "true";
    options.diffcomm = options.diffcomm === true || options.diffcomm === "true";
    options.inchar = typeof options.inchar !== "string" || options.inchar === "" ? " " : options.inchar;
    options.inlevel = isNaN(options.inlevel) === true ? 0 : Number(options.inlevel);
    options.insize = isNaN(options.insize) === true ? 4 : Number(options.insize);
    options.mode = options.mode === "minify" || options.mode === "parse" || options.mode === "diff" ? options.mode : "beautify";
    options.noleadzero = options.noleadzero === true || options.noleadzero === "true";
    options.preserve = function csspretty__options_preserve() {
      if (options.preserve === 1 || options.preserve === undefined || options.preserve === true || options.preserve === "all" || options.preserve === "js" || options.preserve === "css") {
        return 1;
      }
      if (options.preserve === false || isNaN(options.preserve) === true || Number(options.preserve) < 1 || options.preserve === "none") {
        return 0;
      }
      return Number(options.preserve);
    }();
    options.quoteConvert = options.quoteConvert === "single" || options.quoteConvert === "double" ? options.quoteConvert : "none";
    options.selectorlist = options.selectorlist === true || options.selectorlist === "true";
    options.source = typeof options.source !== "string" || options.source === "" || /^(\s+)$/.test(options.source) === true ? "Error: no source supplied to csspretty." : options.source.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    options.topcoms = options.topcoms === true || options.topcoms === "true";
    verticalop = options.vertical === true || options.vertical === "true" || options.vertical === "all" || options.vertical === "css";
    if (options.compressedcss === true) {
      verticalop = false;
    }
  })();
  if (options.source === "Error: no source supplied to csspretty.") {
    return options.source;
  }
  (function csspretty__tokenize() {
    var a = 0,
      b = options.source.split(""),
      len = options.source.length,
      ltype = "",
      itemsize = 0,
      space = "",
      endtest = false,
      spacecol = false,
      nosort = [],
      //map location of empty lines for beautification
      spacer = function csspretty__tokenize_space(end) {
        var slen = space.split(lf).length - 1,
          value = 0;
        if (token.length === 0 && slen > 0) {
          slen += 1;
        }
        if (slen > 0 && options.preserve > 0) {
          if (slen > options.preserve) {
            value = options.preserve + 1;
          } else {
            value = slen;
          }
        } else if (space.length > 1) {
          value = 1;
        } else if (slen === 0 && types[types.length - 1] === "comment" && types[types.length - 2] !== "comment") {
          types[types.length - 1] = "comment-inline";
        }
        if (slen > 1 && end === true && options.preserve > 0) {
          endline = true;
          space = "";
          return value;
        }
        space = "";
        return value;
      },
      //sort parsed properties intelligently
      objSort = function csspretty__tokenize_objSort() {
        var cc = 0,
          dd = 0,
          ee = 0,
          startlen = token.length - 1,
          end = startlen,
          keys = [],
          keylen = 0,
          keyend = 0,
          start = 0,
          sort = function csspretty__tokenize_objSort_sort(x, y) {
            var xx = x[0],
              yy = y[0];
            if (types[xx] === "comment" || types[xx] === "comment-inline") {
              do {
                xx += 1;
              } while (xx < startlen && (types[xx] === "comment" || types[xx] === "comment-inline"));
            }
            if (types[yy] === "comment" || types[yy] === "comment-inline") {
              do {
                yy += 1;
              } while (yy < startlen && (types[yy] === "comment" || types[yy] === "comment-inline"));
            }
            if (types[xx] < types[yy]) {
              return -1;
            }
            if (types[xx] === types[yy] && token[xx].toLowerCase() < token[yy].toLowerCase()) {
              return -1;
            }
            return 1;
          },
          semiTest = true,
          pairToken = [],
          pairTypes = [],
          pairLines = [];
        if (types[end] === "comment" || types[end] === "comment-inline") {
          do {
            end -= 1;
          } while (end > 0 && (types[end] === "comment" || types[end] === "comment-inline"));
        }
        for (cc = startlen; cc > -1; cc -= 1) {
          if (types[cc] === "end") {
            dd += 1;
          }
          if (types[cc] === "start") {
            dd -= 1;
          }
          if (dd === 0) {
            if ((types[cc] === "property" || types[cc] === "selector" || types[cc] === "propvar") && types[cc - 1] !== "property" && types[cc - 1] !== "selector") {
              start = cc;
              if (types[end + 1] === "comment-inline") {
                end += 1;
              }
              if (types[start - 1] === "comment") {
                do {
                  start -= 1;
                } while (start > -1 && types[start - 1] === "comment");
              }
              keys.push([start, end + 1, false]);
              end = start - 1;
            }
          }
          if (dd < 0 && cc < startlen) {
            if (keys.length > 1 && (types[cc - 1] === "selector" || token[cc - 1] === "=" || token[cc - 1] === ":" || token[cc - 1] === "[" || token[cc - 1] === "{" || token[cc - 1] === "," || cc === 0)) {
              keys.sort(sort);
              keylen = keys.length;
              semiTest = false;
              for (dd = 0; dd < keylen; dd += 1) {
                keyend = keys[dd][1];
                for (ee = keys[dd][0]; ee < keyend; ee += 1) {
                  pairToken.push(token[ee]);
                  pairTypes.push(types[ee]);
                  pairLines.push(lines[ee]);
                  if (token[ee] === ";" || token[ee] === "}") {
                    semiTest = true;
                  } else if (token[ee] !== ";" && token[ee] !== "}" && types[ee] !== "comment" && types[ee] !== "comment-inline") {
                    semiTest = false;
                  }
                }
                if (semiTest === false) {
                  ee = pairTypes.length - 1;
                  if (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline") {
                    do {
                      ee -= 1;
                    } while (ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline"));
                  }
                  ee += 1;
                  pairToken.splice(ee, 0, ";");
                  pairTypes.splice(ee, 0, "semi");
                  if (pairLines[ee - 1] > 0) {
                    pairLines[ee - 1] = 0;
                    pairLines.splice(ee, 0, 1);
                  } else {
                    pairLines.splice(ee, 0, 0);
                  }
                }
              }
              ee = pairTypes.length - 1;
              if (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline") {
                do {
                  ee -= 1;
                } while (ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline"));
              }
              keylen = token.length - (cc + 1);
              token.splice(cc + 1, keylen);
              types.splice(cc + 1, keylen);
              lines.splice(cc + 1, keylen);
              token = token.concat(pairToken);
              types = types.concat(pairTypes);
              lines = lines.concat(pairLines);
            }
            return;
          }
        }
      },
      //Some tokens receive a generic type named 'item'
      //because their type is unknown until we know the
      //following syntax.  This function replaces the type
      //'item' with something more specific.
      item = function csspretty__tokenize_item(type) {
        var aa = token.length,
          bb = 0,
          coms = [],
          //Since I am already identifying value types
          //this is a good place to do some quick analysis
          //and clean up on certain value conditions.
          //These things are being corrected:
          //  * fractional values missing a leading 0 are
          //    provided a leading 0
          //  * 0 values with a dimension indicator
          //    (px, em) have the dimension indicator
          //    removed
          //  * eliminate unnecessary leading 0s
          //  * url values that are not quoted are wrapped
          //    in double quote characters
          //  * color values are set to lowercase and
          //    reduced from 6 to 3 digits if appropriate
          value = function csspretty__tokenize_item_value(val, font) {
            var x = val.split(""),
              leng = x.length,
              cc = 0,
              dd = 0,
              items = [],
              block = "",
              values = [],
              qchar = "",
              colorPush = function csspretty__tokenize_item_value_colorPush(value) {
                var vl = value.toLowerCase();
                if (/^(#[0-9a-f]{3,6})$/.test(vl) === true) {
                  colors.push(value);
                } else if (/^(rgba?\()/.test(vl) === true) {
                  colors.push(value);
                } else if (colorNames[vl] !== undefined) {
                  colors.push(value);
                }
                return value;
              };
            if (options.quoteConvert === "double") {
              qchar = "\"";
            } else if (options.quoteConvert === "single") {
              qchar = "'";
            }
            //this loop identifies containment so that
            //tokens/sub-tokens are correctly taken
            for (cc = 0; cc < leng; cc += 1) {
              items.push(x[cc]);
              if (block === "") {
                if (x[cc] === "\"") {
                  block = "\"";
                  dd += 1;
                } else if (x[cc] === "'") {
                  block = "'";
                  dd += 1;
                } else if (x[cc] === "(") {
                  block = ")";
                  dd += 1;
                } else if (x[cc] === "[") {
                  block = "]";
                  dd += 1;
                }
              } else if (x[cc] === "(" && block === ")" || x[cc] === "[" && block === "]") {
                dd += 1;
              } else if (x[cc] === block) {
                dd -= 1;
                if (dd === 0) {
                  block = "";
                }
              }
              if (block === "" && x[cc] === " ") {
                items.pop();
                values.push(colorPush(items.join("")));
                items = [];
              }
            }
            values.push(colorPush(items.join("")));
            leng = values.length;
            //This is where the rules mentioned above
            //are applied
            for (cc = 0; cc < leng; cc += 1) {
              if (options.noleadzero === false && /^(\.\d)/.test(values[cc]) === true) {
                values[cc] = "0" + values[cc];
              } else if (options.noleadzero === true && /^(0+\.)/.test(values[cc])) {
                values[cc] = values[cc].replace(/^(0+\.)/, ".");
              } else if (/^(0+([a-z]{2,3}|%))$/.test(values[cc]) === true) {
                values[cc] = "0";
              } else if (/^(0+)/.test(values[cc]) === true) {
                values[cc] = values[cc].replace(/0+/, "0");
                if (/\d/.test(values[cc].charAt(1)) === true) {
                  values[cc] = values[cc].substr(1);
                }
              } else if (/^url\((?!\$)/.test(values[cc]) === true && values[cc].charAt(values[cc].length - 1) === ")") {
                if (qchar === "" && /url\(('|")/.test(values[cc]) === false) {
                  values[cc] = values[cc].replace(/url\(('|")?/, "url(\"").replace(/(('|")?\))$/, "\")");
                } else if (qchar !== "") {
                  values[cc] = values[cc].replace(/url\(('|")?/, "url(" + qchar).replace(/(('|")?\))$/, qchar + ")");
                }
              } else if (font === true) {
                if (qchar === "'") {
                  values[cc] = values[cc].replace(/"/g, "'");
                } else {
                  values[cc] = values[cc].replace(/'/g, "\"");
                }
              } else if (font === false && qchar !== "" && (qchar === "\"" && values[cc].charAt(0) === "'" && values[cc].charAt(values[cc].length - 1) === "'" || qchar === "'" && values[cc].charAt(0) === "\"" && values[cc].charAt(values[cc].length - 1) === "\"")) {
                values[cc] = qchar + values[cc].slice(1, values[cc].length - 1) + qchar;
              }
            }
            return values.join(" ");
          };
        //backtrack through immediately prior comments to
        //find the correct token
        if (ltype === "comment" || ltype === "comment-inline") {
          do {
            aa -= 1;
            ltype = types[aa];
            coms.push(token[aa]);
          } while (aa > 0 && (ltype === "comment" || ltype === "comment-inline"));
        } else {
          aa -= 1;
        }
        //if the last non-comment type is 'item' then id it
        if (ltype === "item" && types[aa].indexOf("external") < 0) {
          if (type === "start") {
            stats.selectors.count += 1;
            stats.selectors.chars += itemsize;
            if (types[aa - 1] !== "comment" && types[aa - 1] !== "comment-inline" && types[aa - 1] !== "end" && types[aa - 1] !== "start" && types[aa - 1] !== "semi" && types[aa - 1] !== undefined && types[aa - 1].indexOf("external") < 0) {
              (function csspretty__tokenize_item_selparts() {
                var parts = [],
                  cc = aa,
                  dd = 0;
                do {
                  parts.push(token[cc]);
                  if (spacecol === true && token[cc] === ":" && token[cc - 1] !== ":") {
                    parts.push(" ");
                  }
                  cc -= 1;
                } while (cc > -1 && types[cc] !== "comment" && types[cc] !== "comment-inline" && types[cc] !== "end" && types[cc] !== "start" && types[cc] !== "semi" && types[cc] !== undefined);
                parts.reverse();
                cc += 1;
                dd = aa - cc;
                token.splice(cc, dd);
                types.splice(cc, dd);
                lines.splice(cc, dd);
                aa -= dd;
                token[aa] = parts.join("").replace(/\s*,(\s*)/g, ",");
              })();
            } else {
              token[aa] = token[aa].replace(/\s*,(\s*)/g, ",");
            }
            types[aa] = "selector";
          } else if (type === "end") {
            types[aa] = "value";
            if (options.mode !== "diff") {
              if (options.quoteConvert !== "none" && (token[aa - 2] === "font" || token[aa - 2] === "font-family")) {
                token[aa] = value(token[aa], true);
              } else {
                token[aa] = value(token[aa], false);
              }
            }
            //take comments out until the 'item' is
            //found and then put the comments back
            if (options.mode === "beautify" || options.mode === "diff" && options.diffcomm === true) {
              if (token[token.length - 2] === "{") {
                types[types.length - 1] = "propvar";
                stats.values.count -= 1;
                stats.values.chars -= itemsize;
                stats.variables.count += 1;
                stats.variables.chars += itemsize;
              } else {
                if (coms.length > 0 && ltype !== "semi" && ltype !== "end" && ltype !== "start") {
                  aa = coms.length - 1;
                  do {
                    token.pop();
                    types.pop();
                    lines.pop();
                    aa -= 1;
                  } while (aa > 0);
                  if (options.mode === "diff") {
                    token.push("x;");
                  } else {
                    token.push(";");
                  }
                  types.push("semi");
                  lines.push(spacer(false));
                  bb = coms.length - 1;
                  do {
                    token.push(coms[aa]);
                    if (coms[aa].indexOf("//") === 0 && lines[lines.length - 1] === 0) {
                      types.push("comment-inline");
                    } else {
                      types.push("comment");
                    }
                    lines.push(0);
                    aa += 1;
                  } while (aa < bb);
                } else {
                  if (options.mode === "diff") {
                    token.push("x;");
                  } else {
                    token.push(";");
                  }
                  types.push("semi");
                  lines.push(spacer(false));
                }
              }
            }
            stats.values.count += 1;
            stats.values.chars += itemsize;
          } else if (type === "semi") {
            if (types[aa - 1] === "colon") {
              stats.values.count += 1;
              stats.values.chars += itemsize;
              types[aa] = "value";
              if (options.mode !== "diff") {
                if (options.quoteConvert !== "none" && (token[aa - 2] === "font" || token[aa - 2] === "font-family")) {
                  token[aa] = value(token[aa], true);
                } else {
                  token[aa] = value(token[aa], false);
                }
              }
            } else {
              //properties without values are
              //considered variables
              types[aa] = "propvar";
              stats.variables.count += 1;
              stats.variables.chars += itemsize;
            }
          } else if (type === "colon") {
            types[aa] = "property";
            stats.properties.count += 1;
            stats.properties.chars += itemsize;
          }
        }
      },
      external = function csspretty__tokenize_external(open, end) {
        var store = [],
          quote = "",
          name = "",
          endlen = 0,
          start = open.length,
          linev = spacer(false);
        nosort[nosort.length - 1] = true;
        for (a = a; a < len; a += 1) {
          store.push(b[a]);
          if (quote === "") {
            if (b[a] === "\"") {
              quote = "\"";
            } else if (b[a] === "'") {
              quote = "'";
            } else if (b[a] === "/") {
              if (b[a + 1] === "/") {
                quote = "/";
              } else if (b[a + 1] === "*") {
                quote = "*";
              }
            } else if (b[a + 1] === end.charAt(0)) {
              do {
                endlen += 1;
                a += 1;
                store.push(b[a]);
              } while (a < len && endlen < end.length && b[a + 1] === end.charAt(endlen));
              if (endlen === end.length) {
                quote = store.join("");
                if (/\s/.test(quote.charAt(start)) === true) {
                  do {
                    start += 1;
                  } while (/\s/.test(quote.charAt(start)) === true);
                }
                endlen = start;
                do {
                  endlen += 1;
                } while (endlen < end.length && /\s/.test(quote.charAt(endlen)) === false);
                if (endlen === quote.length) {
                  endlen -= end.length;
                }
                if (open === "{%") {
                  quote = quote.replace(/^(\{%\s*)/, "{% ").replace(/(\s*%\})$/, " %}");
                }
                lines.push(linev);
                token.push(quote);
                if (open === "{%") {
                  name = quote.slice(3);
                  name = name.slice(0, name.indexOf(" "));
                  store = ["autoescape", "block", "capture", "case", "comment", "embed", "filter", "for", "form", "if", "macro", "raw", "sandbox", "spaceless", "tablerow", "unless", "verbatim"];
                  if (name === "else" || name === "elseif" || name === "when") {
                    return types.push("external_else");
                  }
                  for (endlen = store.length - 1; endlen > -1; endlen -= 1) {
                    if (name === store[endlen]) {
                      return types.push("external_start");
                    }
                    if (name === "end" + store[endlen]) {
                      return types.push("external_end");
                    }
                  }
                }
                return types.push("external");
              }
              endlen = 0;
            }
          } else if (quote === b[a]) {
            if (quote === "\"" || quote === "'") {
              quote = "";
            } else if (quote === "/" && (b[a] === "\r" || b[a] === "\n")) {
              quote = "";
            } else if (quote === "*" && b[a + 1] === "/") {
              quote = "";
            }
          }
        }
      },
      //finds comments include those JS looking '//' comments
      comment = function csspretty__tokenize_comment(inline) {
        var aa = 0,
          out = [b[a]],
          type = "comment",
          spareType = [],
          spareToke = [],
          spareLine = [],
          linev = spacer(false);
        type = inline === true && linev === 0 ? "comment-inline" : "comment";
        for (aa = a + 1; aa < len; aa += 1) {
          out.push(b[aa]);
          if (inline === false && b[aa - 1] === "*" && b[aa] === "/" || inline === true && b[aa + 1] === "\n") {
            break;
          }
        }
        a = aa;
        stats.comments.count += 1;
        stats.comments.chars += out.length;
        if (options.mode === "minify") {
          out.push("\n");
        }
        if (options.mode === "beautify" || options.mode === "diff" && options.diffcomm === true || options.mode === "minify" && options.topcoms === true) {
          if (token.length > 0 && token[token.length - 1].charAt(token[token.length - 1].length - 1) === "," && types[types.length - 1] !== "comment" && types[types.length - 1] !== "comment-inline") {
            spareToke.push(token[token.length - 1]);
            token.pop();
            types.pop();
            lines.pop();
            token.push(out.join(""));
            types.push(type);
            lines.push(linev);
            token.push(spareToke[0]);
            types.push("selector");
            lines.push(0);
          } else if (ltype === "colon" || ltype === "property" || ltype === "value" || ltype === "propvar") {
            do {
              spareToke.push(token[token.length - 1]);
              spareType.push(types[types.length - 1]);
              spareLine.push(lines[lines.length - 1]);
              token.pop();
              types.pop();
              lines.pop();
            } while (types.length > 1 && types[types.length - 1] !== "semi" && types[types.length - 1] !== "start");
            token.push(out.join(""));
            types.push(type);
            lines.push(linev);
            do {
              token.push(spareToke[spareToke.length - 1]);
              types.push(spareType[spareType.length - 1]);
              lines.push(spareLine[spareLine.length - 1]);
              spareToke.pop();
              spareType.pop();
              spareLine.pop();
            } while (spareToke.length > 0);
          } else {
            ltype = type;
            types.push(type);
            token.push(out.join(""));
            lines.push(linev);
          }
        }
      },
      //the generic token builder
      buildtoken = function csspretty__tokenize_build() {
        var aa = 0,
          bb = 0,
          out = [],
          block = "",
          comma = token.length > 0 && token[token.length - 1].charAt(token[token.length - 1].length - 1) === ",",
          linev = spacer(false);
        //this loop accounts for grouping mechanisms
        for (aa = a; aa < len; aa += 1) {
          out.push(b[aa]);
          if (block === "") {
            if (b[aa] === "\"") {
              block = "\"";
              bb += 1;
            } else if (b[aa] === "'") {
              block = "'";
              bb += 1;
            } else if (b[aa] === "(") {
              block = ")";
              bb += 1;
            } else if (b[aa] === "[") {
              block = "]";
              bb += 1;
            } else if (b[aa] === "#" && b[aa + 1] === "{") {
              block = "}";
              bb += 1;
            }
          } else if (b[aa] === "(" && block === ")" || b[aa] === "[" && block === "]") {
            bb += 1;
          } else if (b[aa] === block) {
            bb -= 1;
            if (bb === 0) {
              block = "";
            }
          }
          if (block === "" && b[aa] !== "\\" && (b[aa + 1] === ";" || b[aa + 1] === ":" || b[aa + 1] === "}" || b[aa + 1] === "{" || b[aa + 1] === "/" && (b[aa + 2] === "*" || b[aa + 2] === "/"))) {
            break;
          }
        }
        a = aa;
        itemsize = out.length;
        if (comma === true && types[types.length - 1] !== "comment" && types[types.length - 1] !== "comment-inline") {
          token[token.length - 1] = token[token.length - 1] + out.join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "");
          return;
        }
        token.push(out.join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, ""));
        lines.push(linev);
        if (token[token.length - 1].indexOf("extend(") === 0) {
          ltype = "pseudo";
          types.push("pseudo");
        } else {
          ltype = "item";
          types.push("item");
        }
      },
      //do fancy things to property types like: sorting,
      //consolidating, and padding
      properties = function csspretty__tokenize_properties() {
        var aa = 0,
          bb = 1,
          cc = 0,
          dd = 0,
          p = [],
          set = [[]],
          next = 0,
          stoke = [],
          stype = [],
          sline = [];
        //identify properties and build out prop/val sets
        for (aa = token.length - 1; aa > -1; aa -= 1) {
          if (types[aa] === "start") {
            bb -= 1;
            if (bb === 0) {
              next = aa;
              set.pop();
              for (aa = set.length - 1; aa > -1; aa -= 1) {
                set[aa].reverse();
              }
              break;
            }
          }
          if (types[aa] === "end") {
            bb += 1;
          }
          if (bb === 1 && types[aa] === "property" && options.mode === "beautify") {
            p.push(aa);
          }
          set[set.length - 1].push(aa);
          if (bb === 1 && (types[aa - 1] === "comment" || types[aa - 1] === "comment-inline" || types[aa - 1] === "semi" || types[aa - 1] === "end" || types[aa - 1] === "start") && types[aa] !== "start" && types[aa] !== "end") {
            set.push([]);
          }
        }
        //this reverse fixes the order of consecutive comments
        set.reverse();
        p.reverse();

        //consolidate margin and padding
        (function csspretty__tokenize_properties_propcheck() {
          var leng = set.length,
            fourcount = function csspretty__tokenize_properties_propcheck_fourcount(name) {
              var test = [false, false, false, false],
                value = ["0", "0", "0", "0"],
                zero = /^(0+([a-z]+|%))/,
                start = aa,
                yy = -1,
                zz = 0,
                valsplit = [],
                important = false,
                store = function csspretty__tokenize_properties_propcheck_fourcount_store(side) {
                  yy += 1;
                  value[side] = token[set[aa][2]];
                  test[side] = true;
                  if (start < 0) {
                    start = aa;
                  }
                };
              for (aa = aa; aa < leng; aa += 1) {
                if (token[set[aa][2]] !== undefined && token[set[aa][0]].indexOf(name) === 0) {
                  if (token[set[aa][2]].indexOf("!important") > -1) {
                    important = true;
                    token[set[aa][2]] = token[set[aa][2]].replace(/\s*!important/, "");
                  }
                  if (token[set[aa][0]] === name || token[set[aa][0]].indexOf(name + " ") === 0) {
                    yy += 1;
                    valsplit = token[set[aa][2]].split(" ");
                    if (valsplit.length === 1) {
                      value = [token[set[aa][2]], token[set[aa][2]], token[set[aa][2]], token[set[aa][2]]];
                    } else if (valsplit.length === 2) {
                      value = [valsplit[0], valsplit[1], valsplit[0], valsplit[1]];
                    } else if (valsplit.length === 3) {
                      value = [valsplit[0], valsplit[1], valsplit[2], valsplit[1]];
                    } else if (valsplit.length === 4) {
                      value = [valsplit[0], valsplit[1], valsplit[2], valsplit[3]];
                    } else {
                      return;
                    }
                    test = [true, true, true, true];
                  } else if (token[set[aa][0]].indexOf(name + "-bottom") === 0) {
                    store(2);
                  } else if (token[set[aa][0]].indexOf(name + "-left") === 0) {
                    store(3);
                  } else if (token[set[aa][0]].indexOf(name + "-right") === 0) {
                    store(1);
                  } else if (token[set[aa][0]].indexOf(name + "-top") === 0) {
                    store(0);
                  }
                }
                if (set[aa + 1] === undefined || token[set[aa + 1][0]].indexOf(name) < 0 || aa === leng - 1) {
                  if (test[0] === true && test[1] === true && test[2] === true && test[3] === true) {
                    set.splice(start + 1, yy);
                    leng -= yy;
                    aa -= yy;
                    zz = 0;
                    bb = p.length;
                    do {
                      if (p[zz] === set[start][0]) {
                        break;
                      }
                      zz += 1;
                    } while (zz < bb);
                    if (zz < bb) {
                      p.splice(zz + 1, yy);
                    }
                    token[set[start][0]] = name;
                    if (zero.test(value[0]) === true) {
                      value[0] = "0";
                    }
                    if (zero.test(value[1]) === true) {
                      value[1] = "0";
                    }
                    if (zero.test(value[2]) === true) {
                      value[2] = "0";
                    }
                    if (zero.test(value[3]) === true) {
                      value[3] = "0";
                    }
                    if (value[1] === value[3]) {
                      value.pop();
                      if (value[0] === value[2]) {
                        value.pop();
                        if (value[0] === value[1]) {
                          value.pop();
                        }
                      }
                    }
                    token[set[start][2]] = value.join(" ");
                    if (options.mode === "beautify" && verticalop === true) {
                      if (token[set[start][0]].charAt(token[set[start][0]].length - 1) === " ") {
                        yy = token[set[start][0]].length - name.length;
                        do {
                          name = name + " ";
                          yy -= 1;
                        } while (yy > 0);
                      }
                    }
                  }
                  if (important === true) {
                    token[set[start][2]] = token[set[start][2]] + " !important";
                  }
                  break;
                }
              }
              if (important === true && token[set[aa][2]].indexOf("!important") < 0) {
                token[set[aa][2]] = token[set[aa][2]] + " !important";
              }
            };
          for (aa = 0; aa < leng; aa += 1) {
            if (types[set[aa][0]] === "property") {
              if (token[set[aa][0]].indexOf("margin") === 0) {
                fourcount("margin");
              }
              if (token[set[aa][0]].indexOf("padding") === 0) {
                fourcount("padding");
              }
            }
          }
        })();

        //pad out those property names so that the colons
        //are vertically aligned
        if (verticalop === true) {
          bb = 0;
          for (aa = p.length - 1; aa > -1; aa -= 1) {
            if (token[p[aa]].length > bb && token[p[aa]] !== "filter" && token[p[aa]] !== "progid") {
              bb = token[p[aa]].length;
            }
          }
          for (aa = p.length - 1; aa > -1; aa -= 1) {
            cc = bb - token[p[aa]].length;
            if (cc > 0 && token[p[aa]] !== "filter" && token[p[aa]] !== "progid") {
              do {
                token[p[aa]] = token[p[aa]] + " ";
                cc -= 1;
              } while (cc > 0);
            }
          }
          if (endtest === false) {
            return;
          }
        }
        bb = set.length;
        for (aa = 0; aa < bb; aa += 1) {
          dd = set[aa].length;
          for (cc = 0; cc < dd; cc += 1) {
            stoke.push(token[set[aa][cc]]);
            stype.push(types[set[aa][cc]]);
            sline.push(lines[set[aa][cc]]);
          }
        }
        //replace a block's data with sorted analyzed data
        token.splice(next + 1, token.length - next - 1);
        types.splice(next + 1, types.length - next - 1);
        lines.splice(next + 1, lines.length - next - 1);
        token = token.concat(stoke);
        types = types.concat(stype);
        lines = lines.concat(sline);
      };
    //token building loop
    for (a = 0; a < len; a += 1) {
      if (ltype !== "comment" && ltype !== "comment-inline" && ltype !== "" && options.topcoms === true) {
        options.topcoms = false;
      }
      if (/\s/.test(b[a]) === true) {
        stats.space += 1;
        space += b[a];
      } else if (b[a] === "/" && b[a + 1] === "*") {
        comment(false);
      } else if (b[a] === "/" && b[a + 1] === "/") {
        comment(true);
      } else if (b[a] === "<" && b[a + 1] === "?" && b[a + 2] === "p" && b[a + 3] === "h" && b[a + 4] === "p") {
        //php
        external("<?php", "?>");
      } else if (b[a] === "<" && b[a + 1] === "%") {
        //asp
        external("<%", "%>");
      } else if (b[a] === "{" && b[a + 1] === "%") {
        //asp
        external("{%", "%}");
      } else if (b[a] === "{" && b[a + 1] === "{" && b[a + 2] === "{") {
        //mustache
        external("{{{", "}}}");
      } else if (b[a] === "{" && b[a + 1] === "{") {
        //handlebars
        external("{{", "}}");
      } else if (b[a] === "<" && b[a + 1] === "!" && b[a + 2] === "-" && b[a + 3] === "-" && b[a + 4] === "#") {
        //ssi
        external("<!--#", "-->");
      } else if (b[a] === "{") {
        if (token[token.length - 2] === ":") {
          types[types.length - 1] = "pseudo";
        }
        item("start");
        ltype = "start";
        types.push("start");
        token.push("{");
        nosort.push(false);
        lines.push(spacer(false));
        stats.braces += 1;
        spacecol = false;
      } else if (b[a] === "}") {
        endtest = true;
        if (types[types.length - 1] === "item" && token[token.length - 2] === "{" && token[token.length - 3] !== undefined && token[token.length - 3].charAt(token[token.length - 3].length - 1) === "@") {
          token[token.length - 3] = token[token.length - 3] + "{" + token[token.length - 1] + "}";
          token.pop();
          token.pop();
          types.pop();
          types.pop();
          lines.pop();
          lines.pop();
        } else {
          item("end");
          if (options.mode !== "diff") {
            properties();
          }
          ltype = "end";
          if (objsortop === true && nosort[nosort.length - 1] === false) {
            objSort();
          }
          nosort.pop();
          types.push("end");
          token.push("}");
          lines.push(spacer(false));
          stats.braces += 1;
        }
      } else if (b[a] === ";") {
        item("semi");
        if (types[types.length - 1] !== "semi") {
          ltype = "semi";
          types.push("semi");
          token.push(";");
          lines.push(spacer(false));
        }
        stats.semi += 1;
        space = "";
      } else if (b[a] === ":") {
        item("colon");
        types.push("colon");
        token.push(":");
        lines.push(0);
        ltype = "colon";
        stats.colon += 1;
        space = "";
        if (/\s/.test(b[a - 1]) === true) {
          spacecol = true;
        } else if (b[a - 1] !== ":") {
          spacecol = false;
        }
      } else {
        buildtoken();
      }
    }
    if (endtest === false && verticalop === true) {
      properties();
    }
  })();
  if (options.mode === "parse") {
    return {
      token: token,
      types: types
    };
  }

  //beautification
  if (options.mode !== "minify") {
    output = function csspretty__beautify() {
      var a = 0,
        len = token.length,
        build = [],
        indent = options.inlevel,
        mixin = false,
        //a single unit of indentation
        tab = function csspretty__beautify_tab() {
          var aa = 0,
            bb = [];
          for (aa = 0; aa < options.insize; aa += 1) {
            bb.push(options.inchar);
          }
          return bb.join("");
        }(),
        //new lines plus indentation
        nl = function csspretty__beautify_nl(tabs) {
          var aa = 0;
          if (build[build.length - 1] === tab) {
            do {
              build.pop();
            } while (build[build.length - 1] === tab);
          }
          build.push(lf);
          for (aa = 0; aa < tabs; aa += 1) {
            build.push(tab);
          }
        },
        //breaks selector lists onto newlines
        selector = function csspretty__beautify_selector(item) {
          var aa = 0,
            bb = 0,
            cc = 0,
            block = "",
            items = [],
            leng = item.length;
          if (options.compressedcss === true && /\)\s*when\s*\(/.test(item) === true) {
            item = item.replace(/\)\s*when\s*\(/, ")" + lf + function csspretty__beautify_selector_whenTab() {
              var wtab = "",
                aaa = indent + 1;
              do {
                wtab += tab;
                aaa -= 1;
              } while (aaa > 0);
              return wtab;
            }() + "when (");
          }
          for (aa = 0; aa < leng; aa += 1) {
            if (block === "") {
              if (item.charAt(aa) === "\"") {
                block = "\"";
                bb += 1;
              } else if (item.charAt(aa) === "'") {
                block = "'";
                bb += 1;
              } else if (item.charAt(aa) === "(") {
                block = ")";
                bb += 1;
              } else if (item.charAt(aa) === "[") {
                block = "]";
                bb += 1;
              }
            } else if (item.charAt(aa) === "(" && block === ")" || item.charAt(aa) === "[" && block === "]") {
              bb += 1;
            } else if (item.charAt(aa) === block) {
              bb -= 1;
              if (bb === 0) {
                block = "";
              }
            }
            if (block === "" && item.charAt(aa) === ",") {
              items.push(item.substring(cc, aa + 1));
              cc = aa + 1;
            }
          }
          if (cc > 0) {
            items.push(item.substr(cc));
          }
          leng = items.length;
          if (leng === 0) {
            items.push(item);
          }
          if (options.selectorlist === true) {
            build.push(items.join(" "));
          } else {
            build.push(items[0].replace(/,(\s*)/g, ", ").replace(/(,\ )$/, ","));
            for (aa = 1; aa < leng; aa += 1) {
              nl(indent);
              build.push(items[aa].replace(/,(\s*)/g, ", ").replace(/(,\ )$/, ","));
            }
          }
          if (options.compressedcss === false) {
            build.push(" ");
          }
        };
      if (options.inlevel > 0) {
        a = options.inlevel;
        do {
          a -= 1;
          build.push(tab);
        } while (a > 0);
      }

      //beautification loop
      for (a = 0; a < len; a += 1) {
        if (lines[a] > 1 && options.compressedcss === false && (types[a] === "start" || types[a] === "end" || types[a] === "selector" || types[a] === "comment" || types[a] === "property" || types[a].indexOf("external") > -1)) {
          if (options.cssinsertlines === true && types[a] === "selector" && types[a - 1] !== "comment") {
            lines[a] -= 1;
          }
          if (build[build.length - 1] === tab) {
            do {
              build.pop();
            } while (build[build.length - 1] === tab);
          }
          if (lines[a] > 1) {
            if (lines[a] > 2) {
              do {
                lines[a] -= 1;
                build.push(lf);
              } while (lines[a] > 2);
            }
            nl(indent);
          }
        }
        if (types[a] === "start") {
          if (a > 0 && token[a - 1].charAt(token[a - 1].length - 1) === "#") {
            build.push(token[a]);
          } else {
            if (options.braces === true) {
              if (build[build.length - 1] === " ") {
                build.pop();
              }
              nl(indent);
            } else if (types[a - 1] === "colon") {
              build.push(" ");
            }
            build.push(token[a]);
            indent += 1;
            if (types[a + 1] !== "end" && (options.compressedcss === false || options.compressedcss === true && types[a + 1] === "start") && (types[a + 1] !== "selector" || options.cssinsertlines === false)) {
              nl(indent);
            }
          }
        } else if (types[a] === "end") {
          if (mixin === true) {
            mixin = false;
            build.push(token[a]);
            build.push(" ");
          } else {
            indent -= 1;
            if (types[a - 1] !== "start" && options.compressedcss === false) {
              nl(indent);
            }
            build.push(token[a]);
            if (options.compressedcss === true && types[a + 1] === "end") {
              nl(indent - 1);
            } else if (options.cssinsertlines === true && types[a + 1] === "selector" && lines[a] < 2 && token[a - 1] !== "{") {
              build.push(lf);
            } else if (types[a + 1] !== "end" && types[a + 1] !== "semi" && types[a + 1] !== "comment") {
              nl(indent);
            }
          }
        } else if (types[a] === "semi") {
          if (token[a] !== "x;" && (options.compressedcss === false || options.compressedcss === true && types[a + 1] !== "end")) {
            build.push(token[a]);
          }
          if (types[a + 1] === "comment-inline") {
            build.push(" ");
          } else if (types[a + 1] !== "end" && types[a + 1] !== "comment" && options.compressedcss === false) {
            if (options.cssinsertlines === true && types[a + 1] === "selector") {
              build.push(lf);
            } else {
              nl(indent);
            }
          }
        } else if (types[a] === "selector") {
          if (a > 0 && types[a - 1] !== "comment" && (options.cssinsertlines === true || options.compressedcss === true && (types[a - 1] === "start" || types[a - 1] === "semi"))) {
            nl(indent);
          }
          if (token[a].charAt(token[a].length - 1) === "#") {
            build.push(token[a]);
            mixin = true;
          } else if (token[a].indexOf(",") > -1) {
            selector(token[a]);
          } else {
            if (token[a].charAt(0) === ":" && token[a - 1] === "}" && build[build.length - 1] === " ") {
              build.pop();
            }
            build.push(token[a]);
            if (options.compressedcss === false) {
              build.push(" ");
            }
          }
        } else if ((types[a] === "comment" || types[a] === "comment-inline") && types[a - 1] !== "colon" && types[a - 1] !== "property") {
          if (a > 0 && options.compressedcss === true && types[a] === "comment" && types[a - 1] !== "comment") {
            build.push(lf);
            nl(indent);
          } else if (a > 0 && types[a - 1] !== "start" && types[a] !== "comment-inline") {
            nl(indent);
          }
          build.push(token[a]);
          if (types[a + 1] !== "end" && types[a + 1] !== "comment") {
            nl(indent);
          }
        } else {
          if ((types[a] === "value" || types[a].indexOf("external") > -1 && types[a - 1] === "colon") && types[a - 1] !== "semi" && options.compressedcss === false && (mixin === false || token[a - 1] === ":") && token[a - 2] !== "filter" && token[a - 2] !== "progid") {
            build.push(" ");
          }
          if (types[a] === "external_start" && types[a + 1] !== "selector") {
            indent += 1;
          } else if (types[a] === "external_end" && (types[a + 1] === "end" || types[a + 1] === "external_end")) {
            indent -= 1;
            if (build[build.length - 1] === tab && types[a - 1] === "end") {
              build.pop();
            }
          } else if (types[a] === "external_else" && build[build.length - 1] === tab) {
            build.pop();
          }
          build.push(token[a]);
          if (types[a].indexOf("external") > -1 && types[a + 1] !== "semi") {
            if (lines[a + 1] < 0 || types[a + 1] === "selector" || types[a + 1] !== undefined && lines[a + 1] > 0 && types[a + 1].indexOf("external") > -1) {
              if (types[a] === "external_end") {
                nl(indent - 1);
              } else {
                nl(indent);
              }
            }
          }
        }
      }
      if (options.preserve > 0 && (lines[lines.length - 1] > 0 || endline === true)) {
        return build.join("").replace(/(\s+)$/, lf);
      }
      return build.join("").replace(/(\s+)$/, "");
    }();
  } else {
    output = token.join("").replace(/;\}/g, "}");
  }
  //summary
  if (options.mode === "beautify") {
    (function csspretty__summary() {
      var summ = [],
        inl = options.source.length,
        out = output.length,
        uris = uri.length,
        uric = 0,
        a = 0,
        b = 0,
        color = [];
      (function csspretty_summary_colorNormalize() {
        var aa = 0,
          bb = 0,
          cc = colors.length;
        colors.sort();
        color.push(colors[0]);
        for (aa = 0; aa < cc; aa += 1) {
          if (colors[aa] !== color[bb]) {
            color.push(colors[aa]);
            bb += 1;
          }
        }
      })();
      summ.push("<div class='report' id='cssreport'><p><strong>Number of HTTP requests:</strong> <em" + ">");
      summ.push(uris);
      summ.push("</em></p><table class='analysis' id='css-parts' summary='Component counts and si" + "zes'><caption>Component counts and sizes</caption><thead><tr><th>Type Name</th><" + "th>Quantity</th><th>Character Size</th></tr></thead><tbody><tr><th>curly braces<" + "/th><td>");
      summ.push(stats.braces);
      summ.push("</td><td>");
      summ.push(stats.braces);
      summ.push("</td></tr><tr><th>colon</th><td>");
      summ.push(stats.colon);
      summ.push("</td><td>");
      summ.push(stats.colon);
      summ.push("</td></tr><tr><th>comments</th><td>");
      summ.push(stats.comments.count);
      summ.push("</td><td>");
      summ.push(stats.comments.chars);
      summ.push("</td></tr><tr><th>properties</th><td>");
      summ.push(stats.properties.count);
      summ.push("</td><td>");
      summ.push(stats.properties.chars);
      summ.push("</td></tr><tr><th>selectors</th><td>");
      summ.push(stats.selectors.count);
      summ.push("</td><td>");
      summ.push(stats.selectors.chars);
      summ.push("</td></tr><tr><th>semicolons</th><td>");
      summ.push(stats.semi);
      summ.push("</td><td>");
      summ.push(stats.semi);
      summ.push("</td></tr><tr><th>white space</th><td>");
      summ.push(stats.space);
      summ.push("</td><td>");
      summ.push(stats.space);
      summ.push("</td></tr><tr><th>values</th><td>");
      summ.push(stats.values.count);
      summ.push("</td><td>");
      summ.push(stats.values.chars);
      summ.push("</td></tr><tr><th>variables</th><td>");
      summ.push(stats.variables.count);
      summ.push("</td><td>");
      summ.push(stats.variables.chars);
      summ.push("</td></tr></tbody></table><table class='analysis' id='css-size' summary='CSS cha" + "racter size change'><caption>CSS character size change</caption><tbody><tr><th>I" + "nput</th><td>");
      summ.push(inl);
      summ.push("</td></tr><tr><th>Output</th><td>");
      summ.push(out);
      summ.push("</td></tr><tr><th>");
      if (out > inl) {
        summ.push("Increase</th><td>");
        summ.push(out - inl);
        summ.push("</td></tr><tr><th>Percent Change</th><td>");
        a = (out - inl) / out * 100;
        summ.push(a.toFixed(2));
      } else {
        summ.push("Decrease</th><td>");
        summ.push(inl - out);
        summ.push("</td></tr><tr><th>Percent Change</th><td>");
        a = (inl - out) / inl * 100;
        summ.push(a.toFixed(2));
      }
      summ.push("%</td></tr></tbody></table><table class='analysis' id='css-uri' summary='A list " + "of HTTP requests'><caption>A List of HTTP Requests</caption><thead><tr><th>Quant" + "ity</th><th>URI</th></tr></thead><tbody>");
      for (a = 0; a < uris; a += 1) {
        uric = 1;
        for (b = a + 1; b < uris; b += 1) {
          if (uri[a] === uri[b]) {
            uric += 1;
            uri.splice(b, 1);
            uris -= 1;
          }
        }
        summ.push("<tr><td>");
        summ.push(uric);
        summ.push("</td><td>");
        summ.push(uri[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"));
        summ.push("</td></tr>");
      }
      summ.push("</tbody></table>");
      summ.push("</div><span class='clear'></span>");
      if (color.length === 0) {
        summ.push("<h4>0 colors were identified in the provided code.</h4>");
      } else {
        summ.push("<h4>These ");
        summ.push(color.length);
        if (color.length > 1) {
          summ.push(" different");
        }
        summ.push(" color");
        if (color.length > 1) {
          summ.push("s");
        }
        summ.push(" were identified in the provided code:</h4><p>");
        summ.push(color.join(", "));
        summ.push("</p>");
        if (options.accessibility === true) {
          (function csspretty__summary_colorConvert() {
            var vl = "",
              bb = color.length,
              aa = 0,
              luminance = function csspretty__summary_colorConvert_luminance(rgb) {
                var convert = function csspretty__summary_colorConvert_luminance_convert(x) {
                  if (x === 0) {
                    return 0;
                  }
                  x = x / 255;
                  if (x * 100000 <= 3928) {
                    return x * 100 / 1292 * 10000;
                  }
                  x *= 100000;
                  return Math.pow((x + 5500) / 105500, 2.4) * 10000;
                };
                return (2126 * convert(rgb[0]) + 7152 * convert(rgb[1]) + 722 * convert(rgb[2])) / 100000000;
              },
              hexToDec = function csspretty__summary_colorConvert_hexToDec(val) {
                var str = val.slice(1).split(""),
                  rgb = [],
                  num = [],
                  aaa = 0,
                  bbb = str.length;
                for (aaa = 0; aaa < bbb; aaa += 1) {
                  if (str[aaa] === "a") {
                    num.push(10);
                  } else if (str[aaa] === "b") {
                    num.push(11);
                  } else if (str[aaa] === "c") {
                    num.push(12);
                  } else if (str[aaa] === "d") {
                    num.push(13);
                  } else if (str[aaa] === "e") {
                    num.push(14);
                  } else if (str[aaa] === "f") {
                    num.push(15);
                  } else {
                    num.push(Number(str[aaa]));
                  }
                }
                if (bbb === 3) {
                  rgb.push(num[0] * 16 + num[0]);
                  rgb.push(num[1] * 16 + num[1]);
                  rgb.push(num[2] * 16 + num[2]);
                } else {
                  rgb.push(num[0] * 16 + num[1]);
                  rgb.push(num[2] * 16 + num[3]);
                  rgb.push(num[4] * 16 + num[5]);
                }
                return luminance(rgb);
              },
              rgbToDec = function csspretty__summary_colorConvert_rgbToDec(val) {
                var rgb = [],
                  rgbs = [],
                  rr = 0;
                if (vl.charAt(3) === "a") {
                  vl = vl.slice(5, vl.length - 1).replace(/\s+/g, "");
                  rgbs = vl.split(",");
                  rgbs.pop();
                } else {
                  vl = vl.slice(4, vl.length - 1).replace(/\s+/g, "");
                  rgbs = vl.split(",");
                }
                do {
                  if (/^([0-9a-f]{2})$/.test(rgbs[rr]) === false) {
                    if (rgbs[rr].charAt(rgbs[rr].length - 1) === "%") {
                      vl = rgbs[rr].slice(0, rgbs[rr].length - 1);
                      if (isNaN(vl) === true) {
                        return val;
                      }
                      rgb.push(Number(vl));
                      if (rgb[rr] < 0) {
                        rgb[rr] = 0;
                      } else if (rgb[rr] > 100) {
                        rgb[rr] = 100;
                      }
                      rgb[rr] = Math.round(2.55 * rgb[rr]);
                    } else {
                      if (isNaN(rgbs[rr]) === true) {
                        return val;
                      }
                      rgb.push(Number(rgbs[rr]));
                      if (rgb[rr] < 0) {
                        rgb[rr] = 0;
                      } else if (rgb[rr] > 255) {
                        rgb[rr] = 255;
                      }
                      rgb[rr] = Math.round(rgb[rr]);
                    }
                  }
                  rr += 1;
                } while (rr < 3);
                return luminance(rgb);
              };
            colors = [];
            for (aa = 0; aa < bb; aa += 1) {
              if (color[aa] === undefined) {
                break;
              }
              vl = color[aa].toLowerCase();
              if (/^(#[0-9a-f]{3,6})$/.test(vl) === true) {
                colors.push(hexToDec(vl.slice(1)));
              } else if (/^(rgba?\()/.test(vl) === true) {
                colors.push(rgbToDec(vl));
              } else if (colorNames[vl] !== undefined) {
                colors.push(colorNames[vl]);
              }
            }
          })();
        }
      }
      __webpack_require__.g.report = summ.join("");
    })();
  } else {
    __webpack_require__.g.report = "";
  }
  return output;
};
if (true) {
  //commonjs and nodejs support
  __webpack_unused_export__ = function commonjs(x) {
    "use strict";

    return csspretty(x);
  };
} else {}

/***/ }),

/***/ "./scripts/3rdparty/jquery-ui.js":
/*!***************************************!*\
  !*** ./scripts/3rdparty/jquery-ui.js ***!
  \***************************************/
/***/ (() => {

/*! jQuery UI - v1.12.1 - 2017-07-08
* http://jqueryui.com
* Includes: widget.js, data.js, disable-selection.js, scroll-parent.js, widgets/draggable.js, widgets/resizable.js, widgets/mouse.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function (factory) {
  // if ( typeof define === "function" && define.amd ) {

  // 	// AMD. Register as an anonymous module.
  // 	define([ "jquery" ], factory );
  // } else {

  // Browser globals
  factory(jQuery);
  // }
})(function ($) {
  $.ui = $.ui || {};
  var version = $.ui.version = "1.12.1";

  /*!
   * jQuery UI Widget 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: Widget
  //>>group: Core
  //>>description: Provides a factory for creating stateful widgets with a common API.
  //>>docs: http://api.jqueryui.com/jQuery.widget/
  //>>demos: http://jqueryui.com/widget/

  var widgetUuid = 0;
  var widgetSlice = Array.prototype.slice;
  $.cleanData = function (orig) {
    return function (elems) {
      var events, elem, i;
      for (i = 0; (elem = elems[i]) != null; i++) {
        try {
          // Only trigger remove when necessary to save time
          events = $._data(elem, "events");
          if (events && events.remove) {
            $(elem).triggerHandler("remove");
          }

          // Http://bugs.jquery.com/ticket/8235
        } catch (e) {}
      }
      orig(elems);
    };
  }($.cleanData);
  $.widget = function (name, base, prototype) {
    var existingConstructor, constructor, basePrototype;

    // ProxiedPrototype allows the provided prototype to remain unmodified
    // so that it can be used as a mixin for multiple widgets (#8876)
    var proxiedPrototype = {};
    var namespace = name.split(".")[0];
    name = name.split(".")[1];
    var fullName = namespace + "-" + name;
    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }
    if ($.isArray(prototype)) {
      prototype = $.extend.apply(null, [{}].concat(prototype));
    }

    // Create selector for plugin
    $.expr[":"][fullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };
    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function (options, element) {
      // Allow instantiation without "new" keyword
      if (!this._createWidget) {
        return new constructor(options, element);
      }

      // Allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };

    // Extend with the existing constructor to carry over any static properties
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      // Copy the object used to create the prototype in case we need to
      // redefine the widget later
      _proto: $.extend({}, prototype),
      // Track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: []
    });
    basePrototype = new base();

    // We need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function (prop, value) {
      if (!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = function () {
        function _super() {
          return base.prototype[prop].apply(this, arguments);
        }
        function _superApply(args) {
          return base.prototype[prop].apply(this, args);
        }
        return function () {
          var __super = this._super;
          var __superApply = this._superApply;
          var returnValue;
          this._super = _super;
          this._superApply = _superApply;
          returnValue = value.apply(this, arguments);
          this._super = __super;
          this._superApply = __superApply;
          return returnValue;
        };
      }();
    });
    constructor.prototype = $.widget.extend(basePrototype, {
      // TODO: remove support for widgetEventPrefix
      // always use the name + a colon as the prefix, e.g., draggable:start
      // don't prefix for widgets that aren't DOM-based
      widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
    }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });

    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function (i, child) {
        var childPrototype = child.prototype;

        // Redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
      });

      // Remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }
    $.widget.bridge(name, constructor);
    return constructor;
  };
  $.widget.extend = function (target) {
    var input = widgetSlice.call(arguments, 1);
    var inputIndex = 0;
    var inputLength = input.length;
    var key;
    var value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
          // Clone objects
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) :
            // Don't extend strings, arrays, etc. with objects
            $.widget.extend({}, value);

            // Copy everything else by reference
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };
  $.widget.bridge = function (name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function (options) {
      var isMethodCall = typeof options === "string";
      var args = widgetSlice.call(arguments, 1);
      var returnValue = this;
      if (isMethodCall) {
        // If this is an empty collection, we need to have the instance method
        // return undefined instead of the jQuery instance
        if (!this.length && options === "instance") {
          returnValue = undefined;
        } else {
          this.each(function () {
            var methodValue;
            var instance = $.data(this, fullName);
            if (options === "instance") {
              returnValue = instance;
              return false;
            }
            if (!instance) {
              return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
            }
            if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
              return $.error("no such method '" + options + "' for " + name + " widget instance");
            }
            methodValue = instance[options].apply(instance, args);
            if (methodValue !== instance && methodValue !== undefined) {
              returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
              return false;
            }
          });
        }
      } else {
        // Allow multiple hashes to be passed on init
        if (args.length) {
          options = $.widget.extend.apply(null, [options].concat(args));
        }
        this.each(function () {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {});
            if (instance._init) {
              instance._init();
            }
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }
      return returnValue;
    };
  };
  $.Widget = function /* options, element */ () {};
  $.Widget._childConstructors = [];
  $.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
      classes: {},
      disabled: false,
      // Callbacks
      create: null
    },
    _createWidget: function (options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = widgetUuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;
      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      this.classesElementLookup = {};
      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function (event) {
            if (event.target === element) {
              this.destroy();
            }
          }
        });
        this.document = $(element.style ?
        // Element within the document
        element.ownerDocument :
        // Element is window or document
        element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }
      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
      this._create();
      if (this.options.disabled) {
        this._setOptionDisabled(this.options.disabled);
      }
      this._trigger("create", null, this._getCreateEventData());
      this._init();
    },
    _getCreateOptions: function () {
      return {};
    },
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,
    destroy: function () {
      var that = this;
      this._destroy();
      $.each(this.classesElementLookup, function (key, value) {
        that._removeClass(value, key);
      });

      // We can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element.off(this.eventNamespace).removeData(this.widgetFullName);
      this.widget().off(this.eventNamespace).removeAttr("aria-disabled");

      // Clean up events and states
      this.bindings.off(this.eventNamespace);
    },
    _destroy: $.noop,
    widget: function () {
      return this.element;
    },
    option: function (key, value) {
      var options = key;
      var parts;
      var curOption;
      var i;
      if (arguments.length === 0) {
        // Don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }
      if (typeof key === "string") {
        // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split(".");
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }
      this._setOptions(options);
      return this;
    },
    _setOptions: function (options) {
      var key;
      for (key in options) {
        this._setOption(key, options[key]);
      }
      return this;
    },
    _setOption: function (key, value) {
      if (key === "classes") {
        this._setOptionClasses(value);
      }
      this.options[key] = value;
      if (key === "disabled") {
        this._setOptionDisabled(value);
      }
      return this;
    },
    _setOptionClasses: function (value) {
      var classKey, elements, currentElements;
      for (classKey in value) {
        currentElements = this.classesElementLookup[classKey];
        if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {
          continue;
        }

        // We are doing this to create a new jQuery object because the _removeClass() call
        // on the next line is going to destroy the reference to the current elements being
        // tracked. We need to save a copy of this collection so that we can add the new classes
        // below.
        elements = $(currentElements.get());
        this._removeClass(currentElements, classKey);

        // We don't use _addClass() here, because that uses this.options.classes
        // for generating the string of classes. We want to use the value passed in from
        // _setOption(), this is the new value of the classes option which was passed to
        // _setOption(). We pass this value directly to _classes().
        elements.addClass(this._classes({
          element: elements,
          keys: classKey,
          classes: value,
          add: true
        }));
      }
    },
    _setOptionDisabled: function (value) {
      this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value);

      // If the widget is becoming disabled, then nothing is interactive
      if (value) {
        this._removeClass(this.hoverable, null, "ui-state-hover");
        this._removeClass(this.focusable, null, "ui-state-focus");
      }
    },
    enable: function () {
      return this._setOptions({
        disabled: false
      });
    },
    disable: function () {
      return this._setOptions({
        disabled: true
      });
    },
    _classes: function (options) {
      var full = [];
      var that = this;
      options = $.extend({
        element: this.element,
        classes: this.options.classes || {}
      }, options);
      function processClassString(classes, checkOption) {
        var current, i;
        for (i = 0; i < classes.length; i++) {
          current = that.classesElementLookup[classes[i]] || $();
          if (options.add) {
            current = $($.unique(current.get().concat(options.element.get())));
          } else {
            current = $(current.not(options.element).get());
          }
          that.classesElementLookup[classes[i]] = current;
          full.push(classes[i]);
          if (checkOption && options.classes[classes[i]]) {
            full.push(options.classes[classes[i]]);
          }
        }
      }
      this._on(options.element, {
        "remove": "_untrackClassesElement"
      });
      if (options.keys) {
        processClassString(options.keys.match(/\S+/g) || [], true);
      }
      if (options.extra) {
        processClassString(options.extra.match(/\S+/g) || []);
      }
      return full.join(" ");
    },
    _untrackClassesElement: function (event) {
      var that = this;
      $.each(that.classesElementLookup, function (key, value) {
        if ($.inArray(event.target, value) !== -1) {
          that.classesElementLookup[key] = $(value.not(event.target).get());
        }
      });
    },
    _removeClass: function (element, keys, extra) {
      return this._toggleClass(element, keys, extra, false);
    },
    _addClass: function (element, keys, extra) {
      return this._toggleClass(element, keys, extra, true);
    },
    _toggleClass: function (element, keys, extra, add) {
      add = typeof add === "boolean" ? add : extra;
      var shift = typeof element === "string" || element === null,
        options = {
          extra: shift ? keys : extra,
          keys: shift ? element : keys,
          element: shift ? this.element : element,
          add: add
        };
      options.element.toggleClass(this._classes(options), add);
      return this;
    },
    _on: function (suppressDisabledCheck, element, handlers) {
      var delegateElement;
      var instance = this;

      // No suppressDisabledCheck flag, shuffle arguments
      if (typeof suppressDisabledCheck !== "boolean") {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }

      // No element argument, shuffle and use this.element
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }
      $.each(handlers, function (event, handler) {
        function handlerProxy() {
          // Allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
            return;
          }
          return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
        }

        // Copy the guid so direct unbinding works
        if (typeof handler !== "string") {
          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
        }
        var match = event.match(/^([\w:-]*)\s*(.*)$/);
        var eventName = match[1] + instance.eventNamespace;
        var selector = match[2];
        if (selector) {
          delegateElement.on(eventName, selector, handlerProxy);
        } else {
          element.on(eventName, handlerProxy);
        }
      });
    },
    _off: function (element, eventName) {
      eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
      element.off(eventName).off(eventName);

      // Clear the stack to avoid memory leaks (#10056)
      this.bindings = $(this.bindings.not(element).get());
      this.focusable = $(this.focusable.not(element).get());
      this.hoverable = $(this.hoverable.not(element).get());
    },
    _delay: function (handler, delay) {
      function handlerProxy() {
        return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },
    _hoverable: function (element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function (event) {
          this._addClass($(event.currentTarget), null, "ui-state-hover");
        },
        mouseleave: function (event) {
          this._removeClass($(event.currentTarget), null, "ui-state-hover");
        }
      });
    },
    _focusable: function (element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function (event) {
          this._addClass($(event.currentTarget), null, "ui-state-focus");
        },
        focusout: function (event) {
          this._removeClass($(event.currentTarget), null, "ui-state-focus");
        }
      });
    },
    _trigger: function (type, event, data) {
      var prop, orig;
      var callback = this.options[type];
      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();

      // The original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[0];

      // Copy original event properties over to the new event
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }
      this.element.trigger(event, data);
      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
    }
  };
  $.each({
    show: "fadeIn",
    hide: "fadeOut"
  }, function (method, defaultEffect) {
    $.Widget.prototype["_" + method] = function (element, options, callback) {
      if (typeof options === "string") {
        options = {
          effect: options
        };
      }
      var hasOptions;
      var effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
      options = options || {};
      if (typeof options === "number") {
        options = {
          duration: options
        };
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function (next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });
  var widget = $.widget;

  /*!
   * jQuery UI :data 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: :data Selector
  //>>group: Core
  //>>description: Selects elements which have data stored under the specified key.
  //>>docs: http://api.jqueryui.com/data-selector/

  var data = $.extend($.expr[":"], {
    data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
      return function (elem) {
        return !!$.data(elem, dataName);
      };
    }) :
    // Support: jQuery <1.8
    function (elem, i, match) {
      return !!$.data(elem, match[3]);
    }
  });

  /*!
   * jQuery UI Disable Selection 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: disableSelection
  //>>group: Core
  //>>description: Disable selection of text content within the set of matched elements.
  //>>docs: http://api.jqueryui.com/disableSelection/

  // This file is deprecated

  var disableSelection = $.fn.extend({
    disableSelection: function () {
      var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
      return function () {
        return this.on(eventType + ".ui-disableSelection", function (event) {
          event.preventDefault();
        });
      };
    }(),
    enableSelection: function () {
      return this.off(".ui-disableSelection");
    }
  });

  /*!
   * jQuery UI Scroll Parent 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: scrollParent
  //>>group: Core
  //>>description: Get the closest ancestor element that is scrollable.
  //>>docs: http://api.jqueryui.com/scrollParent/

  var scrollParent = $.fn.scrollParent = function (includeHidden) {
    var position = this.css("position"),
      excludeStaticParent = position === "absolute",
      overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
      scrollParent = this.parents().filter(function () {
        var parent = $(this);
        if (excludeStaticParent && parent.css("position") === "static") {
          return false;
        }
        return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
      }).eq(0);
    return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
  };

  // This file is deprecated
  var ie = $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

  /*!
   * jQuery UI Mouse 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: Mouse
  //>>group: Widgets
  //>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
  //>>docs: http://api.jqueryui.com/mouse/

  var mouseHandled = false;
  $(document).on("mouseup", function () {
    mouseHandled = false;
  });
  var widgetsMouse = $.widget("ui.mouse", {
    version: "1.12.1",
    options: {
      cancel: "input, textarea, button, select, option",
      distance: 1,
      delay: 0
    },
    _mouseInit: function () {
      var that = this;
      this.element.on("mousedown." + this.widgetName, function (event) {
        return that._mouseDown(event);
      }).on("click." + this.widgetName, function (event) {
        if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
          $.removeData(event.target, that.widgetName + ".preventClickEvent");
          event.stopImmediatePropagation();
          return false;
        }
      });
      this.started = false;
    },
    // TODO: make sure destroying one instance of mouse doesn't mess with
    // other instances of mouse
    _mouseDestroy: function () {
      this.element.off("." + this.widgetName);
      if (this._mouseMoveDelegate) {
        this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
      }
    },
    _mouseDown: function (event) {
      // don't let more than one widget handle mouseStart
      if (mouseHandled) {
        return;
      }
      this._mouseMoved = false;

      // We may have missed mouseup (out of window)
      this._mouseStarted && this._mouseUp(event);
      this._mouseDownEvent = event;
      var that = this,
        btnIsLeft = event.which === 1,
        // event.target.nodeName works around a bug in IE 8 with
        // disabled inputs (#7620)
        elIsCancel = typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
      if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
        return true;
      }
      this.mouseDelayMet = !this.options.delay;
      if (!this.mouseDelayMet) {
        this._mouseDelayTimer = setTimeout(function () {
          that.mouseDelayMet = true;
        }, this.options.delay);
      }
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = this._mouseStart(event) !== false;
        if (!this._mouseStarted) {
          event.preventDefault();
          return true;
        }
      }

      // Click event may never have fired (Gecko & Opera)
      if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
        $.removeData(event.target, this.widgetName + ".preventClickEvent");
      }

      // These delegates are required to keep context
      this._mouseMoveDelegate = function (event) {
        return that._mouseMove(event);
      };
      this._mouseUpDelegate = function (event) {
        return that._mouseUp(event);
      };
      this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate);
      event.preventDefault();
      mouseHandled = true;
      return true;
    },
    _mouseMove: function (event) {
      // Only check for mouseups outside the document if you've moved inside the document
      // at least once. This prevents the firing of mouseup in the case of IE<9, which will
      // fire a mousemove event if content is placed under the cursor. See #7778
      // Support: IE <9
      if (this._mouseMoved) {
        // IE mouseup check - mouseup happened when mouse was out of window
        if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
          return this._mouseUp(event);

          // Iframe mouseup check - mouseup occurred in another document
        } else if (!event.which) {
          // Support: Safari <=8 - 9
          // Safari sets which to 0 if you press any of the following keys
          // during a drag (#14461)
          if (event.originalEvent.altKey || event.originalEvent.ctrlKey || event.originalEvent.metaKey || event.originalEvent.shiftKey) {
            this.ignoreMissingWhich = true;
          } else if (!this.ignoreMissingWhich) {
            return this._mouseUp(event);
          }
        }
      }
      if (event.which || event.button) {
        this._mouseMoved = true;
      }
      if (this._mouseStarted) {
        this._mouseDrag(event);
        return event.preventDefault();
      }
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
        this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
      }
      return !this._mouseStarted;
    },
    _mouseUp: function (event) {
      this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
      if (this._mouseStarted) {
        this._mouseStarted = false;
        if (event.target === this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + ".preventClickEvent", true);
        }
        this._mouseStop(event);
      }
      if (this._mouseDelayTimer) {
        clearTimeout(this._mouseDelayTimer);
        delete this._mouseDelayTimer;
      }
      this.ignoreMissingWhich = false;
      mouseHandled = false;
      event.preventDefault();
    },
    _mouseDistanceMet: function (event) {
      return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
    },
    _mouseDelayMet: function /* event */
    () {
      return this.mouseDelayMet;
    },
    // These are placeholder methods, to be overriden by extending plugin
    _mouseStart: function /* event */ () {},
    _mouseDrag: function /* event */ () {},
    _mouseStop: function /* event */ () {},
    _mouseCapture: function /* event */ () {
      return true;
    }
  });

  // $.ui.plugin is deprecated. Use $.widget() extensions instead.
  var plugin = $.ui.plugin = {
    add: function (module, option, set) {
      var i,
        proto = $.ui[module].prototype;
      for (i in set) {
        proto.plugins[i] = proto.plugins[i] || [];
        proto.plugins[i].push([option, set[i]]);
      }
    },
    call: function (instance, name, args, allowDisconnected) {
      var i,
        set = instance.plugins[name];
      if (!set) {
        return;
      }
      if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
        return;
      }
      for (i = 0; i < set.length; i++) {
        if (instance.options[set[i][0]]) {
          set[i][1].apply(instance.element, args);
        }
      }
    }
  };
  var safeActiveElement = $.ui.safeActiveElement = function (document) {
    var activeElement;

    // Support: IE 9 only
    // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
    try {
      activeElement = document.activeElement;
    } catch (error) {
      activeElement = document.body;
    }

    // Support: IE 9 - 11 only
    // IE may return null instead of an element
    // Interestingly, this only seems to occur when NOT in an iframe
    if (!activeElement) {
      activeElement = document.body;
    }

    // Support: IE 11 only
    // IE11 returns a seemingly empty object in some cases when accessing
    // document.activeElement from an <iframe>
    if (!activeElement.nodeName) {
      activeElement = document.body;
    }
    return activeElement;
  };
  var safeBlur = $.ui.safeBlur = function (element) {
    // Support: IE9 - 10 only
    // If the <body> is blurred, IE will switch windows, see #9420
    if (element && element.nodeName.toLowerCase() !== "body") {
      $(element).trigger("blur");
    }
  };

  /*!
   * jQuery UI Draggable 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: Draggable
  //>>group: Interactions
  //>>description: Enables dragging functionality for any element.
  //>>docs: http://api.jqueryui.com/draggable/
  //>>demos: http://jqueryui.com/draggable/
  //>>css.structure: ../../themes/base/draggable.css

  $.widget("ui.draggable", $.ui.mouse, {
    version: "1.12.1",
    widgetEventPrefix: "drag",
    options: {
      addClasses: true,
      appendTo: "parent",
      axis: false,
      connectToSortable: false,
      containment: false,
      cursor: "auto",
      cursorAt: false,
      grid: false,
      handle: false,
      helper: "original",
      iframeFix: false,
      opacity: false,
      refreshPositions: false,
      revert: false,
      revertDuration: 500,
      scope: "default",
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      snap: false,
      snapMode: "both",
      snapTolerance: 20,
      stack: false,
      zIndex: false,
      // Callbacks
      drag: null,
      start: null,
      stop: null
    },
    _create: function () {
      if (this.options.helper === "original") {
        this._setPositionRelative();
      }
      if (this.options.addClasses) {
        this._addClass("ui-draggable");
      }
      this._setHandleClassName();
      this._mouseInit();
    },
    _setOption: function (key, value) {
      this._super(key, value);
      if (key === "handle") {
        this._removeHandleClassName();
        this._setHandleClassName();
      }
    },
    _destroy: function () {
      if ((this.helper || this.element).is(".ui-draggable-dragging")) {
        this.destroyOnClear = true;
        return;
      }
      this._removeHandleClassName();
      this._mouseDestroy();
    },
    _mouseCapture: function (event) {
      var o = this.options;

      // Among others, prevent a drag on a resizable-handle
      if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
        return false;
      }

      //Quit if we're not on a valid handle
      this.handle = this._getHandle(event);
      if (!this.handle) {
        return false;
      }
      this._blurActiveElement(event);
      this._blockFrames(o.iframeFix === true ? "iframe" : o.iframeFix);
      return true;
    },
    _blockFrames: function (selector) {
      this.iframeBlocks = this.document.find(selector).map(function () {
        var iframe = $(this);
        return $("<div>").css("position", "absolute").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0];
      });
    },
    _unblockFrames: function () {
      if (this.iframeBlocks) {
        this.iframeBlocks.remove();
        delete this.iframeBlocks;
      }
    },
    _blurActiveElement: function (event) {
      var activeElement = $.ui.safeActiveElement(this.document[0]),
        target = $(event.target);

      // Don't blur if the event occurred on an element that is within
      // the currently focused element
      // See #10527, #12472
      if (target.closest(activeElement).length) {
        return;
      }

      // Blur any element that currently has focus, see #4261
      $.ui.safeBlur(activeElement);
    },
    _mouseStart: function (event) {
      var o = this.options;

      //Create and append the visible helper
      this.helper = this._createHelper(event);
      this._addClass(this.helper, "ui-draggable-dragging");

      //Cache the helper size
      this._cacheHelperProportions();

      //If ddmanager is used for droppables, set the global draggable
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }

      /*
       * - Position generation -
       * This block generates everything position related - it's the core of draggables.
       */

      //Cache the margins of the original element
      this._cacheMargins();

      //Store the helper's css position
      this.cssPosition = this.helper.css("position");
      this.scrollParent = this.helper.scrollParent(true);
      this.offsetParent = this.helper.offsetParent();
      this.hasFixedAncestor = this.helper.parents().filter(function () {
        return $(this).css("position") === "fixed";
      }).length > 0;

      //The element's absolute position on the page minus margins
      this.positionAbs = this.element.offset();
      this._refreshOffsets(event);

      //Generate the original position
      this.originalPosition = this.position = this._generatePosition(event, false);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;

      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);

      //Set a containment if given in the options
      this._setContainment();

      //Trigger event + callbacks
      if (this._trigger("start", event) === false) {
        this._clear();
        return false;
      }

      //Recache the helper size
      this._cacheHelperProportions();

      //Prepare the droppable offsets
      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }

      // Execute the drag once - this causes the helper not to be visible before getting its
      // correct position
      this._mouseDrag(event, true);

      // If the ddmanager is used for droppables, inform the manager that dragging has started
      // (see #5003)
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStart(this, event);
      }
      return true;
    },
    _refreshOffsets: function (event) {
      this.offset = {
        top: this.positionAbs.top - this.margins.top,
        left: this.positionAbs.left - this.margins.left,
        scroll: false,
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      };
      this.offset.click = {
        left: event.pageX - this.offset.left,
        top: event.pageY - this.offset.top
      };
    },
    _mouseDrag: function (event, noPropagation) {
      // reset any necessary cached properties (see #5009)
      if (this.hasFixedAncestor) {
        this.offset.parent = this._getParentOffset();
      }

      //Compute the helpers position
      this.position = this._generatePosition(event, true);
      this.positionAbs = this._convertPositionTo("absolute");

      //Call plugins and callbacks and use the resulting position if something is returned
      if (!noPropagation) {
        var ui = this._uiHash();
        if (this._trigger("drag", event, ui) === false) {
          this._mouseUp(new $.Event("mouseup", event));
          return false;
        }
        this.position = ui.position;
      }
      this.helper[0].style.left = this.position.left + "px";
      this.helper[0].style.top = this.position.top + "px";
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }
      return false;
    },
    _mouseStop: function (event) {
      //If we are using droppables, inform the manager about the drop
      var that = this,
        dropped = false;
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        dropped = $.ui.ddmanager.drop(this, event);
      }

      //if a drop comes from outside (a sortable)
      if (this.dropped) {
        dropped = this.dropped;
        this.dropped = false;
      }
      if (this.options.revert === "invalid" && !dropped || this.options.revert === "valid" && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {
        $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
          if (that._trigger("stop", event) !== false) {
            that._clear();
          }
        });
      } else {
        if (this._trigger("stop", event) !== false) {
          this._clear();
        }
      }
      return false;
    },
    _mouseUp: function (event) {
      this._unblockFrames();

      // If the ddmanager is used for droppables, inform the manager that dragging has stopped
      // (see #5003)
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStop(this, event);
      }

      // Only need to focus if the event occurred on the draggable itself, see #10527
      if (this.handleElement.is(event.target)) {
        // The interaction is over; whether or not the click resulted in a drag,
        // focus the element
        this.element.trigger("focus");
      }
      return $.ui.mouse.prototype._mouseUp.call(this, event);
    },
    cancel: function () {
      if (this.helper.is(".ui-draggable-dragging")) {
        this._mouseUp(new $.Event("mouseup", {
          target: this.element[0]
        }));
      } else {
        this._clear();
      }
      return this;
    },
    _getHandle: function (event) {
      return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
    },
    _setHandleClassName: function () {
      this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;
      this._addClass(this.handleElement, "ui-draggable-handle");
    },
    _removeHandleClassName: function () {
      this._removeClass(this.handleElement, "ui-draggable-handle");
    },
    _createHelper: function (event) {
      var o = this.options,
        helperIsFunction = $.isFunction(o.helper),
        helper = helperIsFunction ? $(o.helper.apply(this.element[0], [event])) : o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element;
      if (!helper.parents("body").length) {
        helper.appendTo(o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo);
      }

      // Http://bugs.jqueryui.com/ticket/9446
      // a helper function can return the original element
      // which wouldn't have been set to relative in _create
      if (helperIsFunction && helper[0] === this.element[0]) {
        this._setPositionRelative();
      }
      if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css("position"))) {
        helper.css("position", "absolute");
      }
      return helper;
    },
    _setPositionRelative: function () {
      if (!/^(?:r|a|f)/.test(this.element.css("position"))) {
        this.element[0].style.position = "relative";
      }
    },
    _adjustOffsetFromHelper: function (obj) {
      if (typeof obj === "string") {
        obj = obj.split(" ");
      }
      if ($.isArray(obj)) {
        obj = {
          left: +obj[0],
          top: +obj[1] || 0
        };
      }
      if ("left" in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ("right" in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ("top" in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ("bottom" in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },
    _isRootNode: function (element) {
      return /(html|body)/i.test(element.tagName) || element === this.document[0];
    },
    _getParentOffset: function () {
      //Get the offsetParent and cache its position
      var po = this.offsetParent.offset(),
        document = this.document[0];

      // This is a special case where we need to modify a offset calculated on start, since the
      // following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the
      // next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
      // the document, which means that the scroll is included in the initial calculation of the
      // offset of the parent, and never recalculated upon drag
      if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }
      if (this._isRootNode(this.offsetParent[0])) {
        po = {
          top: 0,
          left: 0
        };
      }
      return {
        top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
      };
    },
    _getRelativeOffset: function () {
      if (this.cssPosition !== "relative") {
        return {
          top: 0,
          left: 0
        };
      }
      var p = this.element.position(),
        scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
      return {
        top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
        left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
      };
    },
    _cacheMargins: function () {
      this.margins = {
        left: parseInt(this.element.css("marginLeft"), 10) || 0,
        top: parseInt(this.element.css("marginTop"), 10) || 0,
        right: parseInt(this.element.css("marginRight"), 10) || 0,
        bottom: parseInt(this.element.css("marginBottom"), 10) || 0
      };
    },
    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function () {
      var isUserScrollable,
        c,
        ce,
        o = this.options,
        document = this.document[0];
      this.relativeContainer = null;
      if (!o.containment) {
        this.containment = null;
        return;
      }
      if (o.containment === "window") {
        this.containment = [$(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
        return;
      }
      if (o.containment === "document") {
        this.containment = [0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
        return;
      }
      if (o.containment.constructor === Array) {
        this.containment = o.containment;
        return;
      }
      if (o.containment === "parent") {
        o.containment = this.helper[0].parentNode;
      }
      c = $(o.containment);
      ce = c[0];
      if (!ce) {
        return;
      }
      isUserScrollable = /(scroll|auto)/.test(c.css("overflow"));
      this.containment = [(parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom];
      this.relativeContainer = c;
    },
    _convertPositionTo: function (d, pos) {
      if (!pos) {
        pos = this.position;
      }
      var mod = d === "absolute" ? 1 : -1,
        scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
      return {
        top:
        // The absolute mouse position
        pos.top +
        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.top * mod +
        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod,
        left:
        // The absolute mouse position
        pos.left +
        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.left * mod +
        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod
      };
    },
    _generatePosition: function (event, constrainPosition) {
      var containment,
        co,
        top,
        left,
        o = this.options,
        scrollIsRootNode = this._isRootNode(this.scrollParent[0]),
        pageX = event.pageX,
        pageY = event.pageY;

      // Cache the scroll
      if (!scrollIsRootNode || !this.offset.scroll) {
        this.offset.scroll = {
          top: this.scrollParent.scrollTop(),
          left: this.scrollParent.scrollLeft()
        };
      }

      /*
       * - Position constraining -
       * Constrain the position to a mix of grid, containment.
       */

      // If we are not dragging yet, we won't check for options
      if (constrainPosition) {
        if (this.containment) {
          if (this.relativeContainer) {
            co = this.relativeContainer.offset();
            containment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top];
          } else {
            containment = this.containment;
          }
          if (event.pageX - this.offset.click.left < containment[0]) {
            pageX = containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < containment[1]) {
            pageY = containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > containment[2]) {
            pageX = containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > containment[3]) {
            pageY = containment[3] + this.offset.click.top;
          }
        }
        if (o.grid) {
          //Check for grid elements set to 0 to prevent divide by 0 error causing invalid
          // argument errors in IE (see ticket #6950)
          top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
          pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
          left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
          pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
        }
        if (o.axis === "y") {
          pageX = this.originalPageX;
        }
        if (o.axis === "x") {
          pageY = this.originalPageY;
        }
      }
      return {
        top:
        // The absolute mouse position
        pageY -
        // Click offset (relative to the element)
        this.offset.click.top -
        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.top -
        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.top + (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top),
        left:
        // The absolute mouse position
        pageX -
        // Click offset (relative to the element)
        this.offset.click.left -
        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.left -
        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.left + (this.cssPosition === "fixed" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)
      };
    },
    _clear: function () {
      this._removeClass(this.helper, "ui-draggable-dragging");
      if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
        this.helper.remove();
      }
      this.helper = null;
      this.cancelHelperRemoval = false;
      if (this.destroyOnClear) {
        this.destroy();
      }
    },
    // From now on bulk stuff - mainly helpers

    _trigger: function (type, event, ui) {
      ui = ui || this._uiHash();
      $.ui.plugin.call(this, type, [event, ui, this], true);

      // Absolute position and offset (see #6884 ) have to be recalculated after plugins
      if (/^(drag|start|stop)/.test(type)) {
        this.positionAbs = this._convertPositionTo("absolute");
        ui.offset = this.positionAbs;
      }
      return $.Widget.prototype._trigger.call(this, type, event, ui);
    },
    plugins: {},
    _uiHash: function () {
      return {
        helper: this.helper,
        position: this.position,
        originalPosition: this.originalPosition,
        offset: this.positionAbs
      };
    }
  });
  $.ui.plugin.add("draggable", "connectToSortable", {
    start: function (event, ui, draggable) {
      var uiSortable = $.extend({}, ui, {
        item: draggable.element
      });
      draggable.sortables = [];
      $(draggable.options.connectToSortable).each(function () {
        var sortable = $(this).sortable("instance");
        if (sortable && !sortable.options.disabled) {
          draggable.sortables.push(sortable);

          // RefreshPositions is called at drag start to refresh the containerCache
          // which is used in drag. This ensures it's initialized and synchronized
          // with any changes that might have happened on the page since initialization.
          sortable.refreshPositions();
          sortable._trigger("activate", event, uiSortable);
        }
      });
    },
    stop: function (event, ui, draggable) {
      var uiSortable = $.extend({}, ui, {
        item: draggable.element
      });
      draggable.cancelHelperRemoval = false;
      $.each(draggable.sortables, function () {
        var sortable = this;
        if (sortable.isOver) {
          sortable.isOver = 0;

          // Allow this sortable to handle removing the helper
          draggable.cancelHelperRemoval = true;
          sortable.cancelHelperRemoval = false;

          // Use _storedCSS To restore properties in the sortable,
          // as this also handles revert (#9675) since the draggable
          // may have modified them in unexpected ways (#8809)
          sortable._storedCSS = {
            position: sortable.placeholder.css("position"),
            top: sortable.placeholder.css("top"),
            left: sortable.placeholder.css("left")
          };
          sortable._mouseStop(event);

          // Once drag has ended, the sortable should return to using
          // its original helper, not the shared helper from draggable
          sortable.options.helper = sortable.options._helper;
        } else {
          // Prevent this Sortable from removing the helper.
          // However, don't set the draggable to remove the helper
          // either as another connected Sortable may yet handle the removal.
          sortable.cancelHelperRemoval = true;
          sortable._trigger("deactivate", event, uiSortable);
        }
      });
    },
    drag: function (event, ui, draggable) {
      $.each(draggable.sortables, function () {
        var innermostIntersecting = false,
          sortable = this;

        // Copy over variables that sortable's _intersectsWith uses
        sortable.positionAbs = draggable.positionAbs;
        sortable.helperProportions = draggable.helperProportions;
        sortable.offset.click = draggable.offset.click;
        if (sortable._intersectsWith(sortable.containerCache)) {
          innermostIntersecting = true;
          $.each(draggable.sortables, function () {
            // Copy over variables that sortable's _intersectsWith uses
            this.positionAbs = draggable.positionAbs;
            this.helperProportions = draggable.helperProportions;
            this.offset.click = draggable.offset.click;
            if (this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0])) {
              innermostIntersecting = false;
            }
            return innermostIntersecting;
          });
        }
        if (innermostIntersecting) {
          // If it intersects, we use a little isOver variable and set it once,
          // so that the move-in stuff gets fired only once.
          if (!sortable.isOver) {
            sortable.isOver = 1;

            // Store draggable's parent in case we need to reappend to it later.
            draggable._parent = ui.helper.parent();
            sortable.currentItem = ui.helper.appendTo(sortable.element).data("ui-sortable-item", true);

            // Store helper option to later restore it
            sortable.options._helper = sortable.options.helper;
            sortable.options.helper = function () {
              return ui.helper[0];
            };

            // Fire the start events of the sortable with our passed browser event,
            // and our own helper (so it doesn't create a new one)
            event.target = sortable.currentItem[0];
            sortable._mouseCapture(event, true);
            sortable._mouseStart(event, true, true);

            // Because the browser event is way off the new appended portlet,
            // modify necessary variables to reflect the changes
            sortable.offset.click.top = draggable.offset.click.top;
            sortable.offset.click.left = draggable.offset.click.left;
            sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left;
            sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top;
            draggable._trigger("toSortable", event);

            // Inform draggable that the helper is in a valid drop zone,
            // used solely in the revert option to handle "valid/invalid".
            draggable.dropped = sortable.element;

            // Need to refreshPositions of all sortables in the case that
            // adding to one sortable changes the location of the other sortables (#9675)
            $.each(draggable.sortables, function () {
              this.refreshPositions();
            });

            // Hack so receive/update callbacks work (mostly)
            draggable.currentItem = draggable.element;
            sortable.fromOutside = draggable;
          }
          if (sortable.currentItem) {
            sortable._mouseDrag(event);

            // Copy the sortable's position because the draggable's can potentially reflect
            // a relative position, while sortable is always absolute, which the dragged
            // element has now become. (#8809)
            ui.position = sortable.position;
          }
        } else {
          // If it doesn't intersect with the sortable, and it intersected before,
          // we fake the drag stop of the sortable, but make sure it doesn't remove
          // the helper by using cancelHelperRemoval.
          if (sortable.isOver) {
            sortable.isOver = 0;
            sortable.cancelHelperRemoval = true;

            // Calling sortable's mouseStop would trigger a revert,
            // so revert must be temporarily false until after mouseStop is called.
            sortable.options._revert = sortable.options.revert;
            sortable.options.revert = false;
            sortable._trigger("out", event, sortable._uiHash(sortable));
            sortable._mouseStop(event, true);

            // Restore sortable behaviors that were modfied
            // when the draggable entered the sortable area (#9481)
            sortable.options.revert = sortable.options._revert;
            sortable.options.helper = sortable.options._helper;
            if (sortable.placeholder) {
              sortable.placeholder.remove();
            }

            // Restore and recalculate the draggable's offset considering the sortable
            // may have modified them in unexpected ways. (#8809, #10669)
            ui.helper.appendTo(draggable._parent);
            draggable._refreshOffsets(event);
            ui.position = draggable._generatePosition(event, true);
            draggable._trigger("fromSortable", event);

            // Inform draggable that the helper is no longer in a valid drop zone
            draggable.dropped = false;

            // Need to refreshPositions of all sortables just in case removing
            // from one sortable changes the location of other sortables (#9675)
            $.each(draggable.sortables, function () {
              this.refreshPositions();
            });
          }
        }
      });
    }
  });
  $.ui.plugin.add("draggable", "cursor", {
    start: function (event, ui, instance) {
      var t = $("body"),
        o = instance.options;
      if (t.css("cursor")) {
        o._cursor = t.css("cursor");
      }
      t.css("cursor", o.cursor);
    },
    stop: function (event, ui, instance) {
      var o = instance.options;
      if (o._cursor) {
        $("body").css("cursor", o._cursor);
      }
    }
  });
  $.ui.plugin.add("draggable", "opacity", {
    start: function (event, ui, instance) {
      var t = $(ui.helper),
        o = instance.options;
      if (t.css("opacity")) {
        o._opacity = t.css("opacity");
      }
      t.css("opacity", o.opacity);
    },
    stop: function (event, ui, instance) {
      var o = instance.options;
      if (o._opacity) {
        $(ui.helper).css("opacity", o._opacity);
      }
    }
  });
  $.ui.plugin.add("draggable", "scroll", {
    start: function (event, ui, i) {
      if (!i.scrollParentNotHidden) {
        i.scrollParentNotHidden = i.helper.scrollParent(false);
      }
      if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== "HTML") {
        i.overflowOffset = i.scrollParentNotHidden.offset();
      }
    },
    drag: function (event, ui, i) {
      var o = i.options,
        scrolled = false,
        scrollParent = i.scrollParentNotHidden[0],
        document = i.document[0];
      if (scrollParent !== document && scrollParent.tagName !== "HTML") {
        if (!o.axis || o.axis !== "x") {
          if (i.overflowOffset.top + scrollParent.offsetHeight - event.pageY < o.scrollSensitivity) {
            scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
          } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
            scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
          }
        }
        if (!o.axis || o.axis !== "y") {
          if (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity) {
            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
          } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
          }
        }
      } else {
        if (!o.axis || o.axis !== "x") {
          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
          }
        }
        if (!o.axis || o.axis !== "y") {
          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
          }
        }
      }
      if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(i, event);
      }
    }
  });
  $.ui.plugin.add("draggable", "snap", {
    start: function (event, ui, i) {
      var o = i.options;
      i.snapElements = [];
      $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function () {
        var $t = $(this),
          $o = $t.offset();
        if (this !== i.element[0]) {
          i.snapElements.push({
            item: this,
            width: $t.outerWidth(),
            height: $t.outerHeight(),
            top: $o.top,
            left: $o.left
          });
        }
      });
    },
    drag: function (event, ui, inst) {
      var ts,
        bs,
        ls,
        rs,
        l,
        r,
        t,
        b,
        i,
        first,
        o = inst.options,
        d = o.snapTolerance,
        x1 = ui.offset.left,
        x2 = x1 + inst.helperProportions.width,
        y1 = ui.offset.top,
        y2 = y1 + inst.helperProportions.height;
      for (i = inst.snapElements.length - 1; i >= 0; i--) {
        l = inst.snapElements[i].left - inst.margins.left;
        r = l + inst.snapElements[i].width;
        t = inst.snapElements[i].top - inst.margins.top;
        b = t + inst.snapElements[i].height;
        if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
          if (inst.snapElements[i].snapping) {
            inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
              snapItem: inst.snapElements[i].item
            }));
          }
          inst.snapElements[i].snapping = false;
          continue;
        }
        if (o.snapMode !== "inner") {
          ts = Math.abs(t - y2) <= d;
          bs = Math.abs(b - y1) <= d;
          ls = Math.abs(l - x2) <= d;
          rs = Math.abs(r - x1) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo("relative", {
              top: t - inst.helperProportions.height,
              left: 0
            }).top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo("relative", {
              top: b,
              left: 0
            }).top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo("relative", {
              top: 0,
              left: l - inst.helperProportions.width
            }).left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo("relative", {
              top: 0,
              left: r
            }).left;
          }
        }
        first = ts || bs || ls || rs;
        if (o.snapMode !== "outer") {
          ts = Math.abs(t - y1) <= d;
          bs = Math.abs(b - y2) <= d;
          ls = Math.abs(l - x1) <= d;
          rs = Math.abs(r - x2) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo("relative", {
              top: t,
              left: 0
            }).top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo("relative", {
              top: b - inst.helperProportions.height,
              left: 0
            }).top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo("relative", {
              top: 0,
              left: l
            }).left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo("relative", {
              top: 0,
              left: r - inst.helperProportions.width
            }).left;
          }
        }
        if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
          inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
            snapItem: inst.snapElements[i].item
          }));
        }
        inst.snapElements[i].snapping = ts || bs || ls || rs || first;
      }
    }
  });
  $.ui.plugin.add("draggable", "stack", {
    start: function (event, ui, instance) {
      var min,
        o = instance.options,
        group = $.makeArray($(o.stack)).sort(function (a, b) {
          return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
        });
      if (!group.length) {
        return;
      }
      min = parseInt($(group[0]).css("zIndex"), 10) || 0;
      $(group).each(function (i) {
        $(this).css("zIndex", min + i);
      });
      this.css("zIndex", min + group.length);
    }
  });
  $.ui.plugin.add("draggable", "zIndex", {
    start: function (event, ui, instance) {
      var t = $(ui.helper),
        o = instance.options;
      if (t.css("zIndex")) {
        o._zIndex = t.css("zIndex");
      }
      t.css("zIndex", o.zIndex);
    },
    stop: function (event, ui, instance) {
      var o = instance.options;
      if (o._zIndex) {
        $(ui.helper).css("zIndex", o._zIndex);
      }
    }
  });
  var widgetsDraggable = $.ui.draggable;

  /*!
   * jQuery UI Resizable 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  //>>label: Resizable
  //>>group: Interactions
  //>>description: Enables resize functionality for any element.
  //>>docs: http://api.jqueryui.com/resizable/
  //>>demos: http://jqueryui.com/resizable/
  //>>css.structure: ../../themes/base/core.css
  //>>css.structure: ../../themes/base/resizable.css
  //>>css.theme: ../../themes/base/theme.css

  $.widget("ui.resizable", $.ui.mouse, {
    version: "1.12.1",
    widgetEventPrefix: "resize",
    options: {
      alsoResize: false,
      animate: false,
      animateDuration: "slow",
      animateEasing: "swing",
      aspectRatio: false,
      autoHide: false,
      classes: {
        "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
      },
      containment: false,
      ghost: false,
      grid: false,
      handles: "e,s,se",
      helper: false,
      maxHeight: null,
      maxWidth: null,
      minHeight: 10,
      minWidth: 10,
      // See #7960
      zIndex: 90,
      // Callbacks
      resize: null,
      start: null,
      stop: null
    },
    _num: function (value) {
      return parseFloat(value) || 0;
    },
    _isNumber: function (value) {
      return !isNaN(parseFloat(value));
    },
    _hasScroll: function (el, a) {
      if ($(el).css("overflow") === "hidden") {
        return false;
      }
      var scroll = a && a === "left" ? "scrollLeft" : "scrollTop",
        has = false;
      if (el[scroll] > 0) {
        return true;
      }

      // TODO: determine which cases actually cause this to happen
      // if the element doesn't have the scroll set, see if it's possible to
      // set the scroll
      el[scroll] = 1;
      has = el[scroll] > 0;
      el[scroll] = 0;
      return has;
    },
    _create: function () {
      var margins,
        o = this.options,
        that = this;
      this._addClass("ui-resizable");
      $.extend(this, {
        _aspectRatio: !!o.aspectRatio,
        aspectRatio: o.aspectRatio,
        originalElement: this.element,
        _proportionallyResizeElements: [],
        _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
      });

      // Wrap the element if it cannot hold child nodes
      if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
        this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
          position: this.element.css("position"),
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          top: this.element.css("top"),
          left: this.element.css("left")
        }));
        this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance"));
        this.elementIsWrapper = true;
        margins = {
          marginTop: this.originalElement.css("marginTop"),
          marginRight: this.originalElement.css("marginRight"),
          marginBottom: this.originalElement.css("marginBottom"),
          marginLeft: this.originalElement.css("marginLeft")
        };
        this.element.css(margins);
        this.originalElement.css("margin", 0);

        // support: Safari
        // Prevent Safari textarea resize
        this.originalResizeStyle = this.originalElement.css("resize");
        this.originalElement.css("resize", "none");
        this._proportionallyResizeElements.push(this.originalElement.css({
          position: "static",
          zoom: 1,
          display: "block"
        }));

        // Support: IE9
        // avoid IE jump (hard set the margin)
        this.originalElement.css(margins);
        this._proportionallyResize();
      }
      this._setupHandles();
      if (o.autoHide) {
        $(this.element).on("mouseenter", function () {
          if (o.disabled) {
            return;
          }
          that._removeClass("ui-resizable-autohide");
          that._handles.show();
        }).on("mouseleave", function () {
          if (o.disabled) {
            return;
          }
          if (!that.resizing) {
            that._addClass("ui-resizable-autohide");
            that._handles.hide();
          }
        });
      }
      this._mouseInit();
    },
    _destroy: function () {
      this._mouseDestroy();
      var wrapper,
        _destroy = function (exp) {
          $(exp).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove();
        };

      // TODO: Unwrap at same DOM position
      if (this.elementIsWrapper) {
        _destroy(this.element);
        wrapper = this.element;
        this.originalElement.css({
          position: wrapper.css("position"),
          width: wrapper.outerWidth(),
          height: wrapper.outerHeight(),
          top: wrapper.css("top"),
          left: wrapper.css("left")
        }).insertAfter(wrapper);
        wrapper.remove();
      }
      this.originalElement.css("resize", this.originalResizeStyle);
      _destroy(this.originalElement);
      return this;
    },
    _setOption: function (key, value) {
      this._super(key, value);
      switch (key) {
        case "handles":
          this._removeHandles();
          this._setupHandles();
          break;
        default:
          break;
      }
    },
    _setupHandles: function () {
      var o = this.options,
        handle,
        i,
        n,
        hname,
        axis,
        that = this;
      this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
        n: ".ui-resizable-n",
        e: ".ui-resizable-e",
        s: ".ui-resizable-s",
        w: ".ui-resizable-w",
        se: ".ui-resizable-se",
        sw: ".ui-resizable-sw",
        ne: ".ui-resizable-ne",
        nw: ".ui-resizable-nw"
      });
      this._handles = $();
      if (this.handles.constructor === String) {
        if (this.handles === "all") {
          this.handles = "n,e,s,w,se,sw,ne,nw";
        }
        n = this.handles.split(",");
        this.handles = {};
        for (i = 0; i < n.length; i++) {
          handle = $.trim(n[i]);
          hname = "ui-resizable-" + handle;
          axis = $("<div>");
          this._addClass(axis, "ui-resizable-handle " + hname);
          axis.css({
            zIndex: o.zIndex
          });
          this.handles[handle] = ".ui-resizable-" + handle;
          this.element.append(axis);
        }
      }
      this._renderAxis = function (target) {
        var i, axis, padPos, padWrapper;
        target = target || this.element;
        for (i in this.handles) {
          if (this.handles[i].constructor === String) {
            this.handles[i] = this.element.children(this.handles[i]).first().show();
          } else if (this.handles[i].jquery || this.handles[i].nodeType) {
            this.handles[i] = $(this.handles[i]);
            this._on(this.handles[i], {
              "mousedown": that._mouseDown
            });
          }
          if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
            axis = $(this.handles[i], this.element);
            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
            padPos = ["padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left"].join("");
            target.css(padPos, padWrapper);
            this._proportionallyResize();
          }
          this._handles = this._handles.add(this.handles[i]);
        }
      };

      // TODO: make renderAxis a prototype function
      this._renderAxis(this.element);
      this._handles = this._handles.add(this.element.find(".ui-resizable-handle"));
      this._handles.disableSelection();
      this._handles.on("mouseover", function () {
        if (!that.resizing) {
          if (this.className) {
            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
          }
          that.axis = axis && axis[1] ? axis[1] : "se";
        }
      });
      if (o.autoHide) {
        this._handles.hide();
        this._addClass("ui-resizable-autohide");
      }
    },
    _removeHandles: function () {
      this._handles.remove();
    },
    _mouseCapture: function (event) {
      var i,
        handle,
        capture = false;
      for (i in this.handles) {
        handle = $(this.handles[i])[0];
        if (handle === event.target || $.contains(handle, event.target)) {
          capture = true;
        }
      }
      return !this.options.disabled && capture;
    },
    _mouseStart: function (event) {
      var curleft,
        curtop,
        cursor,
        o = this.options,
        el = this.element;
      this.resizing = true;
      this._renderProxy();
      curleft = this._num(this.helper.css("left"));
      curtop = this._num(this.helper.css("top"));
      if (o.containment) {
        curleft += $(o.containment).scrollLeft() || 0;
        curtop += $(o.containment).scrollTop() || 0;
      }
      this.offset = this.helper.offset();
      this.position = {
        left: curleft,
        top: curtop
      };
      this.size = this._helper ? {
        width: this.helper.width(),
        height: this.helper.height()
      } : {
        width: el.width(),
        height: el.height()
      };
      this.originalSize = this._helper ? {
        width: el.outerWidth(),
        height: el.outerHeight()
      } : {
        width: el.width(),
        height: el.height()
      };
      this.sizeDiff = {
        width: el.outerWidth() - el.width(),
        height: el.outerHeight() - el.height()
      };
      this.originalPosition = {
        left: curleft,
        top: curtop
      };
      this.originalMousePosition = {
        left: event.pageX,
        top: event.pageY
      };
      this.aspectRatio = typeof o.aspectRatio === "number" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
      cursor = $(".ui-resizable-" + this.axis).css("cursor");
      $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
      this._addClass("ui-resizable-resizing");
      this._propagate("start", event);
      return true;
    },
    _mouseDrag: function (event) {
      var data,
        props,
        smp = this.originalMousePosition,
        a = this.axis,
        dx = event.pageX - smp.left || 0,
        dy = event.pageY - smp.top || 0,
        trigger = this._change[a];
      this._updatePrevProperties();
      if (!trigger) {
        return false;
      }
      data = trigger.apply(this, [event, dx, dy]);
      this._updateVirtualBoundaries(event.shiftKey);
      if (this._aspectRatio || event.shiftKey) {
        data = this._updateRatio(data, event);
      }
      data = this._respectSize(data, event);
      this._updateCache(data);
      this._propagate("resize", event);
      props = this._applyChanges();
      if (!this._helper && this._proportionallyResizeElements.length) {
        this._proportionallyResize();
      }
      if (!$.isEmptyObject(props)) {
        this._updatePrevProperties();
        this._trigger("resize", event, this.ui());
        this._applyChanges();
      }
      return false;
    },
    _mouseStop: function (event) {
      this.resizing = false;
      var pr,
        ista,
        soffseth,
        soffsetw,
        s,
        left,
        top,
        o = this.options,
        that = this;
      if (this._helper) {
        pr = this._proportionallyResizeElements;
        ista = pr.length && /textarea/i.test(pr[0].nodeName);
        soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
        soffsetw = ista ? 0 : that.sizeDiff.width;
        s = {
          width: that.helper.width() - soffsetw,
          height: that.helper.height() - soffseth
        };
        left = parseFloat(that.element.css("left")) + (that.position.left - that.originalPosition.left) || null;
        top = parseFloat(that.element.css("top")) + (that.position.top - that.originalPosition.top) || null;
        if (!o.animate) {
          this.element.css($.extend(s, {
            top: top,
            left: left
          }));
        }
        that.helper.height(that.size.height);
        that.helper.width(that.size.width);
        if (this._helper && !o.animate) {
          this._proportionallyResize();
        }
      }
      $("body").css("cursor", "auto");
      this._removeClass("ui-resizable-resizing");
      this._propagate("stop", event);
      if (this._helper) {
        this.helper.remove();
      }
      return false;
    },
    _updatePrevProperties: function () {
      this.prevPosition = {
        top: this.position.top,
        left: this.position.left
      };
      this.prevSize = {
        width: this.size.width,
        height: this.size.height
      };
    },
    _applyChanges: function () {
      var props = {};
      if (this.position.top !== this.prevPosition.top) {
        props.top = this.position.top + "px";
      }
      if (this.position.left !== this.prevPosition.left) {
        props.left = this.position.left + "px";
      }
      if (this.size.width !== this.prevSize.width) {
        props.width = this.size.width + "px";
      }
      if (this.size.height !== this.prevSize.height) {
        props.height = this.size.height + "px";
      }
      this.helper.css(props);
      return props;
    },
    _updateVirtualBoundaries: function (forceAspectRatio) {
      var pMinWidth,
        pMaxWidth,
        pMinHeight,
        pMaxHeight,
        b,
        o = this.options;
      b = {
        minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
        maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
        minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
        maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
      };
      if (this._aspectRatio || forceAspectRatio) {
        pMinWidth = b.minHeight * this.aspectRatio;
        pMinHeight = b.minWidth / this.aspectRatio;
        pMaxWidth = b.maxHeight * this.aspectRatio;
        pMaxHeight = b.maxWidth / this.aspectRatio;
        if (pMinWidth > b.minWidth) {
          b.minWidth = pMinWidth;
        }
        if (pMinHeight > b.minHeight) {
          b.minHeight = pMinHeight;
        }
        if (pMaxWidth < b.maxWidth) {
          b.maxWidth = pMaxWidth;
        }
        if (pMaxHeight < b.maxHeight) {
          b.maxHeight = pMaxHeight;
        }
      }
      this._vBoundaries = b;
    },
    _updateCache: function (data) {
      this.offset = this.helper.offset();
      if (this._isNumber(data.left)) {
        this.position.left = data.left;
      }
      if (this._isNumber(data.top)) {
        this.position.top = data.top;
      }
      if (this._isNumber(data.height)) {
        this.size.height = data.height;
      }
      if (this._isNumber(data.width)) {
        this.size.width = data.width;
      }
    },
    _updateRatio: function (data) {
      var cpos = this.position,
        csize = this.size,
        a = this.axis;
      if (this._isNumber(data.height)) {
        data.width = data.height * this.aspectRatio;
      } else if (this._isNumber(data.width)) {
        data.height = data.width / this.aspectRatio;
      }
      if (a === "sw") {
        data.left = cpos.left + (csize.width - data.width);
        data.top = null;
      }
      if (a === "nw") {
        data.top = cpos.top + (csize.height - data.height);
        data.left = cpos.left + (csize.width - data.width);
      }
      return data;
    },
    _respectSize: function (data) {
      var o = this._vBoundaries,
        a = this.axis,
        ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width,
        ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height,
        isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width,
        isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height,
        dw = this.originalPosition.left + this.originalSize.width,
        dh = this.originalPosition.top + this.originalSize.height,
        cw = /sw|nw|w/.test(a),
        ch = /nw|ne|n/.test(a);
      if (isminw) {
        data.width = o.minWidth;
      }
      if (isminh) {
        data.height = o.minHeight;
      }
      if (ismaxw) {
        data.width = o.maxWidth;
      }
      if (ismaxh) {
        data.height = o.maxHeight;
      }
      if (isminw && cw) {
        data.left = dw - o.minWidth;
      }
      if (ismaxw && cw) {
        data.left = dw - o.maxWidth;
      }
      if (isminh && ch) {
        data.top = dh - o.minHeight;
      }
      if (ismaxh && ch) {
        data.top = dh - o.maxHeight;
      }

      // Fixing jump error on top/left - bug #2330
      if (!data.width && !data.height && !data.left && data.top) {
        data.top = null;
      } else if (!data.width && !data.height && !data.top && data.left) {
        data.left = null;
      }
      return data;
    },
    _getPaddingPlusBorderDimensions: function (element) {
      var i = 0,
        widths = [],
        borders = [element.css("borderTopWidth"), element.css("borderRightWidth"), element.css("borderBottomWidth"), element.css("borderLeftWidth")],
        paddings = [element.css("paddingTop"), element.css("paddingRight"), element.css("paddingBottom"), element.css("paddingLeft")];
      for (; i < 4; i++) {
        widths[i] = parseFloat(borders[i]) || 0;
        widths[i] += parseFloat(paddings[i]) || 0;
      }
      return {
        height: widths[0] + widths[2],
        width: widths[1] + widths[3]
      };
    },
    _proportionallyResize: function () {
      if (!this._proportionallyResizeElements.length) {
        return;
      }
      var prel,
        i = 0,
        element = this.helper || this.element;
      for (; i < this._proportionallyResizeElements.length; i++) {
        prel = this._proportionallyResizeElements[i];

        // TODO: Seems like a bug to cache this.outerDimensions
        // considering that we are in a loop.
        if (!this.outerDimensions) {
          this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
        }
        prel.css({
          height: element.height() - this.outerDimensions.height || 0,
          width: element.width() - this.outerDimensions.width || 0
        });
      }
    },
    _renderProxy: function () {
      var el = this.element,
        o = this.options;
      this.elementOffset = el.offset();
      if (this._helper) {
        this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
        this._addClass(this.helper, this._helper);
        this.helper.css({
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          position: "absolute",
          left: this.elementOffset.left + "px",
          top: this.elementOffset.top + "px",
          zIndex: ++o.zIndex //TODO: Don't modify option
        });

        this.helper.appendTo("body").disableSelection();
      } else {
        this.helper = this.element;
      }
    },
    _change: {
      e: function (event, dx) {
        return {
          width: this.originalSize.width + dx
        };
      },
      w: function (event, dx) {
        var cs = this.originalSize,
          sp = this.originalPosition;
        return {
          left: sp.left + dx,
          width: cs.width - dx
        };
      },
      n: function (event, dx, dy) {
        var cs = this.originalSize,
          sp = this.originalPosition;
        return {
          top: sp.top + dy,
          height: cs.height - dy
        };
      },
      s: function (event, dx, dy) {
        return {
          height: this.originalSize.height + dy
        };
      },
      se: function (event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
      },
      sw: function (event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
      },
      ne: function (event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
      },
      nw: function (event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
      }
    },
    _propagate: function (n, event) {
      $.ui.plugin.call(this, n, [event, this.ui()]);
      n !== "resize" && this._trigger(n, event, this.ui());
    },
    plugins: {},
    ui: function () {
      return {
        originalElement: this.originalElement,
        element: this.element,
        helper: this.helper,
        position: this.position,
        size: this.size,
        originalSize: this.originalSize,
        originalPosition: this.originalPosition
      };
    }
  });

  /*
   * Resizable Extensions
   */

  $.ui.plugin.add("resizable", "animate", {
    stop: function (event) {
      var that = $(this).resizable("instance"),
        o = that.options,
        pr = that._proportionallyResizeElements,
        ista = pr.length && /textarea/i.test(pr[0].nodeName),
        soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
        soffsetw = ista ? 0 : that.sizeDiff.width,
        style = {
          width: that.size.width - soffsetw,
          height: that.size.height - soffseth
        },
        left = parseFloat(that.element.css("left")) + (that.position.left - that.originalPosition.left) || null,
        top = parseFloat(that.element.css("top")) + (that.position.top - that.originalPosition.top) || null;
      that.element.animate($.extend(style, top && left ? {
        top: top,
        left: left
      } : {}), {
        duration: o.animateDuration,
        easing: o.animateEasing,
        step: function () {
          var data = {
            width: parseFloat(that.element.css("width")),
            height: parseFloat(that.element.css("height")),
            top: parseFloat(that.element.css("top")),
            left: parseFloat(that.element.css("left"))
          };
          if (pr && pr.length) {
            $(pr[0]).css({
              width: data.width,
              height: data.height
            });
          }

          // Propagating resize, and updating values for each animation step
          that._updateCache(data);
          that._propagate("resize", event);
        }
      });
    }
  });
  $.ui.plugin.add("resizable", "containment", {
    start: function () {
      var element,
        p,
        co,
        ch,
        cw,
        width,
        height,
        that = $(this).resizable("instance"),
        o = that.options,
        el = that.element,
        oc = o.containment,
        ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
      if (!ce) {
        return;
      }
      that.containerElement = $(ce);
      if (/document/.test(oc) || oc === document) {
        that.containerOffset = {
          left: 0,
          top: 0
        };
        that.containerPosition = {
          left: 0,
          top: 0
        };
        that.parentData = {
          element: $(document),
          left: 0,
          top: 0,
          width: $(document).width(),
          height: $(document).height() || document.body.parentNode.scrollHeight
        };
      } else {
        element = $(ce);
        p = [];
        $(["Top", "Right", "Left", "Bottom"]).each(function (i, name) {
          p[i] = that._num(element.css("padding" + name));
        });
        that.containerOffset = element.offset();
        that.containerPosition = element.position();
        that.containerSize = {
          height: element.innerHeight() - p[3],
          width: element.innerWidth() - p[1]
        };
        co = that.containerOffset;
        ch = that.containerSize.height;
        cw = that.containerSize.width;
        width = that._hasScroll(ce, "left") ? ce.scrollWidth : cw;
        height = that._hasScroll(ce) ? ce.scrollHeight : ch;
        that.parentData = {
          element: ce,
          left: co.left,
          top: co.top,
          width: width,
          height: height
        };
      }
    },
    resize: function (event) {
      var woset,
        hoset,
        isParent,
        isOffsetRelative,
        that = $(this).resizable("instance"),
        o = that.options,
        co = that.containerOffset,
        cp = that.position,
        pRatio = that._aspectRatio || event.shiftKey,
        cop = {
          top: 0,
          left: 0
        },
        ce = that.containerElement,
        continueResize = true;
      if (ce[0] !== document && /static/.test(ce.css("position"))) {
        cop = co;
      }
      if (cp.left < (that._helper ? co.left : 0)) {
        that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
          continueResize = false;
        }
        that.position.left = o.helper ? co.left : 0;
      }
      if (cp.top < (that._helper ? co.top : 0)) {
        that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
          continueResize = false;
        }
        that.position.top = that._helper ? co.top : 0;
      }
      isParent = that.containerElement.get(0) === that.element.parent().get(0);
      isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
      if (isParent && isOffsetRelative) {
        that.offset.left = that.parentData.left + that.position.left;
        that.offset.top = that.parentData.top + that.position.top;
      } else {
        that.offset.left = that.element.offset().left;
        that.offset.top = that.element.offset().top;
      }
      woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left));
      hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top));
      if (woset + that.size.width >= that.parentData.width) {
        that.size.width = that.parentData.width - woset;
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
          continueResize = false;
        }
      }
      if (hoset + that.size.height >= that.parentData.height) {
        that.size.height = that.parentData.height - hoset;
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
          continueResize = false;
        }
      }
      if (!continueResize) {
        that.position.left = that.prevPosition.left;
        that.position.top = that.prevPosition.top;
        that.size.width = that.prevSize.width;
        that.size.height = that.prevSize.height;
      }
    },
    stop: function () {
      var that = $(this).resizable("instance"),
        o = that.options,
        co = that.containerOffset,
        cop = that.containerPosition,
        ce = that.containerElement,
        helper = $(that.helper),
        ho = helper.offset(),
        w = helper.outerWidth() - that.sizeDiff.width,
        h = helper.outerHeight() - that.sizeDiff.height;
      if (that._helper && !o.animate && /relative/.test(ce.css("position"))) {
        $(this).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
      if (that._helper && !o.animate && /static/.test(ce.css("position"))) {
        $(this).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
    }
  });
  $.ui.plugin.add("resizable", "alsoResize", {
    start: function () {
      var that = $(this).resizable("instance"),
        o = that.options;
      $(o.alsoResize).each(function () {
        var el = $(this);
        el.data("ui-resizable-alsoresize", {
          width: parseFloat(el.width()),
          height: parseFloat(el.height()),
          left: parseFloat(el.css("left")),
          top: parseFloat(el.css("top"))
        });
      });
    },
    resize: function (event, ui) {
      var that = $(this).resizable("instance"),
        o = that.options,
        os = that.originalSize,
        op = that.originalPosition,
        delta = {
          height: that.size.height - os.height || 0,
          width: that.size.width - os.width || 0,
          top: that.position.top - op.top || 0,
          left: that.position.left - op.left || 0
        };
      $(o.alsoResize).each(function () {
        var el = $(this),
          start = $(this).data("ui-resizable-alsoresize"),
          style = {},
          css = el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
        $.each(css, function (i, prop) {
          var sum = (start[prop] || 0) + (delta[prop] || 0);
          if (sum && sum >= 0) {
            style[prop] = sum || null;
          }
        });
        el.css(style);
      });
    },
    stop: function () {
      $(this).removeData("ui-resizable-alsoresize");
    }
  });
  $.ui.plugin.add("resizable", "ghost", {
    start: function () {
      var that = $(this).resizable("instance"),
        cs = that.size;
      that.ghost = that.originalElement.clone();
      that.ghost.css({
        opacity: 0.25,
        display: "block",
        position: "relative",
        height: cs.height,
        width: cs.width,
        margin: 0,
        left: 0,
        top: 0
      });
      that._addClass(that.ghost, "ui-resizable-ghost");

      // DEPRECATED
      // TODO: remove after 1.12
      if ($.uiBackCompat !== false && typeof that.options.ghost === "string") {
        // Ghost option
        that.ghost.addClass(this.options.ghost);
      }
      that.ghost.appendTo(that.helper);
    },
    resize: function () {
      var that = $(this).resizable("instance");
      if (that.ghost) {
        that.ghost.css({
          position: "relative",
          height: that.size.height,
          width: that.size.width
        });
      }
    },
    stop: function () {
      var that = $(this).resizable("instance");
      if (that.ghost && that.helper) {
        that.helper.get(0).removeChild(that.ghost.get(0));
      }
    }
  });
  $.ui.plugin.add("resizable", "grid", {
    resize: function () {
      var outerDimensions,
        that = $(this).resizable("instance"),
        o = that.options,
        cs = that.size,
        os = that.originalSize,
        op = that.originalPosition,
        a = that.axis,
        grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
        gridX = grid[0] || 1,
        gridY = grid[1] || 1,
        ox = Math.round((cs.width - os.width) / gridX) * gridX,
        oy = Math.round((cs.height - os.height) / gridY) * gridY,
        newWidth = os.width + ox,
        newHeight = os.height + oy,
        isMaxWidth = o.maxWidth && o.maxWidth < newWidth,
        isMaxHeight = o.maxHeight && o.maxHeight < newHeight,
        isMinWidth = o.minWidth && o.minWidth > newWidth,
        isMinHeight = o.minHeight && o.minHeight > newHeight;
      o.grid = grid;
      if (isMinWidth) {
        newWidth += gridX;
      }
      if (isMinHeight) {
        newHeight += gridY;
      }
      if (isMaxWidth) {
        newWidth -= gridX;
      }
      if (isMaxHeight) {
        newHeight -= gridY;
      }
      if (/^(se|s|e)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
      } else if (/^(ne)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.top = op.top - oy;
      } else if (/^(sw)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.left = op.left - ox;
      } else {
        if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
          outerDimensions = that._getPaddingPlusBorderDimensions(this);
        }
        if (newHeight - gridY > 0) {
          that.size.height = newHeight;
          that.position.top = op.top - oy;
        } else {
          newHeight = gridY - outerDimensions.height;
          that.size.height = newHeight;
          that.position.top = op.top + os.height - newHeight;
        }
        if (newWidth - gridX > 0) {
          that.size.width = newWidth;
          that.position.left = op.left - ox;
        } else {
          newWidth = gridX - outerDimensions.width;
          that.size.width = newWidth;
          that.position.left = op.left + os.width - newWidth;
        }
      }
    }
  });
  var widgetsResizable = $.ui.resizable;
});

/***/ }),

/***/ "./scripts/3rdparty/jquery.js":
/*!************************************!*\
  !*** ./scripts/3rdparty/jquery.js ***!
  \************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery v3.3.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function (e, t) {
  "use strict";

   true && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) {
    if (!e.document) throw new Error("jQuery requires a window with a document");
    return t(e);
  } : t(e);
}("undefined" != typeof window ? window : this, function (e, t) {
  "use strict";

  var n = [],
    r = e.document,
    i = Object.getPrototypeOf,
    o = n.slice,
    a = n.concat,
    s = n.push,
    u = n.indexOf,
    l = {},
    c = l.toString,
    f = l.hasOwnProperty,
    p = f.toString,
    d = p.call(Object),
    h = {},
    g = function e(t) {
      return "function" == typeof t && "number" != typeof t.nodeType;
    },
    y = function e(t) {
      return null != t && t === t.window;
    },
    v = {
      type: !0,
      src: !0,
      noModule: !0
    };
  function m(e, t, n) {
    var i,
      o = (t = t || r).createElement("script");
    if (o.text = e, n) for (i in v) n[i] && (o[i] = n[i]);
    t.head.appendChild(o).parentNode.removeChild(o);
  }
  function x(e) {
    return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? l[c.call(e)] || "object" : typeof e;
  }
  var b = "3.3.1",
    w = function (e, t) {
      return new w.fn.init(e, t);
    },
    T = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  w.fn = w.prototype = {
    jquery: "3.3.1",
    constructor: w,
    length: 0,
    toArray: function () {
      return o.call(this);
    },
    get: function (e) {
      return null == e ? o.call(this) : e < 0 ? this[e + this.length] : this[e];
    },
    pushStack: function (e) {
      var t = w.merge(this.constructor(), e);
      return t.prevObject = this, t;
    },
    each: function (e) {
      return w.each(this, e);
    },
    map: function (e) {
      return this.pushStack(w.map(this, function (t, n) {
        return e.call(t, n, t);
      }));
    },
    slice: function () {
      return this.pushStack(o.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (e) {
      var t = this.length,
        n = +e + (e < 0 ? t : 0);
      return this.pushStack(n >= 0 && n < t ? [this[n]] : []);
    },
    end: function () {
      return this.prevObject || this.constructor();
    },
    push: s,
    sort: n.sort,
    splice: n.splice
  }, w.extend = w.fn.extend = function () {
    var e,
      t,
      n,
      r,
      i,
      o,
      a = arguments[0] || {},
      s = 1,
      u = arguments.length,
      l = !1;
    for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || g(a) || (a = {}), s === u && (a = this, s--); s < u; s++) if (null != (e = arguments[s])) for (t in e) n = a[t], a !== (r = e[t]) && (l && r && (w.isPlainObject(r) || (i = Array.isArray(r))) ? (i ? (i = !1, o = n && Array.isArray(n) ? n : []) : o = n && w.isPlainObject(n) ? n : {}, a[t] = w.extend(l, o, r)) : void 0 !== r && (a[t] = r));
    return a;
  }, w.extend({
    expando: "jQuery" + ("3.3.1" + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function (e) {
      throw new Error(e);
    },
    noop: function () {},
    isPlainObject: function (e) {
      var t, n;
      return !(!e || "[object Object]" !== c.call(e)) && (!(t = i(e)) || "function" == typeof (n = f.call(t, "constructor") && t.constructor) && p.call(n) === d);
    },
    isEmptyObject: function (e) {
      var t;
      for (t in e) return !1;
      return !0;
    },
    globalEval: function (e) {
      m(e);
    },
    each: function (e, t) {
      var n,
        r = 0;
      if (C(e)) {
        for (n = e.length; r < n; r++) if (!1 === t.call(e[r], r, e[r])) break;
      } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break;
      return e;
    },
    trim: function (e) {
      return null == e ? "" : (e + "").replace(T, "");
    },
    makeArray: function (e, t) {
      var n = t || [];
      return null != e && (C(Object(e)) ? w.merge(n, "string" == typeof e ? [e] : e) : s.call(n, e)), n;
    },
    inArray: function (e, t, n) {
      return null == t ? -1 : u.call(t, e, n);
    },
    merge: function (e, t) {
      for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];
      return e.length = i, e;
    },
    grep: function (e, t, n) {
      for (var r, i = [], o = 0, a = e.length, s = !n; o < a; o++) (r = !t(e[o], o)) !== s && i.push(e[o]);
      return i;
    },
    map: function (e, t, n) {
      var r,
        i,
        o = 0,
        s = [];
      if (C(e)) for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && s.push(i);else for (o in e) null != (i = t(e[o], o, n)) && s.push(i);
      return a.apply([], s);
    },
    guid: 1,
    support: h
  }), "function" == typeof Symbol && (w.fn[Symbol.iterator] = n[Symbol.iterator]), w.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
    l["[object " + t + "]"] = t.toLowerCase();
  });
  function C(e) {
    var t = !!e && "length" in e && e.length,
      n = x(e);
    return !g(e) && !y(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e);
  }
  var E = function (e) {
    var t,
      n,
      r,
      i,
      o,
      a,
      s,
      u,
      l,
      c,
      f,
      p,
      d,
      h,
      g,
      y,
      v,
      m,
      x,
      b = "sizzle" + 1 * new Date(),
      w = e.document,
      T = 0,
      C = 0,
      E = ae(),
      k = ae(),
      S = ae(),
      D = function (e, t) {
        return e === t && (f = !0), 0;
      },
      N = {}.hasOwnProperty,
      A = [],
      j = A.pop,
      q = A.push,
      L = A.push,
      H = A.slice,
      O = function (e, t) {
        for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
        return -1;
      },
      P = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      M = "[\\x20\\t\\r\\n\\f]",
      R = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
      I = "\\[" + M + "*(" + R + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + R + "))|)" + M + "*\\]",
      W = ":(" + R + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + I + ")*)|.*)\\)|)",
      $ = new RegExp(M + "+", "g"),
      B = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
      F = new RegExp("^" + M + "*," + M + "*"),
      _ = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
      z = new RegExp("=" + M + "*([^\\]'\"]*?)" + M + "*\\]", "g"),
      X = new RegExp(W),
      U = new RegExp("^" + R + "$"),
      V = {
        ID: new RegExp("^#(" + R + ")"),
        CLASS: new RegExp("^\\.(" + R + ")"),
        TAG: new RegExp("^(" + R + "|[*])"),
        ATTR: new RegExp("^" + I),
        PSEUDO: new RegExp("^" + W),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + P + ")$", "i"),
        needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i")
      },
      G = /^(?:input|select|textarea|button)$/i,
      Y = /^h\d$/i,
      Q = /^[^{]+\{\s*\[native \w/,
      J = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      K = /[+~]/,
      Z = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"),
      ee = function (e, t, n) {
        var r = "0x" + t - 65536;
        return r !== r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320);
      },
      te = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
      ne = function (e, t) {
        return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e;
      },
      re = function () {
        p();
      },
      ie = me(function (e) {
        return !0 === e.disabled && ("form" in e || "label" in e);
      }, {
        dir: "parentNode",
        next: "legend"
      });
    try {
      L.apply(A = H.call(w.childNodes), w.childNodes), A[w.childNodes.length].nodeType;
    } catch (e) {
      L = {
        apply: A.length ? function (e, t) {
          q.apply(e, H.call(t));
        } : function (e, t) {
          var n = e.length,
            r = 0;
          while (e[n++] = t[r++]);
          e.length = n - 1;
        }
      };
    }
    function oe(e, t, r, i) {
      var o,
        s,
        l,
        c,
        f,
        h,
        v,
        m = t && t.ownerDocument,
        T = t ? t.nodeType : 9;
      if (r = r || [], "string" != typeof e || !e || 1 !== T && 9 !== T && 11 !== T) return r;
      if (!i && ((t ? t.ownerDocument || t : w) !== d && p(t), t = t || d, g)) {
        if (11 !== T && (f = J.exec(e))) if (o = f[1]) {
          if (9 === T) {
            if (!(l = t.getElementById(o))) return r;
            if (l.id === o) return r.push(l), r;
          } else if (m && (l = m.getElementById(o)) && x(t, l) && l.id === o) return r.push(l), r;
        } else {
          if (f[2]) return L.apply(r, t.getElementsByTagName(e)), r;
          if ((o = f[3]) && n.getElementsByClassName && t.getElementsByClassName) return L.apply(r, t.getElementsByClassName(o)), r;
        }
        if (n.qsa && !S[e + " "] && (!y || !y.test(e))) {
          if (1 !== T) m = t, v = e;else if ("object" !== t.nodeName.toLowerCase()) {
            (c = t.getAttribute("id")) ? c = c.replace(te, ne) : t.setAttribute("id", c = b), s = (h = a(e)).length;
            while (s--) h[s] = "#" + c + " " + ve(h[s]);
            v = h.join(","), m = K.test(e) && ge(t.parentNode) || t;
          }
          if (v) try {
            return L.apply(r, m.querySelectorAll(v)), r;
          } catch (e) {} finally {
            c === b && t.removeAttribute("id");
          }
        }
      }
      return u(e.replace(B, "$1"), t, r, i);
    }
    function ae() {
      var e = [];
      function t(n, i) {
        return e.push(n + " ") > r.cacheLength && delete t[e.shift()], t[n + " "] = i;
      }
      return t;
    }
    function se(e) {
      return e[b] = !0, e;
    }
    function ue(e) {
      var t = d.createElement("fieldset");
      try {
        return !!e(t);
      } catch (e) {
        return !1;
      } finally {
        t.parentNode && t.parentNode.removeChild(t), t = null;
      }
    }
    function le(e, t) {
      var n = e.split("|"),
        i = n.length;
      while (i--) r.attrHandle[n[i]] = t;
    }
    function ce(e, t) {
      var n = t && e,
        r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
      if (r) return r;
      if (n) while (n = n.nextSibling) if (n === t) return -1;
      return e ? 1 : -1;
    }
    function fe(e) {
      return function (t) {
        return "input" === t.nodeName.toLowerCase() && t.type === e;
      };
    }
    function pe(e) {
      return function (t) {
        var n = t.nodeName.toLowerCase();
        return ("input" === n || "button" === n) && t.type === e;
      };
    }
    function de(e) {
      return function (t) {
        return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && ie(t) === e : t.disabled === e : "label" in t && t.disabled === e;
      };
    }
    function he(e) {
      return se(function (t) {
        return t = +t, se(function (n, r) {
          var i,
            o = e([], n.length, t),
            a = o.length;
          while (a--) n[i = o[a]] && (n[i] = !(r[i] = n[i]));
        });
      });
    }
    function ge(e) {
      return e && "undefined" != typeof e.getElementsByTagName && e;
    }
    n = oe.support = {}, o = oe.isXML = function (e) {
      var t = e && (e.ownerDocument || e).documentElement;
      return !!t && "HTML" !== t.nodeName;
    }, p = oe.setDocument = function (e) {
      var t,
        i,
        a = e ? e.ownerDocument || e : w;
      return a !== d && 9 === a.nodeType && a.documentElement ? (d = a, h = d.documentElement, g = !o(d), w !== d && (i = d.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", re, !1) : i.attachEvent && i.attachEvent("onunload", re)), n.attributes = ue(function (e) {
        return e.className = "i", !e.getAttribute("className");
      }), n.getElementsByTagName = ue(function (e) {
        return e.appendChild(d.createComment("")), !e.getElementsByTagName("*").length;
      }), n.getElementsByClassName = Q.test(d.getElementsByClassName), n.getById = ue(function (e) {
        return h.appendChild(e).id = b, !d.getElementsByName || !d.getElementsByName(b).length;
      }), n.getById ? (r.filter.ID = function (e) {
        var t = e.replace(Z, ee);
        return function (e) {
          return e.getAttribute("id") === t;
        };
      }, r.find.ID = function (e, t) {
        if ("undefined" != typeof t.getElementById && g) {
          var n = t.getElementById(e);
          return n ? [n] : [];
        }
      }) : (r.filter.ID = function (e) {
        var t = e.replace(Z, ee);
        return function (e) {
          var n = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
          return n && n.value === t;
        };
      }, r.find.ID = function (e, t) {
        if ("undefined" != typeof t.getElementById && g) {
          var n,
            r,
            i,
            o = t.getElementById(e);
          if (o) {
            if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
            i = t.getElementsByName(e), r = 0;
            while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
          }
          return [];
        }
      }), r.find.TAG = n.getElementsByTagName ? function (e, t) {
        return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0;
      } : function (e, t) {
        var n,
          r = [],
          i = 0,
          o = t.getElementsByTagName(e);
        if ("*" === e) {
          while (n = o[i++]) 1 === n.nodeType && r.push(n);
          return r;
        }
        return o;
      }, r.find.CLASS = n.getElementsByClassName && function (e, t) {
        if ("undefined" != typeof t.getElementsByClassName && g) return t.getElementsByClassName(e);
      }, v = [], y = [], (n.qsa = Q.test(d.querySelectorAll)) && (ue(function (e) {
        h.appendChild(e).innerHTML = "<a id='" + b + "'></a><select id='" + b + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && y.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || y.push("\\[" + M + "*(?:value|" + P + ")"), e.querySelectorAll("[id~=" + b + "-]").length || y.push("~="), e.querySelectorAll(":checked").length || y.push(":checked"), e.querySelectorAll("a#" + b + "+*").length || y.push(".#.+[+~]");
      }), ue(function (e) {
        e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
        var t = d.createElement("input");
        t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && y.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && y.push(":enabled", ":disabled"), h.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && y.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), y.push(",.*:");
      })), (n.matchesSelector = Q.test(m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue(function (e) {
        n.disconnectedMatch = m.call(e, "*"), m.call(e, "[s!='']:x"), v.push("!=", W);
      }), y = y.length && new RegExp(y.join("|")), v = v.length && new RegExp(v.join("|")), t = Q.test(h.compareDocumentPosition), x = t || Q.test(h.contains) ? function (e, t) {
        var n = 9 === e.nodeType ? e.documentElement : e,
          r = t && t.parentNode;
        return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
      } : function (e, t) {
        if (t) while (t = t.parentNode) if (t === e) return !0;
        return !1;
      }, D = t ? function (e, t) {
        if (e === t) return f = !0, 0;
        var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
        return r || (1 & (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === r ? e === d || e.ownerDocument === w && x(w, e) ? -1 : t === d || t.ownerDocument === w && x(w, t) ? 1 : c ? O(c, e) - O(c, t) : 0 : 4 & r ? -1 : 1);
      } : function (e, t) {
        if (e === t) return f = !0, 0;
        var n,
          r = 0,
          i = e.parentNode,
          o = t.parentNode,
          a = [e],
          s = [t];
        if (!i || !o) return e === d ? -1 : t === d ? 1 : i ? -1 : o ? 1 : c ? O(c, e) - O(c, t) : 0;
        if (i === o) return ce(e, t);
        n = e;
        while (n = n.parentNode) a.unshift(n);
        n = t;
        while (n = n.parentNode) s.unshift(n);
        while (a[r] === s[r]) r++;
        return r ? ce(a[r], s[r]) : a[r] === w ? -1 : s[r] === w ? 1 : 0;
      }, d) : d;
    }, oe.matches = function (e, t) {
      return oe(e, null, null, t);
    }, oe.matchesSelector = function (e, t) {
      if ((e.ownerDocument || e) !== d && p(e), t = t.replace(z, "='$1']"), n.matchesSelector && g && !S[t + " "] && (!v || !v.test(t)) && (!y || !y.test(t))) try {
        var r = m.call(e, t);
        if (r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r;
      } catch (e) {}
      return oe(t, d, null, [e]).length > 0;
    }, oe.contains = function (e, t) {
      return (e.ownerDocument || e) !== d && p(e), x(e, t);
    }, oe.attr = function (e, t) {
      (e.ownerDocument || e) !== d && p(e);
      var i = r.attrHandle[t.toLowerCase()],
        o = i && N.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !g) : void 0;
      return void 0 !== o ? o : n.attributes || !g ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null;
    }, oe.escape = function (e) {
      return (e + "").replace(te, ne);
    }, oe.error = function (e) {
      throw new Error("Syntax error, unrecognized expression: " + e);
    }, oe.uniqueSort = function (e) {
      var t,
        r = [],
        i = 0,
        o = 0;
      if (f = !n.detectDuplicates, c = !n.sortStable && e.slice(0), e.sort(D), f) {
        while (t = e[o++]) t === e[o] && (i = r.push(o));
        while (i--) e.splice(r[i], 1);
      }
      return c = null, e;
    }, i = oe.getText = function (e) {
      var t,
        n = "",
        r = 0,
        o = e.nodeType;
      if (o) {
        if (1 === o || 9 === o || 11 === o) {
          if ("string" == typeof e.textContent) return e.textContent;
          for (e = e.firstChild; e; e = e.nextSibling) n += i(e);
        } else if (3 === o || 4 === o) return e.nodeValue;
      } else while (t = e[r++]) n += i(t);
      return n;
    }, (r = oe.selectors = {
      cacheLength: 50,
      createPseudo: se,
      match: V,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function (e) {
          return e[1] = e[1].replace(Z, ee), e[3] = (e[3] || e[4] || e[5] || "").replace(Z, ee), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
        },
        CHILD: function (e) {
          return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || oe.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && oe.error(e[0]), e;
        },
        PSEUDO: function (e) {
          var t,
            n = !e[6] && e[2];
          return V.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = a(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3));
        }
      },
      filter: {
        TAG: function (e) {
          var t = e.replace(Z, ee).toLowerCase();
          return "*" === e ? function () {
            return !0;
          } : function (e) {
            return e.nodeName && e.nodeName.toLowerCase() === t;
          };
        },
        CLASS: function (e) {
          var t = E[e + " "];
          return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && E(e, function (e) {
            return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "");
          });
        },
        ATTR: function (e, t, n) {
          return function (r) {
            var i = oe.attr(r, e);
            return null == i ? "!=" === t : !t || (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i.replace($, " ") + " ").indexOf(n) > -1 : "|=" === t && (i === n || i.slice(0, n.length + 1) === n + "-"));
          };
        },
        CHILD: function (e, t, n, r, i) {
          var o = "nth" !== e.slice(0, 3),
            a = "last" !== e.slice(-4),
            s = "of-type" === t;
          return 1 === r && 0 === i ? function (e) {
            return !!e.parentNode;
          } : function (t, n, u) {
            var l,
              c,
              f,
              p,
              d,
              h,
              g = o !== a ? "nextSibling" : "previousSibling",
              y = t.parentNode,
              v = s && t.nodeName.toLowerCase(),
              m = !u && !s,
              x = !1;
            if (y) {
              if (o) {
                while (g) {
                  p = t;
                  while (p = p[g]) if (s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) return !1;
                  h = g = "only" === e && !h && "nextSibling";
                }
                return !0;
              }
              if (h = [a ? y.firstChild : y.lastChild], a && m) {
                x = (d = (l = (c = (f = (p = y)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]) && l[2], p = d && y.childNodes[d];
                while (p = ++d && p && p[g] || (x = d = 0) || h.pop()) if (1 === p.nodeType && ++x && p === t) {
                  c[e] = [T, d, x];
                  break;
                }
              } else if (m && (x = d = (l = (c = (f = (p = t)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]), !1 === x) while (p = ++d && p && p[g] || (x = d = 0) || h.pop()) if ((s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) && ++x && (m && ((c = (f = p[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] = [T, x]), p === t)) break;
              return (x -= i) === r || x % r == 0 && x / r >= 0;
            }
          };
        },
        PSEUDO: function (e, t) {
          var n,
            i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || oe.error("unsupported pseudo: " + e);
          return i[b] ? i(t) : i.length > 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? se(function (e, n) {
            var r,
              o = i(e, t),
              a = o.length;
            while (a--) e[r = O(e, o[a])] = !(n[r] = o[a]);
          }) : function (e) {
            return i(e, 0, n);
          }) : i;
        }
      },
      pseudos: {
        not: se(function (e) {
          var t = [],
            n = [],
            r = s(e.replace(B, "$1"));
          return r[b] ? se(function (e, t, n, i) {
            var o,
              a = r(e, null, i, []),
              s = e.length;
            while (s--) (o = a[s]) && (e[s] = !(t[s] = o));
          }) : function (e, i, o) {
            return t[0] = e, r(t, null, o, n), t[0] = null, !n.pop();
          };
        }),
        has: se(function (e) {
          return function (t) {
            return oe(e, t).length > 0;
          };
        }),
        contains: se(function (e) {
          return e = e.replace(Z, ee), function (t) {
            return (t.textContent || t.innerText || i(t)).indexOf(e) > -1;
          };
        }),
        lang: se(function (e) {
          return U.test(e || "") || oe.error("unsupported lang: " + e), e = e.replace(Z, ee).toLowerCase(), function (t) {
            var n;
            do {
              if (n = g ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-");
            } while ((t = t.parentNode) && 1 === t.nodeType);
            return !1;
          };
        }),
        target: function (t) {
          var n = e.location && e.location.hash;
          return n && n.slice(1) === t.id;
        },
        root: function (e) {
          return e === h;
        },
        focus: function (e) {
          return e === d.activeElement && (!d.hasFocus || d.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
        },
        enabled: de(!1),
        disabled: de(!0),
        checked: function (e) {
          var t = e.nodeName.toLowerCase();
          return "input" === t && !!e.checked || "option" === t && !!e.selected;
        },
        selected: function (e) {
          return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
        },
        empty: function (e) {
          for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
          return !0;
        },
        parent: function (e) {
          return !r.pseudos.empty(e);
        },
        header: function (e) {
          return Y.test(e.nodeName);
        },
        input: function (e) {
          return G.test(e.nodeName);
        },
        button: function (e) {
          var t = e.nodeName.toLowerCase();
          return "input" === t && "button" === e.type || "button" === t;
        },
        text: function (e) {
          var t;
          return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
        },
        first: he(function () {
          return [0];
        }),
        last: he(function (e, t) {
          return [t - 1];
        }),
        eq: he(function (e, t, n) {
          return [n < 0 ? n + t : n];
        }),
        even: he(function (e, t) {
          for (var n = 0; n < t; n += 2) e.push(n);
          return e;
        }),
        odd: he(function (e, t) {
          for (var n = 1; n < t; n += 2) e.push(n);
          return e;
        }),
        lt: he(function (e, t, n) {
          for (var r = n < 0 ? n + t : n; --r >= 0;) e.push(r);
          return e;
        }),
        gt: he(function (e, t, n) {
          for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);
          return e;
        })
      }
    }).pseudos.nth = r.pseudos.eq;
    for (t in {
      radio: !0,
      checkbox: !0,
      file: !0,
      password: !0,
      image: !0
    }) r.pseudos[t] = fe(t);
    for (t in {
      submit: !0,
      reset: !0
    }) r.pseudos[t] = pe(t);
    function ye() {}
    ye.prototype = r.filters = r.pseudos, r.setFilters = new ye(), a = oe.tokenize = function (e, t) {
      var n,
        i,
        o,
        a,
        s,
        u,
        l,
        c = k[e + " "];
      if (c) return t ? 0 : c.slice(0);
      s = e, u = [], l = r.preFilter;
      while (s) {
        n && !(i = F.exec(s)) || (i && (s = s.slice(i[0].length) || s), u.push(o = [])), n = !1, (i = _.exec(s)) && (n = i.shift(), o.push({
          value: n,
          type: i[0].replace(B, " ")
        }), s = s.slice(n.length));
        for (a in r.filter) !(i = V[a].exec(s)) || l[a] && !(i = l[a](i)) || (n = i.shift(), o.push({
          value: n,
          type: a,
          matches: i
        }), s = s.slice(n.length));
        if (!n) break;
      }
      return t ? s.length : s ? oe.error(e) : k(e, u).slice(0);
    };
    function ve(e) {
      for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
      return r;
    }
    function me(e, t, n) {
      var r = t.dir,
        i = t.next,
        o = i || r,
        a = n && "parentNode" === o,
        s = C++;
      return t.first ? function (t, n, i) {
        while (t = t[r]) if (1 === t.nodeType || a) return e(t, n, i);
        return !1;
      } : function (t, n, u) {
        var l,
          c,
          f,
          p = [T, s];
        if (u) {
          while (t = t[r]) if ((1 === t.nodeType || a) && e(t, n, u)) return !0;
        } else while (t = t[r]) if (1 === t.nodeType || a) if (f = t[b] || (t[b] = {}), c = f[t.uniqueID] || (f[t.uniqueID] = {}), i && i === t.nodeName.toLowerCase()) t = t[r] || t;else {
          if ((l = c[o]) && l[0] === T && l[1] === s) return p[2] = l[2];
          if (c[o] = p, p[2] = e(t, n, u)) return !0;
        }
        return !1;
      };
    }
    function xe(e) {
      return e.length > 1 ? function (t, n, r) {
        var i = e.length;
        while (i--) if (!e[i](t, n, r)) return !1;
        return !0;
      } : e[0];
    }
    function be(e, t, n) {
      for (var r = 0, i = t.length; r < i; r++) oe(e, t[r], n);
      return n;
    }
    function we(e, t, n, r, i) {
      for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++) (o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));
      return a;
    }
    function Te(e, t, n, r, i, o) {
      return r && !r[b] && (r = Te(r)), i && !i[b] && (i = Te(i, o)), se(function (o, a, s, u) {
        var l,
          c,
          f,
          p = [],
          d = [],
          h = a.length,
          g = o || be(t || "*", s.nodeType ? [s] : s, []),
          y = !e || !o && t ? g : we(g, p, e, s, u),
          v = n ? i || (o ? e : h || r) ? [] : a : y;
        if (n && n(y, v, s, u), r) {
          l = we(v, d), r(l, [], s, u), c = l.length;
          while (c--) (f = l[c]) && (v[d[c]] = !(y[d[c]] = f));
        }
        if (o) {
          if (i || e) {
            if (i) {
              l = [], c = v.length;
              while (c--) (f = v[c]) && l.push(y[c] = f);
              i(null, v = [], l, u);
            }
            c = v.length;
            while (c--) (f = v[c]) && (l = i ? O(o, f) : p[c]) > -1 && (o[l] = !(a[l] = f));
          }
        } else v = we(v === a ? v.splice(h, v.length) : v), i ? i(null, a, v, u) : L.apply(a, v);
      });
    }
    function Ce(e) {
      for (var t, n, i, o = e.length, a = r.relative[e[0].type], s = a || r.relative[" "], u = a ? 1 : 0, c = me(function (e) {
          return e === t;
        }, s, !0), f = me(function (e) {
          return O(t, e) > -1;
        }, s, !0), p = [function (e, n, r) {
          var i = !a && (r || n !== l) || ((t = n).nodeType ? c(e, n, r) : f(e, n, r));
          return t = null, i;
        }]; u < o; u++) if (n = r.relative[e[u].type]) p = [me(xe(p), n)];else {
        if ((n = r.filter[e[u].type].apply(null, e[u].matches))[b]) {
          for (i = ++u; i < o; i++) if (r.relative[e[i].type]) break;
          return Te(u > 1 && xe(p), u > 1 && ve(e.slice(0, u - 1).concat({
            value: " " === e[u - 2].type ? "*" : ""
          })).replace(B, "$1"), n, u < i && Ce(e.slice(u, i)), i < o && Ce(e = e.slice(i)), i < o && ve(e));
        }
        p.push(n);
      }
      return xe(p);
    }
    function Ee(e, t) {
      var n = t.length > 0,
        i = e.length > 0,
        o = function (o, a, s, u, c) {
          var f,
            h,
            y,
            v = 0,
            m = "0",
            x = o && [],
            b = [],
            w = l,
            C = o || i && r.find.TAG("*", c),
            E = T += null == w ? 1 : Math.random() || .1,
            k = C.length;
          for (c && (l = a === d || a || c); m !== k && null != (f = C[m]); m++) {
            if (i && f) {
              h = 0, a || f.ownerDocument === d || (p(f), s = !g);
              while (y = e[h++]) if (y(f, a || d, s)) {
                u.push(f);
                break;
              }
              c && (T = E);
            }
            n && ((f = !y && f) && v--, o && x.push(f));
          }
          if (v += m, n && m !== v) {
            h = 0;
            while (y = t[h++]) y(x, b, a, s);
            if (o) {
              if (v > 0) while (m--) x[m] || b[m] || (b[m] = j.call(u));
              b = we(b);
            }
            L.apply(u, b), c && !o && b.length > 0 && v + t.length > 1 && oe.uniqueSort(u);
          }
          return c && (T = E, l = w), x;
        };
      return n ? se(o) : o;
    }
    return s = oe.compile = function (e, t) {
      var n,
        r = [],
        i = [],
        o = S[e + " "];
      if (!o) {
        t || (t = a(e)), n = t.length;
        while (n--) (o = Ce(t[n]))[b] ? r.push(o) : i.push(o);
        (o = S(e, Ee(i, r))).selector = e;
      }
      return o;
    }, u = oe.select = function (e, t, n, i) {
      var o,
        u,
        l,
        c,
        f,
        p = "function" == typeof e && e,
        d = !i && a(e = p.selector || e);
      if (n = n || [], 1 === d.length) {
        if ((u = d[0] = d[0].slice(0)).length > 2 && "ID" === (l = u[0]).type && 9 === t.nodeType && g && r.relative[u[1].type]) {
          if (!(t = (r.find.ID(l.matches[0].replace(Z, ee), t) || [])[0])) return n;
          p && (t = t.parentNode), e = e.slice(u.shift().value.length);
        }
        o = V.needsContext.test(e) ? 0 : u.length;
        while (o--) {
          if (l = u[o], r.relative[c = l.type]) break;
          if ((f = r.find[c]) && (i = f(l.matches[0].replace(Z, ee), K.test(u[0].type) && ge(t.parentNode) || t))) {
            if (u.splice(o, 1), !(e = i.length && ve(u))) return L.apply(n, i), n;
            break;
          }
        }
      }
      return (p || s(e, d))(i, t, !g, n, !t || K.test(e) && ge(t.parentNode) || t), n;
    }, n.sortStable = b.split("").sort(D).join("") === b, n.detectDuplicates = !!f, p(), n.sortDetached = ue(function (e) {
      return 1 & e.compareDocumentPosition(d.createElement("fieldset"));
    }), ue(function (e) {
      return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href");
    }) || le("type|href|height|width", function (e, t, n) {
      if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
    }), n.attributes && ue(function (e) {
      return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");
    }) || le("value", function (e, t, n) {
      if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
    }), ue(function (e) {
      return null == e.getAttribute("disabled");
    }) || le(P, function (e, t, n) {
      var r;
      if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
    }), oe;
  }(e);
  w.find = E, w.expr = E.selectors, w.expr[":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape;
  var k = function (e, t, n) {
      var r = [],
        i = void 0 !== n;
      while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) {
        if (i && w(e).is(n)) break;
        r.push(e);
      }
      return r;
    },
    S = function (e, t) {
      for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
      return n;
    },
    D = w.expr.match.needsContext;
  function N(e, t) {
    return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
  }
  var A = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
  function j(e, t, n) {
    return g(t) ? w.grep(e, function (e, r) {
      return !!t.call(e, r, e) !== n;
    }) : t.nodeType ? w.grep(e, function (e) {
      return e === t !== n;
    }) : "string" != typeof t ? w.grep(e, function (e) {
      return u.call(t, e) > -1 !== n;
    }) : w.filter(t, e, n);
  }
  w.filter = function (e, t, n) {
    var r = t[0];
    return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? w.find.matchesSelector(r, e) ? [r] : [] : w.find.matches(e, w.grep(t, function (e) {
      return 1 === e.nodeType;
    }));
  }, w.fn.extend({
    find: function (e) {
      var t,
        n,
        r = this.length,
        i = this;
      if ("string" != typeof e) return this.pushStack(w(e).filter(function () {
        for (t = 0; t < r; t++) if (w.contains(i[t], this)) return !0;
      }));
      for (n = this.pushStack([]), t = 0; t < r; t++) w.find(e, i[t], n);
      return r > 1 ? w.uniqueSort(n) : n;
    },
    filter: function (e) {
      return this.pushStack(j(this, e || [], !1));
    },
    not: function (e) {
      return this.pushStack(j(this, e || [], !0));
    },
    is: function (e) {
      return !!j(this, "string" == typeof e && D.test(e) ? w(e) : e || [], !1).length;
    }
  });
  var q,
    L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
  (w.fn.init = function (e, t, n) {
    var i, o;
    if (!e) return this;
    if (n = n || q, "string" == typeof e) {
      if (!(i = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : L.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
      if (i[1]) {
        if (t = t instanceof w ? t[0] : t, w.merge(this, w.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : r, !0)), A.test(i[1]) && w.isPlainObject(t)) for (i in t) g(this[i]) ? this[i](t[i]) : this.attr(i, t[i]);
        return this;
      }
      return (o = r.getElementById(i[2])) && (this[0] = o, this.length = 1), this;
    }
    return e.nodeType ? (this[0] = e, this.length = 1, this) : g(e) ? void 0 !== n.ready ? n.ready(e) : e(w) : w.makeArray(e, this);
  }).prototype = w.fn, q = w(r);
  var H = /^(?:parents|prev(?:Until|All))/,
    O = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };
  w.fn.extend({
    has: function (e) {
      var t = w(e, this),
        n = t.length;
      return this.filter(function () {
        for (var e = 0; e < n; e++) if (w.contains(this, t[e])) return !0;
      });
    },
    closest: function (e, t) {
      var n,
        r = 0,
        i = this.length,
        o = [],
        a = "string" != typeof e && w(e);
      if (!D.test(e)) for (; r < i; r++) for (n = this[r]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && w.find.matchesSelector(n, e))) {
        o.push(n);
        break;
      }
      return this.pushStack(o.length > 1 ? w.uniqueSort(o) : o);
    },
    index: function (e) {
      return e ? "string" == typeof e ? u.call(w(e), this[0]) : u.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
    },
    add: function (e, t) {
      return this.pushStack(w.uniqueSort(w.merge(this.get(), w(e, t))));
    },
    addBack: function (e) {
      return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
    }
  });
  function P(e, t) {
    while ((e = e[t]) && 1 !== e.nodeType);
    return e;
  }
  w.each({
    parent: function (e) {
      var t = e.parentNode;
      return t && 11 !== t.nodeType ? t : null;
    },
    parents: function (e) {
      return k(e, "parentNode");
    },
    parentsUntil: function (e, t, n) {
      return k(e, "parentNode", n);
    },
    next: function (e) {
      return P(e, "nextSibling");
    },
    prev: function (e) {
      return P(e, "previousSibling");
    },
    nextAll: function (e) {
      return k(e, "nextSibling");
    },
    prevAll: function (e) {
      return k(e, "previousSibling");
    },
    nextUntil: function (e, t, n) {
      return k(e, "nextSibling", n);
    },
    prevUntil: function (e, t, n) {
      return k(e, "previousSibling", n);
    },
    siblings: function (e) {
      return S((e.parentNode || {}).firstChild, e);
    },
    children: function (e) {
      return S(e.firstChild);
    },
    contents: function (e) {
      return N(e, "iframe") ? e.contentDocument : (N(e, "template") && (e = e.content || e), w.merge([], e.childNodes));
    }
  }, function (e, t) {
    w.fn[e] = function (n, r) {
      var i = w.map(this, t, n);
      return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = w.filter(r, i)), this.length > 1 && (O[e] || w.uniqueSort(i), H.test(e) && i.reverse()), this.pushStack(i);
    };
  });
  var M = /[^\x20\t\r\n\f]+/g;
  function R(e) {
    var t = {};
    return w.each(e.match(M) || [], function (e, n) {
      t[n] = !0;
    }), t;
  }
  w.Callbacks = function (e) {
    e = "string" == typeof e ? R(e) : w.extend({}, e);
    var t,
      n,
      r,
      i,
      o = [],
      a = [],
      s = -1,
      u = function () {
        for (i = i || e.once, r = t = !0; a.length; s = -1) {
          n = a.shift();
          while (++s < o.length) !1 === o[s].apply(n[0], n[1]) && e.stopOnFalse && (s = o.length, n = !1);
        }
        e.memory || (n = !1), t = !1, i && (o = n ? [] : "");
      },
      l = {
        add: function () {
          return o && (n && !t && (s = o.length - 1, a.push(n)), function t(n) {
            w.each(n, function (n, r) {
              g(r) ? e.unique && l.has(r) || o.push(r) : r && r.length && "string" !== x(r) && t(r);
            });
          }(arguments), n && !t && u()), this;
        },
        remove: function () {
          return w.each(arguments, function (e, t) {
            var n;
            while ((n = w.inArray(t, o, n)) > -1) o.splice(n, 1), n <= s && s--;
          }), this;
        },
        has: function (e) {
          return e ? w.inArray(e, o) > -1 : o.length > 0;
        },
        empty: function () {
          return o && (o = []), this;
        },
        disable: function () {
          return i = a = [], o = n = "", this;
        },
        disabled: function () {
          return !o;
        },
        lock: function () {
          return i = a = [], n || t || (o = n = ""), this;
        },
        locked: function () {
          return !!i;
        },
        fireWith: function (e, n) {
          return i || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || u()), this;
        },
        fire: function () {
          return l.fireWith(this, arguments), this;
        },
        fired: function () {
          return !!r;
        }
      };
    return l;
  };
  function I(e) {
    return e;
  }
  function W(e) {
    throw e;
  }
  function $(e, t, n, r) {
    var i;
    try {
      e && g(i = e.promise) ? i.call(e).done(t).fail(n) : e && g(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r));
    } catch (e) {
      n.apply(void 0, [e]);
    }
  }
  w.extend({
    Deferred: function (t) {
      var n = [["notify", "progress", w.Callbacks("memory"), w.Callbacks("memory"), 2], ["resolve", "done", w.Callbacks("once memory"), w.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", w.Callbacks("once memory"), w.Callbacks("once memory"), 1, "rejected"]],
        r = "pending",
        i = {
          state: function () {
            return r;
          },
          always: function () {
            return o.done(arguments).fail(arguments), this;
          },
          "catch": function (e) {
            return i.then(null, e);
          },
          pipe: function () {
            var e = arguments;
            return w.Deferred(function (t) {
              w.each(n, function (n, r) {
                var i = g(e[r[4]]) && e[r[4]];
                o[r[1]](function () {
                  var e = i && i.apply(this, arguments);
                  e && g(e.promise) ? e.promise().progress(t.notify).done(t.resolve).fail(t.reject) : t[r[0] + "With"](this, i ? [e] : arguments);
                });
              }), e = null;
            }).promise();
          },
          then: function (t, r, i) {
            var o = 0;
            function a(t, n, r, i) {
              return function () {
                var s = this,
                  u = arguments,
                  l = function () {
                    var e, l;
                    if (!(t < o)) {
                      if ((e = r.apply(s, u)) === n.promise()) throw new TypeError("Thenable self-resolution");
                      l = e && ("object" == typeof e || "function" == typeof e) && e.then, g(l) ? i ? l.call(e, a(o, n, I, i), a(o, n, W, i)) : (o++, l.call(e, a(o, n, I, i), a(o, n, W, i), a(o, n, I, n.notifyWith))) : (r !== I && (s = void 0, u = [e]), (i || n.resolveWith)(s, u));
                    }
                  },
                  c = i ? l : function () {
                    try {
                      l();
                    } catch (e) {
                      w.Deferred.exceptionHook && w.Deferred.exceptionHook(e, c.stackTrace), t + 1 >= o && (r !== W && (s = void 0, u = [e]), n.rejectWith(s, u));
                    }
                  };
                t ? c() : (w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook()), e.setTimeout(c));
              };
            }
            return w.Deferred(function (e) {
              n[0][3].add(a(0, e, g(i) ? i : I, e.notifyWith)), n[1][3].add(a(0, e, g(t) ? t : I)), n[2][3].add(a(0, e, g(r) ? r : W));
            }).promise();
          },
          promise: function (e) {
            return null != e ? w.extend(e, i) : i;
          }
        },
        o = {};
      return w.each(n, function (e, t) {
        var a = t[2],
          s = t[5];
        i[t[1]] = a.add, s && a.add(function () {
          r = s;
        }, n[3 - e][2].disable, n[3 - e][3].disable, n[0][2].lock, n[0][3].lock), a.add(t[3].fire), o[t[0]] = function () {
          return o[t[0] + "With"](this === o ? void 0 : this, arguments), this;
        }, o[t[0] + "With"] = a.fireWith;
      }), i.promise(o), t && t.call(o, o), o;
    },
    when: function (e) {
      var t = arguments.length,
        n = t,
        r = Array(n),
        i = o.call(arguments),
        a = w.Deferred(),
        s = function (e) {
          return function (n) {
            r[e] = this, i[e] = arguments.length > 1 ? o.call(arguments) : n, --t || a.resolveWith(r, i);
          };
        };
      if (t <= 1 && ($(e, a.done(s(n)).resolve, a.reject, !t), "pending" === a.state() || g(i[n] && i[n].then))) return a.then();
      while (n--) $(i[n], s(n), a.reject);
      return a.promise();
    }
  });
  var B = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  w.Deferred.exceptionHook = function (t, n) {
    e.console && e.console.warn && t && B.test(t.name) && e.console.warn("jQuery.Deferred exception: " + t.message, t.stack, n);
  }, w.readyException = function (t) {
    e.setTimeout(function () {
      throw t;
    });
  };
  var F = w.Deferred();
  w.fn.ready = function (e) {
    return F.then(e)["catch"](function (e) {
      w.readyException(e);
    }), this;
  }, w.extend({
    isReady: !1,
    readyWait: 1,
    ready: function (e) {
      (!0 === e ? --w.readyWait : w.isReady) || (w.isReady = !0, !0 !== e && --w.readyWait > 0 || F.resolveWith(r, [w]));
    }
  }), w.ready.then = F.then;
  function _() {
    r.removeEventListener("DOMContentLoaded", _), e.removeEventListener("load", _), w.ready();
  }
  "complete" === r.readyState || "loading" !== r.readyState && !r.documentElement.doScroll ? e.setTimeout(w.ready) : (r.addEventListener("DOMContentLoaded", _), e.addEventListener("load", _));
  var z = function (e, t, n, r, i, o, a) {
      var s = 0,
        u = e.length,
        l = null == n;
      if ("object" === x(n)) {
        i = !0;
        for (s in n) z(e, t, s, n[s], !0, o, a);
      } else if (void 0 !== r && (i = !0, g(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) {
        return l.call(w(e), n);
      })), t)) for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
      return i ? e : l ? t.call(e) : u ? t(e[0], n) : o;
    },
    X = /^-ms-/,
    U = /-([a-z])/g;
  function V(e, t) {
    return t.toUpperCase();
  }
  function G(e) {
    return e.replace(X, "ms-").replace(U, V);
  }
  var Y = function (e) {
    return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
  };
  function Q() {
    this.expando = w.expando + Q.uid++;
  }
  Q.uid = 1, Q.prototype = {
    cache: function (e) {
      var t = e[this.expando];
      return t || (t = {}, Y(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
        value: t,
        configurable: !0
      }))), t;
    },
    set: function (e, t, n) {
      var r,
        i = this.cache(e);
      if ("string" == typeof t) i[G(t)] = n;else for (r in t) i[G(r)] = t[r];
      return i;
    },
    get: function (e, t) {
      return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][G(t)];
    },
    access: function (e, t, n) {
      return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t);
    },
    remove: function (e, t) {
      var n,
        r = e[this.expando];
      if (void 0 !== r) {
        if (void 0 !== t) {
          n = (t = Array.isArray(t) ? t.map(G) : (t = G(t)) in r ? [t] : t.match(M) || []).length;
          while (n--) delete r[t[n]];
        }
        (void 0 === t || w.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]);
      }
    },
    hasData: function (e) {
      var t = e[this.expando];
      return void 0 !== t && !w.isEmptyObject(t);
    }
  };
  var J = new Q(),
    K = new Q(),
    Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    ee = /[A-Z]/g;
  function te(e) {
    return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : Z.test(e) ? JSON.parse(e) : e);
  }
  function ne(e, t, n) {
    var r;
    if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(ee, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) {
      try {
        n = te(n);
      } catch (e) {}
      K.set(e, t, n);
    } else n = void 0;
    return n;
  }
  w.extend({
    hasData: function (e) {
      return K.hasData(e) || J.hasData(e);
    },
    data: function (e, t, n) {
      return K.access(e, t, n);
    },
    removeData: function (e, t) {
      K.remove(e, t);
    },
    _data: function (e, t, n) {
      return J.access(e, t, n);
    },
    _removeData: function (e, t) {
      J.remove(e, t);
    }
  }), w.fn.extend({
    data: function (e, t) {
      var n,
        r,
        i,
        o = this[0],
        a = o && o.attributes;
      if (void 0 === e) {
        if (this.length && (i = K.get(o), 1 === o.nodeType && !J.get(o, "hasDataAttrs"))) {
          n = a.length;
          while (n--) a[n] && 0 === (r = a[n].name).indexOf("data-") && (r = G(r.slice(5)), ne(o, r, i[r]));
          J.set(o, "hasDataAttrs", !0);
        }
        return i;
      }
      return "object" == typeof e ? this.each(function () {
        K.set(this, e);
      }) : z(this, function (t) {
        var n;
        if (o && void 0 === t) {
          if (void 0 !== (n = K.get(o, e))) return n;
          if (void 0 !== (n = ne(o, e))) return n;
        } else this.each(function () {
          K.set(this, e, t);
        });
      }, null, t, arguments.length > 1, null, !0);
    },
    removeData: function (e) {
      return this.each(function () {
        K.remove(this, e);
      });
    }
  }), w.extend({
    queue: function (e, t, n) {
      var r;
      if (e) return t = (t || "fx") + "queue", r = J.get(e, t), n && (!r || Array.isArray(n) ? r = J.access(e, t, w.makeArray(n)) : r.push(n)), r || [];
    },
    dequeue: function (e, t) {
      t = t || "fx";
      var n = w.queue(e, t),
        r = n.length,
        i = n.shift(),
        o = w._queueHooks(e, t),
        a = function () {
          w.dequeue(e, t);
        };
      "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire();
    },
    _queueHooks: function (e, t) {
      var n = t + "queueHooks";
      return J.get(e, n) || J.access(e, n, {
        empty: w.Callbacks("once memory").add(function () {
          J.remove(e, [t + "queue", n]);
        })
      });
    }
  }), w.fn.extend({
    queue: function (e, t) {
      var n = 2;
      return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? w.queue(this[0], e) : void 0 === t ? this : this.each(function () {
        var n = w.queue(this, e, t);
        w._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && w.dequeue(this, e);
      });
    },
    dequeue: function (e) {
      return this.each(function () {
        w.dequeue(this, e);
      });
    },
    clearQueue: function (e) {
      return this.queue(e || "fx", []);
    },
    promise: function (e, t) {
      var n,
        r = 1,
        i = w.Deferred(),
        o = this,
        a = this.length,
        s = function () {
          --r || i.resolveWith(o, [o]);
        };
      "string" != typeof e && (t = e, e = void 0), e = e || "fx";
      while (a--) (n = J.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
      return s(), i.promise(t);
    }
  });
  var re = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    ie = new RegExp("^(?:([+-])=|)(" + re + ")([a-z%]*)$", "i"),
    oe = ["Top", "Right", "Bottom", "Left"],
    ae = function (e, t) {
      return "none" === (e = t || e).style.display || "" === e.style.display && w.contains(e.ownerDocument, e) && "none" === w.css(e, "display");
    },
    se = function (e, t, n, r) {
      var i,
        o,
        a = {};
      for (o in t) a[o] = e.style[o], e.style[o] = t[o];
      i = n.apply(e, r || []);
      for (o in t) e.style[o] = a[o];
      return i;
    };
  function ue(e, t, n, r) {
    var i,
      o,
      a = 20,
      s = r ? function () {
        return r.cur();
      } : function () {
        return w.css(e, t, "");
      },
      u = s(),
      l = n && n[3] || (w.cssNumber[t] ? "" : "px"),
      c = (w.cssNumber[t] || "px" !== l && +u) && ie.exec(w.css(e, t));
    if (c && c[3] !== l) {
      u /= 2, l = l || c[3], c = +u || 1;
      while (a--) w.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
      c *= 2, w.style(e, t, c + l), n = n || [];
    }
    return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i;
  }
  var le = {};
  function ce(e) {
    var t,
      n = e.ownerDocument,
      r = e.nodeName,
      i = le[r];
    return i || (t = n.body.appendChild(n.createElement(r)), i = w.css(t, "display"), t.parentNode.removeChild(t), "none" === i && (i = "block"), le[r] = i, i);
  }
  function fe(e, t) {
    for (var n, r, i = [], o = 0, a = e.length; o < a; o++) (r = e[o]).style && (n = r.style.display, t ? ("none" === n && (i[o] = J.get(r, "display") || null, i[o] || (r.style.display = "")), "" === r.style.display && ae(r) && (i[o] = ce(r))) : "none" !== n && (i[o] = "none", J.set(r, "display", n)));
    for (o = 0; o < a; o++) null != i[o] && (e[o].style.display = i[o]);
    return e;
  }
  w.fn.extend({
    show: function () {
      return fe(this, !0);
    },
    hide: function () {
      return fe(this);
    },
    toggle: function (e) {
      return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
        ae(this) ? w(this).show() : w(this).hide();
      });
    }
  });
  var pe = /^(?:checkbox|radio)$/i,
    de = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
    he = /^$|^module$|\/(?:java|ecma)script/i,
    ge = {
      option: [1, "<select multiple='multiple'>", "</select>"],
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
  ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td;
  function ye(e, t) {
    var n;
    return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && N(e, t) ? w.merge([e], n) : n;
  }
  function ve(e, t) {
    for (var n = 0, r = e.length; n < r; n++) J.set(e[n], "globalEval", !t || J.get(t[n], "globalEval"));
  }
  var me = /<|&#?\w+;/;
  function xe(e, t, n, r, i) {
    for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++) if ((o = e[d]) || 0 === o) if ("object" === x(o)) w.merge(p, o.nodeType ? [o] : o);else if (me.test(o)) {
      a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + w.htmlPrefilter(o) + u[2], c = u[0];
      while (c--) a = a.lastChild;
      w.merge(p, a.childNodes), (a = f.firstChild).textContent = "";
    } else p.push(t.createTextNode(o));
    f.textContent = "", d = 0;
    while (o = p[d++]) if (r && w.inArray(o, r) > -1) i && i.push(o);else if (l = w.contains(o.ownerDocument, o), a = ye(f.appendChild(o), "script"), l && ve(a), n) {
      c = 0;
      while (o = a[c++]) he.test(o.type || "") && n.push(o);
    }
    return f;
  }
  !function () {
    var e = r.createDocumentFragment().appendChild(r.createElement("div")),
      t = r.createElement("input");
    t.setAttribute("type", "radio"), t.setAttribute("checked", "checked"), t.setAttribute("name", "t"), e.appendChild(t), h.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = "<textarea>x</textarea>", h.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue;
  }();
  var be = r.documentElement,
    we = /^key/,
    Te = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
    Ce = /^([^.]*)(?:\.(.+)|)/;
  function Ee() {
    return !0;
  }
  function ke() {
    return !1;
  }
  function Se() {
    try {
      return r.activeElement;
    } catch (e) {}
  }
  function De(e, t, n, r, i, o) {
    var a, s;
    if ("object" == typeof t) {
      "string" != typeof n && (r = r || n, n = void 0);
      for (s in t) De(e, s, n, r, t[s], o);
      return e;
    }
    if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = ke;else if (!i) return e;
    return 1 === o && (a = i, (i = function (e) {
      return w().off(e), a.apply(this, arguments);
    }).guid = a.guid || (a.guid = w.guid++)), e.each(function () {
      w.event.add(this, t, i, r, n);
    });
  }
  w.event = {
    global: {},
    add: function (e, t, n, r, i) {
      var o,
        a,
        s,
        u,
        l,
        c,
        f,
        p,
        d,
        h,
        g,
        y = J.get(e);
      if (y) {
        n.handler && (n = (o = n).handler, i = o.selector), i && w.find.matchesSelector(be, i), n.guid || (n.guid = w.guid++), (u = y.events) || (u = y.events = {}), (a = y.handle) || (a = y.handle = function (t) {
          return "undefined" != typeof w && w.event.triggered !== t.type ? w.event.dispatch.apply(e, arguments) : void 0;
        }), l = (t = (t || "").match(M) || [""]).length;
        while (l--) d = g = (s = Ce.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = w.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = w.event.special[d] || {}, c = w.extend({
          type: d,
          origType: g,
          data: r,
          handler: n,
          guid: n.guid,
          selector: i,
          needsContext: i && w.expr.match.needsContext.test(i),
          namespace: h.join(".")
        }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(e, r, h, a) || e.addEventListener && e.addEventListener(d, a)), f.add && (f.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), w.event.global[d] = !0);
      }
    },
    remove: function (e, t, n, r, i) {
      var o,
        a,
        s,
        u,
        l,
        c,
        f,
        p,
        d,
        h,
        g,
        y = J.hasData(e) && J.get(e);
      if (y && (u = y.events)) {
        l = (t = (t || "").match(M) || [""]).length;
        while (l--) if (s = Ce.exec(t[l]) || [], d = g = s[1], h = (s[2] || "").split(".").sort(), d) {
          f = w.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length;
          while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
          a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, y.handle) || w.removeEvent(e, d, y.handle), delete u[d]);
        } else for (d in u) w.event.remove(e, d + t[l], n, r, !0);
        w.isEmptyObject(u) && J.remove(e, "handle events");
      }
    },
    dispatch: function (e) {
      var t = w.event.fix(e),
        n,
        r,
        i,
        o,
        a,
        s,
        u = new Array(arguments.length),
        l = (J.get(this, "events") || {})[t.type] || [],
        c = w.event.special[t.type] || {};
      for (u[0] = t, n = 1; n < arguments.length; n++) u[n] = arguments[n];
      if (t.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, t)) {
        s = w.event.handlers.call(this, t, l), n = 0;
        while ((o = s[n++]) && !t.isPropagationStopped()) {
          t.currentTarget = o.elem, r = 0;
          while ((a = o.handlers[r++]) && !t.isImmediatePropagationStopped()) t.rnamespace && !t.rnamespace.test(a.namespace) || (t.handleObj = a, t.data = a.data, void 0 !== (i = ((w.event.special[a.origType] || {}).handle || a.handler).apply(o.elem, u)) && !1 === (t.result = i) && (t.preventDefault(), t.stopPropagation()));
        }
        return c.postDispatch && c.postDispatch.call(this, t), t.result;
      }
    },
    handlers: function (e, t) {
      var n,
        r,
        i,
        o,
        a,
        s = [],
        u = t.delegateCount,
        l = e.target;
      if (u && l.nodeType && !("click" === e.type && e.button >= 1)) for (; l !== this; l = l.parentNode || this) if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
        for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? w(i, this).index(l) > -1 : w.find(i, this, null, [l]).length), a[i] && o.push(r);
        o.length && s.push({
          elem: l,
          handlers: o
        });
      }
      return l = this, u < t.length && s.push({
        elem: l,
        handlers: t.slice(u)
      }), s;
    },
    addProp: function (e, t) {
      Object.defineProperty(w.Event.prototype, e, {
        enumerable: !0,
        configurable: !0,
        get: g(t) ? function () {
          if (this.originalEvent) return t(this.originalEvent);
        } : function () {
          if (this.originalEvent) return this.originalEvent[e];
        },
        set: function (t) {
          Object.defineProperty(this, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: t
          });
        }
      });
    },
    fix: function (e) {
      return e[w.expando] ? e : new w.Event(e);
    },
    special: {
      load: {
        noBubble: !0
      },
      focus: {
        trigger: function () {
          if (this !== Se() && this.focus) return this.focus(), !1;
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function () {
          if (this === Se() && this.blur) return this.blur(), !1;
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function () {
          if ("checkbox" === this.type && this.click && N(this, "input")) return this.click(), !1;
        },
        _default: function (e) {
          return N(e.target, "a");
        }
      },
      beforeunload: {
        postDispatch: function (e) {
          void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);
        }
      }
    }
  }, w.removeEvent = function (e, t, n) {
    e.removeEventListener && e.removeEventListener(t, n);
  }, w.Event = function (e, t) {
    if (!(this instanceof w.Event)) return new w.Event(e, t);
    e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ee : ke, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && w.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[w.expando] = !0;
  }, w.Event.prototype = {
    constructor: w.Event,
    isDefaultPrevented: ke,
    isPropagationStopped: ke,
    isImmediatePropagationStopped: ke,
    isSimulated: !1,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = Ee, e && !this.isSimulated && e.preventDefault();
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = Ee, e && !this.isSimulated && e.stopPropagation();
    },
    stopImmediatePropagation: function () {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = Ee, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation();
    }
  }, w.each({
    altKey: !0,
    bubbles: !0,
    cancelable: !0,
    changedTouches: !0,
    ctrlKey: !0,
    detail: !0,
    eventPhase: !0,
    metaKey: !0,
    pageX: !0,
    pageY: !0,
    shiftKey: !0,
    view: !0,
    "char": !0,
    charCode: !0,
    key: !0,
    keyCode: !0,
    button: !0,
    buttons: !0,
    clientX: !0,
    clientY: !0,
    offsetX: !0,
    offsetY: !0,
    pointerId: !0,
    pointerType: !0,
    screenX: !0,
    screenY: !0,
    targetTouches: !0,
    toElement: !0,
    touches: !0,
    which: function (e) {
      var t = e.button;
      return null == e.which && we.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && Te.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which;
    }
  }, w.event.addProp), w.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (e, t) {
    w.event.special[e] = {
      delegateType: t,
      bindType: t,
      handle: function (e) {
        var n,
          r = this,
          i = e.relatedTarget,
          o = e.handleObj;
        return i && (i === r || w.contains(r, i)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n;
      }
    };
  }), w.fn.extend({
    on: function (e, t, n, r) {
      return De(this, e, t, n, r);
    },
    one: function (e, t, n, r) {
      return De(this, e, t, n, r, 1);
    },
    off: function (e, t, n) {
      var r, i;
      if (e && e.preventDefault && e.handleObj) return r = e.handleObj, w(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
      if ("object" == typeof e) {
        for (i in e) this.off(i, t, e[i]);
        return this;
      }
      return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = ke), this.each(function () {
        w.event.remove(this, e, n, t);
      });
    }
  });
  var Ne = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
    Ae = /<script|<style|<link/i,
    je = /checked\s*(?:[^=]|=\s*.checked.)/i,
    qe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function Le(e, t) {
    return N(e, "table") && N(11 !== t.nodeType ? t : t.firstChild, "tr") ? w(e).children("tbody")[0] || e : e;
  }
  function He(e) {
    return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e;
  }
  function Oe(e) {
    return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e;
  }
  function Pe(e, t) {
    var n, r, i, o, a, s, u, l;
    if (1 === t.nodeType) {
      if (J.hasData(e) && (o = J.access(e), a = J.set(t, o), l = o.events)) {
        delete a.handle, a.events = {};
        for (i in l) for (n = 0, r = l[i].length; n < r; n++) w.event.add(t, i, l[i][n]);
      }
      K.hasData(e) && (s = K.access(e), u = w.extend({}, s), K.set(t, u));
    }
  }
  function Me(e, t) {
    var n = t.nodeName.toLowerCase();
    "input" === n && pe.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue);
  }
  function Re(e, t, n, r) {
    t = a.apply([], t);
    var i,
      o,
      s,
      u,
      l,
      c,
      f = 0,
      p = e.length,
      d = p - 1,
      y = t[0],
      v = g(y);
    if (v || p > 1 && "string" == typeof y && !h.checkClone && je.test(y)) return e.each(function (i) {
      var o = e.eq(i);
      v && (t[0] = y.call(this, i, o.html())), Re(o, t, n, r);
    });
    if (p && (i = xe(t, e[0].ownerDocument, !1, e, r), o = i.firstChild, 1 === i.childNodes.length && (i = o), o || r)) {
      for (u = (s = w.map(ye(i, "script"), He)).length; f < p; f++) l = i, f !== d && (l = w.clone(l, !0, !0), u && w.merge(s, ye(l, "script"))), n.call(e[f], l, f);
      if (u) for (c = s[s.length - 1].ownerDocument, w.map(s, Oe), f = 0; f < u; f++) l = s[f], he.test(l.type || "") && !J.access(l, "globalEval") && w.contains(c, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? w._evalUrl && w._evalUrl(l.src) : m(l.textContent.replace(qe, ""), c, l));
    }
    return e;
  }
  function Ie(e, t, n) {
    for (var r, i = t ? w.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || w.cleanData(ye(r)), r.parentNode && (n && w.contains(r.ownerDocument, r) && ve(ye(r, "script")), r.parentNode.removeChild(r));
    return e;
  }
  w.extend({
    htmlPrefilter: function (e) {
      return e.replace(Ne, "<$1></$2>");
    },
    clone: function (e, t, n) {
      var r,
        i,
        o,
        a,
        s = e.cloneNode(!0),
        u = w.contains(e.ownerDocument, e);
      if (!(h.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || w.isXMLDoc(e))) for (a = ye(s), r = 0, i = (o = ye(e)).length; r < i; r++) Me(o[r], a[r]);
      if (t) if (n) for (o = o || ye(e), a = a || ye(s), r = 0, i = o.length; r < i; r++) Pe(o[r], a[r]);else Pe(e, s);
      return (a = ye(s, "script")).length > 0 && ve(a, !u && ye(e, "script")), s;
    },
    cleanData: function (e) {
      for (var t, n, r, i = w.event.special, o = 0; void 0 !== (n = e[o]); o++) if (Y(n)) {
        if (t = n[J.expando]) {
          if (t.events) for (r in t.events) i[r] ? w.event.remove(n, r) : w.removeEvent(n, r, t.handle);
          n[J.expando] = void 0;
        }
        n[K.expando] && (n[K.expando] = void 0);
      }
    }
  }), w.fn.extend({
    detach: function (e) {
      return Ie(this, e, !0);
    },
    remove: function (e) {
      return Ie(this, e);
    },
    text: function (e) {
      return z(this, function (e) {
        return void 0 === e ? w.text(this) : this.empty().each(function () {
          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e);
        });
      }, null, e, arguments.length);
    },
    append: function () {
      return Re(this, arguments, function (e) {
        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Le(this, e).appendChild(e);
      });
    },
    prepend: function () {
      return Re(this, arguments, function (e) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var t = Le(this, e);
          t.insertBefore(e, t.firstChild);
        }
      });
    },
    before: function () {
      return Re(this, arguments, function (e) {
        this.parentNode && this.parentNode.insertBefore(e, this);
      });
    },
    after: function () {
      return Re(this, arguments, function (e) {
        this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
      });
    },
    empty: function () {
      for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (w.cleanData(ye(e, !1)), e.textContent = "");
      return this;
    },
    clone: function (e, t) {
      return e = null != e && e, t = null == t ? e : t, this.map(function () {
        return w.clone(this, e, t);
      });
    },
    html: function (e) {
      return z(this, function (e) {
        var t = this[0] || {},
          n = 0,
          r = this.length;
        if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
        if ("string" == typeof e && !Ae.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) {
          e = w.htmlPrefilter(e);
          try {
            for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (w.cleanData(ye(t, !1)), t.innerHTML = e);
            t = 0;
          } catch (e) {}
        }
        t && this.empty().append(e);
      }, null, e, arguments.length);
    },
    replaceWith: function () {
      var e = [];
      return Re(this, arguments, function (t) {
        var n = this.parentNode;
        w.inArray(this, e) < 0 && (w.cleanData(ye(this)), n && n.replaceChild(t, this));
      }, e);
    }
  }), w.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (e, t) {
    w.fn[e] = function (e) {
      for (var n, r = [], i = w(e), o = i.length - 1, a = 0; a <= o; a++) n = a === o ? this : this.clone(!0), w(i[a])[t](n), s.apply(r, n.get());
      return this.pushStack(r);
    };
  });
  var We = new RegExp("^(" + re + ")(?!px)[a-z%]+$", "i"),
    $e = function (t) {
      var n = t.ownerDocument.defaultView;
      return n && n.opener || (n = e), n.getComputedStyle(t);
    },
    Be = new RegExp(oe.join("|"), "i");
  !function () {
    function t() {
      if (c) {
        l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", c.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", be.appendChild(l).appendChild(c);
        var t = e.getComputedStyle(c);
        i = "1%" !== t.top, u = 12 === n(t.marginLeft), c.style.right = "60%", s = 36 === n(t.right), o = 36 === n(t.width), c.style.position = "absolute", a = 36 === c.offsetWidth || "absolute", be.removeChild(l), c = null;
      }
    }
    function n(e) {
      return Math.round(parseFloat(e));
    }
    var i,
      o,
      a,
      s,
      u,
      l = r.createElement("div"),
      c = r.createElement("div");
    c.style && (c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", h.clearCloneStyle = "content-box" === c.style.backgroundClip, w.extend(h, {
      boxSizingReliable: function () {
        return t(), o;
      },
      pixelBoxStyles: function () {
        return t(), s;
      },
      pixelPosition: function () {
        return t(), i;
      },
      reliableMarginLeft: function () {
        return t(), u;
      },
      scrollboxSize: function () {
        return t(), a;
      }
    }));
  }();
  function Fe(e, t, n) {
    var r,
      i,
      o,
      a,
      s = e.style;
    return (n = n || $e(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || w.contains(e.ownerDocument, e) || (a = w.style(e, t)), !h.pixelBoxStyles() && We.test(a) && Be.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a;
  }
  function _e(e, t) {
    return {
      get: function () {
        if (!e()) return (this.get = t).apply(this, arguments);
        delete this.get;
      }
    };
  }
  var ze = /^(none|table(?!-c[ea]).+)/,
    Xe = /^--/,
    Ue = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Ve = {
      letterSpacing: "0",
      fontWeight: "400"
    },
    Ge = ["Webkit", "Moz", "ms"],
    Ye = r.createElement("div").style;
  function Qe(e) {
    if (e in Ye) return e;
    var t = e[0].toUpperCase() + e.slice(1),
      n = Ge.length;
    while (n--) if ((e = Ge[n] + t) in Ye) return e;
  }
  function Je(e) {
    var t = w.cssProps[e];
    return t || (t = w.cssProps[e] = Qe(e) || e), t;
  }
  function Ke(e, t, n) {
    var r = ie.exec(t);
    return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t;
  }
  function Ze(e, t, n, r, i, o) {
    var a = "width" === t ? 1 : 0,
      s = 0,
      u = 0;
    if (n === (r ? "border" : "content")) return 0;
    for (; a < 4; a += 2) "margin" === n && (u += w.css(e, n + oe[a], !0, i)), r ? ("content" === n && (u -= w.css(e, "padding" + oe[a], !0, i)), "margin" !== n && (u -= w.css(e, "border" + oe[a] + "Width", !0, i))) : (u += w.css(e, "padding" + oe[a], !0, i), "padding" !== n ? u += w.css(e, "border" + oe[a] + "Width", !0, i) : s += w.css(e, "border" + oe[a] + "Width", !0, i));
    return !r && o >= 0 && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5))), u;
  }
  function et(e, t, n) {
    var r = $e(e),
      i = Fe(e, t, r),
      o = "border-box" === w.css(e, "boxSizing", !1, r),
      a = o;
    if (We.test(i)) {
      if (!n) return i;
      i = "auto";
    }
    return a = a && (h.boxSizingReliable() || i === e.style[t]), ("auto" === i || !parseFloat(i) && "inline" === w.css(e, "display", !1, r)) && (i = e["offset" + t[0].toUpperCase() + t.slice(1)], a = !0), (i = parseFloat(i) || 0) + Ze(e, t, n || (o ? "border" : "content"), a, r, i) + "px";
  }
  w.extend({
    cssHooks: {
      opacity: {
        get: function (e, t) {
          if (t) {
            var n = Fe(e, "opacity");
            return "" === n ? "1" : n;
          }
        }
      }
    },
    cssNumber: {
      animationIterationCount: !0,
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {},
    style: function (e, t, n, r) {
      if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
        var i,
          o,
          a,
          s = G(t),
          u = Xe.test(t),
          l = e.style;
        if (u || (t = Je(s)), a = w.cssHooks[t] || w.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
        "string" == (o = typeof n) && (i = ie.exec(n)) && i[1] && (n = ue(e, t, i), o = "number"), null != n && n === n && ("number" === o && (n += i && i[3] || (w.cssNumber[s] ? "" : "px")), h.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n));
      }
    },
    css: function (e, t, n, r) {
      var i,
        o,
        a,
        s = G(t);
      return Xe.test(t) || (t = Je(s)), (a = w.cssHooks[t] || w.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = Fe(e, t, r)), "normal" === i && t in Ve && (i = Ve[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i;
    }
  }), w.each(["height", "width"], function (e, t) {
    w.cssHooks[t] = {
      get: function (e, n, r) {
        if (n) return !ze.test(w.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? et(e, t, r) : se(e, Ue, function () {
          return et(e, t, r);
        });
      },
      set: function (e, n, r) {
        var i,
          o = $e(e),
          a = "border-box" === w.css(e, "boxSizing", !1, o),
          s = r && Ze(e, t, r, a, o);
        return a && h.scrollboxSize() === o.position && (s -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(o[t]) - Ze(e, t, "border", !1, o) - .5)), s && (i = ie.exec(n)) && "px" !== (i[3] || "px") && (e.style[t] = n, n = w.css(e, t)), Ke(e, n, s);
      }
    };
  }), w.cssHooks.marginLeft = _e(h.reliableMarginLeft, function (e, t) {
    if (t) return (parseFloat(Fe(e, "marginLeft")) || e.getBoundingClientRect().left - se(e, {
      marginLeft: 0
    }, function () {
      return e.getBoundingClientRect().left;
    })) + "px";
  }), w.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (e, t) {
    w.cssHooks[e + t] = {
      expand: function (n) {
        for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++) i[e + oe[r] + t] = o[r] || o[r - 2] || o[0];
        return i;
      }
    }, "margin" !== e && (w.cssHooks[e + t].set = Ke);
  }), w.fn.extend({
    css: function (e, t) {
      return z(this, function (e, t, n) {
        var r,
          i,
          o = {},
          a = 0;
        if (Array.isArray(t)) {
          for (r = $e(e), i = t.length; a < i; a++) o[t[a]] = w.css(e, t[a], !1, r);
          return o;
        }
        return void 0 !== n ? w.style(e, t, n) : w.css(e, t);
      }, e, t, arguments.length > 1);
    }
  });
  function tt(e, t, n, r, i) {
    return new tt.prototype.init(e, t, n, r, i);
  }
  w.Tween = tt, tt.prototype = {
    constructor: tt,
    init: function (e, t, n, r, i, o) {
      this.elem = e, this.prop = n, this.easing = i || w.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (w.cssNumber[n] ? "" : "px");
    },
    cur: function () {
      var e = tt.propHooks[this.prop];
      return e && e.get ? e.get(this) : tt.propHooks._default.get(this);
    },
    run: function (e) {
      var t,
        n = tt.propHooks[this.prop];
      return this.options.duration ? this.pos = t = w.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : tt.propHooks._default.set(this), this;
    }
  }, tt.prototype.init.prototype = tt.prototype, tt.propHooks = {
    _default: {
      get: function (e) {
        var t;
        return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = w.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0;
      },
      set: function (e) {
        w.fx.step[e.prop] ? w.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[w.cssProps[e.prop]] && !w.cssHooks[e.prop] ? e.elem[e.prop] = e.now : w.style(e.elem, e.prop, e.now + e.unit);
      }
    }
  }, tt.propHooks.scrollTop = tt.propHooks.scrollLeft = {
    set: function (e) {
      e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
    }
  }, w.easing = {
    linear: function (e) {
      return e;
    },
    swing: function (e) {
      return .5 - Math.cos(e * Math.PI) / 2;
    },
    _default: "swing"
  }, w.fx = tt.prototype.init, w.fx.step = {};
  var nt,
    rt,
    it = /^(?:toggle|show|hide)$/,
    ot = /queueHooks$/;
  function at() {
    rt && (!1 === r.hidden && e.requestAnimationFrame ? e.requestAnimationFrame(at) : e.setTimeout(at, w.fx.interval), w.fx.tick());
  }
  function st() {
    return e.setTimeout(function () {
      nt = void 0;
    }), nt = Date.now();
  }
  function ut(e, t) {
    var n,
      r = 0,
      i = {
        height: e
      };
    for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = oe[r])] = i["padding" + n] = e;
    return t && (i.opacity = i.width = e), i;
  }
  function lt(e, t, n) {
    for (var r, i = (pt.tweeners[t] || []).concat(pt.tweeners["*"]), o = 0, a = i.length; o < a; o++) if (r = i[o].call(n, t, e)) return r;
  }
  function ct(e, t, n) {
    var r,
      i,
      o,
      a,
      s,
      u,
      l,
      c,
      f = "width" in t || "height" in t,
      p = this,
      d = {},
      h = e.style,
      g = e.nodeType && ae(e),
      y = J.get(e, "fxshow");
    n.queue || (null == (a = w._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
      a.unqueued || s();
    }), a.unqueued++, p.always(function () {
      p.always(function () {
        a.unqueued--, w.queue(e, "fx").length || a.empty.fire();
      });
    }));
    for (r in t) if (i = t[r], it.test(i)) {
      if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
        if ("show" !== i || !y || void 0 === y[r]) continue;
        g = !0;
      }
      d[r] = y && y[r] || w.style(e, r);
    }
    if ((u = !w.isEmptyObject(t)) || !w.isEmptyObject(d)) {
      f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = y && y.display) && (l = J.get(e, "display")), "none" === (c = w.css(e, "display")) && (l ? c = l : (fe([e], !0), l = e.style.display || l, c = w.css(e, "display"), fe([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === w.css(e, "float") && (u || (p.done(function () {
        h.display = l;
      }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () {
        h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2];
      })), u = !1;
      for (r in d) u || (y ? "hidden" in y && (g = y.hidden) : y = J.access(e, "fxshow", {
        display: l
      }), o && (y.hidden = !g), g && fe([e], !0), p.done(function () {
        g || fe([e]), J.remove(e, "fxshow");
        for (r in d) w.style(e, r, d[r]);
      })), u = lt(g ? y[r] : 0, r, p), r in y || (y[r] = u.start, g && (u.end = u.start, u.start = 0));
    }
  }
  function ft(e, t) {
    var n, r, i, o, a;
    for (n in e) if (r = G(n), i = t[r], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = w.cssHooks[r]) && "expand" in a) {
      o = a.expand(o), delete e[r];
      for (n in o) n in e || (e[n] = o[n], t[n] = i);
    } else t[r] = i;
  }
  function pt(e, t, n) {
    var r,
      i,
      o = 0,
      a = pt.prefilters.length,
      s = w.Deferred().always(function () {
        delete u.elem;
      }),
      u = function () {
        if (i) return !1;
        for (var t = nt || st(), n = Math.max(0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), o = 0, a = l.tweens.length; o < a; o++) l.tweens[o].run(r);
        return s.notifyWith(e, [l, r, n]), r < 1 && a ? n : (a || s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l]), !1);
      },
      l = s.promise({
        elem: e,
        props: w.extend({}, t),
        opts: w.extend(!0, {
          specialEasing: {},
          easing: w.easing._default
        }, n),
        originalProperties: t,
        originalOptions: n,
        startTime: nt || st(),
        duration: n.duration,
        tweens: [],
        createTween: function (t, n) {
          var r = w.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing);
          return l.tweens.push(r), r;
        },
        stop: function (t) {
          var n = 0,
            r = t ? l.tweens.length : 0;
          if (i) return this;
          for (i = !0; n < r; n++) l.tweens[n].run(1);
          return t ? (s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l, t])) : s.rejectWith(e, [l, t]), this;
        }
      }),
      c = l.props;
    for (ft(c, l.opts.specialEasing); o < a; o++) if (r = pt.prefilters[o].call(l, e, c, l.opts)) return g(r.stop) && (w._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)), r;
    return w.map(c, lt, l), g(l.opts.start) && l.opts.start.call(e, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), w.fx.timer(w.extend(u, {
      elem: e,
      anim: l,
      queue: l.opts.queue
    })), l;
  }
  w.Animation = w.extend(pt, {
    tweeners: {
      "*": [function (e, t) {
        var n = this.createTween(e, t);
        return ue(n.elem, e, ie.exec(t), n), n;
      }]
    },
    tweener: function (e, t) {
      g(e) ? (t = e, e = ["*"]) : e = e.match(M);
      for (var n, r = 0, i = e.length; r < i; r++) n = e[r], pt.tweeners[n] = pt.tweeners[n] || [], pt.tweeners[n].unshift(t);
    },
    prefilters: [ct],
    prefilter: function (e, t) {
      t ? pt.prefilters.unshift(e) : pt.prefilters.push(e);
    }
  }), w.speed = function (e, t, n) {
    var r = e && "object" == typeof e ? w.extend({}, e) : {
      complete: n || !n && t || g(e) && e,
      duration: e,
      easing: n && t || t && !g(t) && t
    };
    return w.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in w.fx.speeds ? r.duration = w.fx.speeds[r.duration] : r.duration = w.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () {
      g(r.old) && r.old.call(this), r.queue && w.dequeue(this, r.queue);
    }, r;
  }, w.fn.extend({
    fadeTo: function (e, t, n, r) {
      return this.filter(ae).css("opacity", 0).show().end().animate({
        opacity: t
      }, e, n, r);
    },
    animate: function (e, t, n, r) {
      var i = w.isEmptyObject(e),
        o = w.speed(t, n, r),
        a = function () {
          var t = pt(this, w.extend({}, e), o);
          (i || J.get(this, "finish")) && t.stop(!0);
        };
      return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a);
    },
    stop: function (e, t, n) {
      var r = function (e) {
        var t = e.stop;
        delete e.stop, t(n);
      };
      return "string" != typeof e && (n = t, t = e, e = void 0), t && !1 !== e && this.queue(e || "fx", []), this.each(function () {
        var t = !0,
          i = null != e && e + "queueHooks",
          o = w.timers,
          a = J.get(this);
        if (i) a[i] && a[i].stop && r(a[i]);else for (i in a) a[i] && a[i].stop && ot.test(i) && r(a[i]);
        for (i = o.length; i--;) o[i].elem !== this || null != e && o[i].queue !== e || (o[i].anim.stop(n), t = !1, o.splice(i, 1));
        !t && n || w.dequeue(this, e);
      });
    },
    finish: function (e) {
      return !1 !== e && (e = e || "fx"), this.each(function () {
        var t,
          n = J.get(this),
          r = n[e + "queue"],
          i = n[e + "queueHooks"],
          o = w.timers,
          a = r ? r.length : 0;
        for (n.finish = !0, w.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
        for (t = 0; t < a; t++) r[t] && r[t].finish && r[t].finish.call(this);
        delete n.finish;
      });
    }
  }), w.each(["toggle", "show", "hide"], function (e, t) {
    var n = w.fn[t];
    w.fn[t] = function (e, r, i) {
      return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ut(t, !0), e, r, i);
    };
  }), w.each({
    slideDown: ut("show"),
    slideUp: ut("hide"),
    slideToggle: ut("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (e, t) {
    w.fn[e] = function (e, n, r) {
      return this.animate(t, e, n, r);
    };
  }), w.timers = [], w.fx.tick = function () {
    var e,
      t = 0,
      n = w.timers;
    for (nt = Date.now(); t < n.length; t++) (e = n[t])() || n[t] !== e || n.splice(t--, 1);
    n.length || w.fx.stop(), nt = void 0;
  }, w.fx.timer = function (e) {
    w.timers.push(e), w.fx.start();
  }, w.fx.interval = 13, w.fx.start = function () {
    rt || (rt = !0, at());
  }, w.fx.stop = function () {
    rt = null;
  }, w.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  }, w.fn.delay = function (t, n) {
    return t = w.fx ? w.fx.speeds[t] || t : t, n = n || "fx", this.queue(n, function (n, r) {
      var i = e.setTimeout(n, t);
      r.stop = function () {
        e.clearTimeout(i);
      };
    });
  }, function () {
    var e = r.createElement("input"),
      t = r.createElement("select").appendChild(r.createElement("option"));
    e.type = "checkbox", h.checkOn = "" !== e.value, h.optSelected = t.selected, (e = r.createElement("input")).value = "t", e.type = "radio", h.radioValue = "t" === e.value;
  }();
  var dt,
    ht = w.expr.attrHandle;
  w.fn.extend({
    attr: function (e, t) {
      return z(this, w.attr, e, t, arguments.length > 1);
    },
    removeAttr: function (e) {
      return this.each(function () {
        w.removeAttr(this, e);
      });
    }
  }), w.extend({
    attr: function (e, t, n) {
      var r,
        i,
        o = e.nodeType;
      if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? w.prop(e, t, n) : (1 === o && w.isXMLDoc(e) || (i = w.attrHooks[t.toLowerCase()] || (w.expr.match.bool.test(t) ? dt : void 0)), void 0 !== n ? null === n ? void w.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = w.find.attr(e, t)) ? void 0 : r);
    },
    attrHooks: {
      type: {
        set: function (e, t) {
          if (!h.radioValue && "radio" === t && N(e, "input")) {
            var n = e.value;
            return e.setAttribute("type", t), n && (e.value = n), t;
          }
        }
      }
    },
    removeAttr: function (e, t) {
      var n,
        r = 0,
        i = t && t.match(M);
      if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n);
    }
  }), dt = {
    set: function (e, t, n) {
      return !1 === t ? w.removeAttr(e, n) : e.setAttribute(n, n), n;
    }
  }, w.each(w.expr.match.bool.source.match(/\w+/g), function (e, t) {
    var n = ht[t] || w.find.attr;
    ht[t] = function (e, t, r) {
      var i,
        o,
        a = t.toLowerCase();
      return r || (o = ht[a], ht[a] = i, i = null != n(e, t, r) ? a : null, ht[a] = o), i;
    };
  });
  var gt = /^(?:input|select|textarea|button)$/i,
    yt = /^(?:a|area)$/i;
  w.fn.extend({
    prop: function (e, t) {
      return z(this, w.prop, e, t, arguments.length > 1);
    },
    removeProp: function (e) {
      return this.each(function () {
        delete this[w.propFix[e] || e];
      });
    }
  }), w.extend({
    prop: function (e, t, n) {
      var r,
        i,
        o = e.nodeType;
      if (3 !== o && 8 !== o && 2 !== o) return 1 === o && w.isXMLDoc(e) || (t = w.propFix[t] || t, i = w.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t];
    },
    propHooks: {
      tabIndex: {
        get: function (e) {
          var t = w.find.attr(e, "tabindex");
          return t ? parseInt(t, 10) : gt.test(e.nodeName) || yt.test(e.nodeName) && e.href ? 0 : -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }), h.optSelected || (w.propHooks.selected = {
    get: function (e) {
      var t = e.parentNode;
      return t && t.parentNode && t.parentNode.selectedIndex, null;
    },
    set: function (e) {
      var t = e.parentNode;
      t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
    }
  }), w.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    w.propFix[this.toLowerCase()] = this;
  });
  function vt(e) {
    return (e.match(M) || []).join(" ");
  }
  function mt(e) {
    return e.getAttribute && e.getAttribute("class") || "";
  }
  function xt(e) {
    return Array.isArray(e) ? e : "string" == typeof e ? e.match(M) || [] : [];
  }
  w.fn.extend({
    addClass: function (e) {
      var t,
        n,
        r,
        i,
        o,
        a,
        s,
        u = 0;
      if (g(e)) return this.each(function (t) {
        w(this).addClass(e.call(this, t, mt(this)));
      });
      if ((t = xt(e)).length) while (n = this[u++]) if (i = mt(n), r = 1 === n.nodeType && " " + vt(i) + " ") {
        a = 0;
        while (o = t[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
        i !== (s = vt(r)) && n.setAttribute("class", s);
      }
      return this;
    },
    removeClass: function (e) {
      var t,
        n,
        r,
        i,
        o,
        a,
        s,
        u = 0;
      if (g(e)) return this.each(function (t) {
        w(this).removeClass(e.call(this, t, mt(this)));
      });
      if (!arguments.length) return this.attr("class", "");
      if ((t = xt(e)).length) while (n = this[u++]) if (i = mt(n), r = 1 === n.nodeType && " " + vt(i) + " ") {
        a = 0;
        while (o = t[a++]) while (r.indexOf(" " + o + " ") > -1) r = r.replace(" " + o + " ", " ");
        i !== (s = vt(r)) && n.setAttribute("class", s);
      }
      return this;
    },
    toggleClass: function (e, t) {
      var n = typeof e,
        r = "string" === n || Array.isArray(e);
      return "boolean" == typeof t && r ? t ? this.addClass(e) : this.removeClass(e) : g(e) ? this.each(function (n) {
        w(this).toggleClass(e.call(this, n, mt(this), t), t);
      }) : this.each(function () {
        var t, i, o, a;
        if (r) {
          i = 0, o = w(this), a = xt(e);
          while (t = a[i++]) o.hasClass(t) ? o.removeClass(t) : o.addClass(t);
        } else void 0 !== e && "boolean" !== n || ((t = mt(this)) && J.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : J.get(this, "__className__") || ""));
      });
    },
    hasClass: function (e) {
      var t,
        n,
        r = 0;
      t = " " + e + " ";
      while (n = this[r++]) if (1 === n.nodeType && (" " + vt(mt(n)) + " ").indexOf(t) > -1) return !0;
      return !1;
    }
  });
  var bt = /\r/g;
  w.fn.extend({
    val: function (e) {
      var t,
        n,
        r,
        i = this[0];
      {
        if (arguments.length) return r = g(e), this.each(function (n) {
          var i;
          1 === this.nodeType && (null == (i = r ? e.call(this, n, w(this).val()) : e) ? i = "" : "number" == typeof i ? i += "" : Array.isArray(i) && (i = w.map(i, function (e) {
            return null == e ? "" : e + "";
          })), (t = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i));
        });
        if (i) return (t = w.valHooks[i.type] || w.valHooks[i.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : "string" == typeof (n = i.value) ? n.replace(bt, "") : null == n ? "" : n;
      }
    }
  }), w.extend({
    valHooks: {
      option: {
        get: function (e) {
          var t = w.find.attr(e, "value");
          return null != t ? t : vt(w.text(e));
        }
      },
      select: {
        get: function (e) {
          var t,
            n,
            r,
            i = e.options,
            o = e.selectedIndex,
            a = "select-one" === e.type,
            s = a ? null : [],
            u = a ? o + 1 : i.length;
          for (r = o < 0 ? u : a ? o : 0; r < u; r++) if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !N(n.parentNode, "optgroup"))) {
            if (t = w(n).val(), a) return t;
            s.push(t);
          }
          return s;
        },
        set: function (e, t) {
          var n,
            r,
            i = e.options,
            o = w.makeArray(t),
            a = i.length;
          while (a--) ((r = i[a]).selected = w.inArray(w.valHooks.option.get(r), o) > -1) && (n = !0);
          return n || (e.selectedIndex = -1), o;
        }
      }
    }
  }), w.each(["radio", "checkbox"], function () {
    w.valHooks[this] = {
      set: function (e, t) {
        if (Array.isArray(t)) return e.checked = w.inArray(w(e).val(), t) > -1;
      }
    }, h.checkOn || (w.valHooks[this].get = function (e) {
      return null === e.getAttribute("value") ? "on" : e.value;
    });
  }), h.focusin = "onfocusin" in e;
  var wt = /^(?:focusinfocus|focusoutblur)$/,
    Tt = function (e) {
      e.stopPropagation();
    };
  w.extend(w.event, {
    trigger: function (t, n, i, o) {
      var a,
        s,
        u,
        l,
        c,
        p,
        d,
        h,
        v = [i || r],
        m = f.call(t, "type") ? t.type : t,
        x = f.call(t, "namespace") ? t.namespace.split(".") : [];
      if (s = h = u = i = i || r, 3 !== i.nodeType && 8 !== i.nodeType && !wt.test(m + w.event.triggered) && (m.indexOf(".") > -1 && (m = (x = m.split(".")).shift(), x.sort()), c = m.indexOf(":") < 0 && "on" + m, t = t[w.expando] ? t : new w.Event(m, "object" == typeof t && t), t.isTrigger = o ? 2 : 3, t.namespace = x.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + x.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = i), n = null == n ? [t] : w.makeArray(n, [t]), d = w.event.special[m] || {}, o || !d.trigger || !1 !== d.trigger.apply(i, n))) {
        if (!o && !d.noBubble && !y(i)) {
          for (l = d.delegateType || m, wt.test(l + m) || (s = s.parentNode); s; s = s.parentNode) v.push(s), u = s;
          u === (i.ownerDocument || r) && v.push(u.defaultView || u.parentWindow || e);
        }
        a = 0;
        while ((s = v[a++]) && !t.isPropagationStopped()) h = s, t.type = a > 1 ? l : d.bindType || m, (p = (J.get(s, "events") || {})[t.type] && J.get(s, "handle")) && p.apply(s, n), (p = c && s[c]) && p.apply && Y(s) && (t.result = p.apply(s, n), !1 === t.result && t.preventDefault());
        return t.type = m, o || t.isDefaultPrevented() || d._default && !1 !== d._default.apply(v.pop(), n) || !Y(i) || c && g(i[m]) && !y(i) && ((u = i[c]) && (i[c] = null), w.event.triggered = m, t.isPropagationStopped() && h.addEventListener(m, Tt), i[m](), t.isPropagationStopped() && h.removeEventListener(m, Tt), w.event.triggered = void 0, u && (i[c] = u)), t.result;
      }
    },
    simulate: function (e, t, n) {
      var r = w.extend(new w.Event(), n, {
        type: e,
        isSimulated: !0
      });
      w.event.trigger(r, null, t);
    }
  }), w.fn.extend({
    trigger: function (e, t) {
      return this.each(function () {
        w.event.trigger(e, t, this);
      });
    },
    triggerHandler: function (e, t) {
      var n = this[0];
      if (n) return w.event.trigger(e, t, n, !0);
    }
  }), h.focusin || w.each({
    focus: "focusin",
    blur: "focusout"
  }, function (e, t) {
    var n = function (e) {
      w.event.simulate(t, e.target, w.event.fix(e));
    };
    w.event.special[t] = {
      setup: function () {
        var r = this.ownerDocument || this,
          i = J.access(r, t);
        i || r.addEventListener(e, n, !0), J.access(r, t, (i || 0) + 1);
      },
      teardown: function () {
        var r = this.ownerDocument || this,
          i = J.access(r, t) - 1;
        i ? J.access(r, t, i) : (r.removeEventListener(e, n, !0), J.remove(r, t));
      }
    };
  });
  var Ct = e.location,
    Et = Date.now(),
    kt = /\?/;
  w.parseXML = function (t) {
    var n;
    if (!t || "string" != typeof t) return null;
    try {
      n = new e.DOMParser().parseFromString(t, "text/xml");
    } catch (e) {
      n = void 0;
    }
    return n && !n.getElementsByTagName("parsererror").length || w.error("Invalid XML: " + t), n;
  };
  var St = /\[\]$/,
    Dt = /\r?\n/g,
    Nt = /^(?:submit|button|image|reset|file)$/i,
    At = /^(?:input|select|textarea|keygen)/i;
  function jt(e, t, n, r) {
    var i;
    if (Array.isArray(t)) w.each(t, function (t, i) {
      n || St.test(e) ? r(e, i) : jt(e + "[" + ("object" == typeof i && null != i ? t : "") + "]", i, n, r);
    });else if (n || "object" !== x(t)) r(e, t);else for (i in t) jt(e + "[" + i + "]", t[i], n, r);
  }
  w.param = function (e, t) {
    var n,
      r = [],
      i = function (e, t) {
        var n = g(t) ? t() : t;
        r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
      };
    if (Array.isArray(e) || e.jquery && !w.isPlainObject(e)) w.each(e, function () {
      i(this.name, this.value);
    });else for (n in e) jt(n, e[n], t, i);
    return r.join("&");
  }, w.fn.extend({
    serialize: function () {
      return w.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        var e = w.prop(this, "elements");
        return e ? w.makeArray(e) : this;
      }).filter(function () {
        var e = this.type;
        return this.name && !w(this).is(":disabled") && At.test(this.nodeName) && !Nt.test(e) && (this.checked || !pe.test(e));
      }).map(function (e, t) {
        var n = w(this).val();
        return null == n ? null : Array.isArray(n) ? w.map(n, function (e) {
          return {
            name: t.name,
            value: e.replace(Dt, "\r\n")
          };
        }) : {
          name: t.name,
          value: n.replace(Dt, "\r\n")
        };
      }).get();
    }
  });
  var qt = /%20/g,
    Lt = /#.*$/,
    Ht = /([?&])_=[^&]*/,
    Ot = /^(.*?):[ \t]*([^\r\n]*)$/gm,
    Pt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    Mt = /^(?:GET|HEAD)$/,
    Rt = /^\/\//,
    It = {},
    Wt = {},
    $t = "*/".concat("*"),
    Bt = r.createElement("a");
  Bt.href = Ct.href;
  function Ft(e) {
    return function (t, n) {
      "string" != typeof t && (n = t, t = "*");
      var r,
        i = 0,
        o = t.toLowerCase().match(M) || [];
      if (g(n)) while (r = o[i++]) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n);
    };
  }
  function _t(e, t, n, r) {
    var i = {},
      o = e === Wt;
    function a(s) {
      var u;
      return i[s] = !0, w.each(e[s] || [], function (e, s) {
        var l = s(t, n, r);
        return "string" != typeof l || o || i[l] ? o ? !(u = l) : void 0 : (t.dataTypes.unshift(l), a(l), !1);
      }), u;
    }
    return a(t.dataTypes[0]) || !i["*"] && a("*");
  }
  function zt(e, t) {
    var n,
      r,
      i = w.ajaxSettings.flatOptions || {};
    for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
    return r && w.extend(!0, e, r), e;
  }
  function Xt(e, t, n) {
    var r,
      i,
      o,
      a,
      s = e.contents,
      u = e.dataTypes;
    while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
    if (r) for (i in s) if (s[i] && s[i].test(r)) {
      u.unshift(i);
      break;
    }
    if (u[0] in n) o = u[0];else {
      for (i in n) {
        if (!u[0] || e.converters[i + " " + u[0]]) {
          o = i;
          break;
        }
        a || (a = i);
      }
      o = o || a;
    }
    if (o) return o !== u[0] && u.unshift(o), n[o];
  }
  function Ut(e, t, n, r) {
    var i,
      o,
      a,
      s,
      u,
      l = {},
      c = e.dataTypes.slice();
    if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
    o = c.shift();
    while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u;else if ("*" !== u && u !== o) {
      if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {
        !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1]));
        break;
      }
      if (!0 !== a) if (a && e["throws"]) t = a(t);else try {
        t = a(t);
      } catch (e) {
        return {
          state: "parsererror",
          error: a ? e : "No conversion from " + u + " to " + o
        };
      }
    }
    return {
      state: "success",
      data: t
    };
  }
  w.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: Ct.href,
      type: "GET",
      isLocal: Pt.test(Ct.protocol),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": $t,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": JSON.parse,
        "text xml": w.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function (e, t) {
      return t ? zt(zt(e, w.ajaxSettings), t) : zt(w.ajaxSettings, e);
    },
    ajaxPrefilter: Ft(It),
    ajaxTransport: Ft(Wt),
    ajax: function (t, n) {
      "object" == typeof t && (n = t, t = void 0), n = n || {};
      var i,
        o,
        a,
        s,
        u,
        l,
        c,
        f,
        p,
        d,
        h = w.ajaxSetup({}, n),
        g = h.context || h,
        y = h.context && (g.nodeType || g.jquery) ? w(g) : w.event,
        v = w.Deferred(),
        m = w.Callbacks("once memory"),
        x = h.statusCode || {},
        b = {},
        T = {},
        C = "canceled",
        E = {
          readyState: 0,
          getResponseHeader: function (e) {
            var t;
            if (c) {
              if (!s) {
                s = {};
                while (t = Ot.exec(a)) s[t[1].toLowerCase()] = t[2];
              }
              t = s[e.toLowerCase()];
            }
            return null == t ? null : t;
          },
          getAllResponseHeaders: function () {
            return c ? a : null;
          },
          setRequestHeader: function (e, t) {
            return null == c && (e = T[e.toLowerCase()] = T[e.toLowerCase()] || e, b[e] = t), this;
          },
          overrideMimeType: function (e) {
            return null == c && (h.mimeType = e), this;
          },
          statusCode: function (e) {
            var t;
            if (e) if (c) E.always(e[E.status]);else for (t in e) x[t] = [x[t], e[t]];
            return this;
          },
          abort: function (e) {
            var t = e || C;
            return i && i.abort(t), k(0, t), this;
          }
        };
      if (v.promise(E), h.url = ((t || h.url || Ct.href) + "").replace(Rt, Ct.protocol + "//"), h.type = n.method || n.type || h.method || h.type, h.dataTypes = (h.dataType || "*").toLowerCase().match(M) || [""], null == h.crossDomain) {
        l = r.createElement("a");
        try {
          l.href = h.url, l.href = l.href, h.crossDomain = Bt.protocol + "//" + Bt.host != l.protocol + "//" + l.host;
        } catch (e) {
          h.crossDomain = !0;
        }
      }
      if (h.data && h.processData && "string" != typeof h.data && (h.data = w.param(h.data, h.traditional)), _t(It, h, n, E), c) return E;
      (f = w.event && h.global) && 0 == w.active++ && w.event.trigger("ajaxStart"), h.type = h.type.toUpperCase(), h.hasContent = !Mt.test(h.type), o = h.url.replace(Lt, ""), h.hasContent ? h.data && h.processData && 0 === (h.contentType || "").indexOf("application/x-www-form-urlencoded") && (h.data = h.data.replace(qt, "+")) : (d = h.url.slice(o.length), h.data && (h.processData || "string" == typeof h.data) && (o += (kt.test(o) ? "&" : "?") + h.data, delete h.data), !1 === h.cache && (o = o.replace(Ht, "$1"), d = (kt.test(o) ? "&" : "?") + "_=" + Et++ + d), h.url = o + d), h.ifModified && (w.lastModified[o] && E.setRequestHeader("If-Modified-Since", w.lastModified[o]), w.etag[o] && E.setRequestHeader("If-None-Match", w.etag[o])), (h.data && h.hasContent && !1 !== h.contentType || n.contentType) && E.setRequestHeader("Content-Type", h.contentType), E.setRequestHeader("Accept", h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + ("*" !== h.dataTypes[0] ? ", " + $t + "; q=0.01" : "") : h.accepts["*"]);
      for (p in h.headers) E.setRequestHeader(p, h.headers[p]);
      if (h.beforeSend && (!1 === h.beforeSend.call(g, E, h) || c)) return E.abort();
      if (C = "abort", m.add(h.complete), E.done(h.success), E.fail(h.error), i = _t(Wt, h, n, E)) {
        if (E.readyState = 1, f && y.trigger("ajaxSend", [E, h]), c) return E;
        h.async && h.timeout > 0 && (u = e.setTimeout(function () {
          E.abort("timeout");
        }, h.timeout));
        try {
          c = !1, i.send(b, k);
        } catch (e) {
          if (c) throw e;
          k(-1, e);
        }
      } else k(-1, "No Transport");
      function k(t, n, r, s) {
        var l,
          p,
          d,
          b,
          T,
          C = n;
        c || (c = !0, u && e.clearTimeout(u), i = void 0, a = s || "", E.readyState = t > 0 ? 4 : 0, l = t >= 200 && t < 300 || 304 === t, r && (b = Xt(h, E, r)), b = Ut(h, b, E, l), l ? (h.ifModified && ((T = E.getResponseHeader("Last-Modified")) && (w.lastModified[o] = T), (T = E.getResponseHeader("etag")) && (w.etag[o] = T)), 204 === t || "HEAD" === h.type ? C = "nocontent" : 304 === t ? C = "notmodified" : (C = b.state, p = b.data, l = !(d = b.error))) : (d = C, !t && C || (C = "error", t < 0 && (t = 0))), E.status = t, E.statusText = (n || C) + "", l ? v.resolveWith(g, [p, C, E]) : v.rejectWith(g, [E, C, d]), E.statusCode(x), x = void 0, f && y.trigger(l ? "ajaxSuccess" : "ajaxError", [E, h, l ? p : d]), m.fireWith(g, [E, C]), f && (y.trigger("ajaxComplete", [E, h]), --w.active || w.event.trigger("ajaxStop")));
      }
      return E;
    },
    getJSON: function (e, t, n) {
      return w.get(e, t, n, "json");
    },
    getScript: function (e, t) {
      return w.get(e, void 0, t, "script");
    }
  }), w.each(["get", "post"], function (e, t) {
    w[t] = function (e, n, r, i) {
      return g(n) && (i = i || r, r = n, n = void 0), w.ajax(w.extend({
        url: e,
        type: t,
        dataType: i,
        data: n,
        success: r
      }, w.isPlainObject(e) && e));
    };
  }), w._evalUrl = function (e) {
    return w.ajax({
      url: e,
      type: "GET",
      dataType: "script",
      cache: !0,
      async: !1,
      global: !1,
      "throws": !0
    });
  }, w.fn.extend({
    wrapAll: function (e) {
      var t;
      return this[0] && (g(e) && (e = e.call(this[0])), t = w(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
        var e = this;
        while (e.firstElementChild) e = e.firstElementChild;
        return e;
      }).append(this)), this;
    },
    wrapInner: function (e) {
      return g(e) ? this.each(function (t) {
        w(this).wrapInner(e.call(this, t));
      }) : this.each(function () {
        var t = w(this),
          n = t.contents();
        n.length ? n.wrapAll(e) : t.append(e);
      });
    },
    wrap: function (e) {
      var t = g(e);
      return this.each(function (n) {
        w(this).wrapAll(t ? e.call(this, n) : e);
      });
    },
    unwrap: function (e) {
      return this.parent(e).not("body").each(function () {
        w(this).replaceWith(this.childNodes);
      }), this;
    }
  }), w.expr.pseudos.hidden = function (e) {
    return !w.expr.pseudos.visible(e);
  }, w.expr.pseudos.visible = function (e) {
    return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
  }, w.ajaxSettings.xhr = function () {
    try {
      return new e.XMLHttpRequest();
    } catch (e) {}
  };
  var Vt = {
      0: 200,
      1223: 204
    },
    Gt = w.ajaxSettings.xhr();
  h.cors = !!Gt && "withCredentials" in Gt, h.ajax = Gt = !!Gt, w.ajaxTransport(function (t) {
    var n, r;
    if (h.cors || Gt && !t.crossDomain) return {
      send: function (i, o) {
        var a,
          s = t.xhr();
        if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields) for (a in t.xhrFields) s[a] = t.xhrFields[a];
        t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest");
        for (a in i) s.setRequestHeader(a, i[a]);
        n = function (e) {
          return function () {
            n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e ? s.abort() : "error" === e ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(Vt[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {
              binary: s.response
            } : {
              text: s.responseText
            }, s.getAllResponseHeaders()));
          };
        }, s.onload = n(), r = s.onerror = s.ontimeout = n("error"), void 0 !== s.onabort ? s.onabort = r : s.onreadystatechange = function () {
          4 === s.readyState && e.setTimeout(function () {
            n && r();
          });
        }, n = n("abort");
        try {
          s.send(t.hasContent && t.data || null);
        } catch (e) {
          if (n) throw e;
        }
      },
      abort: function () {
        n && n();
      }
    };
  }), w.ajaxPrefilter(function (e) {
    e.crossDomain && (e.contents.script = !1);
  }), w.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function (e) {
        return w.globalEval(e), e;
      }
    }
  }), w.ajaxPrefilter("script", function (e) {
    void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");
  }), w.ajaxTransport("script", function (e) {
    if (e.crossDomain) {
      var t, n;
      return {
        send: function (i, o) {
          t = w("<script>").prop({
            charset: e.scriptCharset,
            src: e.url
          }).on("load error", n = function (e) {
            t.remove(), n = null, e && o("error" === e.type ? 404 : 200, e.type);
          }), r.head.appendChild(t[0]);
        },
        abort: function () {
          n && n();
        }
      };
    }
  });
  var Yt = [],
    Qt = /(=)\?(?=&|$)|\?\?/;
  w.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var e = Yt.pop() || w.expando + "_" + Et++;
      return this[e] = !0, e;
    }
  }), w.ajaxPrefilter("json jsonp", function (t, n, r) {
    var i,
      o,
      a,
      s = !1 !== t.jsonp && (Qt.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Qt.test(t.data) && "data");
    if (s || "jsonp" === t.dataTypes[0]) return i = t.jsonpCallback = g(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(Qt, "$1" + i) : !1 !== t.jsonp && (t.url += (kt.test(t.url) ? "&" : "?") + t.jsonp + "=" + i), t.converters["script json"] = function () {
      return a || w.error(i + " was not called"), a[0];
    }, t.dataTypes[0] = "json", o = e[i], e[i] = function () {
      a = arguments;
    }, r.always(function () {
      void 0 === o ? w(e).removeProp(i) : e[i] = o, t[i] && (t.jsonpCallback = n.jsonpCallback, Yt.push(i)), a && g(o) && o(a[0]), a = o = void 0;
    }), "script";
  }), h.createHTMLDocument = function () {
    var e = r.implementation.createHTMLDocument("").body;
    return e.innerHTML = "<form></form><form></form>", 2 === e.childNodes.length;
  }(), w.parseHTML = function (e, t, n) {
    if ("string" != typeof e) return [];
    "boolean" == typeof t && (n = t, t = !1);
    var i, o, a;
    return t || (h.createHTMLDocument ? ((i = (t = r.implementation.createHTMLDocument("")).createElement("base")).href = r.location.href, t.head.appendChild(i)) : t = r), o = A.exec(e), a = !n && [], o ? [t.createElement(o[1])] : (o = xe([e], t, a), a && a.length && w(a).remove(), w.merge([], o.childNodes));
  }, w.fn.load = function (e, t, n) {
    var r,
      i,
      o,
      a = this,
      s = e.indexOf(" ");
    return s > -1 && (r = vt(e.slice(s)), e = e.slice(0, s)), g(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), a.length > 0 && w.ajax({
      url: e,
      type: i || "GET",
      dataType: "html",
      data: t
    }).done(function (e) {
      o = arguments, a.html(r ? w("<div>").append(w.parseHTML(e)).find(r) : e);
    }).always(n && function (e, t) {
      a.each(function () {
        n.apply(this, o || [e.responseText, t, e]);
      });
    }), this;
  }, w.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
    w.fn[t] = function (e) {
      return this.on(t, e);
    };
  }), w.expr.pseudos.animated = function (e) {
    return w.grep(w.timers, function (t) {
      return e === t.elem;
    }).length;
  }, w.offset = {
    setOffset: function (e, t, n) {
      var r,
        i,
        o,
        a,
        s,
        u,
        l,
        c = w.css(e, "position"),
        f = w(e),
        p = {};
      "static" === c && (e.style.position = "relative"), s = f.offset(), o = w.css(e, "top"), u = w.css(e, "left"), (l = ("absolute" === c || "fixed" === c) && (o + u).indexOf("auto") > -1) ? (a = (r = f.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), g(t) && (t = t.call(e, n, w.extend({}, s))), null != t.top && (p.top = t.top - s.top + a), null != t.left && (p.left = t.left - s.left + i), "using" in t ? t.using.call(e, p) : f.css(p);
    }
  }, w.fn.extend({
    offset: function (e) {
      if (arguments.length) return void 0 === e ? this : this.each(function (t) {
        w.offset.setOffset(this, e, t);
      });
      var t,
        n,
        r = this[0];
      if (r) return r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
        top: t.top + n.pageYOffset,
        left: t.left + n.pageXOffset
      }) : {
        top: 0,
        left: 0
      };
    },
    position: function () {
      if (this[0]) {
        var e,
          t,
          n,
          r = this[0],
          i = {
            top: 0,
            left: 0
          };
        if ("fixed" === w.css(r, "position")) t = r.getBoundingClientRect();else {
          t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;
          while (e && (e === n.body || e === n.documentElement) && "static" === w.css(e, "position")) e = e.parentNode;
          e && e !== r && 1 === e.nodeType && ((i = w(e).offset()).top += w.css(e, "borderTopWidth", !0), i.left += w.css(e, "borderLeftWidth", !0));
        }
        return {
          top: t.top - i.top - w.css(r, "marginTop", !0),
          left: t.left - i.left - w.css(r, "marginLeft", !0)
        };
      }
    },
    offsetParent: function () {
      return this.map(function () {
        var e = this.offsetParent;
        while (e && "static" === w.css(e, "position")) e = e.offsetParent;
        return e || be;
      });
    }
  }), w.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (e, t) {
    var n = "pageYOffset" === t;
    w.fn[e] = function (r) {
      return z(this, function (e, r, i) {
        var o;
        if (y(e) ? o = e : 9 === e.nodeType && (o = e.defaultView), void 0 === i) return o ? o[t] : e[r];
        o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : e[r] = i;
      }, e, r, arguments.length);
    };
  }), w.each(["top", "left"], function (e, t) {
    w.cssHooks[t] = _e(h.pixelPosition, function (e, n) {
      if (n) return n = Fe(e, t), We.test(n) ? w(e).position()[t] + "px" : n;
    });
  }), w.each({
    Height: "height",
    Width: "width"
  }, function (e, t) {
    w.each({
      padding: "inner" + e,
      content: t,
      "": "outer" + e
    }, function (n, r) {
      w.fn[r] = function (i, o) {
        var a = arguments.length && (n || "boolean" != typeof i),
          s = n || (!0 === i || !0 === o ? "margin" : "border");
        return z(this, function (t, n, i) {
          var o;
          return y(t) ? 0 === r.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === i ? w.css(t, n, s) : w.style(t, n, i, s);
        }, t, a ? i : void 0, a);
      };
    });
  }), w.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, t) {
    w.fn[t] = function (e, n) {
      return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t);
    };
  }), w.fn.extend({
    hover: function (e, t) {
      return this.mouseenter(e).mouseleave(t || e);
    }
  }), w.fn.extend({
    bind: function (e, t, n) {
      return this.on(e, null, t, n);
    },
    unbind: function (e, t) {
      return this.off(e, null, t);
    },
    delegate: function (e, t, n, r) {
      return this.on(t, e, n, r);
    },
    undelegate: function (e, t, n) {
      return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
    }
  }), w.proxy = function (e, t) {
    var n, r, i;
    if ("string" == typeof t && (n = e[t], t = e, e = n), g(e)) return r = o.call(arguments, 2), i = function () {
      return e.apply(t || this, r.concat(o.call(arguments)));
    }, i.guid = e.guid = e.guid || w.guid++, i;
  }, w.holdReady = function (e) {
    e ? w.readyWait++ : w.ready(!0);
  }, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = N, w.isFunction = g, w.isWindow = y, w.camelCase = G, w.type = x, w.now = Date.now, w.isNumeric = function (e) {
    var t = w.type(e);
    return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
  },  true && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return w;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  var Jt = e.jQuery,
    Kt = e.$;
  return w.noConflict = function (t) {
    return e.$ === w && (e.$ = Kt), t && e.jQuery === w && (e.jQuery = Jt), w;
  }, t || (e.jQuery = e.$ = w), w;
});

/***/ }),

/***/ "./scripts/3rdparty/jquery.ui.touch-punch_customized.js":
/*!**************************************************************!*\
  !*** ./scripts/3rdparty/jquery.ui.touch-punch_customized.js ***!
  \**************************************************************/
/***/ (() => {

/*!
 * jQuery UI Touch Punch 0.2.3
 *
 * Copyright 2011–2014, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
(function ($) {
  // Detect touch support
  $.support.touch = 'ontouchend' in document;

  // Commenting out the following code since touch support may get added dynamically when the user is using debugging tools
  /*
  // Ignore browsers without touch support
  if (!$.support.touch) {
    return;
  }
  */

  // Custom change (don't handle touch events if the element has cancel drag)
  // eventOccurredOnElementWithCancelDrag helps in detecting that the original event's srcElement has the cancelDragHandle class
  var eventOccurredOnElementWithCancelDrag = function (evt) {
    if ($(evt.originalEvent.srcElement).hasClass('cancelDragHandle')) {
      return true;
    }
    return false;
  };
  var mouseProto = $.ui.mouse.prototype,
    _mouseInit = mouseProto._mouseInit,
    _mouseDestroy = mouseProto._mouseDestroy,
    touchHandled;

  /**
   * Simulate a mouse event based on a corresponding touch event
   * @param {Object} event A touch event
   * @param {String} simulatedType The corresponding mouse event
   */
  function simulateMouseEvent(event, simulatedType) {
    // Ignore multi-touch events
    if (event.originalEvent.touches.length > 1) {
      return;
    }
    event.preventDefault();
    var touch = event.originalEvent.changedTouches[0],
      simulatedEvent = document.createEvent('MouseEvents');

    // Initialize the simulated mouse event using the touch event's coordinates
    simulatedEvent.initMouseEvent(simulatedType,
    // type
    true,
    // bubbles                    
    true,
    // cancelable                 
    window,
    // view                       
    1,
    // detail                     
    touch.screenX,
    // screenX                    
    touch.screenY,
    // screenY                    
    touch.clientX,
    // clientX                    
    touch.clientY,
    // clientY                    
    false,
    // ctrlKey                    
    false,
    // altKey                     
    false,
    // shiftKey                   
    false,
    // metaKey                    
    0,
    // button                     
    null // relatedTarget              
    );

    // Dispatch the simulated event to the target element
    event.target.dispatchEvent(simulatedEvent);
  }

  /**
   * Handle the jQuery UI widget's touchstart events
   * @param {Object} event The widget element's touchstart event
   */
  mouseProto._touchStart = function (event) {
    if (eventOccurredOnElementWithCancelDrag(event)) {
      return;
    } // Custom change (don't handle touch events if the element has cancel drag)
    var self = this;

    // Ignore the event if another widget is already being handled
    if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {
      return;
    }

    // Set the flag to prevent other widgets from inheriting the touch event
    touchHandled = true;

    // Track movement to determine if interaction was a click
    self._touchMoved = false;

    // Simulate the mouseover event
    simulateMouseEvent(event, 'mouseover');

    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');

    // Simulate the mousedown event
    simulateMouseEvent(event, 'mousedown');
  };

  /**
   * Handle the jQuery UI widget's touchmove events
   * @param {Object} event The document's touchmove event
   */
  mouseProto._touchMove = function (event) {
    if (eventOccurredOnElementWithCancelDrag(event)) {
      return;
    } // Custom change (don't handle touch events if the element has cancel drag)
    // Ignore event if not handled
    if (!touchHandled) {
      return;
    }

    // Interaction was not a click
    this._touchMoved = true;

    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');
  };

  /**
   * Handle the jQuery UI widget's touchend events
   * @param {Object} event The document's touchend event
   */
  mouseProto._touchEnd = function (event) {
    if (eventOccurredOnElementWithCancelDrag(event)) {
      return;
    } // Custom change (don't handle touch events if the element has cancel drag)
    // Ignore event if not handled
    if (!touchHandled) {
      return;
    }

    // Simulate the mouseup event
    simulateMouseEvent(event, 'mouseup');

    // Simulate the mouseout event
    simulateMouseEvent(event, 'mouseout');

    // If the touch interaction did not move, it should trigger a click
    if (!this._touchMoved) {
      // Simulate the click event
      simulateMouseEvent(event, 'click');
    }

    // Unset the flag to allow other widgets to inherit the touch event
    touchHandled = false;
  };

  /**
   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.
   * This method extends the widget with bound touch event handlers that
   * translate touch events to mouse events and pass them to the widget's
   * original mouse event handling methods.
   */
  mouseProto._mouseInit = function () {
    var self = this;

    // Delegate the touch handlers to the widget's element
    self.element.bind({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    });

    // Call the original $.ui.mouse init method
    _mouseInit.call(self);
  };

  /**
   * Remove the touch event handlers
   */
  mouseProto._mouseDestroy = function () {
    var self = this;

    // Delegate the touch handlers to the widget's element
    self.element.unbind({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    });

    // Call the original $.ui.mouse destroy method
    _mouseDestroy.call(self);
  };
})(jQuery);

/***/ }),

/***/ "./scripts/3rdparty/magicsuggest/magicsuggest.js":
/*!*******************************************************!*\
  !*** ./scripts/3rdparty/magicsuggest/magicsuggest.js ***!
  \*******************************************************/
/***/ (() => {

/**
 * Multiple Selection Component for Bootstrap
 * Check nicolasbize.github.io/magicsuggest/ for latest updates.
 *
 * Author:       Nicolas Bize
 * Created:      Feb 8th 2013
 * Last Updated: Oct 16th 2014
 * Version:      2.1.4
 * Licence:      MagicSuggest is licenced under MIT licence (http://opensource.org/licenses/MIT)
 */
(function ($) {
  "use strict";

  var MagicSuggest = function (element, options) {
    var ms = this;

    /**
     * Initializes the MagicSuggest component
     */
    var defaults = {
      /**********  CONFIGURATION PROPERTIES ************/
      /**
       * Restricts or allows the user to validate typed entries.
       * Defaults to true.
       */
      allowFreeEntries: true,
      /**
       * Restricts or allows the user to add the same entry more than once
       * Defaults to false.
       */
      allowDuplicates: false,
      /**
       * Additional config object passed to each $.ajax call
       */
      ajaxConfig: {},
      /**
       * If a single suggestion comes out, it is preselected.
       */
      autoSelect: true,
      /**
       * Auto select the first matching item with multiple items shown
       */
      selectFirst: false,
      /**
       * Allow customization of query parameter
       */
      queryParam: 'query',
      /**
       * A function triggered just before the ajax request is sent, similar to jQuery
       */
      beforeSend: function () {},
      /**
       * A custom CSS class to apply to the field's underlying element.
       */
      cls: '',
      /**
       * JSON Data source used to populate the combo box. 3 options are available here:
       * No Data Source (default)
       *    When left null, the combo box will not suggest anything. It can still enable the user to enter
       *    multiple entries if allowFreeEntries is * set to true (default).
       * Static Source
       *    You can pass an array of JSON objects, an array of strings or even a single CSV string as the
       *    data source.For ex. data: [* {id:0,name:"Paris"}, {id: 1, name: "New York"}]
       *    You can also pass any json object with the results property containing the json array.
       * Url
       *     You can pass the url from which the component will fetch its JSON data.Data will be fetched
       *     using a POST ajax request that will * include the entered text as 'query' parameter. The results
       *     fetched from the server can be:
       *     - an array of JSON objects (ex: [{id:...,name:...},{...}])
       *     - a string containing an array of JSON objects ready to be parsed (ex: "[{id:...,name:...},{...}]")
       *     - a JSON object whose data will be contained in the results property
       *      (ex: {results: [{id:...,name:...},{...}]
       * Function
       *     You can pass a function which returns an array of JSON objects  (ex: [{id:...,name:...},{...}])
       *     The function can return the JSON data or it can use the first argument as function to handle the data.
       *     Only one (callback function or return value) is needed for the function to succeed.
       *     See the following example:
       *     function (response) { var myjson = [{name: 'test', id: 1}]; response(myjson); return myjson; }
       */
      data: null,
      /**
       * Additional parameters to the ajax call
       */
      dataUrlParams: {},
      /**
       * Start the component in a disabled state.
       */
      disabled: false,
      /**
       * Name of JSON object property that defines the disabled behaviour
       */
      disabledField: null,
      /**
       * Name of JSON object property displayed in the combo list
       */
      displayField: 'name',
      /**
       * Set to false if you only want mouse interaction. In that case the combo will
       * automatically expand on focus.
       */
      editable: true,
      /**
       * Set starting state for combo.
       */
      expanded: false,
      /**
       * Automatically expands combo on focus.
       */
      expandOnFocus: false,
      /**
       * JSON property by which the list should be grouped
       */
      groupBy: null,
      /**
       * Set to true to hide the trigger on the right
       */
      hideTrigger: false,
      /**
       * Set to true to highlight search input within displayed suggestions
       */
      highlight: true,
      /**
       * A custom ID for this component
       */
      id: null,
      /**
       * A class that is added to the info message appearing on the top-right part of the component
       */
      infoMsgCls: '',
      /**
       * Additional parameters passed out to the INPUT tag. Enables usage of AngularJS's custom tags for ex.
       */
      inputCfg: {},
      /**
       * The class that is applied to show that the field is invalid
       */
      invalidCls: 'ms-inv',
      /**
       * Set to true to filter data results according to case. Useless if the data is fetched remotely
       */
      matchCase: false,
      /**
       * Once expanded, the combo's height will take as much room as the # of available results.
       *    In case there are too many results displayed, this will fix the drop down height.
       */
      maxDropHeight: 290,
      /**
       * Defines how long the user free entry can be. Set to null for no limit.
       */
      maxEntryLength: null,
      /**
       * A function that defines the helper text when the max entry length has been surpassed.
       */
      maxEntryRenderer: function (v) {
        return 'Please reduce your entry by ' + v + ' character' + (v > 1 ? 's' : '');
      },
      /**
       * The maximum number of results displayed in the combo drop down at once.
       */
      maxSuggestions: null,
      /**
       * The maximum number of items the user can select if multiple selection is allowed.
       *    Set to null to remove the limit.
       */
      maxSelection: 10,
      /**
       * A function that defines the helper text when the max selection amount has been reached. The function has a single
       *    parameter which is the number of selected elements.
       */
      maxSelectionRenderer: function (v) {
        return 'You cannot choose more than ' + v + ' item' + (v > 1 ? 's' : '');
      },
      /**
       * The method used by the ajax request.
       */
      method: 'POST',
      /**
       * The minimum number of characters the user must type before the combo expands and offers suggestions.
       */
      minChars: 0,
      /**
       * A function that defines the helper text when not enough letters are set. The function has a single
       *    parameter which is the difference between the required amount of letters and the current one.
       */
      minCharsRenderer: function (v) {
        return 'Please type ' + v + ' more character' + (v > 1 ? 's' : '');
      },
      /**
       * Whether or not sorting / filtering should be done remotely or locally.
       * Use either 'local' or 'remote'
       */
      mode: 'local',
      /**
       * The name used as a form element.
       */
      name: null,
      /**
       * The text displayed when there are no suggestions.
       */
      noSuggestionText: 'No suggestions',
      /**
       * The default placeholder text when nothing has been entered
       */
      placeholder: 'Type or click here',
      /**
       * A function used to define how the items will be presented in the combo
       */
      renderer: null,
      /**
       * Whether or not this field should be required
       */
      required: false,
      /**
       * Set to true to render selection as a delimited string
       */
      resultAsString: false,
      /**
       * Text delimiter to use in a delimited string.
       */
      resultAsStringDelimiter: ',',
      /**
       * Name of JSON object property that represents the list of suggested objects
       */
      resultsField: 'results',
      /**
       * A custom CSS class to add to a selected item
       */
      selectionCls: '',
      /**
       * An optional element replacement in which the selection is rendered
       */
      selectionContainer: null,
      /**
       * Where the selected items will be displayed. Only 'right', 'bottom' and 'inner' are valid values
       */
      selectionPosition: 'inner',
      /**
       * A function used to define how the items will be presented in the tag list
       */
      selectionRenderer: null,
      /**
       * Set to true to stack the selectioned items when positioned on the bottom
       *    Requires the selectionPosition to be set to 'bottom'
       */
      selectionStacked: false,
      /**
       * Direction used for sorting. Only 'asc' and 'desc' are valid values
       */
      sortDir: 'asc',
      /**
       * name of JSON object property for local result sorting.
       *    Leave null if you do not wish the results to be ordered or if they are already ordered remotely.
       */
      sortOrder: null,
      /**
       * If set to true, suggestions will have to start by user input (and not simply contain it as a substring)
       */
      strictSuggest: false,
      /**
       * Custom style added to the component container.
       */
      style: '',
      /**
       * If set to true, the combo will expand / collapse when clicked upon
       */
      toggleOnClick: false,
      /**
       * Amount (in ms) between keyboard registers.
       */
      typeDelay: 400,
      /**
       * If set to true, tab won't blur the component but will be registered as the ENTER key
       */
      useTabKey: false,
      /**
       * If set to true, using comma will validate the user's choice
       */
      useCommaKey: true,
      /**
       * Determines whether or not the results will be displayed with a zebra table style
       */
      useZebraStyle: false,
      /**
       * initial value for the field
       */
      value: null,
      /**
       * name of JSON object property that represents its underlying value
       */
      valueField: 'id',
      /**
       * regular expression to validate the values against
       */
      vregex: null,
      /**
       * type to validate against
       */
      vtype: null
    };
    var conf = $.extend({}, options);
    var cfg = $.extend(true, {}, defaults, conf);

    /**********  PUBLIC METHODS ************/
    /**
     * Add one or multiple json items to the current selection
     * @param items - json object or array of json objects
     * @param isSilent - (optional) set to true to suppress 'selectionchange' event from being triggered
     */
    this.addToSelection = function (items, isSilent) {
      if (!cfg.maxSelection || _selection.length < cfg.maxSelection) {
        if (!$.isArray(items)) {
          items = [items];
        }
        var valuechanged = false;
        $.each(items, function (index, json) {
          if (cfg.allowDuplicates || $.inArray(json[cfg.valueField], ms.getValue()) === -1) {
            _selection.push(json);
            valuechanged = true;
          }
        });
        if (valuechanged === true) {
          self._renderSelection();
          this.empty();
          if (isSilent !== true) {
            $(this).trigger('selectionchange', [this, this.getSelection()]);
          }
        }
      }
      this.input.attr('placeholder', cfg.selectionPosition === 'inner' && this.getValue().length > 0 ? '' : cfg.placeholder);
    };

    /**
     * Clears the current selection
     * @param isSilent - (optional) set to true to suppress 'selectionchange' event from being triggered
     */
    this.clear = function (isSilent) {
      this.removeFromSelection(_selection.slice(0), isSilent); // clone array to avoid concurrency issues
    };

    /**
     * Collapse the drop down part of the combo
     */
    this.collapse = function () {
      if (cfg.expanded === true) {
        this.combobox.detach();
        cfg.expanded = false;
        $(this).trigger('collapse', [this]);
      }
    };

    /**
     * Set the component in a disabled state.
     */
    this.disable = function () {
      this.container.addClass('ms-ctn-disabled');
      cfg.disabled = true;
      ms.input.attr('disabled', true);
    };

    /**
     * Empties out the combo user text
     */
    this.empty = function () {
      this.input.val('');
    };

    /**
     * Set the component in a enable state.
     */
    this.enable = function () {
      this.container.removeClass('ms-ctn-disabled');
      cfg.disabled = false;
      ms.input.attr('disabled', false);
    };

    /**
     * Expand the drop drown part of the combo.
     */
    this.expand = function () {
      if (!cfg.expanded && (this.input.val().length >= cfg.minChars || this.combobox.children().size() > 0)) {
        this.combobox.appendTo(this.container);
        self._processSuggestions();
        cfg.expanded = true;
        $(this).trigger('expand', [this]);
      }
    };

    /**
     * Retrieve component enabled status
     */
    this.isDisabled = function () {
      return cfg.disabled;
    };

    /**
     * Checks whether the field is valid or not
     * @return {boolean}
     */
    this.isValid = function () {
      var valid = cfg.required === false || _selection.length > 0;
      if (cfg.vtype || cfg.vregex) {
        $.each(_selection, function (index, item) {
          valid = valid && self._validateSingleItem(item[cfg.valueField]);
        });
      }
      return valid;
    };

    /**
     * Gets the data params for current ajax request
     */
    this.getDataUrlParams = function () {
      return cfg.dataUrlParams;
    };

    /**
     * Gets the name given to the form input
     */
    this.getName = function () {
      return cfg.name;
    };

    /**
     * Retrieve an array of selected json objects
     * @return {Array}
     */
    this.getSelection = function () {
      return _selection;
    };

    /**
     * Retrieve the current text entered by the user
     */
    this.getRawValue = function () {
      return ms.input.val();
    };

    /**
     * Retrieve an array of selected values
     */
    this.getValue = function () {
      return $.map(_selection, function (o) {
        return o[cfg.valueField];
      });
    };

    /**
     * Remove one or multiples json items from the current selection
     * @param items - json object or array of json objects
     * @param isSilent - (optional) set to true to suppress 'selectionchange' event from being triggered
     */
    this.removeFromSelection = function (items, isSilent) {
      if (!$.isArray(items)) {
        items = [items];
      }
      var valuechanged = false;
      $.each(items, function (index, json) {
        var i = $.inArray(json[cfg.valueField], ms.getValue());
        if (i > -1) {
          _selection.splice(i, 1);
          valuechanged = true;
        }
      });
      if (valuechanged === true) {
        self._renderSelection();
        if (isSilent !== true) {
          $(this).trigger('selectionchange', [this, this.getSelection()]);
        }
        if (cfg.expandOnFocus) {
          ms.expand();
        }
        if (cfg.expanded) {
          self._processSuggestions();
        }
      }
      this.input.attr('placeholder', cfg.selectionPosition === 'inner' && this.getValue().length > 0 ? '' : cfg.placeholder);
    };

    /**
     * Get current data
     */
    this.getData = function () {
      return _cbData;
    };

    /**
     * Set up some combo data after it has been rendered
     * @param data
     */
    this.setData = function (data) {
      cfg.data = data;
      self._processSuggestions();
    };

    /**
     * Sets the name for the input field so it can be fetched in the form
     * @param name
     */
    this.setName = function (name) {
      cfg.name = name;
      if (name) {
        cfg.name += name.indexOf('[]') > 0 ? '' : '[]';
      }
      if (ms._valueContainer) {
        $.each(ms._valueContainer.children(), function (i, el) {
          el.name = cfg.name;
        });
      }
    };

    /**
     * Sets the current selection with the JSON items provided
     * @param items
     */
    this.setSelection = function (items) {
      this.clear();
      this.addToSelection(items);
    };

    /**
     * Sets a value for the combo box. Value must be an array of values with data type matching valueField one.
     * @param data
     */
    this.setValue = function (values) {
      var items = [];
      $.each(values, function (index, value) {
        // first try to see if we have the full objects from our data set
        var found = false;
        $.each(_cbData, function (i, item) {
          if (item[cfg.valueField] == value) {
            items.push(item);
            found = true;
            return false;
          }
        });
        if (!found) {
          if (typeof value === 'object') {
            items.push(value);
          } else {
            var json = {};
            json[cfg.valueField] = value;
            json[cfg.displayField] = value;
            items.push(json);
          }
        }
      });
      if (items.length > 0) {
        this.addToSelection(items);
      }
    };

    /**
     * Sets data params for subsequent ajax requests
     * @param params
     */
    this.setDataUrlParams = function (params) {
      cfg.dataUrlParams = $.extend({}, params);
    };

    /**********  PRIVATE ************/
    var _selection = [],
      // selected objects
      _comboItemHeight = 0,
      // height for each combo item.
      _timer,
      _hasFocus = false,
      _groups = null,
      _cbData = [],
      _ctrlDown = false,
      KEYCODES = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        CTRL: 17,
        ESC: 27,
        SPACE: 32,
        UPARROW: 38,
        DOWNARROW: 40,
        COMMA: 188
      };
    var self = {
      /**
       * Empties the result container and refills it with the array of json results in input
       * @private
       */
      _displaySuggestions: function (data) {
        ms.combobox.show();
        ms.combobox.empty();
        var resHeight = 0,
          // total height taken by displayed results.
          nbGroups = 0;
        if (_groups === null) {
          self._renderComboItems(data);
          resHeight = _comboItemHeight * data.length;
        } else {
          for (var grpName in _groups) {
            nbGroups += 1;
            $('<div/>', {
              'class': 'ms-res-group',
              html: grpName
            }).appendTo(ms.combobox);
            self._renderComboItems(_groups[grpName].items, true);
          }
          var _groupItemHeight = ms.combobox.find('.ms-res-group').outerHeight();
          if (_groupItemHeight !== null) {
            var tmpResHeight = nbGroups * _groupItemHeight;
            resHeight = _comboItemHeight * data.length + tmpResHeight;
          } else {
            resHeight = _comboItemHeight * (data.length + nbGroups);
          }
        }
        if (resHeight < ms.combobox.height() || resHeight <= cfg.maxDropHeight) {
          ms.combobox.height(resHeight);
        } else if (resHeight >= ms.combobox.height() && resHeight > cfg.maxDropHeight) {
          ms.combobox.height(cfg.maxDropHeight);
        }
        if (data.length === 1 && cfg.autoSelect === true) {
          ms.combobox.children().filter(':not(.ms-res-item-disabled):last').addClass('ms-res-item-active');
        }
        if (cfg.selectFirst === true) {
          ms.combobox.children().filter(':not(.ms-res-item-disabled):first').addClass('ms-res-item-active');
        }
        if (data.length === 0 && ms.getRawValue() !== "") {
          var noSuggestionText = cfg.noSuggestionText.replace(/\{\{.*\}\}/, ms.input.val());
          self._updateHelper(noSuggestionText);
          ms.collapse();
        }

        // When free entry is off, add invalid class to input if no data matches
        if (cfg.allowFreeEntries === false) {
          if (data.length === 0) {
            $(ms.input).addClass(cfg.invalidCls);
            ms.combobox.hide();
          } else {
            $(ms.input).removeClass(cfg.invalidCls);
          }
        }
      },
      /**
       * Returns an array of json objects from an array of strings.
       * @private
       */
      _getEntriesFromStringArray: function (data) {
        var json = [];
        $.each(data, function (index, s) {
          var entry = {};
          entry[cfg.displayField] = entry[cfg.valueField] = $.trim(s);
          json.push(entry);
        });
        return json;
      },
      /**
       * Replaces html with highlighted html according to case
       * @param html
       * @private
       */
      _highlightSuggestion: function (html) {
        var q = ms.input.val();

        //escape special regex characters
        var specialCharacters = ['^', '$', '*', '+', '?', '.', '(', ')', ':', '!', '|', '{', '}', '[', ']'];
        $.each(specialCharacters, function (index, value) {
          q = q.replace(value, "\\" + value);
        });
        if (q.length === 0) {
          return html; // nothing entered as input
        }

        var glob = cfg.matchCase === true ? 'g' : 'gi';
        return html.replace(new RegExp('(' + q + ')(?!([^<]+)?>)', glob), '<em>$1</em>');
      },
      /**
       * Moves the selected cursor amongst the list item
       * @param dir - 'up' or 'down'
       * @private
       */
      _moveSelectedRow: function (dir) {
        if (!cfg.expanded) {
          ms.expand();
        }
        var list, start, active, scrollPos;
        list = ms.combobox.find(".ms-res-item:not(.ms-res-item-disabled)");
        if (dir === 'down') {
          start = list.eq(0);
        } else {
          start = list.filter(':last');
        }
        active = ms.combobox.find('.ms-res-item-active:not(.ms-res-item-disabled):first');
        if (active.length > 0) {
          if (dir === 'down') {
            start = active.nextAll('.ms-res-item:not(.ms-res-item-disabled)').first();
            if (start.length === 0) {
              start = list.eq(0);
            }
            scrollPos = ms.combobox.scrollTop();
            ms.combobox.scrollTop(0);
            if (start[0].offsetTop + start.outerHeight() > ms.combobox.height()) {
              ms.combobox.scrollTop(scrollPos + _comboItemHeight);
            }
          } else {
            start = active.prevAll('.ms-res-item:not(.ms-res-item-disabled)').first();
            if (start.length === 0) {
              start = list.filter(':last');
              ms.combobox.scrollTop(_comboItemHeight * list.length);
            }
            if (start[0].offsetTop < ms.combobox.scrollTop()) {
              ms.combobox.scrollTop(ms.combobox.scrollTop() - _comboItemHeight);
            }
          }
        }
        list.removeClass("ms-res-item-active");
        start.addClass("ms-res-item-active");
      },
      /**
       * According to given data and query, sort and add suggestions in their container
       * @private
       */
      _processSuggestions: function (source) {
        var json = null,
          data = source || cfg.data;
        if (data !== null) {
          if (typeof data === 'function') {
            data = data.call(ms, ms.getRawValue());
          }
          if (typeof data === 'string') {
            // get results from ajax
            $(ms).trigger('beforeload', [ms]);
            var queryParams = {};
            queryParams[cfg.queryParam] = ms.input.val();
            var params = $.extend(queryParams, cfg.dataUrlParams);
            $.ajax($.extend({
              type: cfg.method,
              url: data,
              data: params,
              beforeSend: cfg.beforeSend,
              success: function (asyncData) {
                json = typeof asyncData === 'string' ? JSON.parse(asyncData) : asyncData;
                self._processSuggestions(json);
                $(ms).trigger('load', [ms, json]);
                if (self._asyncValues) {
                  ms.setValue(typeof self._asyncValues === 'string' ? JSON.parse(self._asyncValues) : self._asyncValues);
                  self._renderSelection();
                  delete self._asyncValues;
                }
              },
              error: function () {
                throw "Could not reach server";
              }
            }, cfg.ajaxConfig));
            return;
          } else {
            // results from local array
            if (data.length > 0 && typeof data[0] === 'string') {
              // results from array of strings
              _cbData = self._getEntriesFromStringArray(data);
            } else {
              // regular json array or json object with results property
              _cbData = data[cfg.resultsField] || data;
            }
          }
          var sortedData = cfg.mode === 'remote' ? _cbData : self._sortAndTrim(_cbData);
          self._displaySuggestions(self._group(sortedData));
        }
      },
      /**
       * Render the component to the given input DOM element
       * @private
       */
      _render: function (el) {
        ms.setName(cfg.name); // make sure the form name is correct
        // holds the main div, will relay the focus events to the contained input element.
        ms.container = $('<div/>', {
          'class': 'ms-ctn form-control ' + (cfg.resultAsString ? 'ms-as-string ' : '') + cfg.cls + ($(el).hasClass('input-lg') ? ' input-lg' : '') + ($(el).hasClass('input-sm') ? ' input-sm' : '') + (cfg.disabled === true ? ' ms-ctn-disabled' : '') + (cfg.editable === true ? '' : ' ms-ctn-readonly') + (cfg.hideTrigger === false ? '' : ' ms-no-trigger'),
          style: cfg.style,
          id: cfg.id
        });
        ms.container.focus($.proxy(handlers._onFocus, this));
        ms.container.blur($.proxy(handlers._onBlur, this));
        ms.container.keydown($.proxy(handlers._onKeyDown, this));
        ms.container.keyup($.proxy(handlers._onKeyUp, this));

        // holds the input field
        ms.input = $('<input/>', $.extend({
          type: 'text',
          'class': cfg.editable === true ? '' : ' ms-input-readonly',
          readonly: !cfg.editable,
          placeholder: cfg.placeholder,
          disabled: cfg.disabled
        }, cfg.inputCfg));
        ms.input.focus($.proxy(handlers._onInputFocus, this));
        ms.input.click($.proxy(handlers._onInputClick, this));

        // holds the suggestions. will always be placed on focus
        ms.combobox = $('<div/>', {
          'class': 'ms-res-ctn dropdown-menu'
        }).height(cfg.maxDropHeight);

        // bind the onclick and mouseover using delegated events (needs jQuery >= 1.7)
        ms.combobox.on('click', 'div.ms-res-item', $.proxy(handlers._onComboItemSelected, this));
        ms.combobox.on('mouseover', 'div.ms-res-item', $.proxy(handlers._onComboItemMouseOver, this));
        if (cfg.selectionContainer) {
          ms.selectionContainer = cfg.selectionContainer;
          $(ms.selectionContainer).addClass('ms-sel-ctn');
        } else {
          ms.selectionContainer = $('<div/>', {
            'class': 'ms-sel-ctn'
          });
        }
        ms.selectionContainer.click($.proxy(handlers._onFocus, this));
        if (cfg.selectionPosition === 'inner' && !cfg.selectionContainer) {
          ms.selectionContainer.append(ms.input);
        } else {
          ms.container.append(ms.input);
        }
        ms.helper = $('<span/>', {
          'class': 'ms-helper ' + cfg.infoMsgCls
        });
        self._updateHelper();
        ms.container.append(ms.helper);

        // Render the whole thing
        $(el).replaceWith(ms.container);
        if (!cfg.selectionContainer) {
          switch (cfg.selectionPosition) {
            case 'bottom':
              ms.selectionContainer.insertAfter(ms.container);
              if (cfg.selectionStacked === true) {
                ms.selectionContainer.width(ms.container.width());
                ms.selectionContainer.addClass('ms-stacked');
              }
              break;
            case 'right':
              ms.selectionContainer.insertAfter(ms.container);
              ms.container.css('float', 'left');
              break;
            default:
              ms.container.append(ms.selectionContainer);
              break;
          }
        }

        // holds the trigger on the right side
        if (cfg.hideTrigger === false) {
          ms.trigger = $('<div/>', {
            'class': 'ms-trigger',
            html: '<div class="ms-trigger-ico"></div>'
          });
          ms.trigger.click($.proxy(handlers._onTriggerClick, this));
          ms.container.append(ms.trigger);
        }
        $(window).resize($.proxy(handlers._onWindowResized, this));

        // do not perform an initial call if we are using ajax unless we have initial values
        if (cfg.value !== null || cfg.data !== null) {
          if (typeof cfg.data === 'string') {
            self._asyncValues = cfg.value;
            self._processSuggestions();
          } else {
            self._processSuggestions();
            if (cfg.value !== null) {
              ms.setValue(cfg.value);
              self._renderSelection();
            }
          }
        }
        $("body").click(function (e) {
          if (ms.container.hasClass('ms-ctn-focus') && ms.container.has(e.target).length === 0 && e.target.className.indexOf('ms-res-item') < 0 && e.target.className.indexOf('ms-close-btn') < 0 && ms.container[0] !== e.target) {
            handlers._onBlur();
          }
        });
        if (cfg.expanded === true) {
          cfg.expanded = false;
          ms.expand();
        }
      },
      /**
       * Renders each element within the combo box
       * @private
       */
      _renderComboItems: function (items, isGrouped) {
        var ref = this,
          html = '';
        $.each(items, function (index, value) {
          var displayed = cfg.renderer !== null ? cfg.renderer.call(ref, value) : value[cfg.displayField];
          var disabled = cfg.disabledField !== null && value[cfg.disabledField] === true;
          var resultItemEl = $('<div/>', {
            'class': 'ms-res-item ' + (isGrouped ? 'ms-res-item-grouped ' : '') + (disabled ? 'ms-res-item-disabled ' : '') + (index % 2 === 1 && cfg.useZebraStyle === true ? 'ms-res-odd' : ''),
            html: cfg.highlight === true ? self._highlightSuggestion(displayed) : displayed,
            'data-json': JSON.stringify(value)
          });
          html += $('<div/>').append(resultItemEl).html();
        });
        ms.combobox.append(html);
        _comboItemHeight = ms.combobox.find('.ms-res-item:first').outerHeight();
      },
      /**
       * Renders the selected items into their container.
       * @private
       */
      _renderSelection: function () {
        var ref = this,
          w = 0,
          inputOffset = 0,
          items = [],
          asText = cfg.resultAsString === true && !_hasFocus;
        ms.selectionContainer.find('.ms-sel-item').remove();
        if (ms._valueContainer !== undefined) {
          ms._valueContainer.remove();
        }
        $.each(_selection, function (index, value) {
          var selectedItemEl,
            delItemEl,
            selectedItemHtml = cfg.selectionRenderer !== null ? cfg.selectionRenderer.call(ref, value) : value[cfg.displayField];
          var validCls = self._validateSingleItem(value[cfg.displayField]) ? '' : ' ms-sel-invalid';

          // tag representing selected value
          if (asText === true) {
            selectedItemEl = $('<div/>', {
              'class': 'ms-sel-item ms-sel-text ' + cfg.selectionCls + validCls,
              html: selectedItemHtml + (index === _selection.length - 1 ? '' : cfg.resultAsStringDelimiter)
            }).data('json', value);
          } else {
            selectedItemEl = $('<div/>', {
              'class': 'ms-sel-item ' + cfg.selectionCls + validCls,
              html: selectedItemHtml
            }).data('json', value);
            if (cfg.disabled === false) {
              // small cross img
              delItemEl = $('<span/>', {
                'class': 'ms-close-btn'
              }).data('json', value).appendTo(selectedItemEl);
              delItemEl.click($.proxy(handlers._onTagTriggerClick, ref));
            }
          }
          items.push(selectedItemEl);
        });
        ms.selectionContainer.prepend(items);

        // store the values, behaviour of multiple select
        ms._valueContainer = $('<div/>', {
          style: 'display: none;'
        });
        $.each(ms.getValue(), function (i, val) {
          var el = $('<input/>', {
            type: 'hidden',
            name: cfg.name,
            value: val
          });
          el.appendTo(ms._valueContainer);
        });
        ms._valueContainer.appendTo(ms.selectionContainer);
        if (cfg.selectionPosition === 'inner' && !cfg.selectionContainer) {
          ms.input.width(0);
          inputOffset = ms.input.offset().left - ms.selectionContainer.offset().left;
          w = ms.container.width() - inputOffset - 42;
          ms.input.width(w);
        }
        if (_selection.length === cfg.maxSelection) {
          self._updateHelper(cfg.maxSelectionRenderer.call(this, _selection.length));
        } else {
          ms.helper.hide();
        }
      },
      /**
       * Select an item either through keyboard or mouse
       * @param item
       * @private
       */
      _selectItem: function (item) {
        if (cfg.maxSelection === 1) {
          _selection = [];
        }
        ms.addToSelection(item.data('json'));
        item.removeClass('ms-res-item-active');
        if (cfg.expandOnFocus === false || _selection.length === cfg.maxSelection) {
          ms.collapse();
        }
        if (!_hasFocus) {
          ms.input.focus();
        } else if (_hasFocus && (cfg.expandOnFocus || _ctrlDown)) {
          self._processSuggestions();
          if (_ctrlDown) {
            ms.expand();
          }
        }
      },
      /**
       * Sorts the results and cut them down to max # of displayed results at once
       * @private
       */
      _sortAndTrim: function (data) {
        var q = ms.getRawValue(),
          filtered = [],
          newSuggestions = [],
          selectedValues = ms.getValue();
        // filter the data according to given input
        if (q.length > 0) {
          $.each(data, function (index, obj) {
            var name = obj[cfg.displayField];
            if (cfg.matchCase === true && name.indexOf(q) > -1 || cfg.matchCase === false && name.toLowerCase().indexOf(q.toLowerCase()) > -1) {
              if (cfg.strictSuggest === false || name.toLowerCase().indexOf(q.toLowerCase()) === 0) {
                filtered.push(obj);
              }
            }
          });
        } else {
          filtered = data;
        }
        // take out the ones that have already been selected
        $.each(filtered, function (index, obj) {
          if (cfg.allowDuplicates || $.inArray(obj[cfg.valueField], selectedValues) === -1) {
            newSuggestions.push(obj);
          }
        });
        // sort the data
        if (cfg.sortOrder !== null) {
          newSuggestions.sort(function (a, b) {
            if (a[cfg.sortOrder] < b[cfg.sortOrder]) {
              return cfg.sortDir === 'asc' ? -1 : 1;
            }
            if (a[cfg.sortOrder] > b[cfg.sortOrder]) {
              return cfg.sortDir === 'asc' ? 1 : -1;
            }
            return 0;
          });
        }
        // trim it down
        if (cfg.maxSuggestions && cfg.maxSuggestions > 0) {
          newSuggestions = newSuggestions.slice(0, cfg.maxSuggestions);
        }
        return newSuggestions;
      },
      _group: function (data) {
        // build groups
        if (cfg.groupBy !== null) {
          _groups = {};
          $.each(data, function (index, value) {
            var props = cfg.groupBy.indexOf('.') > -1 ? cfg.groupBy.split('.') : cfg.groupBy;
            var prop = value[cfg.groupBy];
            if (typeof props != 'string') {
              prop = value;
              while (props.length > 0) {
                prop = prop[props.shift()];
              }
            }
            if (_groups[prop] === undefined) {
              _groups[prop] = {
                title: prop,
                items: [value]
              };
            } else {
              _groups[prop].items.push(value);
            }
          });
        }
        return data;
      },
      /**
       * Update the helper text
       * @private
       */
      _updateHelper: function (html) {
        ms.helper.html(html);
        if (!ms.helper.is(":visible")) {
          ms.helper.fadeIn();
        }
      },
      /**
       * Validate an item against vtype or vregex
       * @private
       */
      _validateSingleItem: function (value) {
        if (cfg.vregex !== null && cfg.vregex instanceof RegExp) {
          return cfg.vregex.test(value);
        } else if (cfg.vtype !== null) {
          switch (cfg.vtype) {
            case 'alpha':
              return /^[a-zA-Z_]+$/.test(value);
            case 'alphanum':
              return /^[a-zA-Z0-9_]+$/.test(value);
            case 'email':
              return /^(\w+)([\-+.][\w]+)*@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/.test(value);
            case 'url':
              return /(((^https?)|(^ftp)):\/\/([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i.test(value);
            case 'ipaddress':
              return /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(value);
          }
        }
        return true;
      }
    };
    var handlers = {
      /**
       * Triggered when blurring out of the component
       * @private
       */
      _onBlur: function () {
        ms.container.removeClass('ms-ctn-focus');
        ms.collapse();
        _hasFocus = false;
        if (ms.getRawValue() !== '' && cfg.allowFreeEntries === true) {
          var obj = {};
          obj[cfg.displayField] = obj[cfg.valueField] = ms.getRawValue().trim();
          ms.addToSelection(obj);
        }
        self._renderSelection();
        if (ms.isValid() === false) {
          ms.container.addClass(cfg.invalidCls);
        } else if (ms.input.val() !== '' && cfg.allowFreeEntries === false) {
          ms.empty();
          self._updateHelper('');
        }
        $(ms).trigger('blur', [ms]);
      },
      /**
       * Triggered when hovering an element in the combo
       * @param e
       * @private
       */
      _onComboItemMouseOver: function (e) {
        var target = $(e.currentTarget);
        if (!target.hasClass('ms-res-item-disabled')) {
          ms.combobox.children().removeClass('ms-res-item-active');
          target.addClass('ms-res-item-active');
        }
      },
      /**
       * Triggered when an item is chosen from the list
       * @param e
       * @private
       */
      _onComboItemSelected: function (e) {
        var target = $(e.currentTarget);
        if (!target.hasClass('ms-res-item-disabled')) {
          self._selectItem($(e.currentTarget));
        }
      },
      /**
       * Triggered when focusing on the container div. Will focus on the input field instead.
       * @private
       */
      _onFocus: function () {
        ms.input.focus();
      },
      /**
       * Triggered when clicking on the input text field
       * @private
       */
      _onInputClick: function () {
        if (ms.isDisabled() === false && _hasFocus) {
          if (cfg.toggleOnClick === true) {
            if (cfg.expanded) {
              ms.collapse();
            } else {
              ms.expand();
            }
          }
        }
      },
      /**
       * Triggered when focusing on the input text field.
       * @private
       */
      _onInputFocus: function () {
        if (ms.isDisabled() === false && !_hasFocus) {
          _hasFocus = true;
          ms.container.addClass('ms-ctn-focus');
          ms.container.removeClass(cfg.invalidCls);
          var curLength = ms.getRawValue().length;
          if (cfg.expandOnFocus === true) {
            ms.expand();
          }
          if (_selection.length === cfg.maxSelection) {
            self._updateHelper(cfg.maxSelectionRenderer.call(this, _selection.length));
          } else if (curLength < cfg.minChars) {
            self._updateHelper(cfg.minCharsRenderer.call(this, cfg.minChars - curLength));
          }
          self._renderSelection();
          $(ms).trigger('focus', [ms]);
        }
      },
      /**
       * Triggered when the user presses a key while the component has focus
       * This is where we want to handle all keys that don't require the user input field
       * since it hasn't registered the key hit yet
       * @param e keyEvent
       * @private
       */
      _onKeyDown: function (e) {
        // check how tab should be handled
        var active = ms.combobox.find('.ms-res-item-active:not(.ms-res-item-disabled):first'),
          freeInput = ms.input.val();
        $(ms).trigger('keydown', [ms, e]);
        if (e.keyCode === KEYCODES.TAB && (cfg.useTabKey === false || cfg.useTabKey === true && active.length === 0 && ms.input.val().length === 0)) {
          handlers._onBlur();
          return;
        }
        switch (e.keyCode) {
          case KEYCODES.BACKSPACE:
            if (freeInput.length === 0 && ms.getSelection().length > 0 && cfg.selectionPosition === 'inner') {
              _selection.pop();
              self._renderSelection();
              $(ms).trigger('selectionchange', [ms, ms.getSelection()]);
              ms.input.attr('placeholder', cfg.selectionPosition === 'inner' && ms.getValue().length > 0 ? '' : cfg.placeholder);
              ms.input.focus();
              e.preventDefault();
            }
            break;
          case KEYCODES.TAB:
          case KEYCODES.ESC:
            e.preventDefault();
            break;
          case KEYCODES.ENTER:
            if (freeInput !== '' || cfg.expanded) {
              e.preventDefault();
            }
            break;
          case KEYCODES.COMMA:
            if (cfg.useCommaKey === true) {
              e.preventDefault();
            }
            break;
          case KEYCODES.CTRL:
            _ctrlDown = true;
            break;
          case KEYCODES.DOWNARROW:
            e.preventDefault();
            self._moveSelectedRow("down");
            break;
          case KEYCODES.UPARROW:
            e.preventDefault();
            self._moveSelectedRow("up");
            break;
          default:
            if (_selection.length === cfg.maxSelection) {
              e.preventDefault();
            }
            break;
        }
      },
      /**
       * Triggered when a key is released while the component has focus
       * @param e
       * @private
       */
      _onKeyUp: function (e) {
        var freeInput = ms.getRawValue(),
          inputValid = $.trim(ms.input.val()).length > 0 && (!cfg.maxEntryLength || $.trim(ms.input.val()).length <= cfg.maxEntryLength),
          selected,
          obj = {};
        $(ms).trigger('keyup', [ms, e]);
        clearTimeout(_timer);

        // collapse if escape, but keep focus.
        if (e.keyCode === KEYCODES.ESC && cfg.expanded) {
          ms.combobox.hide();
        }
        // ignore a bunch of keys
        if (e.keyCode === KEYCODES.TAB && cfg.useTabKey === false || e.keyCode > KEYCODES.ENTER && e.keyCode < KEYCODES.SPACE) {
          if (e.keyCode === KEYCODES.CTRL) {
            _ctrlDown = false;
          }
          return;
        }
        switch (e.keyCode) {
          case KEYCODES.UPARROW:
          case KEYCODES.DOWNARROW:
            e.preventDefault();
            break;
          case KEYCODES.ENTER:
          case KEYCODES.TAB:
          case KEYCODES.COMMA:
            if (e.keyCode !== KEYCODES.COMMA || cfg.useCommaKey === true) {
              e.preventDefault();
              if (cfg.expanded === true) {
                // if a selection is performed, select it and reset field
                selected = ms.combobox.find('.ms-res-item-active:not(.ms-res-item-disabled):first');
                if (selected.length > 0) {
                  self._selectItem(selected);
                  return;
                }
              }
              // if no selection or if freetext entered and free entries allowed, add new obj to selection
              if (inputValid === true && cfg.allowFreeEntries === true) {
                obj[cfg.displayField] = obj[cfg.valueField] = freeInput.trim();
                ms.addToSelection(obj);
                ms.collapse(); // reset combo suggestions
                ms.input.focus();
              }
              break;
            }
          default:
            if (_selection.length === cfg.maxSelection) {
              self._updateHelper(cfg.maxSelectionRenderer.call(this, _selection.length));
            } else {
              if (freeInput.length < cfg.minChars) {
                self._updateHelper(cfg.minCharsRenderer.call(this, cfg.minChars - freeInput.length));
                if (cfg.expanded === true) {
                  ms.collapse();
                }
              } else if (cfg.maxEntryLength && freeInput.length > cfg.maxEntryLength) {
                self._updateHelper(cfg.maxEntryRenderer.call(this, freeInput.length - cfg.maxEntryLength));
                if (cfg.expanded === true) {
                  ms.collapse();
                }
              } else {
                ms.helper.hide();
                if (cfg.minChars <= freeInput.length) {
                  _timer = setTimeout(function () {
                    if (cfg.expanded === true) {
                      self._processSuggestions();
                    } else {
                      ms.expand();
                    }
                  }, cfg.typeDelay);
                }
              }
            }
            break;
        }
      },
      /**
       * Triggered when clicking upon cross for deletion
       * @param e
       * @private
       */
      _onTagTriggerClick: function (e) {
        ms.removeFromSelection($(e.currentTarget).data('json'));
      },
      /**
       * Triggered when clicking on the small trigger in the right
       * @private
       */
      _onTriggerClick: function () {
        if (ms.isDisabled() === false && !(cfg.expandOnFocus === true && _selection.length === cfg.maxSelection)) {
          $(ms).trigger('triggerclick', [ms]);
          if (cfg.expanded === true) {
            ms.collapse();
          } else {
            var curLength = ms.getRawValue().length;
            if (curLength >= cfg.minChars) {
              ms.input.focus();
              ms.expand();
            } else {
              self._updateHelper(cfg.minCharsRenderer.call(this, cfg.minChars - curLength));
            }
          }
        }
      },
      /**
       * Triggered when the browser window is resized
       * @private
       */
      _onWindowResized: function () {
        self._renderSelection();
      }
    };

    // startup point
    if (element !== null) {
      self._render(element);
    }
  };
  $.fn.magicSuggest = function (options) {
    var obj = $(this);
    if (obj.size() === 1 && obj.data('magicSuggest')) {
      return obj.data('magicSuggest');
    }
    obj.each(function (i) {
      // assume $(this) is an element
      var cntr = $(this);

      // Return early if this element already has a plugin instance
      if (cntr.data('magicSuggest')) {
        return;
      }
      if (this.nodeName.toLowerCase() === 'select') {
        // rendering from select
        options.data = [];
        options.value = [];
        $.each(this.children, function (index, child) {
          if (child.nodeName && child.nodeName.toLowerCase() === 'option') {
            options.data.push({
              id: child.value,
              name: child.text
            });
            if ($(child).attr('selected')) {
              options.value.push(child.value);
            }
          }
        });
      }
      var def = {};
      // set values from DOM container element
      $.each(this.attributes, function (i, att) {
        def[att.name] = att.name === 'value' && att.value !== '' ? JSON.parse(att.value) : att.value;
      });
      var field = new MagicSuggest(this, $.extend([], $.fn.magicSuggest.defaults, options, def));
      cntr.data('magicSuggest', field);
      field.container.data('magicSuggest', field);
    });
    if (obj.size() === 1) {
      return obj.data('magicSuggest');
    }
    return obj;
  };
  $.fn.magicSuggest.defaults = {};
})(jQuery);

/***/ }),

/***/ "./scripts/3rdparty/socket.io/socket.io.slim.dev.js":
/*!**********************************************************!*\
  !*** ./scripts/3rdparty/socket.io/socket.io.slim.dev.js ***!
  \**********************************************************/
/***/ (function() {

/*!
 * Socket.IO v2.5.0
 * (c) 2014-2021 Guillermo Rauch
 * Released under the MIT License.
 */
(function webpackUniversalModuleDefinition(root, factory) {
  // if(typeof exports === 'object' && typeof module === 'object')
  // 	module.exports = factory();
  // else if(typeof define === 'function' && define.amd)
  // 	define([], factory);
  // else if(typeof exports === 'object')
  // 	exports["io"] = factory();
  // else
  root["io"] = factory();
})(this, function () {
  return (/******/function (modules) {
      // webpackBootstrap
      /******/ // The module cache
      /******/
      var installedModules = {};
      /******/
      /******/ // The require function
      /******/
      function __nested_webpack_require_698__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;
        /******/
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
          /******/exports: {},
          /******/id: moduleId,
          /******/loaded: false
          /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_698__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.loaded = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
      }
      /******/
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/
      __nested_webpack_require_698__.m = modules;
      /******/
      /******/ // expose the module cache
      /******/
      __nested_webpack_require_698__.c = installedModules;
      /******/
      /******/ // __webpack_public_path__
      /******/
      __nested_webpack_require_698__.p = "";
      /******/
      /******/ // Load entry module and return exports
      /******/
      return __nested_webpack_require_698__(0);
      /******/
    }
    /************************************************************************/
    /******/([/* 0 */
    /***/function (module, exports, __nested_webpack_require_2266__) {
      'use strict';

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      /**
       * Module dependencies.
       */

      var url = __nested_webpack_require_2266__(1);
      var parser = __nested_webpack_require_2266__(4);
      var Manager = __nested_webpack_require_2266__(9);
      var debug = __nested_webpack_require_2266__(3)('socket.io-client');

      /**
       * Module exports.
       */

      module.exports = exports = lookup;

      /**
       * Managers cache.
       */

      var cache = exports.managers = {};

      /**
       * Looks up an existing `Manager` for multiplexing.
       * If the user summons:
       *
       *   `io('http://localhost/a');`
       *   `io('http://localhost/b');`
       *
       * We reuse the existing instance based on same scheme/port/host,
       * and we initialize sockets for each namespace.
       *
       * @api public
       */

      function lookup(uri, opts) {
        if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
          opts = uri;
          uri = undefined;
        }
        opts = opts || {};
        var parsed = url(uri);
        var source = parsed.source;
        var id = parsed.id;
        var path = parsed.path;
        var sameNamespace = cache[id] && path in cache[id].nsps;
        var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
        var io;
        if (newConnection) {
          io = Manager(source, opts);
        } else {
          if (!cache[id]) {
            cache[id] = Manager(source, opts);
          }
          io = cache[id];
        }
        if (parsed.query && !opts.query) {
          opts.query = parsed.query;
        }
        return io.socket(parsed.path, opts);
      }

      /**
       * Protocol version.
       *
       * @api public
       */

      exports.protocol = parser.protocol;

      /**
       * `connect`.
       *
       * @param {String} uri
       * @api public
       */

      exports.connect = lookup;

      /**
       * Expose constructors for standalone build.
       *
       * @api public
       */

      exports.Manager = __nested_webpack_require_2266__(9);
      exports.Socket = __nested_webpack_require_2266__(34);

      /***/
    }, /* 1 */
    /***/function (module, exports, __nested_webpack_require_4796__) {
      'use strict';

      /**
       * Module dependencies.
       */
      var parseuri = __nested_webpack_require_4796__(2);
      var debug = __nested_webpack_require_4796__(3)('socket.io-client:url');

      /**
       * Module exports.
       */

      module.exports = url;

      /**
       * URL parser.
       *
       * @param {String} url
       * @param {Object} An object meant to mimic window.location.
       *                 Defaults to window.location.
       * @api public
       */

      function url(uri, loc) {
        var obj = uri;

        // default to window.location
        loc = loc || typeof location !== 'undefined' && location;
        if (null == uri) uri = loc.protocol + '//' + loc.host;

        // relative path support
        if ('string' === typeof uri) {
          if ('/' === uri.charAt(0)) {
            if ('/' === uri.charAt(1)) {
              uri = loc.protocol + uri;
            } else {
              uri = loc.host + uri;
            }
          }
          if (!/^(https?|wss?):\/\//.test(uri)) {
            if ('undefined' !== typeof loc) {
              uri = loc.protocol + '//' + uri;
            } else {
              uri = 'https://' + uri;
            }
          }

          // parse

          obj = parseuri(uri);
        }

        // make sure we treat `localhost:80` and `localhost` equally
        if (!obj.port) {
          if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = '80';
          } else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = '443';
          }
        }
        obj.path = obj.path || '/';
        var ipv6 = obj.host.indexOf(':') !== -1;
        var host = ipv6 ? '[' + obj.host + ']' : obj.host;

        // define unique id
        obj.id = obj.protocol + '://' + host + ':' + obj.port;
        // define href
        obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);
        return obj;
      }

      /***/
    }, /* 2 */
    /***/function (module, exports) {
      /**
       * Parses an URI
       *
       * @author Steven Levithan <stevenlevithan.com> (MIT license)
       * @api private
       */

      var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
      var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
      module.exports = function parseuri(str) {
        var src = str,
          b = str.indexOf('['),
          e = str.indexOf(']');
        if (b != -1 && e != -1) {
          str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
        }
        var m = re.exec(str || ''),
          uri = {},
          i = 14;
        while (i--) {
          uri[parts[i]] = m[i] || '';
        }
        if (b != -1 && e != -1) {
          uri.source = src;
          uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
          uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
          uri.ipv6uri = true;
        }
        uri.pathNames = pathNames(uri, uri['path']);
        uri.queryKey = queryKey(uri, uri['query']);
        return uri;
      };
      function pathNames(obj, path) {
        var regx = /\/{2,9}/g,
          names = path.replace(regx, "/").split("/");
        if (path.substr(0, 1) == '/' || path.length === 0) {
          names.splice(0, 1);
        }
        if (path.substr(path.length - 1, 1) == '/') {
          names.splice(names.length - 1, 1);
        }
        return names;
      }
      function queryKey(uri, query) {
        var data = {};
        query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
          if ($1) {
            data[$1] = $2;
          }
        });
        return data;
      }

      /***/
    }, /* 3 */
    /***/function (module, exports) {
      "use strict";

      module.exports = function () {
        return function () {};
      };

      /***/
    }, /* 4 */
    /***/function (module, exports, __nested_webpack_require_9056__) {
      /**
       * Module dependencies.
       */

      var debug = __nested_webpack_require_9056__(3)('socket.io-parser');
      var Emitter = __nested_webpack_require_9056__(5);
      var binary = __nested_webpack_require_9056__(6);
      var isArray = __nested_webpack_require_9056__(7);
      var isBuf = __nested_webpack_require_9056__(8);

      /**
       * Protocol version.
       *
       * @api public
       */

      exports.protocol = 4;

      /**
       * Packet types.
       *
       * @api public
       */

      exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];

      /**
       * Packet type `connect`.
       *
       * @api public
       */

      exports.CONNECT = 0;

      /**
       * Packet type `disconnect`.
       *
       * @api public
       */

      exports.DISCONNECT = 1;

      /**
       * Packet type `event`.
       *
       * @api public
       */

      exports.EVENT = 2;

      /**
       * Packet type `ack`.
       *
       * @api public
       */

      exports.ACK = 3;

      /**
       * Packet type `error`.
       *
       * @api public
       */

      exports.ERROR = 4;

      /**
       * Packet type 'binary event'
       *
       * @api public
       */

      exports.BINARY_EVENT = 5;

      /**
       * Packet type `binary ack`. For acks with binary arguments.
       *
       * @api public
       */

      exports.BINARY_ACK = 6;

      /**
       * Encoder constructor.
       *
       * @api public
       */

      exports.Encoder = Encoder;

      /**
       * Decoder constructor.
       *
       * @api public
       */

      exports.Decoder = Decoder;

      /**
       * A socket.io Encoder instance
       *
       * @api public
       */

      function Encoder() {}
      var ERROR_PACKET = exports.ERROR + '"encode error"';

      /**
       * Encode a packet as a single string if non-binary, or as a
       * buffer sequence, depending on packet type.
       *
       * @param {Object} obj - packet object
       * @param {Function} callback - function to handle encodings (likely engine.write)
       * @return Calls callback with Array of encodings
       * @api public
       */

      Encoder.prototype.encode = function (obj, callback) {
        if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
          encodeAsBinary(obj, callback);
        } else {
          var encoding = encodeAsString(obj);
          callback([encoding]);
        }
      };

      /**
       * Encode packet as string.
       *
       * @param {Object} packet
       * @return {String} encoded
       * @api private
       */

      function encodeAsString(obj) {
        // first is type
        var str = '' + obj.type;

        // attachments if we have them
        if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
          str += obj.attachments + '-';
        }

        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && '/' !== obj.nsp) {
          str += obj.nsp + ',';
        }

        // immediately followed by the id
        if (null != obj.id) {
          str += obj.id;
        }

        // json data
        if (null != obj.data) {
          var payload = tryStringify(obj.data);
          if (payload !== false) {
            str += payload;
          } else {
            return ERROR_PACKET;
          }
        }
        return str;
      }
      function tryStringify(str) {
        try {
          return JSON.stringify(str);
        } catch (e) {
          return false;
        }
      }

      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       *
       * @param {Object} packet
       * @return {Buffer} encoded
       * @api private
       */

      function encodeAsBinary(obj, callback) {
        function writeEncoding(bloblessData) {
          var deconstruction = binary.deconstructPacket(bloblessData);
          var pack = encodeAsString(deconstruction.packet);
          var buffers = deconstruction.buffers;
          buffers.unshift(pack); // add packet info to beginning of data list
          callback(buffers); // write all the buffers
        }

        binary.removeBlobs(obj, writeEncoding);
      }

      /**
       * A socket.io Decoder instance
       *
       * @return {Object} decoder
       * @api public
       */

      function Decoder() {
        this.reconstructor = null;
      }

      /**
       * Mix in `Emitter` with Decoder.
       */

      Emitter(Decoder.prototype);

      /**
       * Decodes an encoded packet string into packet JSON.
       *
       * @param {String} obj - encoded packet
       * @return {Object} packet
       * @api public
       */

      Decoder.prototype.add = function (obj) {
        var packet;
        if (typeof obj === 'string') {
          packet = decodeString(obj);
          if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {
            // binary packet's json
            this.reconstructor = new BinaryReconstructor(packet);

            // no attachments, labeled binary but no binary data to follow
            if (this.reconstructor.reconPack.attachments === 0) {
              this.emit('decoded', packet);
            }
          } else {
            // non-binary full packet
            this.emit('decoded', packet);
          }
        } else if (isBuf(obj) || obj.base64) {
          // raw binary data
          if (!this.reconstructor) {
            throw new Error('got binary data when not reconstructing a packet');
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              // received final buffer
              this.reconstructor = null;
              this.emit('decoded', packet);
            }
          }
        } else {
          throw new Error('Unknown type: ' + obj);
        }
      };

      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       * @api private
       */

      function decodeString(str) {
        var i = 0;
        // look up type
        var p = {
          type: Number(str.charAt(0))
        };
        if (null == exports.types[p.type]) {
          return error('unknown packet type ' + p.type);
        }

        // look up attachments if type binary
        if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
          var buf = '';
          while (str.charAt(++i) !== '-') {
            buf += str.charAt(i);
            if (i == str.length) break;
          }
          if (buf != Number(buf) || str.charAt(i) !== '-') {
            throw new Error('Illegal attachments');
          }
          p.attachments = Number(buf);
        }

        // look up namespace (if any)
        if ('/' === str.charAt(i + 1)) {
          p.nsp = '';
          while (++i) {
            var c = str.charAt(i);
            if (',' === c) break;
            p.nsp += c;
            if (i === str.length) break;
          }
        } else {
          p.nsp = '/';
        }

        // look up id
        var next = str.charAt(i + 1);
        if ('' !== next && Number(next) == next) {
          p.id = '';
          while (++i) {
            var c = str.charAt(i);
            if (null == c || Number(c) != c) {
              --i;
              break;
            }
            p.id += str.charAt(i);
            if (i === str.length) break;
          }
          p.id = Number(p.id);
        }

        // look up json data
        if (str.charAt(++i)) {
          var payload = tryParse(str.substr(i));
          var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
          if (isPayloadValid) {
            p.data = payload;
          } else {
            return error('invalid payload');
          }
        }
        return p;
      }
      function tryParse(str) {
        try {
          return JSON.parse(str);
        } catch (e) {
          return false;
        }
      }

      /**
       * Deallocates a parser's resources
       *
       * @api public
       */

      Decoder.prototype.destroy = function () {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
        }
      };

      /**
       * A manager of a binary event's 'buffer sequence'. Should
       * be constructed whenever a packet of type BINARY_EVENT is
       * decoded.
       *
       * @param {Object} packet
       * @return {BinaryReconstructor} initialized reconstructor
       * @api private
       */

      function BinaryReconstructor(packet) {
        this.reconPack = packet;
        this.buffers = [];
      }

      /**
       * Method to be called when binary data received from connection
       * after a BINARY_EVENT packet.
       *
       * @param {Buffer | ArrayBuffer} binData - the raw binary data received
       * @return {null | Object} returns null if more binary data is expected or
       *   a reconstructed packet object if all buffers have been received.
       * @api private
       */

      BinaryReconstructor.prototype.takeBinaryData = function (binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          // done with buffer list
          var packet = binary.reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      };

      /**
       * Cleans up binary packet reconstruction variables.
       *
       * @api private
       */

      BinaryReconstructor.prototype.finishedReconstruction = function () {
        this.reconPack = null;
        this.buffers = [];
      };
      function error(msg) {
        return {
          type: exports.ERROR,
          data: 'parser error: ' + msg
        };
      }

      /***/
    }, /* 5 */
    /***/function (module, exports, __webpack_require__) {
      /**
       * Expose `Emitter`.
       */

      if (true) {
        module.exports = Emitter;
      }

      /**
       * Initialize a new `Emitter`.
       *
       * @api public
       */

      function Emitter(obj) {
        if (obj) return mixin(obj);
      }
      ;

      /**
       * Mixin the emitter properties.
       *
       * @param {Object} obj
       * @return {Object}
       * @api private
       */

      function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }
        return obj;
      }

      /**
       * Listen on the given `event` with `fn`.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */

      Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
        return this;
      };

      /**
       * Adds an `event` listener that will be invoked a single
       * time then automatically removed.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */

      Emitter.prototype.once = function (event, fn) {
        function on() {
          this.off(event, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.on(event, on);
        return this;
      };

      /**
       * Remove the given callback for `event` or all
       * registered callbacks.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */

      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};

        // all
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }

        // specific event
        var callbacks = this._callbacks['$' + event];
        if (!callbacks) return this;

        // remove all handlers
        if (1 == arguments.length) {
          delete this._callbacks['$' + event];
          return this;
        }

        // remove specific handler
        var cb;
        for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
          }
        }

        // Remove event specific arrays for event types that no
        // one is subscribed for to avoid memory leak.
        if (callbacks.length === 0) {
          delete this._callbacks['$' + event];
        }
        return this;
      };

      /**
       * Emit `event` with the given args.
       *
       * @param {String} event
       * @param {Mixed} ...
       * @return {Emitter}
       */

      Emitter.prototype.emit = function (event) {
        this._callbacks = this._callbacks || {};
        var args = new Array(arguments.length - 1),
          callbacks = this._callbacks['$' + event];
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i = 0, len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }
        return this;
      };

      /**
       * Return array of callbacks for `event`.
       *
       * @param {String} event
       * @return {Array}
       * @api public
       */

      Emitter.prototype.listeners = function (event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks['$' + event] || [];
      };

      /**
       * Check if this emitter has `event` handlers.
       *
       * @param {String} event
       * @return {Boolean}
       * @api public
       */

      Emitter.prototype.hasListeners = function (event) {
        return !!this.listeners(event).length;
      };

      /***/
    }, /* 6 */
    /***/function (module, exports, __nested_webpack_require_23335__) {
      /*global Blob,File*/

      /**
       * Module requirements
       */

      var isArray = __nested_webpack_require_23335__(7);
      var isBuf = __nested_webpack_require_23335__(8);
      var toString = Object.prototype.toString;
      var withNativeBlob = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
      var withNativeFile = typeof File === 'function' || typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

      /**
       * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
       * Anything with blobs or files should be fed through removeBlobs before coming
       * here.
       *
       * @param {Object} packet - socket.io event packet
       * @return {Object} with deconstructed packet and list of buffers
       * @api public
       */

      exports.deconstructPacket = function (packet) {
        var buffers = [];
        var packetData = packet.data;
        var pack = packet;
        pack.data = _deconstructPacket(packetData, buffers);
        pack.attachments = buffers.length; // number of binary 'attachments'
        return {
          packet: pack,
          buffers: buffers
        };
      };
      function _deconstructPacket(data, buffers) {
        if (!data) return data;
        if (isBuf(data)) {
          var placeholder = {
            _placeholder: true,
            num: buffers.length
          };
          buffers.push(data);
          return placeholder;
        } else if (isArray(data)) {
          var newData = new Array(data.length);
          for (var i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
          }
          return newData;
        } else if (typeof data === 'object' && !(data instanceof Date)) {
          var newData = {};
          for (var key in data) {
            newData[key] = _deconstructPacket(data[key], buffers);
          }
          return newData;
        }
        return data;
      }

      /**
       * Reconstructs a binary packet from its placeholder packet and buffers
       *
       * @param {Object} packet - event packet with placeholders
       * @param {Array} buffers - binary buffers to put in placeholder positions
       * @return {Object} reconstructed packet
       * @api public
       */

      exports.reconstructPacket = function (packet, buffers) {
        packet.data = _reconstructPacket(packet.data, buffers);
        packet.attachments = undefined; // no longer useful
        return packet;
      };
      function _reconstructPacket(data, buffers) {
        if (!data) return data;
        if (data && data._placeholder) {
          return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        } else if (isArray(data)) {
          for (var i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
          }
        } else if (typeof data === 'object') {
          for (var key in data) {
            data[key] = _reconstructPacket(data[key], buffers);
          }
        }
        return data;
      }

      /**
       * Asynchronously removes Blobs or Files from data via
       * FileReader's readAsArrayBuffer method. Used before encoding
       * data as msgpack. Calls callback with the blobless data.
       *
       * @param {Object} data
       * @param {Function} callback
       * @api private
       */

      exports.removeBlobs = function (data, callback) {
        function _removeBlobs(obj, curKey, containingObject) {
          if (!obj) return obj;

          // convert any blob
          if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
            pendingBlobs++;

            // async filereader
            var fileReader = new FileReader();
            fileReader.onload = function () {
              // this.result == arraybuffer
              if (containingObject) {
                containingObject[curKey] = this.result;
              } else {
                bloblessData = this.result;
              }

              // if nothing pending its callback time
              if (! --pendingBlobs) {
                callback(bloblessData);
              }
            };
            fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
          } else if (isArray(obj)) {
            // handle array
            for (var i = 0; i < obj.length; i++) {
              _removeBlobs(obj[i], i, obj);
            }
          } else if (typeof obj === 'object' && !isBuf(obj)) {
            // and object
            for (var key in obj) {
              _removeBlobs(obj[key], key, obj);
            }
          }
        }
        var pendingBlobs = 0;
        var bloblessData = data;
        _removeBlobs(bloblessData);
        if (!pendingBlobs) {
          callback(bloblessData);
        }
      };

      /***/
    }, /* 7 */
    /***/function (module, exports) {
      var toString = {}.toString;
      module.exports = Array.isArray || function (arr) {
        return toString.call(arr) == '[object Array]';
      };

      /***/
    }, /* 8 */
    /***/function (module, exports) {
      module.exports = isBuf;
      var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
      var withNativeArrayBuffer = typeof ArrayBuffer === 'function';
      var isView = function (obj) {
        return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
      };

      /**
       * Returns true if obj is a buffer or an arraybuffer.
       *
       * @api private
       */

      function isBuf(obj) {
        return withNativeBuffer && Buffer.isBuffer(obj) || withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj));
      }

      /***/
    }, /* 9 */
    /***/function (module, exports, __nested_webpack_require_29246__) {
      'use strict';

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      /**
       * Module dependencies.
       */

      var eio = __nested_webpack_require_29246__(10);
      var Socket = __nested_webpack_require_29246__(34);
      var Emitter = __nested_webpack_require_29246__(5);
      var parser = __nested_webpack_require_29246__(4);
      var on = __nested_webpack_require_29246__(36);
      var bind = __nested_webpack_require_29246__(37);
      var debug = __nested_webpack_require_29246__(3)('socket.io-client:manager');
      var indexOf = __nested_webpack_require_29246__(33);
      var Backoff = __nested_webpack_require_29246__(38);

      /**
       * IE6+ hasOwnProperty
       */

      var has = Object.prototype.hasOwnProperty;

      /**
       * Module exports
       */

      module.exports = Manager;

      /**
       * `Manager` constructor.
       *
       * @param {String} engine instance or engine uri/opts
       * @param {Object} options
       * @api public
       */

      function Manager(uri, opts) {
        if (!(this instanceof Manager)) return new Manager(uri, opts);
        if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
          opts = uri;
          uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || '/socket.io';
        this.nsps = {};
        this.subs = [];
        this.opts = opts;
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor(opts.randomizationFactor || 0.5);
        this.backoff = new Backoff({
          min: this.reconnectionDelay(),
          max: this.reconnectionDelayMax(),
          jitter: this.randomizationFactor()
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this.readyState = 'closed';
        this.uri = uri;
        this.connecting = [];
        this.lastPing = null;
        this.encoding = false;
        this.packetBuffer = [];
        var _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this.autoConnect = opts.autoConnect !== false;
        if (this.autoConnect) this.open();
      }

      /**
       * Propagate given event to sockets and emit on `this`
       *
       * @api private
       */

      Manager.prototype.emitAll = function () {
        this.emit.apply(this, arguments);
        for (var nsp in this.nsps) {
          if (has.call(this.nsps, nsp)) {
            this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
          }
        }
      };

      /**
       * Update `socket.id` of all sockets
       *
       * @api private
       */

      Manager.prototype.updateSocketIds = function () {
        for (var nsp in this.nsps) {
          if (has.call(this.nsps, nsp)) {
            this.nsps[nsp].id = this.generateId(nsp);
          }
        }
      };

      /**
       * generate `socket.id` for the given `nsp`
       *
       * @param {String} nsp
       * @return {String}
       * @api private
       */

      Manager.prototype.generateId = function (nsp) {
        return (nsp === '/' ? '' : nsp + '#') + this.engine.id;
      };

      /**
       * Mix in `Emitter`.
       */

      Emitter(Manager.prototype);

      /**
       * Sets the `reconnection` config.
       *
       * @param {Boolean} true/false if it should automatically reconnect
       * @return {Manager} self or value
       * @api public
       */

      Manager.prototype.reconnection = function (v) {
        if (!arguments.length) return this._reconnection;
        this._reconnection = !!v;
        return this;
      };

      /**
       * Sets the reconnection attempts config.
       *
       * @param {Number} max reconnection attempts before giving up
       * @return {Manager} self or value
       * @api public
       */

      Manager.prototype.reconnectionAttempts = function (v) {
        if (!arguments.length) return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
      };

      /**
       * Sets the delay between reconnections.
       *
       * @param {Number} delay
       * @return {Manager} self or value
       * @api public
       */

      Manager.prototype.reconnectionDelay = function (v) {
        if (!arguments.length) return this._reconnectionDelay;
        this._reconnectionDelay = v;
        this.backoff && this.backoff.setMin(v);
        return this;
      };
      Manager.prototype.randomizationFactor = function (v) {
        if (!arguments.length) return this._randomizationFactor;
        this._randomizationFactor = v;
        this.backoff && this.backoff.setJitter(v);
        return this;
      };

      /**
       * Sets the maximum delay between reconnections.
       *
       * @param {Number} delay
       * @return {Manager} self or value
       * @api public
       */

      Manager.prototype.reconnectionDelayMax = function (v) {
        if (!arguments.length) return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        this.backoff && this.backoff.setMax(v);
        return this;
      };

      /**
       * Sets the connection timeout. `false` to disable
       *
       * @return {Manager} self or value
       * @api public
       */

      Manager.prototype.timeout = function (v) {
        if (!arguments.length) return this._timeout;
        this._timeout = v;
        return this;
      };

      /**
       * Starts trying to reconnect if reconnection is enabled and we have not
       * started reconnecting yet
       *
       * @api private
       */

      Manager.prototype.maybeReconnectOnOpen = function () {
        // Only try to reconnect if it's the first time we're connecting
        if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
          // keeps reconnection from firing twice for the same reconnection loop
          this.reconnect();
        }
      };

      /**
       * Sets the current transport `socket`.
       *
       * @param {Function} optional, callback
       * @return {Manager} self
       * @api public
       */

      Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
        if (~this.readyState.indexOf('open')) return this;
        this.engine = eio(this.uri, this.opts);
        var socket = this.engine;
        var self = this;
        this.readyState = 'opening';
        this.skipReconnect = false;

        // emit `open`
        var openSub = on(socket, 'open', function () {
          self.onopen();
          fn && fn();
        });

        // emit `connect_error`
        var errorSub = on(socket, 'error', function (data) {
          self.cleanup();
          self.readyState = 'closed';
          self.emitAll('connect_error', data);
          if (fn) {
            var err = new Error('Connection error');
            err.data = data;
            fn(err);
          } else {
            // Only do this if there is no fn to handle the error
            self.maybeReconnectOnOpen();
          }
        });

        // emit `connect_timeout`
        if (false !== this._timeout) {
          var timeout = this._timeout;
          if (timeout === 0) {
            openSub.destroy(); // prevents a race condition with the 'open' event
          }

          // set timer
          var timer = setTimeout(function () {
            openSub.destroy();
            socket.close();
            socket.emit('error', 'timeout');
            self.emitAll('connect_timeout', timeout);
          }, timeout);
          this.subs.push({
            destroy: function destroy() {
              clearTimeout(timer);
            }
          });
        }
        this.subs.push(openSub);
        this.subs.push(errorSub);
        return this;
      };

      /**
       * Called upon transport open.
       *
       * @api private
       */

      Manager.prototype.onopen = function () {
        // clear old subs
        this.cleanup();

        // mark as open
        this.readyState = 'open';
        this.emit('open');

        // add new subs
        var socket = this.engine;
        this.subs.push(on(socket, 'data', bind(this, 'ondata')));
        this.subs.push(on(socket, 'ping', bind(this, 'onping')));
        this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
        this.subs.push(on(socket, 'error', bind(this, 'onerror')));
        this.subs.push(on(socket, 'close', bind(this, 'onclose')));
        this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
      };

      /**
       * Called upon a ping.
       *
       * @api private
       */

      Manager.prototype.onping = function () {
        this.lastPing = new Date();
        this.emitAll('ping');
      };

      /**
       * Called upon a packet.
       *
       * @api private
       */

      Manager.prototype.onpong = function () {
        this.emitAll('pong', new Date() - this.lastPing);
      };

      /**
       * Called with data.
       *
       * @api private
       */

      Manager.prototype.ondata = function (data) {
        this.decoder.add(data);
      };

      /**
       * Called when parser fully decodes a packet.
       *
       * @api private
       */

      Manager.prototype.ondecoded = function (packet) {
        this.emit('packet', packet);
      };

      /**
       * Called upon socket error.
       *
       * @api private
       */

      Manager.prototype.onerror = function (err) {
        this.emitAll('error', err);
      };

      /**
       * Creates a new socket for the given `nsp`.
       *
       * @return {Socket}
       * @api public
       */

      Manager.prototype.socket = function (nsp, opts) {
        var socket = this.nsps[nsp];
        if (!socket) {
          socket = new Socket(this, nsp, opts);
          this.nsps[nsp] = socket;
          var self = this;
          socket.on('connecting', onConnecting);
          socket.on('connect', function () {
            socket.id = self.generateId(nsp);
          });
          if (this.autoConnect) {
            // manually call here since connecting event is fired before listening
            onConnecting();
          }
        }
        function onConnecting() {
          if (!~indexOf(self.connecting, socket)) {
            self.connecting.push(socket);
          }
        }
        return socket;
      };

      /**
       * Called upon a socket close.
       *
       * @param {Socket} socket
       */

      Manager.prototype.destroy = function (socket) {
        var index = indexOf(this.connecting, socket);
        if (~index) this.connecting.splice(index, 1);
        if (this.connecting.length) return;
        this.close();
      };

      /**
       * Writes a packet.
       *
       * @param {Object} packet
       * @api private
       */

      Manager.prototype.packet = function (packet) {
        var self = this;
        if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;
        if (!self.encoding) {
          // encode, then write to engine with result
          self.encoding = true;
          this.encoder.encode(packet, function (encodedPackets) {
            for (var i = 0; i < encodedPackets.length; i++) {
              self.engine.write(encodedPackets[i], packet.options);
            }
            self.encoding = false;
            self.processPacketQueue();
          });
        } else {
          // add packet to the queue
          self.packetBuffer.push(packet);
        }
      };

      /**
       * If packet buffer is non-empty, begins encoding the
       * next packet in line.
       *
       * @api private
       */

      Manager.prototype.processPacketQueue = function () {
        if (this.packetBuffer.length > 0 && !this.encoding) {
          var pack = this.packetBuffer.shift();
          this.packet(pack);
        }
      };

      /**
       * Clean up transport subscriptions and packet buffer.
       *
       * @api private
       */

      Manager.prototype.cleanup = function () {
        var subsLength = this.subs.length;
        for (var i = 0; i < subsLength; i++) {
          var sub = this.subs.shift();
          sub.destroy();
        }
        this.packetBuffer = [];
        this.encoding = false;
        this.lastPing = null;
        this.decoder.destroy();
      };

      /**
       * Close the current socket.
       *
       * @api private
       */

      Manager.prototype.close = Manager.prototype.disconnect = function () {
        this.skipReconnect = true;
        this.reconnecting = false;
        if ('opening' === this.readyState) {
          // `onclose` will not fire because
          // an open event never happened
          this.cleanup();
        }
        this.backoff.reset();
        this.readyState = 'closed';
        if (this.engine) this.engine.close();
      };

      /**
       * Called upon engine close.
       *
       * @api private
       */

      Manager.prototype.onclose = function (reason) {
        this.cleanup();
        this.backoff.reset();
        this.readyState = 'closed';
        this.emit('close', reason);
        if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      };

      /**
       * Attempt a reconnection.
       *
       * @api private
       */

      Manager.prototype.reconnect = function () {
        if (this.reconnecting || this.skipReconnect) return this;
        var self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
          this.backoff.reset();
          this.emitAll('reconnect_failed');
          this.reconnecting = false;
        } else {
          var delay = this.backoff.duration();
          this.reconnecting = true;
          var timer = setTimeout(function () {
            if (self.skipReconnect) return;
            self.emitAll('reconnect_attempt', self.backoff.attempts);
            self.emitAll('reconnecting', self.backoff.attempts);

            // check again for the case socket closed in above events
            if (self.skipReconnect) return;
            self.open(function (err) {
              if (err) {
                self.reconnecting = false;
                self.reconnect();
                self.emitAll('reconnect_error', err.data);
              } else {
                self.onreconnect();
              }
            });
          }, delay);
          this.subs.push({
            destroy: function destroy() {
              clearTimeout(timer);
            }
          });
        }
      };

      /**
       * Called upon successful reconnect.
       *
       * @api private
       */

      Manager.prototype.onreconnect = function () {
        var attempt = this.backoff.attempts;
        this.reconnecting = false;
        this.backoff.reset();
        this.updateSocketIds();
        this.emitAll('reconnect', attempt);
      };

      /***/
    }, /* 10 */
    /***/function (module, exports, __nested_webpack_require_44571__) {
      module.exports = __nested_webpack_require_44571__(11);

      /**
       * Exports parser
       *
       * @api public
       *
       */
      module.exports.parser = __nested_webpack_require_44571__(19);

      /***/
    }, /* 11 */
    /***/function (module, exports, __nested_webpack_require_44846__) {
      /**
       * Module dependencies.
       */

      var transports = __nested_webpack_require_44846__(12);
      var Emitter = __nested_webpack_require_44846__(5);
      var debug = __nested_webpack_require_44846__(3)('engine.io-client:socket');
      var index = __nested_webpack_require_44846__(33);
      var parser = __nested_webpack_require_44846__(19);
      var parseuri = __nested_webpack_require_44846__(2);
      var parseqs = __nested_webpack_require_44846__(27);

      /**
       * Module exports.
       */

      module.exports = Socket;

      /**
       * Socket constructor.
       *
       * @param {String|Object} uri or options
       * @param {Object} options
       * @api public
       */

      function Socket(uri, opts) {
        if (!(this instanceof Socket)) return new Socket(uri, opts);
        opts = opts || {};
        if (uri && 'object' === typeof uri) {
          opts = uri;
          uri = null;
        }
        if (uri) {
          uri = parseuri(uri);
          opts.hostname = uri.host;
          opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
          opts.port = uri.port;
          if (uri.query) opts.query = uri.query;
        } else if (opts.host) {
          opts.hostname = parseuri(opts.host).host;
        }
        this.secure = null != opts.secure ? opts.secure : typeof location !== 'undefined' && 'https:' === location.protocol;
        if (opts.hostname && !opts.port) {
          // if no port is specified manually, use the protocol default
          opts.port = this.secure ? '443' : '80';
        }
        this.agent = opts.agent || false;
        this.hostname = opts.hostname || (typeof location !== 'undefined' ? location.hostname : 'localhost');
        this.port = opts.port || (typeof location !== 'undefined' && location.port ? location.port : this.secure ? 443 : 80);
        this.query = opts.query || {};
        if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
        this.upgrade = false !== opts.upgrade;
        this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
        this.forceJSONP = !!opts.forceJSONP;
        this.jsonp = false !== opts.jsonp;
        this.forceBase64 = !!opts.forceBase64;
        this.enablesXDR = !!opts.enablesXDR;
        this.withCredentials = false !== opts.withCredentials;
        this.timestampParam = opts.timestampParam || 't';
        this.timestampRequests = opts.timestampRequests;
        this.transports = opts.transports || ['polling', 'websocket'];
        this.transportOptions = opts.transportOptions || {};
        this.readyState = '';
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.policyPort = opts.policyPort || 843;
        this.rememberUpgrade = opts.rememberUpgrade || false;
        this.binaryType = null;
        this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
        this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;
        if (true === this.perMessageDeflate) this.perMessageDeflate = {};
        if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
          this.perMessageDeflate.threshold = 1024;
        }

        // SSL options for Node.js client
        this.pfx = opts.pfx || null;
        this.key = opts.key || null;
        this.passphrase = opts.passphrase || null;
        this.cert = opts.cert || null;
        this.ca = opts.ca || null;
        this.ciphers = opts.ciphers || null;
        this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
        this.forceNode = !!opts.forceNode;

        // detect ReactNative environment
        this.isReactNative = typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';

        // other options for Node.js or ReactNative client
        if (typeof self === 'undefined' || this.isReactNative) {
          if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
            this.extraHeaders = opts.extraHeaders;
          }
          if (opts.localAddress) {
            this.localAddress = opts.localAddress;
          }
        }

        // set on handshake
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;

        // set on heartbeat
        this.pingIntervalTimer = null;
        this.pingTimeoutTimer = null;
        this.open();
      }
      Socket.priorWebsocketSuccess = false;

      /**
       * Mix in `Emitter`.
       */

      Emitter(Socket.prototype);

      /**
       * Protocol version.
       *
       * @api public
       */

      Socket.protocol = parser.protocol; // this is an int

      /**
       * Expose deps for legacy compatibility
       * and standalone browser access.
       */

      Socket.Socket = Socket;
      Socket.Transport = __nested_webpack_require_44846__(18);
      Socket.transports = __nested_webpack_require_44846__(12);
      Socket.parser = __nested_webpack_require_44846__(19);

      /**
       * Creates transport of the given type.
       *
       * @param {String} transport name
       * @return {Transport}
       * @api private
       */

      Socket.prototype.createTransport = function (name) {
        var query = clone(this.query);

        // append engine.io protocol identifier
        query.EIO = parser.protocol;

        // transport name
        query.transport = name;

        // per-transport options
        var options = this.transportOptions[name] || {};

        // session id if we already have one
        if (this.id) query.sid = this.id;
        var transport = new transports[name]({
          query: query,
          socket: this,
          agent: options.agent || this.agent,
          hostname: options.hostname || this.hostname,
          port: options.port || this.port,
          secure: options.secure || this.secure,
          path: options.path || this.path,
          forceJSONP: options.forceJSONP || this.forceJSONP,
          jsonp: options.jsonp || this.jsonp,
          forceBase64: options.forceBase64 || this.forceBase64,
          enablesXDR: options.enablesXDR || this.enablesXDR,
          withCredentials: options.withCredentials || this.withCredentials,
          timestampRequests: options.timestampRequests || this.timestampRequests,
          timestampParam: options.timestampParam || this.timestampParam,
          policyPort: options.policyPort || this.policyPort,
          pfx: options.pfx || this.pfx,
          key: options.key || this.key,
          passphrase: options.passphrase || this.passphrase,
          cert: options.cert || this.cert,
          ca: options.ca || this.ca,
          ciphers: options.ciphers || this.ciphers,
          rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
          perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
          extraHeaders: options.extraHeaders || this.extraHeaders,
          forceNode: options.forceNode || this.forceNode,
          localAddress: options.localAddress || this.localAddress,
          requestTimeout: options.requestTimeout || this.requestTimeout,
          protocols: options.protocols || void 0,
          isReactNative: this.isReactNative
        });
        return transport;
      };
      function clone(obj) {
        var o = {};
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            o[i] = obj[i];
          }
        }
        return o;
      }

      /**
       * Initializes transport to use and starts probe.
       *
       * @api private
       */
      Socket.prototype.open = function () {
        var transport;
        if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
          transport = 'websocket';
        } else if (0 === this.transports.length) {
          // Emit error on next tick so it can be listened to
          var self = this;
          setTimeout(function () {
            self.emit('error', 'No transports available');
          }, 0);
          return;
        } else {
          transport = this.transports[0];
        }
        this.readyState = 'opening';

        // Retry with the next transport if the transport is disabled (jsonp: false)
        try {
          transport = this.createTransport(transport);
        } catch (e) {
          this.transports.shift();
          this.open();
          return;
        }
        transport.open();
        this.setTransport(transport);
      };

      /**
       * Sets the current transport. Disables the existing one (if any).
       *
       * @api private
       */

      Socket.prototype.setTransport = function (transport) {
        var self = this;
        if (this.transport) {
          this.transport.removeAllListeners();
        }

        // set up transport
        this.transport = transport;

        // set up transport listeners
        transport.on('drain', function () {
          self.onDrain();
        }).on('packet', function (packet) {
          self.onPacket(packet);
        }).on('error', function (e) {
          self.onError(e);
        }).on('close', function () {
          self.onClose('transport close');
        });
      };

      /**
       * Probes a transport.
       *
       * @param {String} transport name
       * @api private
       */

      Socket.prototype.probe = function (name) {
        var transport = this.createTransport(name, {
          probe: 1
        });
        var failed = false;
        var self = this;
        Socket.priorWebsocketSuccess = false;
        function onTransportOpen() {
          if (self.onlyBinaryUpgrades) {
            var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
            failed = failed || upgradeLosesBinary;
          }
          if (failed) return;
          transport.send([{
            type: 'ping',
            data: 'probe'
          }]);
          transport.once('packet', function (msg) {
            if (failed) return;
            if ('pong' === msg.type && 'probe' === msg.data) {
              self.upgrading = true;
              self.emit('upgrading', transport);
              if (!transport) return;
              Socket.priorWebsocketSuccess = 'websocket' === transport.name;
              self.transport.pause(function () {
                if (failed) return;
                if ('closed' === self.readyState) return;
                cleanup();
                self.setTransport(transport);
                transport.send([{
                  type: 'upgrade'
                }]);
                self.emit('upgrade', transport);
                transport = null;
                self.upgrading = false;
                self.flush();
              });
            } else {
              var err = new Error('probe error');
              err.transport = transport.name;
              self.emit('upgradeError', err);
            }
          });
        }
        function freezeTransport() {
          if (failed) return;

          // Any callback called by transport should be ignored since now
          failed = true;
          cleanup();
          transport.close();
          transport = null;
        }

        // Handle any error that happens while probing
        function onerror(err) {
          var error = new Error('probe error: ' + err);
          error.transport = transport.name;
          freezeTransport();
          self.emit('upgradeError', error);
        }
        function onTransportClose() {
          onerror('transport closed');
        }

        // When the socket is closed while we're probing
        function onclose() {
          onerror('socket closed');
        }

        // When the socket is upgraded while we're probing
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            freezeTransport();
          }
        }

        // Remove all listeners on the transport and on self
        function cleanup() {
          transport.removeListener('open', onTransportOpen);
          transport.removeListener('error', onerror);
          transport.removeListener('close', onTransportClose);
          self.removeListener('close', onclose);
          self.removeListener('upgrading', onupgrade);
        }
        transport.once('open', onTransportOpen);
        transport.once('error', onerror);
        transport.once('close', onTransportClose);
        this.once('close', onclose);
        this.once('upgrading', onupgrade);
        transport.open();
      };

      /**
       * Called when connection is deemed open.
       *
       * @api public
       */

      Socket.prototype.onOpen = function () {
        this.readyState = 'open';
        Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
        this.emit('open');
        this.flush();

        // we check for `readyState` in case an `open`
        // listener already closed the socket
        if ('open' === this.readyState && this.upgrade && this.transport.pause) {
          for (var i = 0, l = this.upgrades.length; i < l; i++) {
            this.probe(this.upgrades[i]);
          }
        }
      };

      /**
       * Handles a packet.
       *
       * @api private
       */

      Socket.prototype.onPacket = function (packet) {
        if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
          this.emit('packet', packet);

          // Socket is live - any packet counts
          this.emit('heartbeat');
          switch (packet.type) {
            case 'open':
              this.onHandshake(JSON.parse(packet.data));
              break;
            case 'pong':
              this.setPing();
              this.emit('pong');
              break;
            case 'error':
              var err = new Error('server error');
              err.code = packet.data;
              this.onError(err);
              break;
            case 'message':
              this.emit('data', packet.data);
              this.emit('message', packet.data);
              break;
          }
        } else {}
      };

      /**
       * Called upon handshake completion.
       *
       * @param {Object} handshake obj
       * @api private
       */

      Socket.prototype.onHandshake = function (data) {
        this.emit('handshake', data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.onOpen();
        // In case open handler closes socket
        if ('closed' === this.readyState) return;
        this.setPing();

        // Prolong liveness of socket on heartbeat
        this.removeListener('heartbeat', this.onHeartbeat);
        this.on('heartbeat', this.onHeartbeat);
      };

      /**
       * Resets ping timeout.
       *
       * @api private
       */

      Socket.prototype.onHeartbeat = function (timeout) {
        clearTimeout(this.pingTimeoutTimer);
        var self = this;
        self.pingTimeoutTimer = setTimeout(function () {
          if ('closed' === self.readyState) return;
          self.onClose('ping timeout');
        }, timeout || self.pingInterval + self.pingTimeout);
      };

      /**
       * Pings server every `this.pingInterval` and expects response
       * within `this.pingTimeout` or closes connection.
       *
       * @api private
       */

      Socket.prototype.setPing = function () {
        var self = this;
        clearTimeout(self.pingIntervalTimer);
        self.pingIntervalTimer = setTimeout(function () {
          self.ping();
          self.onHeartbeat(self.pingTimeout);
        }, self.pingInterval);
      };

      /**
      * Sends a ping packet.
      *
      * @api private
      */

      Socket.prototype.ping = function () {
        var self = this;
        this.sendPacket('ping', function () {
          self.emit('ping');
        });
      };

      /**
       * Called on `drain` event
       *
       * @api private
       */

      Socket.prototype.onDrain = function () {
        this.writeBuffer.splice(0, this.prevBufferLen);

        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
          this.emit('drain');
        } else {
          this.flush();
        }
      };

      /**
       * Flush write buffers.
       *
       * @api private
       */

      Socket.prototype.flush = function () {
        if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          this.transport.send(this.writeBuffer);
          // keep track of current length of writeBuffer
          // splice writeBuffer and callbackBuffer on `drain`
          this.prevBufferLen = this.writeBuffer.length;
          this.emit('flush');
        }
      };

      /**
       * Sends a message.
       *
       * @param {String} message.
       * @param {Function} callback function.
       * @param {Object} options.
       * @return {Socket} for chaining.
       * @api public
       */

      Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
        this.sendPacket('message', msg, options, fn);
        return this;
      };

      /**
       * Sends a packet.
       *
       * @param {String} packet type.
       * @param {String} data.
       * @param {Object} options.
       * @param {Function} callback function.
       * @api private
       */

      Socket.prototype.sendPacket = function (type, data, options, fn) {
        if ('function' === typeof data) {
          fn = data;
          data = undefined;
        }
        if ('function' === typeof options) {
          fn = options;
          options = null;
        }
        if ('closing' === this.readyState || 'closed' === this.readyState) {
          return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        var packet = {
          type: type,
          data: data,
          options: options
        };
        this.emit('packetCreate', packet);
        this.writeBuffer.push(packet);
        if (fn) this.once('flush', fn);
        this.flush();
      };

      /**
       * Closes the connection.
       *
       * @api private
       */

      Socket.prototype.close = function () {
        if ('opening' === this.readyState || 'open' === this.readyState) {
          this.readyState = 'closing';
          var self = this;
          if (this.writeBuffer.length) {
            this.once('drain', function () {
              if (this.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        }
        function close() {
          self.onClose('forced close');
          self.transport.close();
        }
        function cleanupAndClose() {
          self.removeListener('upgrade', cleanupAndClose);
          self.removeListener('upgradeError', cleanupAndClose);
          close();
        }
        function waitForUpgrade() {
          // wait for upgrade to finish since we can't send packets while pausing a transport
          self.once('upgrade', cleanupAndClose);
          self.once('upgradeError', cleanupAndClose);
        }
        return this;
      };

      /**
       * Called upon transport error
       *
       * @api private
       */

      Socket.prototype.onError = function (err) {
        Socket.priorWebsocketSuccess = false;
        this.emit('error', err);
        this.onClose('transport error', err);
      };

      /**
       * Called upon transport close.
       *
       * @api private
       */

      Socket.prototype.onClose = function (reason, desc) {
        if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
          var self = this;

          // clear timers
          clearTimeout(this.pingIntervalTimer);
          clearTimeout(this.pingTimeoutTimer);

          // stop event from firing again for transport
          this.transport.removeAllListeners('close');

          // ensure transport won't stay open
          this.transport.close();

          // ignore further transport communication
          this.transport.removeAllListeners();

          // set ready state
          this.readyState = 'closed';

          // clear session id
          this.id = null;

          // emit close event
          this.emit('close', reason, desc);

          // clean buffers after, so users can still
          // grab the buffers on `close` event
          self.writeBuffer = [];
          self.prevBufferLen = 0;
        }
      };

      /**
       * Filters upgrades, returning only those matching client transports.
       *
       * @param {Array} server upgrades
       * @api private
       *
       */

      Socket.prototype.filterUpgrades = function (upgrades) {
        var filteredUpgrades = [];
        for (var i = 0, j = upgrades.length; i < j; i++) {
          if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
      };

      /***/
    }, /* 12 */
    /***/function (module, exports, __nested_webpack_require_66434__) {
      /**
       * Module dependencies
       */

      var XMLHttpRequest = __nested_webpack_require_66434__(13);
      var XHR = __nested_webpack_require_66434__(16);
      var JSONP = __nested_webpack_require_66434__(30);
      var websocket = __nested_webpack_require_66434__(31);

      /**
       * Export transports.
       */

      exports.polling = polling;
      exports.websocket = websocket;

      /**
       * Polling transport polymorphic constructor.
       * Decides on xhr vs jsonp based on feature detection.
       *
       * @api private
       */

      function polling(opts) {
        var xhr;
        var xd = false;
        var xs = false;
        var jsonp = false !== opts.jsonp;
        if (typeof location !== 'undefined') {
          var isSSL = 'https:' === location.protocol;
          var port = location.port;

          // some user agents have empty `location.port`
          if (!port) {
            port = isSSL ? 443 : 80;
          }
          xd = opts.hostname !== location.hostname || port !== opts.port;
          xs = opts.secure !== isSSL;
        }
        opts.xdomain = xd;
        opts.xscheme = xs;
        xhr = new XMLHttpRequest(opts);
        if ('open' in xhr && !opts.forceJSONP) {
          return new XHR(opts);
        } else {
          if (!jsonp) throw new Error('JSONP disabled');
          return new JSONP(opts);
        }
      }

      /***/
    }, /* 13 */
    /***/function (module, exports, __nested_webpack_require_67869__) {
      // browser shim for xmlhttprequest module

      var hasCORS = __nested_webpack_require_67869__(14);
      var globalThis = __nested_webpack_require_67869__(15);
      module.exports = function (opts) {
        var xdomain = opts.xdomain;

        // scheme must be same when usign XDomainRequest
        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
        var xscheme = opts.xscheme;

        // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
        // https://github.com/Automattic/engine.io-client/pull/217
        var enablesXDR = opts.enablesXDR;

        // XMLHttpRequest can be disabled on IE
        try {
          if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
            return new XMLHttpRequest();
          }
        } catch (e) {}

        // Use XDomainRequest for IE8 if enablesXDR is true
        // because loading bar keeps flashing when using jsonp-polling
        // https://github.com/yujiosaka/socke.io-ie8-loading-example
        try {
          if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
            return new XDomainRequest();
          }
        } catch (e) {}
        if (!xdomain) {
          try {
            return new globalThis[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
          } catch (e) {}
        }
      };

      /***/
    }, /* 14 */
    /***/function (module, exports) {
      /**
       * Module exports.
       *
       * Logic borrowed from Modernizr:
       *
       *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
       */

      try {
        module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
      } catch (err) {
        // if XMLHttp support is disabled in IE then it will throw
        // when trying to create
        module.exports = false;
      }

      /***/
    }, /* 15 */
    /***/function (module, exports) {
      module.exports = function () {
        if (typeof self !== 'undefined') {
          return self;
        } else if (typeof window !== 'undefined') {
          return window;
        } else {
          return Function('return this')(); // eslint-disable-line no-new-func
        }
      }();

      /***/
    }, /* 16 */
    /***/function (module, exports, __nested_webpack_require_70289__) {
      /* global attachEvent */

      /**
       * Module requirements.
       */

      var XMLHttpRequest = __nested_webpack_require_70289__(13);
      var Polling = __nested_webpack_require_70289__(17);
      var Emitter = __nested_webpack_require_70289__(5);
      var inherit = __nested_webpack_require_70289__(28);
      var debug = __nested_webpack_require_70289__(3)('engine.io-client:polling-xhr');
      var globalThis = __nested_webpack_require_70289__(15);

      /**
       * Module exports.
       */

      module.exports = XHR;
      module.exports.Request = Request;

      /**
       * Empty function
       */

      function empty() {}

      /**
       * XHR Polling constructor.
       *
       * @param {Object} opts
       * @api public
       */

      function XHR(opts) {
        Polling.call(this, opts);
        this.requestTimeout = opts.requestTimeout;
        this.extraHeaders = opts.extraHeaders;
        if (typeof location !== 'undefined') {
          var isSSL = 'https:' === location.protocol;
          var port = location.port;

          // some user agents have empty `location.port`
          if (!port) {
            port = isSSL ? 443 : 80;
          }
          this.xd = typeof location !== 'undefined' && opts.hostname !== location.hostname || port !== opts.port;
          this.xs = opts.secure !== isSSL;
        }
      }

      /**
       * Inherits from Polling.
       */

      inherit(XHR, Polling);

      /**
       * XHR supports binary
       */

      XHR.prototype.supportsBinary = true;

      /**
       * Creates a request.
       *
       * @param {String} method
       * @api private
       */

      XHR.prototype.request = function (opts) {
        opts = opts || {};
        opts.uri = this.uri();
        opts.xd = this.xd;
        opts.xs = this.xs;
        opts.agent = this.agent || false;
        opts.supportsBinary = this.supportsBinary;
        opts.enablesXDR = this.enablesXDR;
        opts.withCredentials = this.withCredentials;

        // SSL options for Node.js client
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        opts.requestTimeout = this.requestTimeout;

        // other options for Node.js client
        opts.extraHeaders = this.extraHeaders;
        return new Request(opts);
      };

      /**
       * Sends data.
       *
       * @param {String} data to send.
       * @param {Function} called upon flush.
       * @api private
       */

      XHR.prototype.doWrite = function (data, fn) {
        var isBinary = typeof data !== 'string' && data !== undefined;
        var req = this.request({
          method: 'POST',
          data: data,
          isBinary: isBinary
        });
        var self = this;
        req.on('success', fn);
        req.on('error', function (err) {
          self.onError('xhr post error', err);
        });
        this.sendXhr = req;
      };

      /**
       * Starts a poll cycle.
       *
       * @api private
       */

      XHR.prototype.doPoll = function () {
        var req = this.request();
        var self = this;
        req.on('data', function (data) {
          self.onData(data);
        });
        req.on('error', function (err) {
          self.onError('xhr poll error', err);
        });
        this.pollXhr = req;
      };

      /**
       * Request constructor
       *
       * @param {Object} options
       * @api public
       */

      function Request(opts) {
        this.method = opts.method || 'GET';
        this.uri = opts.uri;
        this.xd = !!opts.xd;
        this.xs = !!opts.xs;
        this.async = false !== opts.async;
        this.data = undefined !== opts.data ? opts.data : null;
        this.agent = opts.agent;
        this.isBinary = opts.isBinary;
        this.supportsBinary = opts.supportsBinary;
        this.enablesXDR = opts.enablesXDR;
        this.withCredentials = opts.withCredentials;
        this.requestTimeout = opts.requestTimeout;

        // SSL options for Node.js client
        this.pfx = opts.pfx;
        this.key = opts.key;
        this.passphrase = opts.passphrase;
        this.cert = opts.cert;
        this.ca = opts.ca;
        this.ciphers = opts.ciphers;
        this.rejectUnauthorized = opts.rejectUnauthorized;

        // other options for Node.js client
        this.extraHeaders = opts.extraHeaders;
        this.create();
      }

      /**
       * Mix in `Emitter`.
       */

      Emitter(Request.prototype);

      /**
       * Creates the XHR object and sends the request.
       *
       * @api private
       */

      Request.prototype.create = function () {
        var opts = {
          agent: this.agent,
          xdomain: this.xd,
          xscheme: this.xs,
          enablesXDR: this.enablesXDR
        };

        // SSL options for Node.js client
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        var xhr = this.xhr = new XMLHttpRequest(opts);
        var self = this;
        try {
          xhr.open(this.method, this.uri, this.async);
          try {
            if (this.extraHeaders) {
              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
              for (var i in this.extraHeaders) {
                if (this.extraHeaders.hasOwnProperty(i)) {
                  xhr.setRequestHeader(i, this.extraHeaders[i]);
                }
              }
            }
          } catch (e) {}
          if ('POST' === this.method) {
            try {
              if (this.isBinary) {
                xhr.setRequestHeader('Content-type', 'application/octet-stream');
              } else {
                xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
              }
            } catch (e) {}
          }
          try {
            xhr.setRequestHeader('Accept', '*/*');
          } catch (e) {}

          // ie6 check
          if ('withCredentials' in xhr) {
            xhr.withCredentials = this.withCredentials;
          }
          if (this.requestTimeout) {
            xhr.timeout = this.requestTimeout;
          }
          if (this.hasXDR()) {
            xhr.onload = function () {
              self.onLoad();
            };
            xhr.onerror = function () {
              self.onError(xhr.responseText);
            };
          } else {
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 2) {
                try {
                  var contentType = xhr.getResponseHeader('Content-Type');
                  if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
                    xhr.responseType = 'arraybuffer';
                  }
                } catch (e) {}
              }
              if (4 !== xhr.readyState) return;
              if (200 === xhr.status || 1223 === xhr.status) {
                self.onLoad();
              } else {
                // make sure the `error` event handler that's user-set
                // does not throw in the same tick and gets caught here
                setTimeout(function () {
                  self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
                }, 0);
              }
            };
          }
          xhr.send(this.data);
        } catch (e) {
          // Need to defer since .create() is called directly fhrom the constructor
          // and thus the 'error' event can only be only bound *after* this exception
          // occurs.  Therefore, also, we cannot throw here at all.
          setTimeout(function () {
            self.onError(e);
          }, 0);
          return;
        }
        if (typeof document !== 'undefined') {
          this.index = Request.requestsCount++;
          Request.requests[this.index] = this;
        }
      };

      /**
       * Called upon successful response.
       *
       * @api private
       */

      Request.prototype.onSuccess = function () {
        this.emit('success');
        this.cleanup();
      };

      /**
       * Called if we have data.
       *
       * @api private
       */

      Request.prototype.onData = function (data) {
        this.emit('data', data);
        this.onSuccess();
      };

      /**
       * Called upon error.
       *
       * @api private
       */

      Request.prototype.onError = function (err) {
        this.emit('error', err);
        this.cleanup(true);
      };

      /**
       * Cleans up house.
       *
       * @api private
       */

      Request.prototype.cleanup = function (fromError) {
        if ('undefined' === typeof this.xhr || null === this.xhr) {
          return;
        }
        // xmlhttprequest
        if (this.hasXDR()) {
          this.xhr.onload = this.xhr.onerror = empty;
        } else {
          this.xhr.onreadystatechange = empty;
        }
        if (fromError) {
          try {
            this.xhr.abort();
          } catch (e) {}
        }
        if (typeof document !== 'undefined') {
          delete Request.requests[this.index];
        }
        this.xhr = null;
      };

      /**
       * Called upon load.
       *
       * @api private
       */

      Request.prototype.onLoad = function () {
        var data;
        try {
          var contentType;
          try {
            contentType = this.xhr.getResponseHeader('Content-Type');
          } catch (e) {}
          if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
            data = this.xhr.response || this.xhr.responseText;
          } else {
            data = this.xhr.responseText;
          }
        } catch (e) {
          this.onError(e);
        }
        if (null != data) {
          this.onData(data);
        }
      };

      /**
       * Check if it has XDomainRequest.
       *
       * @api private
       */

      Request.prototype.hasXDR = function () {
        return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
      };

      /**
       * Aborts the request.
       *
       * @api public
       */

      Request.prototype.abort = function () {
        this.cleanup();
      };

      /**
       * Aborts pending requests when unloading the window. This is needed to prevent
       * memory leaks (e.g. when using IE) and to ensure that no spurious error is
       * emitted.
       */

      Request.requestsCount = 0;
      Request.requests = {};
      if (typeof document !== 'undefined') {
        if (typeof attachEvent === 'function') {
          attachEvent('onunload', unloadHandler);
        } else if (typeof addEventListener === 'function') {
          var terminationEvent = 'onpagehide' in globalThis ? 'pagehide' : 'unload';
          addEventListener(terminationEvent, unloadHandler, false);
        }
      }
      function unloadHandler() {
        for (var i in Request.requests) {
          if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
          }
        }
      }

      /***/
    }, /* 17 */
    /***/function (module, exports, __nested_webpack_require_81699__) {
      /**
       * Module dependencies.
       */

      var Transport = __nested_webpack_require_81699__(18);
      var parseqs = __nested_webpack_require_81699__(27);
      var parser = __nested_webpack_require_81699__(19);
      var inherit = __nested_webpack_require_81699__(28);
      var yeast = __nested_webpack_require_81699__(29);
      var debug = __nested_webpack_require_81699__(3)('engine.io-client:polling');

      /**
       * Module exports.
       */

      module.exports = Polling;

      /**
       * Is XHR2 supported?
       */

      var hasXHR2 = function () {
        var XMLHttpRequest = __nested_webpack_require_81699__(13);
        var xhr = new XMLHttpRequest({
          xdomain: false
        });
        return null != xhr.responseType;
      }();

      /**
       * Polling interface.
       *
       * @param {Object} opts
       * @api private
       */

      function Polling(opts) {
        var forceBase64 = opts && opts.forceBase64;
        if (!hasXHR2 || forceBase64) {
          this.supportsBinary = false;
        }
        Transport.call(this, opts);
      }

      /**
       * Inherits from Transport.
       */

      inherit(Polling, Transport);

      /**
       * Transport name.
       */

      Polling.prototype.name = 'polling';

      /**
       * Opens the socket (triggers polling). We write a PING message to determine
       * when the transport is open.
       *
       * @api private
       */

      Polling.prototype.doOpen = function () {
        this.poll();
      };

      /**
       * Pauses polling.
       *
       * @param {Function} callback upon buffers are flushed and transport is paused
       * @api private
       */

      Polling.prototype.pause = function (onPause) {
        var self = this;
        this.readyState = 'pausing';
        function pause() {
          self.readyState = 'paused';
          onPause();
        }
        if (this.polling || !this.writable) {
          var total = 0;
          if (this.polling) {
            total++;
            this.once('pollComplete', function () {
              --total || pause();
            });
          }
          if (!this.writable) {
            total++;
            this.once('drain', function () {
              --total || pause();
            });
          }
        } else {
          pause();
        }
      };

      /**
       * Starts polling cycle.
       *
       * @api public
       */

      Polling.prototype.poll = function () {
        this.polling = true;
        this.doPoll();
        this.emit('poll');
      };

      /**
       * Overloads onData to detect payloads.
       *
       * @api private
       */

      Polling.prototype.onData = function (data) {
        var self = this;
        var callback = function (packet, index, total) {
          // if its the first message we consider the transport open
          if ('opening' === self.readyState && packet.type === 'open') {
            self.onOpen();
          }

          // if its a close packet, we close the ongoing requests
          if ('close' === packet.type) {
            self.onClose();
            return false;
          }

          // otherwise bypass onData and handle the message
          self.onPacket(packet);
        };

        // decode payload
        parser.decodePayload(data, this.socket.binaryType, callback);

        // if an event did not trigger closing
        if ('closed' !== this.readyState) {
          // if we got data we're not polling
          this.polling = false;
          this.emit('pollComplete');
          if ('open' === this.readyState) {
            this.poll();
          } else {}
        }
      };

      /**
       * For polling, send a close packet.
       *
       * @api private
       */

      Polling.prototype.doClose = function () {
        var self = this;
        function close() {
          self.write([{
            type: 'close'
          }]);
        }
        if ('open' === this.readyState) {
          close();
        } else {
          // in case we're trying to close while
          // handshaking is in progress (GH-164)

          this.once('open', close);
        }
      };

      /**
       * Writes a packets payload.
       *
       * @param {Array} data packets
       * @param {Function} drain callback
       * @api private
       */

      Polling.prototype.write = function (packets) {
        var self = this;
        this.writable = false;
        var callbackfn = function () {
          self.writable = true;
          self.emit('drain');
        };
        parser.encodePayload(packets, this.supportsBinary, function (data) {
          self.doWrite(data, callbackfn);
        });
      };

      /**
       * Generates uri for connection.
       *
       * @api private
       */

      Polling.prototype.uri = function () {
        var query = this.query || {};
        var schema = this.secure ? 'https' : 'http';
        var port = '';

        // cache busting is forced
        if (false !== this.timestampRequests) {
          query[this.timestampParam] = yeast();
        }
        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }
        query = parseqs.encode(query);

        // avoid port if default for schema
        if (this.port && ('https' === schema && Number(this.port) !== 443 || 'http' === schema && Number(this.port) !== 80)) {
          port = ':' + this.port;
        }

        // prepend ? to query
        if (query.length) {
          query = '?' + query;
        }
        var ipv6 = this.hostname.indexOf(':') !== -1;
        return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
      };

      /***/
    }, /* 18 */
    /***/function (module, exports, __nested_webpack_require_87415__) {
      /**
       * Module dependencies.
       */

      var parser = __nested_webpack_require_87415__(19);
      var Emitter = __nested_webpack_require_87415__(5);

      /**
       * Module exports.
       */

      module.exports = Transport;

      /**
       * Transport abstract constructor.
       *
       * @param {Object} options.
       * @api private
       */

      function Transport(opts) {
        this.path = opts.path;
        this.hostname = opts.hostname;
        this.port = opts.port;
        this.secure = opts.secure;
        this.query = opts.query;
        this.timestampParam = opts.timestampParam;
        this.timestampRequests = opts.timestampRequests;
        this.readyState = '';
        this.agent = opts.agent || false;
        this.socket = opts.socket;
        this.enablesXDR = opts.enablesXDR;
        this.withCredentials = opts.withCredentials;

        // SSL options for Node.js client
        this.pfx = opts.pfx;
        this.key = opts.key;
        this.passphrase = opts.passphrase;
        this.cert = opts.cert;
        this.ca = opts.ca;
        this.ciphers = opts.ciphers;
        this.rejectUnauthorized = opts.rejectUnauthorized;
        this.forceNode = opts.forceNode;

        // results of ReactNative environment detection
        this.isReactNative = opts.isReactNative;

        // other options for Node.js client
        this.extraHeaders = opts.extraHeaders;
        this.localAddress = opts.localAddress;
      }

      /**
       * Mix in `Emitter`.
       */

      Emitter(Transport.prototype);

      /**
       * Emits an error.
       *
       * @param {String} str
       * @return {Transport} for chaining
       * @api public
       */

      Transport.prototype.onError = function (msg, desc) {
        var err = new Error(msg);
        err.type = 'TransportError';
        err.description = desc;
        this.emit('error', err);
        return this;
      };

      /**
       * Opens the transport.
       *
       * @api public
       */

      Transport.prototype.open = function () {
        if ('closed' === this.readyState || '' === this.readyState) {
          this.readyState = 'opening';
          this.doOpen();
        }
        return this;
      };

      /**
       * Closes the transport.
       *
       * @api private
       */

      Transport.prototype.close = function () {
        if ('opening' === this.readyState || 'open' === this.readyState) {
          this.doClose();
          this.onClose();
        }
        return this;
      };

      /**
       * Sends multiple packets.
       *
       * @param {Array} packets
       * @api private
       */

      Transport.prototype.send = function (packets) {
        if ('open' === this.readyState) {
          this.write(packets);
        } else {
          throw new Error('Transport not open');
        }
      };

      /**
       * Called upon open
       *
       * @api private
       */

      Transport.prototype.onOpen = function () {
        this.readyState = 'open';
        this.writable = true;
        this.emit('open');
      };

      /**
       * Called with data.
       *
       * @param {String} data
       * @api private
       */

      Transport.prototype.onData = function (data) {
        var packet = parser.decodePacket(data, this.socket.binaryType);
        this.onPacket(packet);
      };

      /**
       * Called with a decoded packet.
       */

      Transport.prototype.onPacket = function (packet) {
        this.emit('packet', packet);
      };

      /**
       * Called upon close.
       *
       * @api private
       */

      Transport.prototype.onClose = function () {
        this.readyState = 'closed';
        this.emit('close');
      };

      /***/
    }, /* 19 */
    /***/function (module, exports, __nested_webpack_require_91217__) {
      /**
       * Module dependencies.
       */

      var keys = __nested_webpack_require_91217__(20);
      var hasBinary = __nested_webpack_require_91217__(21);
      var sliceBuffer = __nested_webpack_require_91217__(22);
      var after = __nested_webpack_require_91217__(23);
      var utf8 = __nested_webpack_require_91217__(24);
      var base64encoder;
      if (typeof ArrayBuffer !== 'undefined') {
        base64encoder = __nested_webpack_require_91217__(25);
      }

      /**
       * Check if we are running an android browser. That requires us to use
       * ArrayBuffer with polling transports...
       *
       * http://ghinda.net/jpeg-blob-ajax-android/
       */

      var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

      /**
       * Check if we are running in PhantomJS.
       * Uploading a Blob with PhantomJS does not work correctly, as reported here:
       * https://github.com/ariya/phantomjs/issues/11395
       * @type boolean
       */
      var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

      /**
       * When true, avoids using Blobs to encode payloads.
       * @type boolean
       */
      var dontSendBlobs = isAndroid || isPhantomJS;

      /**
       * Current protocol version.
       */

      exports.protocol = 3;

      /**
       * Packet types.
       */

      var packets = exports.packets = {
        open: 0 // non-ws
        ,
        close: 1 // non-ws
        ,
        ping: 2,
        pong: 3,
        message: 4,
        upgrade: 5,
        noop: 6
      };
      var packetslist = keys(packets);

      /**
       * Premade error packet.
       */

      var err = {
        type: 'error',
        data: 'parser error'
      };

      /**
       * Create a blob api even for blob builder when vendor prefixes exist
       */

      var Blob = __nested_webpack_require_91217__(26);

      /**
       * Encodes a packet.
       *
       *     <packet type id> [ <data> ]
       *
       * Example:
       *
       *     5hello world
       *     3
       *     4
       *
       * Binary is encoded in an identical principle
       *
       * @api private
       */

      exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
        if (typeof supportsBinary === 'function') {
          callback = supportsBinary;
          supportsBinary = false;
        }
        if (typeof utf8encode === 'function') {
          callback = utf8encode;
          utf8encode = null;
        }
        var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;
        if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
          return encodeArrayBuffer(packet, supportsBinary, callback);
        } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
          return encodeBlob(packet, supportsBinary, callback);
        }

        // might be an object with { base64: true, data: dataAsBase64String }
        if (data && data.base64) {
          return encodeBase64Object(packet, callback);
        }

        // Sending data as a utf-8 string
        var encoded = packets[packet.type];

        // data fragment is optional
        if (undefined !== packet.data) {
          encoded += utf8encode ? utf8.encode(String(packet.data), {
            strict: false
          }) : String(packet.data);
        }
        return callback('' + encoded);
      };
      function encodeBase64Object(packet, callback) {
        // packet data is an object { base64: true, data: dataAsBase64String }
        var message = 'b' + exports.packets[packet.type] + packet.data.data;
        return callback(message);
      }

      /**
       * Encode packet helpers for binary types
       */

      function encodeArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports.encodeBase64Packet(packet, callback);
        }
        var data = packet.data;
        var contentArray = new Uint8Array(data);
        var resultBuffer = new Uint8Array(1 + data.byteLength);
        resultBuffer[0] = packets[packet.type];
        for (var i = 0; i < contentArray.length; i++) {
          resultBuffer[i + 1] = contentArray[i];
        }
        return callback(resultBuffer.buffer);
      }
      function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports.encodeBase64Packet(packet, callback);
        }
        var fr = new FileReader();
        fr.onload = function () {
          exports.encodePacket({
            type: packet.type,
            data: fr.result
          }, supportsBinary, true, callback);
        };
        return fr.readAsArrayBuffer(packet.data);
      }
      function encodeBlob(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports.encodeBase64Packet(packet, callback);
        }
        if (dontSendBlobs) {
          return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
        }
        var length = new Uint8Array(1);
        length[0] = packets[packet.type];
        var blob = new Blob([length.buffer, packet.data]);
        return callback(blob);
      }

      /**
       * Encodes a packet with binary data in a base64 string
       *
       * @param {Object} packet, has `type` and `data`
       * @return {String} base64 encoded message
       */

      exports.encodeBase64Packet = function (packet, callback) {
        var message = 'b' + exports.packets[packet.type];
        if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
          var fr = new FileReader();
          fr.onload = function () {
            var b64 = fr.result.split(',')[1];
            callback(message + b64);
          };
          return fr.readAsDataURL(packet.data);
        }
        var b64data;
        try {
          b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
        } catch (e) {
          // iPhone Safari doesn't let you apply with typed arrays
          var typed = new Uint8Array(packet.data);
          var basic = new Array(typed.length);
          for (var i = 0; i < typed.length; i++) {
            basic[i] = typed[i];
          }
          b64data = String.fromCharCode.apply(null, basic);
        }
        message += btoa(b64data);
        return callback(message);
      };

      /**
       * Decodes a packet. Changes format to Blob if requested.
       *
       * @return {Object} with `type` and `data` (if any)
       * @api private
       */

      exports.decodePacket = function (data, binaryType, utf8decode) {
        if (data === undefined) {
          return err;
        }
        // String data
        if (typeof data === 'string') {
          if (data.charAt(0) === 'b') {
            return exports.decodeBase64Packet(data.substr(1), binaryType);
          }
          if (utf8decode) {
            data = tryDecode(data);
            if (data === false) {
              return err;
            }
          }
          var type = data.charAt(0);
          if (Number(type) != type || !packetslist[type]) {
            return err;
          }
          if (data.length > 1) {
            return {
              type: packetslist[type],
              data: data.substring(1)
            };
          } else {
            return {
              type: packetslist[type]
            };
          }
        }
        var asArray = new Uint8Array(data);
        var type = asArray[0];
        var rest = sliceBuffer(data, 1);
        if (Blob && binaryType === 'blob') {
          rest = new Blob([rest]);
        }
        return {
          type: packetslist[type],
          data: rest
        };
      };
      function tryDecode(data) {
        try {
          data = utf8.decode(data, {
            strict: false
          });
        } catch (e) {
          return false;
        }
        return data;
      }

      /**
       * Decodes a packet encoded in a base64 string
       *
       * @param {String} base64 encoded message
       * @return {Object} with `type` and `data` (if any)
       */

      exports.decodeBase64Packet = function (msg, binaryType) {
        var type = packetslist[msg.charAt(0)];
        if (!base64encoder) {
          return {
            type: type,
            data: {
              base64: true,
              data: msg.substr(1)
            }
          };
        }
        var data = base64encoder.decode(msg.substr(1));
        if (binaryType === 'blob' && Blob) {
          data = new Blob([data]);
        }
        return {
          type: type,
          data: data
        };
      };

      /**
       * Encodes multiple messages (payload).
       *
       *     <length>:data
       *
       * Example:
       *
       *     11:hello world2:hi
       *
       * If any contents are binary, they will be encoded as base64 strings. Base64
       * encoded strings are marked with a b before the length specifier
       *
       * @param {Array} packets
       * @api private
       */

      exports.encodePayload = function (packets, supportsBinary, callback) {
        if (typeof supportsBinary === 'function') {
          callback = supportsBinary;
          supportsBinary = null;
        }
        var isBinary = hasBinary(packets);
        if (supportsBinary && isBinary) {
          if (Blob && !dontSendBlobs) {
            return exports.encodePayloadAsBlob(packets, callback);
          }
          return exports.encodePayloadAsArrayBuffer(packets, callback);
        }
        if (!packets.length) {
          return callback('0:');
        }
        function setLengthHeader(message) {
          return message.length + ':' + message;
        }
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function (message) {
            doneCallback(null, setLengthHeader(message));
          });
        }
        map(packets, encodeOne, function (err, results) {
          return callback(results.join(''));
        });
      };

      /**
       * Async array map using after
       */

      function map(ary, each, done) {
        var result = new Array(ary.length);
        var next = after(ary.length, done);
        var eachWithIndex = function (i, el, cb) {
          each(el, function (error, msg) {
            result[i] = msg;
            cb(error, result);
          });
        };
        for (var i = 0; i < ary.length; i++) {
          eachWithIndex(i, ary[i], next);
        }
      }

      /*
       * Decodes data when a payload is maybe expected. Possible binary contents are
       * decoded from their base64 representation
       *
       * @param {String} data, callback method
       * @api public
       */

      exports.decodePayload = function (data, binaryType, callback) {
        if (typeof data !== 'string') {
          return exports.decodePayloadAsBinary(data, binaryType, callback);
        }
        if (typeof binaryType === 'function') {
          callback = binaryType;
          binaryType = null;
        }
        var packet;
        if (data === '') {
          // parser error - ignoring payload
          return callback(err, 0, 1);
        }
        var length = '',
          n,
          msg;
        for (var i = 0, l = data.length; i < l; i++) {
          var chr = data.charAt(i);
          if (chr !== ':') {
            length += chr;
            continue;
          }
          if (length === '' || length != (n = Number(length))) {
            // parser error - ignoring payload
            return callback(err, 0, 1);
          }
          msg = data.substr(i + 1, n);
          if (length != msg.length) {
            // parser error - ignoring payload
            return callback(err, 0, 1);
          }
          if (msg.length) {
            packet = exports.decodePacket(msg, binaryType, false);
            if (err.type === packet.type && err.data === packet.data) {
              // parser error in individual packet - ignoring payload
              return callback(err, 0, 1);
            }
            var ret = callback(packet, i + n, l);
            if (false === ret) return;
          }

          // advance cursor
          i += n;
          length = '';
        }
        if (length !== '') {
          // parser error - ignoring payload
          return callback(err, 0, 1);
        }
      };

      /**
       * Encodes multiple messages (payload) as binary.
       *
       * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
       * 255><data>
       *
       * Example:
       * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
       *
       * @param {Array} packets
       * @return {ArrayBuffer} encoded payload
       * @api private
       */

      exports.encodePayloadAsArrayBuffer = function (packets, callback) {
        if (!packets.length) {
          return callback(new ArrayBuffer(0));
        }
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, true, true, function (data) {
            return doneCallback(null, data);
          });
        }
        map(packets, encodeOne, function (err, encodedPackets) {
          var totalLength = encodedPackets.reduce(function (acc, p) {
            var len;
            if (typeof p === 'string') {
              len = p.length;
            } else {
              len = p.byteLength;
            }
            return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
          }, 0);
          var resultArray = new Uint8Array(totalLength);
          var bufferIndex = 0;
          encodedPackets.forEach(function (p) {
            var isString = typeof p === 'string';
            var ab = p;
            if (isString) {
              var view = new Uint8Array(p.length);
              for (var i = 0; i < p.length; i++) {
                view[i] = p.charCodeAt(i);
              }
              ab = view.buffer;
            }
            if (isString) {
              // not true binary
              resultArray[bufferIndex++] = 0;
            } else {
              // true binary
              resultArray[bufferIndex++] = 1;
            }
            var lenStr = ab.byteLength.toString();
            for (var i = 0; i < lenStr.length; i++) {
              resultArray[bufferIndex++] = parseInt(lenStr[i]);
            }
            resultArray[bufferIndex++] = 255;
            var view = new Uint8Array(ab);
            for (var i = 0; i < view.length; i++) {
              resultArray[bufferIndex++] = view[i];
            }
          });
          return callback(resultArray.buffer);
        });
      };

      /**
       * Encode as Blob
       */

      exports.encodePayloadAsBlob = function (packets, callback) {
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, true, true, function (encoded) {
            var binaryIdentifier = new Uint8Array(1);
            binaryIdentifier[0] = 1;
            if (typeof encoded === 'string') {
              var view = new Uint8Array(encoded.length);
              for (var i = 0; i < encoded.length; i++) {
                view[i] = encoded.charCodeAt(i);
              }
              encoded = view.buffer;
              binaryIdentifier[0] = 0;
            }
            var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
            var lenStr = len.toString();
            var lengthAry = new Uint8Array(lenStr.length + 1);
            for (var i = 0; i < lenStr.length; i++) {
              lengthAry[i] = parseInt(lenStr[i]);
            }
            lengthAry[lenStr.length] = 255;
            if (Blob) {
              var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
              doneCallback(null, blob);
            }
          });
        }
        map(packets, encodeOne, function (err, results) {
          return callback(new Blob(results));
        });
      };

      /*
       * Decodes data when a payload is maybe expected. Strings are decoded by
       * interpreting each byte as a key code for entries marked to start with 0. See
       * description of encodePayloadAsBinary
       *
       * @param {ArrayBuffer} data, callback method
       * @api public
       */

      exports.decodePayloadAsBinary = function (data, binaryType, callback) {
        if (typeof binaryType === 'function') {
          callback = binaryType;
          binaryType = null;
        }
        var bufferTail = data;
        var buffers = [];
        while (bufferTail.byteLength > 0) {
          var tailArray = new Uint8Array(bufferTail);
          var isString = tailArray[0] === 0;
          var msgLength = '';
          for (var i = 1;; i++) {
            if (tailArray[i] === 255) break;

            // 310 = char length of Number.MAX_VALUE
            if (msgLength.length > 310) {
              return callback(err, 0, 1);
            }
            msgLength += tailArray[i];
          }
          bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
          msgLength = parseInt(msgLength);
          var msg = sliceBuffer(bufferTail, 0, msgLength);
          if (isString) {
            try {
              msg = String.fromCharCode.apply(null, new Uint8Array(msg));
            } catch (e) {
              // iPhone Safari doesn't let you apply to typed arrays
              var typed = new Uint8Array(msg);
              msg = '';
              for (var i = 0; i < typed.length; i++) {
                msg += String.fromCharCode(typed[i]);
              }
            }
          }
          buffers.push(msg);
          bufferTail = sliceBuffer(bufferTail, msgLength);
        }
        var total = buffers.length;
        buffers.forEach(function (buffer, i) {
          callback(exports.decodePacket(buffer, binaryType, true), i, total);
        });
      };

      /***/
    }, /* 20 */
    /***/function (module, exports) {
      /**
       * Gets the keys for an object.
       *
       * @return {Array} keys
       * @api private
       */

      module.exports = Object.keys || function keys(obj) {
        var arr = [];
        var has = Object.prototype.hasOwnProperty;
        for (var i in obj) {
          if (has.call(obj, i)) {
            arr.push(i);
          }
        }
        return arr;
      };

      /***/
    }, /* 21 */
    /***/function (module, exports, __nested_webpack_require_109678__) {
      /* global Blob File */

      /*
       * Module requirements.
       */

      var isArray = __nested_webpack_require_109678__(7);
      var toString = Object.prototype.toString;
      var withNativeBlob = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
      var withNativeFile = typeof File === 'function' || typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

      /**
       * Module exports.
       */

      module.exports = hasBinary;

      /**
       * Checks for binary data.
       *
       * Supports Buffer, ArrayBuffer, Blob and File.
       *
       * @param {Object} anything
       * @api public
       */

      function hasBinary(obj) {
        if (!obj || typeof obj !== 'object') {
          return false;
        }
        if (isArray(obj)) {
          for (var i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
              return true;
            }
          }
          return false;
        }
        if (typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj) || typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
          return true;
        }

        // see: https://github.com/Automattic/has-binary/pull/4
        if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
          return hasBinary(obj.toJSON(), true);
        }
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
          }
        }
        return false;
      }

      /***/
    }, /* 22 */
    /***/function (module, exports) {
      /**
       * An abstraction for slicing an arraybuffer even when
       * ArrayBuffer.prototype.slice is not supported
       *
       * @api public
       */

      module.exports = function (arraybuffer, start, end) {
        var bytes = arraybuffer.byteLength;
        start = start || 0;
        end = end || bytes;
        if (arraybuffer.slice) {
          return arraybuffer.slice(start, end);
        }
        if (start < 0) {
          start += bytes;
        }
        if (end < 0) {
          end += bytes;
        }
        if (end > bytes) {
          end = bytes;
        }
        if (start >= bytes || start >= end || bytes === 0) {
          return new ArrayBuffer(0);
        }
        var abv = new Uint8Array(arraybuffer);
        var result = new Uint8Array(end - start);
        for (var i = start, ii = 0; i < end; i++, ii++) {
          result[ii] = abv[i];
        }
        return result.buffer;
      };

      /***/
    }, /* 23 */
    /***/function (module, exports) {
      module.exports = after;
      function after(count, callback, err_cb) {
        var bail = false;
        err_cb = err_cb || noop;
        proxy.count = count;
        return count === 0 ? callback() : proxy;
        function proxy(err, result) {
          if (proxy.count <= 0) {
            throw new Error('after called too many times');
          }
          --proxy.count;

          // after first error, rest are passed to err_cb
          if (err) {
            bail = true;
            callback(err);
            // future error callbacks will go to error handler
            callback = err_cb;
          } else if (proxy.count === 0 && !bail) {
            callback(null, result);
          }
        }
      }
      function noop() {}

      /***/
    }, /* 24 */
    /***/function (module, exports) {
      /*! https://mths.be/utf8js v2.1.2 by @mathias */

      var stringFromCharCode = String.fromCharCode;

      // Taken from https://mths.be/punycode
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        var value;
        var extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            // high surrogate, and there is a next character
            extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
              // low surrogate
              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
              // unmatched surrogate; only append this code unit, in case the next
              // code unit is the high surrogate of a surrogate pair
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }

      // Taken from https://mths.be/punycode
      function ucs2encode(array) {
        var length = array.length;
        var index = -1;
        var value;
        var output = '';
        while (++index < length) {
          value = array[index];
          if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
          }
          output += stringFromCharCode(value);
        }
        return output;
      }
      function checkScalarValue(codePoint, strict) {
        if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
          if (strict) {
            throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
          }
          return false;
        }
        return true;
      }
      /*--------------------------------------------------------------------------*/

      function createByte(codePoint, shift) {
        return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
      }
      function encodeCodePoint(codePoint, strict) {
        if ((codePoint & 0xFFFFFF80) == 0) {
          // 1-byte sequence
          return stringFromCharCode(codePoint);
        }
        var symbol = '';
        if ((codePoint & 0xFFFFF800) == 0) {
          // 2-byte sequence
          symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
        } else if ((codePoint & 0xFFFF0000) == 0) {
          // 3-byte sequence
          if (!checkScalarValue(codePoint, strict)) {
            codePoint = 0xFFFD;
          }
          symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
          symbol += createByte(codePoint, 6);
        } else if ((codePoint & 0xFFE00000) == 0) {
          // 4-byte sequence
          symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
          symbol += createByte(codePoint, 12);
          symbol += createByte(codePoint, 6);
        }
        symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
        return symbol;
      }
      function utf8encode(string, opts) {
        opts = opts || {};
        var strict = false !== opts.strict;
        var codePoints = ucs2decode(string);
        var length = codePoints.length;
        var index = -1;
        var codePoint;
        var byteString = '';
        while (++index < length) {
          codePoint = codePoints[index];
          byteString += encodeCodePoint(codePoint, strict);
        }
        return byteString;
      }

      /*--------------------------------------------------------------------------*/

      function readContinuationByte() {
        if (byteIndex >= byteCount) {
          throw Error('Invalid byte index');
        }
        var continuationByte = byteArray[byteIndex] & 0xFF;
        byteIndex++;
        if ((continuationByte & 0xC0) == 0x80) {
          return continuationByte & 0x3F;
        }

        // If we end up here, it’s not a continuation byte
        throw Error('Invalid continuation byte');
      }
      function decodeSymbol(strict) {
        var byte1;
        var byte2;
        var byte3;
        var byte4;
        var codePoint;
        if (byteIndex > byteCount) {
          throw Error('Invalid byte index');
        }
        if (byteIndex == byteCount) {
          return false;
        }

        // Read first byte
        byte1 = byteArray[byteIndex] & 0xFF;
        byteIndex++;

        // 1-byte sequence (no continuation bytes)
        if ((byte1 & 0x80) == 0) {
          return byte1;
        }

        // 2-byte sequence
        if ((byte1 & 0xE0) == 0xC0) {
          byte2 = readContinuationByte();
          codePoint = (byte1 & 0x1F) << 6 | byte2;
          if (codePoint >= 0x80) {
            return codePoint;
          } else {
            throw Error('Invalid continuation byte');
          }
        }

        // 3-byte sequence (may include unpaired surrogates)
        if ((byte1 & 0xF0) == 0xE0) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
          if (codePoint >= 0x0800) {
            return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
          } else {
            throw Error('Invalid continuation byte');
          }
        }

        // 4-byte sequence
        if ((byte1 & 0xF8) == 0xF0) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          byte4 = readContinuationByte();
          codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
          if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
            return codePoint;
          }
        }
        throw Error('Invalid UTF-8 detected');
      }
      var byteArray;
      var byteCount;
      var byteIndex;
      function utf8decode(byteString, opts) {
        opts = opts || {};
        var strict = false !== opts.strict;
        byteArray = ucs2decode(byteString);
        byteCount = byteArray.length;
        byteIndex = 0;
        var codePoints = [];
        var tmp;
        while ((tmp = decodeSymbol(strict)) !== false) {
          codePoints.push(tmp);
        }
        return ucs2encode(codePoints);
      }
      module.exports = {
        version: '2.1.2',
        encode: utf8encode,
        decode: utf8decode
      };

      /***/
    }, /* 25 */
    /***/function (module, exports) {
      /*
       * base64-arraybuffer
       * https://github.com/niklasvh/base64-arraybuffer
       *
       * Copyright (c) 2012 Niklas von Hertzen
       * Licensed under the MIT license.
       */
      (function (chars) {
        "use strict";

        exports.encode = function (arraybuffer) {
          var bytes = new Uint8Array(arraybuffer),
            i,
            len = bytes.length,
            base64 = "";
          for (i = 0; i < len; i += 3) {
            base64 += chars[bytes[i] >> 2];
            base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
            base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
            base64 += chars[bytes[i + 2] & 63];
          }
          if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        exports.decode = function (base64) {
          var bufferLength = base64.length * 0.75,
            len = base64.length,
            i,
            p = 0,
            encoded1,
            encoded2,
            encoded3,
            encoded4;
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
          var arraybuffer = new ArrayBuffer(bufferLength),
            bytes = new Uint8Array(arraybuffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = chars.indexOf(base64[i]);
            encoded2 = chars.indexOf(base64[i + 1]);
            encoded3 = chars.indexOf(base64[i + 2]);
            encoded4 = chars.indexOf(base64[i + 3]);
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return arraybuffer;
        };
      })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

      /***/
    }, /* 26 */
    /***/function (module, exports) {
      /**
       * Create a blob builder even when vendor prefixes exist
       */

      var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : false;

      /**
       * Check if Blob constructor is supported
       */

      var blobSupported = function () {
        try {
          var a = new Blob(['hi']);
          return a.size === 2;
        } catch (e) {
          return false;
        }
      }();

      /**
       * Check if Blob constructor supports ArrayBufferViews
       * Fails in Safari 6, so we need to map to ArrayBuffers there.
       */

      var blobSupportsArrayBufferView = blobSupported && function () {
        try {
          var b = new Blob([new Uint8Array([1, 2])]);
          return b.size === 2;
        } catch (e) {
          return false;
        }
      }();

      /**
       * Check if BlobBuilder is supported
       */

      var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;

      /**
       * Helper function that maps ArrayBufferViews to ArrayBuffers
       * Used by BlobBuilder constructor and old browsers that didn't
       * support it in the Blob constructor.
       */

      function mapArrayBufferViews(ary) {
        return ary.map(function (chunk) {
          if (chunk.buffer instanceof ArrayBuffer) {
            var buf = chunk.buffer;

            // if this is a subarray, make a copy so we only
            // include the subarray region from the underlying buffer
            if (chunk.byteLength !== buf.byteLength) {
              var copy = new Uint8Array(chunk.byteLength);
              copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
              buf = copy.buffer;
            }
            return buf;
          }
          return chunk;
        });
      }
      function BlobBuilderConstructor(ary, options) {
        options = options || {};
        var bb = new BlobBuilder();
        mapArrayBufferViews(ary).forEach(function (part) {
          bb.append(part);
        });
        return options.type ? bb.getBlob(options.type) : bb.getBlob();
      }
      ;
      function BlobConstructor(ary, options) {
        return new Blob(mapArrayBufferViews(ary), options || {});
      }
      ;
      if (typeof Blob !== 'undefined') {
        BlobBuilderConstructor.prototype = Blob.prototype;
        BlobConstructor.prototype = Blob.prototype;
      }
      module.exports = function () {
        if (blobSupported) {
          return blobSupportsArrayBufferView ? Blob : BlobConstructor;
        } else if (blobBuilderSupported) {
          return BlobBuilderConstructor;
        } else {
          return undefined;
        }
      }();

      /***/
    }, /* 27 */
    /***/function (module, exports) {
      /**
       * Compiles a querystring
       * Returns string representation of the object
       *
       * @param {Object}
       * @api private
       */

      exports.encode = function (obj) {
        var str = '';
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            if (str.length) str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
          }
        }
        return str;
      };

      /**
       * Parses a simple querystring into an object
       *
       * @param {String} qs
       * @api private
       */

      exports.decode = function (qs) {
        var qry = {};
        var pairs = qs.split('&');
        for (var i = 0, l = pairs.length; i < l; i++) {
          var pair = pairs[i].split('=');
          qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }
        return qry;
      };

      /***/
    }, /* 28 */
    /***/function (module, exports) {
      module.exports = function (a, b) {
        var fn = function () {};
        fn.prototype = b.prototype;
        a.prototype = new fn();
        a.prototype.constructor = a;
      };

      /***/
    }, /* 29 */
    /***/function (module, exports) {
      'use strict';

      var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
        length = 64,
        map = {},
        seed = 0,
        i = 0,
        prev;

      /**
       * Return a string representing the specified number.
       *
       * @param {Number} num The number to convert.
       * @returns {String} The string representation of the number.
       * @api public
       */
      function encode(num) {
        var encoded = '';
        do {
          encoded = alphabet[num % length] + encoded;
          num = Math.floor(num / length);
        } while (num > 0);
        return encoded;
      }

      /**
       * Return the integer value specified by the given string.
       *
       * @param {String} str The string to convert.
       * @returns {Number} The integer value represented by the string.
       * @api public
       */
      function decode(str) {
        var decoded = 0;
        for (i = 0; i < str.length; i++) {
          decoded = decoded * length + map[str.charAt(i)];
        }
        return decoded;
      }

      /**
       * Yeast: A tiny growing id generator.
       *
       * @returns {String} A unique id.
       * @api public
       */
      function yeast() {
        var now = encode(+new Date());
        if (now !== prev) return seed = 0, prev = now;
        return now + '.' + encode(seed++);
      }

      //
      // Map each character to its index.
      //
      for (; i < length; i++) map[alphabet[i]] = i;

      //
      // Expose the `yeast`, `encode` and `decode` functions.
      //
      yeast.encode = encode;
      yeast.decode = decode;
      module.exports = yeast;

      /***/
    }, /* 30 */
    /***/function (module, exports, __nested_webpack_require_127881__) {
      /**
       * Module requirements.
       */

      var Polling = __nested_webpack_require_127881__(17);
      var inherit = __nested_webpack_require_127881__(28);
      var globalThis = __nested_webpack_require_127881__(15);

      /**
       * Module exports.
       */

      module.exports = JSONPPolling;

      /**
       * Cached regular expressions.
       */

      var rNewline = /\n/g;
      var rEscapedNewline = /\\n/g;

      /**
       * Global JSONP callbacks.
       */

      var callbacks;

      /**
       * Noop.
       */

      function empty() {}

      /**
       * JSONP Polling constructor.
       *
       * @param {Object} opts.
       * @api public
       */

      function JSONPPolling(opts) {
        Polling.call(this, opts);
        this.query = this.query || {};

        // define global callbacks array if not present
        // we do this here (lazily) to avoid unneeded global pollution
        if (!callbacks) {
          // we need to consider multiple engines in the same page
          callbacks = globalThis.___eio = globalThis.___eio || [];
        }

        // callback identifier
        this.index = callbacks.length;

        // add callback to jsonp global
        var self = this;
        callbacks.push(function (msg) {
          self.onData(msg);
        });

        // append to query string
        this.query.j = this.index;

        // prevent spurious errors from being emitted when the window is unloaded
        if (typeof addEventListener === 'function') {
          addEventListener('beforeunload', function () {
            if (self.script) self.script.onerror = empty;
          }, false);
        }
      }

      /**
       * Inherits from Polling.
       */

      inherit(JSONPPolling, Polling);

      /*
       * JSONP only supports binary as base64 encoded strings
       */

      JSONPPolling.prototype.supportsBinary = false;

      /**
       * Closes the socket.
       *
       * @api private
       */

      JSONPPolling.prototype.doClose = function () {
        if (this.script) {
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }
        if (this.form) {
          this.form.parentNode.removeChild(this.form);
          this.form = null;
          this.iframe = null;
        }
        Polling.prototype.doClose.call(this);
      };

      /**
       * Starts a poll cycle.
       *
       * @api private
       */

      JSONPPolling.prototype.doPoll = function () {
        var self = this;
        var script = document.createElement('script');
        if (this.script) {
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }
        script.async = true;
        script.src = this.uri();
        script.onerror = function (e) {
          self.onError('jsonp poll error', e);
        };
        var insertAt = document.getElementsByTagName('script')[0];
        if (insertAt) {
          insertAt.parentNode.insertBefore(script, insertAt);
        } else {
          (document.head || document.body).appendChild(script);
        }
        this.script = script;
        var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);
        if (isUAgecko) {
          setTimeout(function () {
            var iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            document.body.removeChild(iframe);
          }, 100);
        }
      };

      /**
       * Writes with a hidden iframe.
       *
       * @param {String} data to send
       * @param {Function} called upon flush.
       * @api private
       */

      JSONPPolling.prototype.doWrite = function (data, fn) {
        var self = this;
        if (!this.form) {
          var form = document.createElement('form');
          var area = document.createElement('textarea');
          var id = this.iframeId = 'eio_iframe_' + this.index;
          var iframe;
          form.className = 'socketio';
          form.style.position = 'absolute';
          form.style.top = '-1000px';
          form.style.left = '-1000px';
          form.target = id;
          form.method = 'POST';
          form.setAttribute('accept-charset', 'utf-8');
          area.name = 'd';
          form.appendChild(area);
          document.body.appendChild(form);
          this.form = form;
          this.area = area;
        }
        this.form.action = this.uri();
        function complete() {
          initIframe();
          fn();
        }
        function initIframe() {
          if (self.iframe) {
            try {
              self.form.removeChild(self.iframe);
            } catch (e) {
              self.onError('jsonp polling iframe removal error', e);
            }
          }
          try {
            // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
            var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
            iframe = document.createElement(html);
          } catch (e) {
            iframe = document.createElement('iframe');
            iframe.name = self.iframeId;
            iframe.src = 'javascript:0';
          }
          iframe.id = self.iframeId;
          self.form.appendChild(iframe);
          self.iframe = iframe;
        }
        initIframe();

        // escape \n to prevent it from being converted into \r\n by some UAs
        // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
        data = data.replace(rEscapedNewline, '\\\n');
        this.area.value = data.replace(rNewline, '\\n');
        try {
          this.form.submit();
        } catch (e) {}
        if (this.iframe.attachEvent) {
          this.iframe.onreadystatechange = function () {
            if (self.iframe.readyState === 'complete') {
              complete();
            }
          };
        } else {
          this.iframe.onload = complete;
        }
      };

      /***/
    }, /* 31 */
    /***/function (module, exports, __nested_webpack_require_133933__) {
      /**
       * Module dependencies.
       */

      var Transport = __nested_webpack_require_133933__(18);
      var parser = __nested_webpack_require_133933__(19);
      var parseqs = __nested_webpack_require_133933__(27);
      var inherit = __nested_webpack_require_133933__(28);
      var yeast = __nested_webpack_require_133933__(29);
      var debug = __nested_webpack_require_133933__(3)('engine.io-client:websocket');
      var BrowserWebSocket, NodeWebSocket;
      if (typeof WebSocket !== 'undefined') {
        BrowserWebSocket = WebSocket;
      } else if (typeof self !== 'undefined') {
        BrowserWebSocket = self.WebSocket || self.MozWebSocket;
      }
      if (typeof window === 'undefined') {
        try {
          NodeWebSocket = __nested_webpack_require_133933__(32);
        } catch (e) {}
      }

      /**
       * Get either the `WebSocket` or `MozWebSocket` globals
       * in the browser or try to resolve WebSocket-compatible
       * interface exposed by `ws` for Node-like environment.
       */

      var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

      /**
       * Module exports.
       */

      module.exports = WS;

      /**
       * WebSocket transport constructor.
       *
       * @api {Object} connection options
       * @api public
       */

      function WS(opts) {
        var forceBase64 = opts && opts.forceBase64;
        if (forceBase64) {
          this.supportsBinary = false;
        }
        this.perMessageDeflate = opts.perMessageDeflate;
        this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
        this.protocols = opts.protocols;
        if (!this.usingBrowserWebSocket) {
          WebSocketImpl = NodeWebSocket;
        }
        Transport.call(this, opts);
      }

      /**
       * Inherits from Transport.
       */

      inherit(WS, Transport);

      /**
       * Transport name.
       *
       * @api public
       */

      WS.prototype.name = 'websocket';

      /*
       * WebSockets support binary
       */

      WS.prototype.supportsBinary = true;

      /**
       * Opens socket.
       *
       * @api private
       */

      WS.prototype.doOpen = function () {
        if (!this.check()) {
          // let probe timeout
          return;
        }
        var uri = this.uri();
        var protocols = this.protocols;
        var opts = {};
        if (!this.isReactNative) {
          opts.agent = this.agent;
          opts.perMessageDeflate = this.perMessageDeflate;

          // SSL options for Node.js client
          opts.pfx = this.pfx;
          opts.key = this.key;
          opts.passphrase = this.passphrase;
          opts.cert = this.cert;
          opts.ca = this.ca;
          opts.ciphers = this.ciphers;
          opts.rejectUnauthorized = this.rejectUnauthorized;
        }
        if (this.extraHeaders) {
          opts.headers = this.extraHeaders;
        }
        if (this.localAddress) {
          opts.localAddress = this.localAddress;
        }
        try {
          this.ws = this.usingBrowserWebSocket && !this.isReactNative ? protocols ? new WebSocketImpl(uri, protocols) : new WebSocketImpl(uri) : new WebSocketImpl(uri, protocols, opts);
        } catch (err) {
          return this.emit('error', err);
        }
        if (this.ws.binaryType === undefined) {
          this.supportsBinary = false;
        }
        if (this.ws.supports && this.ws.supports.binary) {
          this.supportsBinary = true;
          this.ws.binaryType = 'nodebuffer';
        } else {
          this.ws.binaryType = 'arraybuffer';
        }
        this.addEventListeners();
      };

      /**
       * Adds event listeners to the socket
       *
       * @api private
       */

      WS.prototype.addEventListeners = function () {
        var self = this;
        this.ws.onopen = function () {
          self.onOpen();
        };
        this.ws.onclose = function () {
          self.onClose();
        };
        this.ws.onmessage = function (ev) {
          self.onData(ev.data);
        };
        this.ws.onerror = function (e) {
          self.onError('websocket error', e);
        };
      };

      /**
       * Writes data to socket.
       *
       * @param {Array} array of packets.
       * @api private
       */

      WS.prototype.write = function (packets) {
        var self = this;
        this.writable = false;

        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        var total = packets.length;
        for (var i = 0, l = total; i < l; i++) {
          (function (packet) {
            parser.encodePacket(packet, self.supportsBinary, function (data) {
              if (!self.usingBrowserWebSocket) {
                // always create a new object (GH-437)
                var opts = {};
                if (packet.options) {
                  opts.compress = packet.options.compress;
                }
                if (self.perMessageDeflate) {
                  var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
                  if (len < self.perMessageDeflate.threshold) {
                    opts.compress = false;
                  }
                }
              }

              // Sometimes the websocket has already been closed but the browser didn't
              // have a chance of informing us about it yet, in that case send will
              // throw an error
              try {
                if (self.usingBrowserWebSocket) {
                  // TypeError is thrown when passing the second argument on Safari
                  self.ws.send(data);
                } else {
                  self.ws.send(data, opts);
                }
              } catch (e) {}
              --total || done();
            });
          })(packets[i]);
        }
        function done() {
          self.emit('flush');

          // fake drain
          // defer to next tick to allow Socket to clear writeBuffer
          setTimeout(function () {
            self.writable = true;
            self.emit('drain');
          }, 0);
        }
      };

      /**
       * Called upon close
       *
       * @api private
       */

      WS.prototype.onClose = function () {
        Transport.prototype.onClose.call(this);
      };

      /**
       * Closes socket.
       *
       * @api private
       */

      WS.prototype.doClose = function () {
        if (typeof this.ws !== 'undefined') {
          this.ws.close();
        }
      };

      /**
       * Generates uri for connection.
       *
       * @api private
       */

      WS.prototype.uri = function () {
        var query = this.query || {};
        var schema = this.secure ? 'wss' : 'ws';
        var port = '';

        // avoid port if default for schema
        if (this.port && ('wss' === schema && Number(this.port) !== 443 || 'ws' === schema && Number(this.port) !== 80)) {
          port = ':' + this.port;
        }

        // append timestamp to URI
        if (this.timestampRequests) {
          query[this.timestampParam] = yeast();
        }

        // communicate binary support capabilities
        if (!this.supportsBinary) {
          query.b64 = 1;
        }
        query = parseqs.encode(query);

        // prepend ? to query
        if (query.length) {
          query = '?' + query;
        }
        var ipv6 = this.hostname.indexOf(':') !== -1;
        return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
      };

      /**
       * Feature detection for WebSocket.
       *
       * @return {Boolean} whether this transport is available.
       * @api public
       */

      WS.prototype.check = function () {
        return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
      };

      /***/
    }, /* 32 */
    /***/function (module, exports) {

      /* (ignored) */

      /***/}, /* 33 */
    /***/function (module, exports) {
      var indexOf = [].indexOf;
      module.exports = function (arr, obj) {
        if (indexOf) return arr.indexOf(obj);
        for (var i = 0; i < arr.length; ++i) {
          if (arr[i] === obj) return i;
        }
        return -1;
      };

      /***/
    }, /* 34 */
    /***/function (module, exports, __nested_webpack_require_142163__) {
      'use strict';

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      /**
       * Module dependencies.
       */

      var parser = __nested_webpack_require_142163__(4);
      var Emitter = __nested_webpack_require_142163__(5);
      var toArray = __nested_webpack_require_142163__(35);
      var on = __nested_webpack_require_142163__(36);
      var bind = __nested_webpack_require_142163__(37);
      var debug = __nested_webpack_require_142163__(3)('socket.io-client:socket');
      var parseqs = __nested_webpack_require_142163__(27);
      var hasBin = __nested_webpack_require_142163__(21);

      /**
       * Module exports.
       */

      module.exports = exports = Socket;

      /**
       * Internal events (blacklisted).
       * These events can't be emitted by the user.
       *
       * @api private
       */

      var events = {
        connect: 1,
        connect_error: 1,
        connect_timeout: 1,
        connecting: 1,
        disconnect: 1,
        error: 1,
        reconnect: 1,
        reconnect_attempt: 1,
        reconnect_failed: 1,
        reconnect_error: 1,
        reconnecting: 1,
        ping: 1,
        pong: 1
      };

      /**
       * Shortcut to `Emitter#emit`.
       */

      var emit = Emitter.prototype.emit;

      /**
       * `Socket` constructor.
       *
       * @api public
       */

      function Socket(io, nsp, opts) {
        this.io = io;
        this.nsp = nsp;
        this.json = this; // compat
        this.ids = 0;
        this.acks = {};
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.connected = false;
        this.disconnected = true;
        this.flags = {};
        if (opts && opts.query) {
          this.query = opts.query;
        }
        if (this.io.autoConnect) this.open();
      }

      /**
       * Mix in `Emitter`.
       */

      Emitter(Socket.prototype);

      /**
       * Subscribe to open, close and packet events
       *
       * @api private
       */

      Socket.prototype.subEvents = function () {
        if (this.subs) return;
        var io = this.io;
        this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
      };

      /**
       * "Opens" the socket.
       *
       * @api public
       */

      Socket.prototype.open = Socket.prototype.connect = function () {
        if (this.connected) return this;
        this.subEvents();
        if (!this.io.reconnecting) this.io.open(); // ensure open
        if ('open' === this.io.readyState) this.onopen();
        this.emit('connecting');
        return this;
      };

      /**
       * Sends a `message` event.
       *
       * @return {Socket} self
       * @api public
       */

      Socket.prototype.send = function () {
        var args = toArray(arguments);
        args.unshift('message');
        this.emit.apply(this, args);
        return this;
      };

      /**
       * Override `emit`.
       * If the event is in `events`, it's emitted normally.
       *
       * @param {String} event name
       * @return {Socket} self
       * @api public
       */

      Socket.prototype.emit = function (ev) {
        if (events.hasOwnProperty(ev)) {
          emit.apply(this, arguments);
          return this;
        }
        var args = toArray(arguments);
        var packet = {
          type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
          data: args
        };
        packet.options = {};
        packet.options.compress = !this.flags || false !== this.flags.compress;

        // event ack callback
        if ('function' === typeof args[args.length - 1]) {
          this.acks[this.ids] = args.pop();
          packet.id = this.ids++;
        }
        if (this.connected) {
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
      };

      /**
       * Sends a packet.
       *
       * @param {Object} packet
       * @api private
       */

      Socket.prototype.packet = function (packet) {
        packet.nsp = this.nsp;
        this.io.packet(packet);
      };

      /**
       * Called upon engine `open`.
       *
       * @api private
       */

      Socket.prototype.onopen = function () {
        // write connect packet if necessary
        if ('/' !== this.nsp) {
          if (this.query) {
            var query = _typeof(this.query) === 'object' ? parseqs.encode(this.query) : this.query;
            this.packet({
              type: parser.CONNECT,
              query: query
            });
          } else {
            this.packet({
              type: parser.CONNECT
            });
          }
        }
      };

      /**
       * Called upon engine `close`.
       *
       * @param {String} reason
       * @api private
       */

      Socket.prototype.onclose = function (reason) {
        this.connected = false;
        this.disconnected = true;
        delete this.id;
        this.emit('disconnect', reason);
      };

      /**
       * Called with socket packet.
       *
       * @param {Object} packet
       * @api private
       */

      Socket.prototype.onpacket = function (packet) {
        var sameNamespace = packet.nsp === this.nsp;
        var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';
        if (!sameNamespace && !rootNamespaceError) return;
        switch (packet.type) {
          case parser.CONNECT:
            this.onconnect();
            break;
          case parser.EVENT:
            this.onevent(packet);
            break;
          case parser.BINARY_EVENT:
            this.onevent(packet);
            break;
          case parser.ACK:
            this.onack(packet);
            break;
          case parser.BINARY_ACK:
            this.onack(packet);
            break;
          case parser.DISCONNECT:
            this.ondisconnect();
            break;
          case parser.ERROR:
            this.emit('error', packet.data);
            break;
        }
      };

      /**
       * Called upon a server event.
       *
       * @param {Object} packet
       * @api private
       */

      Socket.prototype.onevent = function (packet) {
        var args = packet.data || [];
        if (null != packet.id) {
          args.push(this.ack(packet.id));
        }
        if (this.connected) {
          emit.apply(this, args);
        } else {
          this.receiveBuffer.push(args);
        }
      };

      /**
       * Produces an ack callback to emit with an event.
       *
       * @api private
       */

      Socket.prototype.ack = function (id) {
        var self = this;
        var sent = false;
        return function () {
          // prevent double callbacks
          if (sent) return;
          sent = true;
          var args = toArray(arguments);
          self.packet({
            type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
            id: id,
            data: args
          });
        };
      };

      /**
       * Called upon a server acknowlegement.
       *
       * @param {Object} packet
       * @api private
       */

      Socket.prototype.onack = function (packet) {
        var ack = this.acks[packet.id];
        if ('function' === typeof ack) {
          ack.apply(this, packet.data);
          delete this.acks[packet.id];
        } else {}
      };

      /**
       * Called upon server connect.
       *
       * @api private
       */

      Socket.prototype.onconnect = function () {
        this.connected = true;
        this.disconnected = false;
        this.emitBuffered();
        this.emit('connect');
      };

      /**
       * Emit buffered events (received and emitted).
       *
       * @api private
       */

      Socket.prototype.emitBuffered = function () {
        var i;
        for (i = 0; i < this.receiveBuffer.length; i++) {
          emit.apply(this, this.receiveBuffer[i]);
        }
        this.receiveBuffer = [];
        for (i = 0; i < this.sendBuffer.length; i++) {
          this.packet(this.sendBuffer[i]);
        }
        this.sendBuffer = [];
      };

      /**
       * Called upon server disconnect.
       *
       * @api private
       */

      Socket.prototype.ondisconnect = function () {
        this.destroy();
        this.onclose('io server disconnect');
      };

      /**
       * Called upon forced client/server side disconnections,
       * this method ensures the manager stops tracking us and
       * that reconnections don't get triggered for this.
       *
       * @api private.
       */

      Socket.prototype.destroy = function () {
        if (this.subs) {
          // clean subscriptions to avoid reconnections
          for (var i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
          }
          this.subs = null;
        }
        this.io.destroy(this);
      };

      /**
       * Disconnects the socket manually.
       *
       * @return {Socket} self
       * @api public
       */

      Socket.prototype.close = Socket.prototype.disconnect = function () {
        if (this.connected) {
          this.packet({
            type: parser.DISCONNECT
          });
        }

        // remove socket from pool
        this.destroy();
        if (this.connected) {
          // fire events
          this.onclose('io client disconnect');
        }
        return this;
      };

      /**
       * Sets the compress flag.
       *
       * @param {Boolean} if `true`, compresses the sending data
       * @return {Socket} self
       * @api public
       */

      Socket.prototype.compress = function (compress) {
        this.flags.compress = compress;
        return this;
      };

      /**
       * Sets the binary flag
       *
       * @param {Boolean} whether the emitted data contains binary
       * @return {Socket} self
       * @api public
       */

      Socket.prototype.binary = function (binary) {
        this.flags.binary = binary;
        return this;
      };

      /***/
    }, /* 35 */
    /***/function (module, exports) {
      module.exports = toArray;
      function toArray(list, index) {
        var array = [];
        index = index || 0;
        for (var i = index || 0; i < list.length; i++) {
          array[i - index] = list[i];
        }
        return array;
      }

      /***/
    }, /* 36 */
    /***/function (module, exports) {
      "use strict";

      /**
       * Module exports.
       */
      module.exports = on;

      /**
       * Helper for subscriptions.
       *
       * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
       * @param {String} event name
       * @param {Function} callback
       * @api public
       */

      function on(obj, ev, fn) {
        obj.on(ev, fn);
        return {
          destroy: function destroy() {
            obj.removeListener(ev, fn);
          }
        };
      }

      /***/
    }, /* 37 */
    /***/function (module, exports) {
      /**
       * Slice reference.
       */

      var slice = [].slice;

      /**
       * Bind `obj` to `fn`.
       *
       * @param {Object} obj
       * @param {Function|String} fn or string
       * @return {Function}
       * @api public
       */

      module.exports = function (obj, fn) {
        if ('string' == typeof fn) fn = obj[fn];
        if ('function' != typeof fn) throw new Error('bind() requires a function');
        var args = slice.call(arguments, 2);
        return function () {
          return fn.apply(obj, args.concat(slice.call(arguments)));
        };
      };

      /***/
    }, /* 38 */
    /***/function (module, exports) {
      /**
       * Expose `Backoff`.
       */

      module.exports = Backoff;

      /**
       * Initialize backoff timer with `opts`.
       *
       * - `min` initial timeout in milliseconds [100]
       * - `max` max timeout [10000]
       * - `jitter` [0]
       * - `factor` [2]
       *
       * @param {Object} opts
       * @api public
       */

      function Backoff(opts) {
        opts = opts || {};
        this.ms = opts.min || 100;
        this.max = opts.max || 10000;
        this.factor = opts.factor || 2;
        this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
        this.attempts = 0;
      }

      /**
       * Return the backoff duration.
       *
       * @return {Number}
       * @api public
       */

      Backoff.prototype.duration = function () {
        var ms = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var rand = Math.random();
          var deviation = Math.floor(rand * this.jitter * ms);
          ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
        }
        return Math.min(ms, this.max) | 0;
      };

      /**
       * Reset the number of attempts.
       *
       * @api public
       */

      Backoff.prototype.reset = function () {
        this.attempts = 0;
      };

      /**
       * Set the minimum duration
       *
       * @api public
       */

      Backoff.prototype.setMin = function (min) {
        this.ms = min;
      };

      /**
       * Set the maximum duration
       *
       * @api public
       */

      Backoff.prototype.setMax = function (max) {
        this.max = max;
      };

      /**
       * Set the jitter
       *
       * @api public
       */

      Backoff.prototype.setJitter = function (jitter) {
        this.jitter = jitter;
      };

      /***/
    }
    /******/])
  );
});

;

/***/ }),

/***/ "./scripts/3rdparty/source-map.js":
/*!****************************************!*\
  !*** ./scripts/3rdparty/source-map.js ***!
  \****************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(this, function () {
  return (/******/function (modules) {
      // webpackBootstrap
      /******/ // The module cache
      /******/
      var installedModules = {};
      /******/
      /******/ // The require function
      /******/
      function __nested_webpack_require_578__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;
        /******/
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
          /******/exports: {},
          /******/id: moduleId,
          /******/loaded: false
          /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_578__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.loaded = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
      }
      /******/
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/
      __nested_webpack_require_578__.m = modules;
      /******/
      /******/ // expose the module cache
      /******/
      __nested_webpack_require_578__.c = installedModules;
      /******/
      /******/ // __webpack_public_path__
      /******/
      __nested_webpack_require_578__.p = "";
      /******/
      /******/ // Load entry module and return exports
      /******/
      return __nested_webpack_require_578__(0);
      /******/
    }
    /************************************************************************/
    /******/([/* 0 */
    /***/function (module, exports, __nested_webpack_require_2146__) {
      /*
       * Copyright 2009-2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE.txt or:
       * http://opensource.org/licenses/BSD-3-Clause
       */
      exports.SourceMapGenerator = __nested_webpack_require_2146__(1).SourceMapGenerator;
      exports.SourceMapConsumer = __nested_webpack_require_2146__(7).SourceMapConsumer;
      exports.SourceNode = __nested_webpack_require_2146__(10).SourceNode;

      /***/
    }, /* 1 */
    /***/function (module, exports, __nested_webpack_require_2652__) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var base64VLQ = __nested_webpack_require_2652__(2);
      var util = __nested_webpack_require_2652__(4);
      var ArraySet = __nested_webpack_require_2652__(5).ArraySet;
      var MappingList = __nested_webpack_require_2652__(6).MappingList;

      /**
       * An instance of the SourceMapGenerator represents a source map which is
       * being built incrementally. You may pass an object with the following
       * properties:
       *
       *   - file: The filename of the generated source.
       *   - sourceRoot: A root for all relative URLs in this source map.
       */
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, 'file', null);
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;

      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot: sourceRoot
        });
        aSourceMapConsumer.eachMapping(function (mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };

      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, 'generated');
        var original = util.getArg(aArgs, 'original', null);
        var source = util.getArg(aArgs, 'source', null);
        var name = util.getArg(aArgs, 'name', null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source: source,
          name: name
        });
      };

      /**
       * Set the source content for a source file.
       */
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          // Add the source content to the _sourcesContents map.
          // Create a new _sourcesContents map if the property is null.
          if (!this._sourcesContents) {
            this._sourcesContents = Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          // Remove the source file from the _sourcesContents map.
          // If the _sourcesContents map is empty, set the property to null.
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };

      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        // If aSourceFile is omitted, we will use the file property of the SourceMap
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        // Make "sourceFile" relative if an absolute Url is passed.
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        // Applying the SourceMap can add and remove items from the sources and
        // the names array.
        var newSources = new ArraySet();
        var newNames = new ArraySet();

        // Find mappings for the "sourceFile"
        this._mappings.unsortedForEach(function (mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            // Check if it can be mapped by the source map, then update the mapping.
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              // Copy mapping
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;

        // Copy sourcesContents of applied map.
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
              sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
          }
        }, this);
      };

      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        // When aOriginal is truthy but has empty values for .line and .column,
        // it is most likely a programmer error. In this case we throw a very
        // specific error message to try to guide them the right way.
        // For example: https://github.com/Polymer/polymer-bundler/pull/519
        if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
          throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
        }
        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          // Case 1.
          return;
        } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          // Cases 2 and 3.
          return;
        } else {
          throw new Error('Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };

      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = '';
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = '';
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ';';
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ',';
            }
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;

            // lines are stored 0-based in SourceMap spec version 3
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function (source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };

      /**
       * Externalize the source map.
       */
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      };

      /**
       * Render the source map being generated to a string.
       */
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator;

      /***/
    }, /* 2 */
    /***/function (module, exports, __nested_webpack_require_18336__) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       *
       * Based on the Base 64 VLQ implementation in Closure Compiler:
       * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
       *
       * Copyright 2011 The Closure Compiler Authors. All rights reserved.
       * Redistribution and use in source and binary forms, with or without
       * modification, are permitted provided that the following conditions are
       * met:
       *
       *  * Redistributions of source code must retain the above copyright
       *    notice, this list of conditions and the following disclaimer.
       *  * Redistributions in binary form must reproduce the above
       *    copyright notice, this list of conditions and the following
       *    disclaimer in the documentation and/or other materials provided
       *    with the distribution.
       *  * Neither the name of Google Inc. nor the names of its
       *    contributors may be used to endorse or promote products derived
       *    from this software without specific prior written permission.
       *
       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
       * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
       * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
       * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
       * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
       * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
       * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
       * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
       * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
       * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
       * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
       */

      var base64 = __nested_webpack_require_18336__(3);

      // A single base 64 digit can contain 6 bits of data. For the base 64 variable
      // length quantities we use in the source map spec, the first bit is the sign,
      // the next four bits are the actual value, and the 6th bit is the
      // continuation bit. The continuation bit tells us whether there are more
      // digits in this value following this digit.
      //
      //   Continuation
      //   |    Sign
      //   |    |
      //   V    V
      //   101011

      var VLQ_BASE_SHIFT = 5;

      // binary: 100000
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

      // binary: 011111
      var VLQ_BASE_MASK = VLQ_BASE - 1;

      // binary: 100000
      var VLQ_CONTINUATION_BIT = VLQ_BASE;

      /**
       * Converts from a two-complement value to a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
       */
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }

      /**
       * Converts to a two-complement value from a value where the sign bit is
       * placed in the least significant bit.  For example, as decimals:
       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
       */
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }

      /**
       * Returns the base 64 VLQ encoded value.
       */
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };

      /**
       * Decodes the next base 64 VLQ value from the given string and returns the
       * value and the rest of the string via the out parameter.
       */
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };

      /***/
    }, /* 3 */
    /***/function (module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

      /**
       * Encode an integer in the range of 0 to 63 to a single base 64 digit.
       */
      exports.encode = function (number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };

      /**
       * Decode a single base 64 character code digit to an integer. Returns -1 on
       * failure.
       */
      exports.decode = function (charCode) {
        var bigA = 65; // 'A'
        var bigZ = 90; // 'Z'

        var littleA = 97; // 'a'
        var littleZ = 122; // 'z'

        var zero = 48; // '0'
        var nine = 57; // '9'

        var plus = 43; // '+'
        var slash = 47; // '/'

        var littleOffset = 26;
        var numberOffset = 52;

        // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }

        // 26 - 51: abcdefghijklmnopqrstuvwxyz
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }

        // 52 - 61: 0123456789
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }

        // 62: +
        if (charCode == plus) {
          return 62;
        }

        // 63: /
        if (charCode == slash) {
          return 63;
        }

        // Invalid base64 digit.
        return -1;
      };

      /***/
    }, /* 4 */
    /***/function (module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      /**
       * This is a helper function for getting values from parameter/options
       * objects.
       *
       * @param args The object we are extracting values from
       * @param name The name of the property we are getting.
       * @param defaultValue An optional value to return if the property is missing
       * from the object. If this is not specified and the property is missing, an
       * error will be thrown.
       */
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;

      /**
       * Normalizes a path, or the path portion of a URL:
       *
       * - Replaces consecutive slashes with one slash.
       * - Removes unnecessary '.' parts.
       * - Removes unnecessary '<dir>/..' parts.
       *
       * Based on code in the Node.js 'path' core module.
       *
       * @param aPath The path or url to normalize.
       */
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === '.') {
            parts.splice(i, 1);
          } else if (part === '..') {
            up++;
          } else if (up > 0) {
            if (part === '') {
              // The first part is blank if the path is absolute. Trying to go
              // above the root is a no-op. Therefore we can remove all '..' parts
              // directly after the root.
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join('/');
        if (path === '') {
          path = isAbsolute ? '/' : '.';
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;

      /**
       * Joins two paths/URLs.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be joined with the root.
       *
       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
       *   first.
       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
       *   is updated with the result and aRoot is returned. Otherwise the result
       *   is returned.
       *   - If aPath is absolute, the result is aPath.
       *   - Otherwise the two paths are joined with a slash.
       * - Joining for example 'http://' and 'www.example.com' is also supported.
       */
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || '/';
        }

        // `join(foo, '//www.example.org')`
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }

        // `join('http://', 'www.example.com')`
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      exports.isAbsolute = function (aPath) {
        return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
      };

      /**
       * Make a path relative to a URL or another path.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be made relative to aRoot.
       */
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, '');

        // It is possible for the path to be above the root. In this case, simply
        // checking whether the root is a prefix of the path won't work. Instead, we
        // need to remove components from the root one by one, until either we find
        // a prefix that fits, or we run out of components to remove.
        var level = 0;
        while (aPath.indexOf(aRoot + '/') !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }

          // If the only part of the root that is left is the scheme (i.e. http://,
          // file:///, etc.), one or more slashes (/), or simply nothing at all, we
          // have exhausted all components, so the path is not relative to the root.
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }

        // Make sure we add a "../" for each component we removed from the root.
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = function () {
        var obj = Object.create(null);
        return !('__proto__' in obj);
      }();
      function identity(s) {
        return s;
      }

      /**
       * Because behavior goes wacky when you set `__proto__` on objects, we
       * have to prefix all the strings in our set with an arbitrary character.
       *
       * See https://github.com/mozilla/source-map/pull/31 and
       * https://github.com/mozilla/source-map/issues/30
       *
       * @param String aStr
       */
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return '$' + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9 /* "__proto__".length */) {
          return false;
        }
        if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36 /* '$' */) {
            return false;
          }
        }
        return true;
      }

      /**
       * Comparator between two mappings where the original positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same original source/line/column, but different generated
       * line and column the same. Useful when searching for a mapping with a
       * stubbed out mapping.
       */
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;

      /**
       * Comparator between two mappings with deflated source and name indices where
       * the generated positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same generated line and column, but different
       * source/name/original line and column the same. Useful when searching for a
       * mapping with a stubbed out mapping.
       */
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1; // aStr2 !== null
        }

        if (aStr2 === null) {
          return -1; // aStr1 !== null
        }

        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }

      /**
       * Comparator between two mappings with inflated source and name strings where
       * the generated positions are compared.
       */
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

      /**
       * Strip any JSON XSSI avoidance prefix from the string (as documented
       * in the source maps specification), and then parse the string as
       * JSON.
       */
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
      }
      exports.parseSourceMapInput = parseSourceMapInput;

      /**
       * Compute the URL of a source given the the source root, the source's
       * URL, and the source map's URL.
       */
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || '';
        if (sourceRoot) {
          // This follows what Chrome does.
          if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
            sourceRoot += '/';
          }
          // The spec says:
          //   Line 4: An optional source root, useful for relocating source
          //   files on a server or removing repeated values in the
          //   “sources” entry.  This value is prepended to the individual
          //   entries in the “source” field.
          sourceURL = sourceRoot + sourceURL;
        }

        // Historically, SourceMapConsumer did not take the sourceMapURL as
        // a parameter.  This mode is still somewhat supported, which is why
        // this code block is conditional.  However, it's preferable to pass
        // the source map URL to SourceMapConsumer, so that this function
        // can implement the source URL resolution algorithm as outlined in
        // the spec.  This block is basically the equivalent of:
        //    new URL(sourceURL, sourceMapURL).toString()
        // ... except it avoids using URL, which wasn't available in the
        // older releases of node still supported by this library.
        //
        // The spec says:
        //   If the sources are not absolute URLs after prepending of the
        //   “sourceRoot”, the sources are resolved relative to the
        //   SourceMap (like resolving script src in a html document).
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            // Strip the last path component, but keep the "/".
            var index = parsed.path.lastIndexOf('/');
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;

      /***/
    }, /* 5 */
    /***/function (module, exports, __nested_webpack_require_41130__) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var util = __nested_webpack_require_41130__(4);
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";

      /**
       * A data structure which is a combination of an array and a set. Adding a new
       * member is O(1), testing for membership is O(1), and finding the index of an
       * element is O(1). Removing elements from the set is not supported. Only
       * strings are supported for membership.
       */
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? new Map() : Object.create(null);
      }

      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };

      /**
       * Return how many unique items are in this ArraySet. If duplicates have been
       * added, than those do not count towards the size.
       *
       * @returns Number
       */
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };

      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };

      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };

      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };

      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };

      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;

      /***/
    }, /* 6 */
    /***/function (module, exports, __nested_webpack_require_45075__) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2014 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var util = __nested_webpack_require_45075__(4);

      /**
       * Determine whether mappingB is after mappingA with respect to generated
       * position.
       */
      function generatedPositionAfter(mappingA, mappingB) {
        // Optimized for most common case
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }

      /**
       * A data structure to provide a sorted view of accumulated mappings in a
       * performance conscious manner. It trades a neglibable overhead in general
       * case for a large speedup in case of mappings being added in order.
       */
      function MappingList() {
        this._array = [];
        this._sorted = true;
        // Serves as infimum
        this._last = {
          generatedLine: -1,
          generatedColumn: 0
        };
      }

      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };

      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };

      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;

      /***/
    }, /* 7 */
    /***/function (module, exports, __nested_webpack_require_47940__) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var util = __nested_webpack_require_47940__(4);
      var binarySearch = __nested_webpack_require_47940__(8);
      var ArraySet = __nested_webpack_require_47940__(5).ArraySet;
      var base64VLQ = __nested_webpack_require_47940__(2);
      var quickSort = __nested_webpack_require_47940__(9).quickSort;
      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }
      SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };

      /**
       * The version of the source mapping spec that we are consuming.
       */
      SourceMapConsumer.prototype._version = 3;

      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.

      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        configurable: true,
        enumerable: true,
        get: function () {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        configurable: true,
        enumerable: true,
        get: function () {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      };

      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;

      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function (mapping) {
          var source = mapping.source === null ? null : this._sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          return {
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context);
      };

      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a either the line we are searching for or the next
       * closest line that has any mappings. Otherwise, returns all mappings
       * corresponding to the given line and either the column we are searching for
       * or the next closest column that has any offsets.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number is 1-based.
       *   - column: Optional. the column number in the original source.
       *    The column number is 0-based.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *    line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *    The column number is 0-based.
       */
      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util.getArg(aArgs, 'line');

        // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
        // returns the index of the closest mapping less than the needle. By
        // setting needle.originalColumn to 0, we thus find the last mapping for
        // the given line, provided such a mapping exists.
        var needle = {
          source: util.getArg(aArgs, 'source'),
          originalLine: line,
          originalColumn: util.getArg(aArgs, 'column', 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        var mappings = [];
        var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (aArgs.column === undefined) {
            var originalLine = mapping.originalLine;

            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we found. Since
            // mappings are sorted, this is guaranteed to find all mappings for
            // the line we found.
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              });
              mapping = this._originalMappings[++index];
            }
          } else {
            var originalColumn = mapping.originalColumn;

            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we were searching for.
            // Since mappings are sorted, this is guaranteed to find all mappings for
            // the line we are searching for.
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              });
              mapping = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      };
      exports.SourceMapConsumer = SourceMapConsumer;

      /**
       * A BasicSourceMapConsumer instance represents a parsed source map which we can
       * query for information about the original file positions by giving it a file
       * position in the generated source.
       *
       * The first parameter is the raw source map (either as a JSON string, or
       * already parsed to an object). According to the spec, source maps have the
       * following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - sources: An array of URLs to the original source files.
       *   - names: An array of identifiers which can be referrenced by individual mappings.
       *   - sourceRoot: Optional. The URL root from which all sources are relative.
       *   - sourcesContent: Optional. An array of contents of the original source files.
       *   - mappings: A string of base64 VLQs which contain the actual mappings.
       *   - file: Optional. The generated file this source map is associated with.
       *
       * Here is an example source map, taken from the source map spec[0]:
       *
       *     {
       *       version : 3,
       *       file: "out.js",
       *       sourceRoot : "",
       *       sources: ["foo.js", "bar.js"],
       *       names: ["src", "maps", "are", "fun"],
       *       mappings: "AA,AB;;ABCDE;"
       *     }
       *
       * The second parameter, if given, is a string whose value is the URL
       * at which the source map was found.  This URL is used to compute the
       * sources array.
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
       */
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
        // requires the array) to play nice here.
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);

        // Once again, Sass deviates from the spec and supplies the version as a
        // string rather than a number, so we use loose equality checking here.
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }
        sources = sources.map(String)
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        .map(util.normalize)
        // Always ensure that absolute sources are internally stored relative to
        // the source root, if the source root is absolute. Not doing this would
        // be particularly problematic when the source root is a prefix of the
        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
        .map(function (source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        });

        // Pass `true` below to allow duplicate names and sources. While source maps
        // are intended to be compressed and deduplicated, the TypeScript compiler
        // sometimes generates source maps with duplicates in them. See Github issue
        // #72 and bugzil.la/889492.
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this._absoluteSources = this._sources.toArray().map(function (s) {
          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
        });
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

      /**
       * Utility function to find the index of a source.  Returns -1 if not
       * found.
       */
      BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }

        // Maybe aSource is an absolute URL as returned by |sources|.  In
        // this case we can't simply undo the transform.
        var i;
        for (i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }
        return -1;
      };

      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @param String aSourceMapURL
       *        The URL at which the source map can be found (optional)
       * @returns BasicSourceMapConsumer
       */
      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function (s) {
          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });

        // Because we are modifying the entries (by converting string sources and
        // names to indices into the sources and names ArraySets), we have to make
        // a copy of the entry or else bad things happen. Shared mutable state
        // strikes again! See github issue #191.

        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i = 0, length = generatedMappings.length; i < length; i++) {
          var srcMapping = generatedMappings[i];
          var destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
          }
          destGeneratedMappings.push(destMapping);
        }
        quickSort(smc.__originalMappings, util.compareByOriginalPositions);
        return smc;
      };

      /**
       * The version of the source mapping spec that we are consuming.
       */
      BasicSourceMapConsumer.prototype._version = 3;

      /**
       * The list of original sources.
       */
      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._absoluteSources.slice();
        }
      });

      /**
       * Provide the JIT with a nice shape / hidden class.
       */
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }

      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
        while (index < length) {
          if (aStr.charAt(index) === ';') {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
          } else if (aStr.charAt(index) === ',') {
            index++;
          } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;

            // Because each offset is encoded relative to the previous one,
            // many segments often have the same encoding. We can exploit this
            // fact by caching the parsed variable length fields of each segment,
            // allowing us to avoid a second parse if we encounter the same
            // segment again.
            for (end = index; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index, end);
            segment = cachedSegments[str];
            if (segment) {
              index += str.length;
            } else {
              segment = [];
              while (index < end) {
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
              }
              if (segment.length === 2) {
                throw new Error('Found a source, but no line and column');
              }
              if (segment.length === 3) {
                throw new Error('Found a source and line, but no column');
              }
              cachedSegments[str] = segment;
            }

            // Generated column.
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
              // Original source.
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];

              // Original line.
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              // Lines are stored 0-based
              mapping.originalLine += 1;

              // Original column.
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;
              if (segment.length > 4) {
                // Original name.
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
              originalMappings.push(mapping);
            }
          }
        }
        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;
        quickSort(originalMappings, util.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
      };

      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        // To return the position we are searching for, we must first find the
        // mapping for the given position and then return the opposite position it
        // points to. Because the mappings are sorted, we can use binary search to
        // find the best mapping.

        if (aNeedle[aLineName] <= 0) {
          throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };

      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */
      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];

          // Mappings do not contain a field for the last generated columnt. We
          // can come up with an optimistic estimate, however, by assuming that
          // mappings are contiguous (i.e. given two consecutive mappings, the
          // first mapping ends where the second one starts).
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }

          // The last mapping for each line spans the entire line.
          mapping.lastGeneratedColumn = Infinity;
        }
      };

      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, 'line'),
          generatedColumn: util.getArg(aArgs, 'column')
        };
        var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
        if (index >= 0) {
          var mapping = this._generatedMappings[index];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, 'name', null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source: source,
              line: util.getArg(mapping, 'originalLine', null),
              column: util.getArg(mapping, 'originalColumn', null),
              name: name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };

      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
          return sc == null;
        });
      };

      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        var index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          // XXX: file:// URIs and absolute paths lead to unexpected behavior for
          // many users. We can help them out when they expect file:// URIs to
          // behave like it would if they were running a local HTTP server. See
          // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }

        // This function is used recursively from
        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
        // don't want to throw if we can't find the source - we just want to
        // return null, so we provide a flag to exit gracefully.
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };

      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, 'source');
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        var needle = {
          source: source,
          originalLine: util.getArg(aArgs, 'line'),
          originalColumn: util.getArg(aArgs, 'column')
        };
        var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

      /**
       * An IndexedSourceMapConsumer instance represents a parsed source map which
       * we can query for information. It differs from BasicSourceMapConsumer in
       * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
       * input.
       *
       * The first parameter is a raw source map (either as a JSON string, or already
       * parsed to an object). According to the spec for indexed source maps, they
       * have the following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - file: Optional. The generated file this source map is associated with.
       *   - sections: A list of section definitions.
       *
       * Each value under the "sections" field has two fields:
       *   - offset: The offset into the original specified at which this section
       *       begins to apply, defined as an object with a "line" and "column"
       *       field.
       *   - map: A source map definition. This source map could also be indexed,
       *       but doesn't have to be.
       *
       * Instead of the "map" field, it's also possible to have a "url" field
       * specifying a URL to retrieve a source map from, but that's currently
       * unsupported.
       *
       * Here's an example source map, taken from the source map spec[0], but
       * modified to omit a section which uses the "url" field.
       *
       *  {
       *    version : 3,
       *    file: "app.js",
       *    sections: [{
       *      offset: {line:100, column:10},
       *      map: {
       *        version : 3,
       *        file: "section.js",
       *        sources: ["foo.js", "bar.js"],
       *        names: ["src", "maps", "are", "fun"],
       *        mappings: "AAAA,E;;ABCDE;"
       *      }
       *    }],
       *  }
       *
       * The second parameter, if given, is a string whose value is the URL
       * at which the source map was found.  This URL is used to compute the
       * sources array.
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
       */
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version = util.getArg(sourceMap, 'version');
        var sections = util.getArg(sourceMap, 'sections');
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function (s) {
          if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
          }
          var offset = util.getArg(s, 'offset');
          var offsetLine = util.getArg(offset, 'line');
          var offsetColumn = util.getArg(offset, 'column');
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
          }
          lastOffset = offset;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

      /**
       * The version of the source mapping spec that we are consuming.
       */
      IndexedSourceMapConsumer.prototype._version = 3;

      /**
       * The list of original sources.
       */
      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
        get: function () {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        }
      });

      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, 'line'),
          generatedColumn: util.getArg(aArgs, 'column')
        };

        // Find the section containing the generated position we're trying to map
        // to an original position.
        var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle.generatedColumn - section.generatedOffset.generatedColumn;
        });
        var section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      };

      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function (s) {
          return s.consumer.hasContentsOfAllSources();
        });
      };

      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };

      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based. 
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];

          // Only consider this section if the requested source is in the list of
          // sources of the consumer.
          if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
        return {
          line: null,
          column: null
        };
      };

      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }

            // The mappings coming from the consumer for the section have
            // generated positions relative to the start of the section, so we
            // need to offset them to be relative to the start of the concatenated
            // generated file.
            var adjustedMapping = {
              source: source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name: name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === 'number') {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

      /***/
    }, /* 8 */
    /***/function (module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;

      /**
       * Recursive implementation of binary search.
       *
       * @param aLow Indices here and lower do not contain the needle.
       * @param aHigh Indices here and higher do not contain the needle.
       * @param aNeedle The element being searched for.
       * @param aHaystack The non-empty array being searched.
       * @param aCompare Function which takes two elements and returns -1, 0, or 1.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       */
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the index of
        //      the next-closest element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element than the one we are searching for, so we return -1.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          // Found the element we are looking for.
          return mid;
        } else if (cmp > 0) {
          // Our needle is greater than aHaystack[mid].
          if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }

          // The exact needle element was not found in this haystack. Determine if
          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          // Our needle is less than aHaystack[mid].
          if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }

          // we are in termination case (3) or (2) and return the appropriate thing.
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }

      /**
       * This is an implementation of binary search which will always try and return
       * the index of the closest element if there is no exact hit. This is because
       * mappings between original and generated line/col pairs are single points,
       * and there is an implicit region between each of them, so a miss just means
       * that you aren't on the very start of a region.
       *
       * @param aNeedle The element you are looking for.
       * @param aHaystack The array that is being searched.
       * @param aCompare A function which takes the needle and an element in the
       *     array and returns -1, 0, or 1 depending on whether the needle is less
       *     than, equal to, or greater than the element, respectively.
       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
       */
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
        if (index < 0) {
          return -1;
        }

        // We have found either the exact element, or the next-closest element than
        // the one we are searching for. However, there may be more than one such
        // element. Make sure we always return the smallest of these.
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
        return index;
      };

      /***/
    }, /* 9 */
    /***/function (module, exports) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      // It turns out that some (most?) JavaScript engines don't self-host
      // `Array.prototype.sort`. This makes sense because C++ will likely remain
      // faster than JS when doing raw CPU-intensive sorting. However, when using a
      // custom comparator function, calling back and forth between the VM's C++ and
      // JIT'd JS is rather slow *and* loses JIT type information, resulting in
      // worse generated code for the comparator function than would be optimal. In
      // fact, when sorting with a comparator, these costs outweigh the benefits of
      // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
      // a ~3500ms mean speed-up in `bench/bench.html`.

      /**
       * Swap the elements indexed by `x` and `y` in the array `ary`.
       *
       * @param {Array} ary
       *        The array.
       * @param {Number} x
       *        The index of the first item.
       * @param {Number} y
       *        The index of the second item.
       */
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }

      /**
       * Returns a random integer within the range `low .. high` inclusive.
       *
       * @param {Number} low
       *        The lower bound on the range.
       * @param {Number} high
       *        The upper bound on the range.
       */
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }

      /**
       * The Quick Sort algorithm.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       * @param {Number} p
       *        Start index of the array
       * @param {Number} r
       *        End index of the array
       */
      function doQuickSort(ary, comparator, p, r) {
        // If our lower bound is less than our upper bound, we (1) partition the
        // array into two pieces and (2) recurse on each half. If it is not, this is
        // the empty array and our base case.

        if (p < r) {
          // (1) Partitioning.
          //
          // The partitioning chooses a pivot between `p` and `r` and moves all
          // elements that are less than or equal to the pivot to the before it, and
          // all the elements that are greater than it after it. The effect is that
          // once partition is done, the pivot is in the exact place it will be when
          // the array is put in sorted order, and it will not need to be moved
          // again. This runs in O(n) time.

          // Always choose a random pivot so that an input array which is reverse
          // sorted does not cause O(n^2) running time.
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];

          // Immediately after `j` is incremented in this loop, the following hold
          // true:
          //
          //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
          //
          //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q = i + 1;

          // (2) Recurse on each half.

          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }

      /**
       * Sort the given array in-place with the given comparator function.
       *
       * @param {Array} ary
       *        An array to sort.
       * @param {function} comparator
       *        Function to use to compare two items.
       */
      exports.quickSort = function (ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };

      /***/
    }, /* 10 */
    /***/function (module, exports, __nested_webpack_require_101790__) {
      /* -*- Mode: js; js-indent-level: 2; -*- */
      /*
       * Copyright 2011 Mozilla Foundation and contributors
       * Licensed under the New BSD license. See LICENSE or:
       * http://opensource.org/licenses/BSD-3-Clause
       */

      var SourceMapGenerator = __nested_webpack_require_101790__(1).SourceMapGenerator;
      var util = __nested_webpack_require_101790__(4);

      // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
      // operating systems these days (capturing the result).
      var REGEX_NEWLINE = /(\r?\n)/;

      // Newline character code for charCodeAt() comparisons
      var NEWLINE_CODE = 10;

      // Private symbol for identifying `SourceNode`s when multiple versions of
      // the source-map library are loaded. This MUST NOT CHANGE across
      // versions!
      var isSourceNode = "$$$isSourceNode$$$";

      /**
       * SourceNodes provide a way to abstract over interpolating/concatenating
       * snippets of generated JavaScript source code while maintaining the line and
       * column information associated with the original source code.
       *
       * @param aLine The original line number.
       * @param aColumn The original column number.
       * @param aSource The original source's filename.
       * @param aChunks Optional. An array of strings which are snippets of
       *        generated JS, or other SourceNodes.
       * @param aName The original identifier.
       */
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }

      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        // The SourceNode we want to fill with the generated code
        // and the SourceMap
        var node = new SourceNode();

        // All even indices of this array are one line of the generated code,
        // while all odd indices are the newlines between two adjacent lines
        // (since `REGEX_NEWLINE` captures its match).
        // Processed fragments are accessed by calling `shiftNextLine`.
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function () {
          var lineContents = getNextLine();
          // The last line of a file might not have a newline.
          var newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
          }
        };

        // We need to remember the position of "remainingLines"
        var lastGeneratedLine = 1,
          lastGeneratedColumn = 0;

        // The generate SourceNodes we need a code range.
        // To extract it current and last mapping is used.
        // Here we store the last mapping.
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function (mapping) {
          if (lastMapping !== null) {
            // We add the code from "lastMapping" to "mapping":
            // First check if there is a new line in between.
            if (lastGeneratedLine < mapping.generatedLine) {
              // Associate first line with "lastMapping"
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
              // The remaining code is added without mapping
            } else {
              // There is no new line in between.
              // Associate the code between "lastGeneratedColumn" and
              // "mapping.generatedColumn" with "lastMapping"
              var nextLine = remainingLines[remainingLinesIndex] || '';
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              // No more remaining code, continue
              lastMapping = mapping;
              return;
            }
          }
          // We add the generated code until the first mapping
          // to the SourceNode without any mapping.
          // Each line is added as separate string.
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || '';
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        // We have processed all mappings.
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            // Associate the remaining code in the current line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          // and add the remaining lines without any mapping
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }

        // Copy sourcesContent into SourceNode
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === undefined) {
            node.add(code);
          } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
          }
        }
      };

      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
        }
        return this;
      };

      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
        }
        return this;
      };

      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== '') {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };

      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };

      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };

      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };

      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };

      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };

      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              // Mappings end at eol
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return {
          code: generated.code,
          map: map
        };
      };
      exports.SourceNode = SourceNode;

      /***/
    }
    /******/])
  );
});

;

/***/ }),

/***/ "./scripts/3rdparty/toastr/toastr_customized.js":
/*!******************************************************!*\
  !*** ./scripts/3rdparty/toastr/toastr_customized.js ***!
  \******************************************************/
/***/ (() => {

/*
 * Toastr
 * Copyright 2012-2015
 * Authors: John Papa, Hans Fjällemark, and Tim Ferrell.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * ARIA Support: Greta Krafsig
 *
 * Project: https://github.com/CodeSeven/toastr
 */
/* global define */
(function (define) {
  define(['jquery'], function ($) {
    return function () {
      var $container;
      var listener;
      var toastId = 0;
      var toastType = {
        error: 'error',
        info: 'info',
        success: 'success',
        warning: 'warning'
      };
      var toastr = {
        clear: clear,
        remove: remove,
        error: error,
        getContainer: getContainer,
        info: info,
        options: {},
        subscribe: subscribe,
        success: success,
        version: '2.1.4',
        warning: warning
      };
      var previousToast;
      return toastr;

      ////////////////

      function error(message, title, optionsOverride) {
        return notify({
          type: toastType.error,
          iconClass: getOptions().iconClasses.error,
          message: message,
          optionsOverride: optionsOverride,
          title: title
        });
      }
      function getContainer(options, create) {
        if (!options) {
          options = getOptions();
        }
        $container = $('#' + options.containerId);
        if ($container.length) {
          return $container;
        }
        if (create) {
          $container = createContainer(options);
        }
        return $container;
      }
      function info(message, title, optionsOverride) {
        return notify({
          type: toastType.info,
          iconClass: getOptions().iconClasses.info,
          message: message,
          optionsOverride: optionsOverride,
          title: title
        });
      }
      function subscribe(callback) {
        listener = callback;
      }
      function success(message, title, optionsOverride) {
        return notify({
          type: toastType.success,
          iconClass: getOptions().iconClasses.success,
          message: message,
          optionsOverride: optionsOverride,
          title: title
        });
      }
      function warning(message, title, optionsOverride) {
        return notify({
          type: toastType.warning,
          iconClass: getOptions().iconClasses.warning,
          message: message,
          optionsOverride: optionsOverride,
          title: title
        });
      }
      function clear($toastElement, clearOptions) {
        var options = getOptions();
        if (!$container) {
          getContainer(options);
        }
        if (!clearToast($toastElement, options, clearOptions)) {
          clearContainer(options);
        }
      }
      function remove($toastElement) {
        var options = getOptions();
        if (!$container) {
          getContainer(options);
        }
        if ($toastElement && $(':focus', $toastElement).length === 0) {
          removeToast($toastElement);
          return;
        }
        if ($container.children().length) {
          $container.remove();
        }
      }

      // internal functions

      function clearContainer(options) {
        var toastsToClear = $container.children();
        for (var i = toastsToClear.length - 1; i >= 0; i--) {
          clearToast($(toastsToClear[i]), options);
        }
      }
      function clearToast($toastElement, options, clearOptions) {
        var force = clearOptions && clearOptions.force ? clearOptions.force : false;
        if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
          $toastElement[options.hideMethod]({
            duration: options.hideDuration,
            easing: options.hideEasing,
            complete: function () {
              removeToast($toastElement);
            }
          });
          return true;
        }
        return false;
      }
      function createContainer(options) {
        $container = $('<div/>').attr('id', options.containerId).addClass(options.positionClass);
        $container.appendTo($(options.target));
        return $container;
      }
      function getDefaults() {
        return {
          tapToDismiss: true,
          toastClass: 'toast',
          containerId: 'toast-container',
          debug: false,
          showMethod: 'fadeIn',
          //fadeIn, slideDown, and show are built into jQuery
          showDuration: 300,
          showEasing: 'swing',
          //swing and linear are built into jQuery
          onShown: undefined,
          hideMethod: 'fadeOut',
          hideDuration: 1000,
          hideEasing: 'swing',
          onHidden: undefined,
          closeMethod: false,
          closeDuration: false,
          closeEasing: false,
          closeOnHover: true,
          extendedTimeOut: 1000,
          iconClasses: {
            error: 'toast-error',
            info: 'toast-info',
            success: 'toast-success',
            warning: 'toast-warning'
          },
          iconClass: 'toast-info',
          positionClass: 'toast-top-right',
          timeOut: 5000,
          // Set timeOut and extendedTimeOut to 0 to make it sticky
          titleClass: 'toast-title',
          messageClass: 'toast-message',
          escapeHtml: false,
          target: 'body',
          closeHtml: '<button type="button">&times;</button>',
          closeClass: 'toast-close-button',
          newestOnTop: true,
          preventDuplicates: false,
          progressBar: false,
          progressClass: 'toast-progress',
          rtl: false
        };
      }
      function publish(args) {
        if (!listener) {
          return;
        }
        listener(args);
      }
      function notify(map) {
        var options = getOptions();
        var iconClass = map.iconClass || options.iconClass;
        if (typeof map.optionsOverride !== 'undefined') {
          options = $.extend(options, map.optionsOverride);
          iconClass = map.optionsOverride.iconClass || iconClass;
        }
        if (shouldExit(options, map)) {
          return;
        }
        toastId++;
        $container = getContainer(options, true);
        var intervalId = null;
        var $toastElement = $('<div/>');
        var $titleElement = $('<div/>');
        var $messageElement = $('<div/>');
        var $progressElement = $('<div/>');
        var $closeElement = $(options.closeHtml);
        var progressBar = {
          intervalId: null,
          hideEta: null,
          maxHideTime: null
        };
        var response = {
          toastId: toastId,
          state: 'visible',
          startTime: new Date(),
          options: options,
          map: map
        };
        personalizeToast();
        displayToast();
        handleEvents();
        publish(response);
        if (options.debug && console) {
          console.log(response);
        }
        return $toastElement;
        function escapeHtml(source) {
          if (source == null) {
            source = '';
          }
          return source.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }
        function personalizeToast() {
          setIcon();
          setTitle();
          setMessage();
          setCloseButton();
          setProgressBar();
          setRTL();
          setSequence();
          setAria();
        }
        function setAria() {
          var ariaValue = '';
          switch (map.iconClass) {
            case 'toast-success':
            case 'toast-info':
              ariaValue = 'polite';
              break;
            default:
              ariaValue = 'assertive';
          }
          $toastElement.attr('aria-live', ariaValue);
        }
        function handleEvents() {
          if (options.closeOnHover) {
            $toastElement.hover(stickAround, delayedHideToast);
          }
          if (!options.onclick && options.tapToDismiss) {
            $toastElement.click(hideToast);
          }
          if (options.closeButton && $closeElement) {
            $closeElement.click(function (event) {
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                event.cancelBubble = true;
              }
              if (options.onCloseClick) {
                options.onCloseClick(event);
              }
              hideToast(true);
            });
          }
          if (options.onclick) {
            $toastElement.click(function (event) {
              options.onclick(event);
              // hideToast();     // Commenting it out since hiding toast couldn't be turned off in case of 'onclick()'
            });
          }
        }

        function displayToast() {
          $toastElement.hide();
          $toastElement[options.showMethod]({
            duration: options.showDuration,
            easing: options.showEasing,
            complete: options.onShown
          });
          if (options.timeOut > 0) {
            intervalId = setTimeout(hideToast, options.timeOut);
            progressBar.maxHideTime = parseFloat(options.timeOut);
            progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
            if (options.progressBar) {
              progressBar.intervalId = setInterval(updateProgress, 10);
            }
          }
        }
        function setIcon() {
          if (map.iconClass) {
            $toastElement.addClass(options.toastClass).addClass(iconClass);
          }
        }
        function setSequence() {
          if (options.newestOnTop) {
            $container.prepend($toastElement);
          } else {
            $container.append($toastElement);
          }
        }
        function setTitle() {
          if (map.title) {
            var suffix = map.title;
            if (options.escapeHtml) {
              suffix = escapeHtml(map.title);
            }
            $titleElement.append(suffix).addClass(options.titleClass);
            $toastElement.append($titleElement);
          }
        }
        function setMessage() {
          if (map.message) {
            var suffix = map.message;
            if (options.escapeHtml) {
              suffix = escapeHtml(map.message);
            }
            $messageElement.append(suffix).addClass(options.messageClass);
            $toastElement.append($messageElement);
          }
        }
        function setCloseButton() {
          if (options.closeButton) {
            $closeElement.addClass(options.closeClass).attr('role', 'button');
            $toastElement.prepend($closeElement);
          }
        }
        function setProgressBar() {
          if (options.progressBar) {
            $progressElement.addClass(options.progressClass);
            $toastElement.prepend($progressElement);
          }
        }
        function setRTL() {
          if (options.rtl) {
            $toastElement.addClass('rtl');
          }
        }
        function shouldExit(options, map) {
          if (options.preventDuplicates) {
            if (map.message === previousToast) {
              return true;
            } else {
              previousToast = map.message;
            }
          }
          return false;
        }
        function hideToast(override) {
          var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
          var duration = override && options.closeDuration !== false ? options.closeDuration : options.hideDuration;
          var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
          if ($(':focus', $toastElement).length && !override) {
            return;
          }
          clearTimeout(progressBar.intervalId);
          return $toastElement[method]({
            duration: duration,
            easing: easing,
            complete: function () {
              removeToast($toastElement);
              clearTimeout(intervalId);
              if (options.onHidden && response.state !== 'hidden') {
                options.onHidden();
              }
              response.state = 'hidden';
              response.endTime = new Date();
              publish(response);
            }
          });
        }
        function delayedHideToast() {
          if (options.timeOut > 0 || options.extendedTimeOut > 0) {
            intervalId = setTimeout(hideToast, options.extendedTimeOut);
            progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
            progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
          }
        }
        function stickAround() {
          clearTimeout(intervalId);
          progressBar.hideEta = 0;
          $toastElement.stop(true, true)[options.showMethod]({
            duration: options.showDuration,
            easing: options.showEasing
          });
        }
        function updateProgress() {
          var percentage = (progressBar.hideEta - new Date().getTime()) / progressBar.maxHideTime * 100;
          $progressElement.width(percentage + '%');
        }
      }
      function getOptions() {
        return $.extend({}, getDefaults(), toastr.options);
      }
      function removeToast($toastElement) {
        if (!$container) {
          $container = getContainer();
        }
        if ($toastElement.is(':visible')) {
          return;
        }
        $toastElement.remove();
        $toastElement = null;
        if ($container.children().length === 0) {
          $container.remove();
          previousToast = undefined;
        }
      }
    }();
  });
})( false ? 0 : function (deps, factory) {
  // if (typeof module !== 'undefined' && module.exports) { //Node
  //     module.exports = factory(require('jquery'));
  // } else {
  window.toastr = factory(window.jQuery);
  // }
});

/***/ }),

/***/ "./scripts/3rdparty/tooltipster/jquery.tooltipster.js":
/*!************************************************************!*\
  !*** ./scripts/3rdparty/tooltipster/jquery.tooltipster.js ***!
  \************************************************************/
/***/ (function() {

/**
 * tooltipster http://iamceege.github.io/tooltipster/
 * A rockin' custom tooltip jQuery plugin
 * Developed by Caleb Jacob and Louis Ameline
 * MIT license
 */
(function (root, factory) {
  //   if (typeof define === 'function' && define.amd) {
  //     // AMD. Register as an anonymous module unless amdModuleId is set
  //     define(["jquery"], function (a0) {
  //       return (factory(a0));
  //     });
  //   } else if (typeof exports === 'object') {
  //     // Node. Does not work with strict CommonJS, but
  //     // only CommonJS-like environments that support module.exports,
  //     // like Node.
  //     module.exports = factory(require("jquery"));
  //   } else {
  factory(jQuery);
  //   }
})(this, function ($) {
  // This file will be UMDified by a build task.

  var defaults = {
      animation: 'fade',
      animationDuration: 350,
      content: null,
      contentAsHTML: false,
      contentCloning: false,
      debug: true,
      delay: 300,
      delayTouch: [300, 500],
      functionInit: null,
      functionBefore: null,
      functionReady: null,
      functionAfter: null,
      functionFormat: null,
      IEmin: 6,
      interactive: false,
      multiple: false,
      // will default to document.body, or must be an element positioned at (0, 0)
      // in the document, typically like the very top views of an app.
      parent: null,
      plugins: ['sideTip'],
      repositionOnScroll: false,
      restoration: 'none',
      selfDestruction: true,
      theme: [],
      timer: 0,
      trackerInterval: 500,
      trackOrigin: false,
      trackTooltip: false,
      trigger: 'hover',
      triggerClose: {
        click: false,
        mouseleave: false,
        originClick: false,
        scroll: false,
        tap: false,
        touchleave: false
      },
      triggerOpen: {
        click: false,
        mouseenter: false,
        tap: false,
        touchstart: false
      },
      updateAnimation: 'rotate',
      zIndex: 9999999
    },
    // we'll avoid using the 'window' global as a good practice but npm's
    // jquery@<2.1.0 package actually requires a 'window' global, so not sure
    // it's useful at all
    win = typeof window != 'undefined' ? window : null,
    // env will be proxied by the core for plugins to have access its properties
    env = {
      // detect if this device can trigger touch events. Better have a false
      // positive (unused listeners, that's ok) than a false negative.
      // https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
      // http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript
      hasTouchCapability: !!(win && ('ontouchstart' in win || win.DocumentTouch && win.document instanceof win.DocumentTouch || win.navigator.maxTouchPoints)),
      hasTransitions: transitionSupport(),
      IE: false,
      // don't set manually, it will be updated by a build task after the manifest
      semVer: '4.2.8',
      window: win
    },
    core = function () {
      // core variables

      // the core emitters
      this.__$emitterPrivate = $({});
      this.__$emitterPublic = $({});
      this.__instancesLatestArr = [];
      // collects plugin constructors
      this.__plugins = {};
      // proxy env variables for plugins who might use them
      this._env = env;
    };

  // core methods
  core.prototype = {
    /**
     * A function to proxy the public methods of an object onto another
     *
     * @param {object} constructor The constructor to bridge
     * @param {object} obj The object that will get new methods (an instance or the core)
     * @param {string} pluginName A plugin name for the console log message
     * @return {core}
     * @private
     */
    __bridge: function (constructor, obj, pluginName) {
      // if it's not already bridged
      if (!obj[pluginName]) {
        var fn = function () {};
        fn.prototype = constructor;
        var pluginInstance = new fn();

        // the _init method has to exist in instance constructors but might be missing
        // in core constructors
        if (pluginInstance.__init) {
          pluginInstance.__init(obj);
        }
        $.each(constructor, function (methodName, fn) {
          // don't proxy "private" methods, only "protected" and public ones
          if (methodName.indexOf('__') != 0) {
            // if the method does not exist yet
            if (!obj[methodName]) {
              obj[methodName] = function () {
                return pluginInstance[methodName].apply(pluginInstance, Array.prototype.slice.apply(arguments));
              };

              // remember to which plugin this method corresponds (several plugins may
              // have methods of the same name, we need to be sure)
              obj[methodName].bridged = pluginInstance;
            } else if (defaults.debug) {
              console.log('The ' + methodName + ' method of the ' + pluginName + ' plugin conflicts with another plugin or native methods');
            }
          }
        });
        obj[pluginName] = pluginInstance;
      }
      return this;
    },
    /**
     * For mockup in Node env if need be, for testing purposes
     *
     * @return {core}
     * @private
     */
    __setWindow: function (window) {
      env.window = window;
      return this;
    },
    /**
     * Returns a ruler, a tool to help measure the size of a tooltip under
     * various settings. Meant for plugins
     * 
     * @see Ruler
     * @return {object} A Ruler instance
     * @protected
     */
    _getRuler: function ($tooltip) {
      return new Ruler($tooltip);
    },
    /**
     * For internal use by plugins, if needed
     *
     * @return {core}
     * @protected
     */
    _off: function () {
      this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
      return this;
    },
    /**
     * For internal use by plugins, if needed
     *
     * @return {core}
     * @protected
     */
    _on: function () {
      this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
      return this;
    },
    /**
     * For internal use by plugins, if needed
     *
     * @return {core}
     * @protected
     */
    _one: function () {
      this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
      return this;
    },
    /**
     * Returns (getter) or adds (setter) a plugin
     *
     * @param {string|object} plugin Provide a string (in the full form
     * "namespace.name") to use as as getter, an object to use as a setter
     * @return {object|core}
     * @protected
     */
    _plugin: function (plugin) {
      var self = this;

      // getter
      if (typeof plugin == 'string') {
        var pluginName = plugin,
          p = null;

        // if the namespace is provided, it's easy to search
        if (pluginName.indexOf('.') > 0) {
          p = self.__plugins[pluginName];
        }
        // otherwise, return the first name that matches
        else {
          $.each(self.__plugins, function (i, plugin) {
            if (plugin.name.substring(plugin.name.length - pluginName.length - 1) == '.' + pluginName) {
              p = plugin;
              return false;
            }
          });
        }
        return p;
      }
      // setter
      else {
        // force namespaces
        if (plugin.name.indexOf('.') < 0) {
          throw new Error('Plugins must be namespaced');
        }
        self.__plugins[plugin.name] = plugin;

        // if the plugin has core features
        if (plugin.core) {
          // bridge non-private methods onto the core to allow new core methods
          self.__bridge(plugin.core, self, plugin.name);
        }
        return this;
      }
    },
    /**
     * Trigger events on the core emitters
     * 
     * @returns {core}
     * @protected
     */
    _trigger: function () {
      var args = Array.prototype.slice.apply(arguments);
      if (typeof args[0] == 'string') {
        args[0] = {
          type: args[0]
        };
      }

      // note: the order of emitters matters
      this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
      this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);
      return this;
    },
    /**
     * Returns instances of all tooltips in the page or an a given element
     *
     * @param {string|HTML object collection} selector optional Use this
     * parameter to restrict the set of objects that will be inspected
     * for the retrieval of instances. By default, all instances in the
     * page are returned.
     * @return {array} An array of instance objects
     * @public
     */
    instances: function (selector) {
      var instances = [],
        sel = selector || '.tooltipstered';
      $(sel).each(function () {
        var $this = $(this),
          ns = $this.data('tooltipster-ns');
        if (ns) {
          $.each(ns, function (i, namespace) {
            instances.push($this.data(namespace));
          });
        }
      });
      return instances;
    },
    /**
     * Returns the Tooltipster objects generated by the last initializing call
     *
     * @return {array} An array of instance objects
     * @public
     */
    instancesLatest: function () {
      return this.__instancesLatestArr;
    },
    /**
     * For public use only, not to be used by plugins (use ::_off() instead)
     *
     * @return {core}
     * @public
     */
    off: function () {
      this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
      return this;
    },
    /**
     * For public use only, not to be used by plugins (use ::_on() instead)
     *
     * @return {core}
     * @public
     */
    on: function () {
      this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
      return this;
    },
    /**
     * For public use only, not to be used by plugins (use ::_one() instead)
     * 
     * @return {core}
     * @public
     */
    one: function () {
      this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
      return this;
    },
    /**
     * Returns all HTML elements which have one or more tooltips
     *
     * @param {string} selector optional Use this to restrict the results
     * to the descendants of an element
     * @return {array} An array of HTML elements
     * @public
     */
    origins: function (selector) {
      var sel = selector ? selector + ' ' : '';
      return $(sel + '.tooltipstered').toArray();
    },
    /**
     * Change default options for all future instances
     *
     * @param {object} d The options that should be made defaults
     * @return {core}
     * @public
     */
    setDefaults: function (d) {
      $.extend(defaults, d);
      return this;
    },
    /**
     * For users to trigger their handlers on the public emitter
     * 
     * @returns {core}
     * @public
     */
    triggerHandler: function () {
      this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
      return this;
    }
  };

  // $.tooltipster will be used to call core methods
  $.tooltipster = new core();

  // the Tooltipster instance class (mind the capital T)
  $.Tooltipster = function (element, options) {
    // list of instance variables

    // stack of custom callbacks provided as parameters to API methods
    this.__callbacks = {
      close: [],
      open: []
    };
    // the schedule time of DOM removal
    this.__closingTime;
    // this will be the user content shown in the tooltip. A capital "C" is used
    // because there is also a method called content()
    this.__Content;
    // for the size tracker
    this.__contentBcr;
    // to disable the tooltip after destruction
    this.__destroyed = false;
    // we can't emit directly on the instance because if a method with the same
    // name as the event exists, it will be called by jQuery. Se we use a plain
    // object as emitter. This emitter is for internal use by plugins,
    // if needed.
    this.__$emitterPrivate = $({});
    // this emitter is for the user to listen to events without risking to mess
    // with our internal listeners
    this.__$emitterPublic = $({});
    this.__enabled = true;
    // the reference to the gc interval
    this.__garbageCollector;
    // various position and size data recomputed before each repositioning
    this.__Geometry;
    // the tooltip position, saved after each repositioning by a plugin
    this.__lastPosition;
    // a unique namespace per instance
    this.__namespace = 'tooltipster-' + Math.round(Math.random() * 1000000);
    this.__options;
    // will be used to support origins in scrollable areas
    this.__$originParents;
    this.__pointerIsOverOrigin = false;
    // to remove themes if needed
    this.__previousThemes = [];
    // the state can be either: appearing, stable, disappearing, closed
    this.__state = 'closed';
    // timeout references
    this.__timeouts = {
      close: [],
      open: null
    };
    // store touch events to be able to detect emulated mouse events
    this.__touchEvents = [];
    // the reference to the tracker interval
    this.__tracker = null;
    // the element to which this tooltip is associated
    this._$origin;
    // this will be the tooltip element (jQuery wrapped HTML element).
    // It's the job of a plugin to create it and append it to the DOM
    this._$tooltip;

    // launch
    this.__init(element, options);
  };
  $.Tooltipster.prototype = {
    /**
     * @param origin
     * @param options
     * @private
     */
    __init: function (origin, options) {
      var self = this;
      self._$origin = $(origin);
      self.__options = $.extend(true, {}, defaults, options);

      // some options may need to be reformatted
      self.__optionsFormat();

      // don't run on old IE if asked no to
      if (!env.IE || env.IE >= self.__options.IEmin) {
        // note: the content is null (empty) by default and can stay that
        // way if the plugin remains initialized but not fed any content. The
        // tooltip will just not appear.

        // let's save the initial value of the title attribute for later
        // restoration if need be.
        var initialTitle = null;

        // it will already have been saved in case of multiple tooltips
        if (self._$origin.data('tooltipster-initialTitle') === undefined) {
          initialTitle = self._$origin.attr('title');

          // we do not want initialTitle to be "undefined" because
          // of how jQuery's .data() method works
          if (initialTitle === undefined) initialTitle = null;
          self._$origin.data('tooltipster-initialTitle', initialTitle);
        }

        // If content is provided in the options, it has precedence over the
        // title attribute.
        // Note: an empty string is considered content, only 'null' represents
        // the absence of content.
        // Also, an existing title="" attribute will result in an empty string
        // content
        if (self.__options.content !== null) {
          self.__contentSet(self.__options.content);
        } else {
          var selector = self._$origin.attr('data-tooltip-content'),
            $el;
          if (selector) {
            $el = $(selector);
          }
          if ($el && $el[0]) {
            self.__contentSet($el.first());
          } else {
            self.__contentSet(initialTitle);
          }
        }
        self._$origin
        // strip the title off of the element to prevent the default tooltips
        // from popping up
        .removeAttr('title')
        // to be able to find all instances on the page later (upon window
        // events in particular)
        .addClass('tooltipstered');

        // set listeners on the origin
        self.__prepareOrigin();

        // set the garbage collector
        self.__prepareGC();

        // init plugins
        $.each(self.__options.plugins, function (i, pluginName) {
          self._plug(pluginName);
        });

        // to detect swiping
        if (env.hasTouchCapability) {
          $(env.window.document.body).on('touchmove.' + self.__namespace + '-triggerOpen', function (event) {
            self._touchRecordEvent(event);
          });
        }
        self
        // prepare the tooltip when it gets created. This event must
        // be fired by a plugin
        ._on('created', function () {
          self.__prepareTooltip();
        })
        // save position information when it's sent by a plugin
        ._on('repositioned', function (e) {
          self.__lastPosition = e.position;
        });
      } else {
        self.__options.disabled = true;
      }
    },
    /**
     * Insert the content into the appropriate HTML element of the tooltip
     * 
     * @returns {self}
     * @private
     */
    __contentInsert: function () {
      var self = this,
        $el = self._$tooltip.find('.tooltipster-content'),
        formattedContent = self.__Content,
        format = function (content) {
          formattedContent = content;
        };
      self._trigger({
        type: 'format',
        content: self.__Content,
        format: format
      });
      if (self.__options.functionFormat) {
        formattedContent = self.__options.functionFormat.call(self, self, {
          origin: self._$origin[0]
        }, self.__Content);
      }
      if (typeof formattedContent === 'string' && !self.__options.contentAsHTML) {
        $el.text(formattedContent);
      } else {
        $el.empty().append(formattedContent);
      }
      return self;
    },
    /**
     * Save the content, cloning it beforehand if need be
     * 
     * @param content
     * @returns {self}
     * @private
     */
    __contentSet: function (content) {
      // clone if asked. Cloning the object makes sure that each instance has its
      // own version of the content (in case a same object were provided for several
      // instances)
      // reminder: typeof null === object
      if (content instanceof $ && this.__options.contentCloning) {
        content = content.clone(true);
      }
      this.__Content = content;
      this._trigger({
        type: 'updated',
        content: content
      });
      return this;
    },
    /**
     * Error message about a method call made after destruction
     * 
     * @private
     */
    __destroyError: function () {
      throw new Error('This tooltip has been destroyed and cannot execute your method call.');
    },
    /**
     * Gather all information about dimensions and available space,
     * called before every repositioning
     * 
     * @private
     * @returns {object}
     */
    __geometry: function () {
      var self = this,
        $target = self._$origin,
        originIsArea = self._$origin.is('area');

      // if this._$origin is a map area, the target we'll need
      // the dimensions of is actually the image using the map,
      // not the area itself
      if (originIsArea) {
        var mapName = self._$origin.parent().attr('name');
        $target = $('img[usemap="#' + mapName + '"]');
      }
      var bcr = $target[0].getBoundingClientRect(),
        $document = $(env.window.document),
        $window = $(env.window),
        $parent = $target,
        // some useful properties of important elements
        geo = {
          // available space for the tooltip, see down below
          available: {
            document: null,
            window: null
          },
          document: {
            size: {
              height: $document.height(),
              width: $document.width()
            }
          },
          window: {
            scroll: {
              // the second ones are for IE compatibility
              left: env.window.scrollX || env.window.document.documentElement.scrollLeft,
              top: env.window.scrollY || env.window.document.documentElement.scrollTop
            },
            size: {
              height: $window.height(),
              width: $window.width()
            }
          },
          origin: {
            // the origin has a fixed lineage if itself or one of its
            // ancestors has a fixed position
            fixedLineage: false,
            // relative to the document
            offset: {},
            size: {
              height: bcr.bottom - bcr.top,
              width: bcr.right - bcr.left
            },
            usemapImage: originIsArea ? $target[0] : null,
            // relative to the window
            windowOffset: {
              bottom: bcr.bottom,
              left: bcr.left,
              right: bcr.right,
              top: bcr.top
            }
          }
        },
        geoFixed = false;

      // if the element is a map area, some properties may need
      // to be recalculated
      if (originIsArea) {
        var shape = self._$origin.attr('shape'),
          coords = self._$origin.attr('coords');
        if (coords) {
          coords = coords.split(',');
          $.map(coords, function (val, i) {
            coords[i] = parseInt(val);
          });
        }

        // if the image itself is the area, nothing more to do
        if (shape != 'default') {
          switch (shape) {
            case 'circle':
              var circleCenterLeft = coords[0],
                circleCenterTop = coords[1],
                circleRadius = coords[2],
                areaTopOffset = circleCenterTop - circleRadius,
                areaLeftOffset = circleCenterLeft - circleRadius;
              geo.origin.size.height = circleRadius * 2;
              geo.origin.size.width = geo.origin.size.height;
              geo.origin.windowOffset.left += areaLeftOffset;
              geo.origin.windowOffset.top += areaTopOffset;
              break;
            case 'rect':
              var areaLeft = coords[0],
                areaTop = coords[1],
                areaRight = coords[2],
                areaBottom = coords[3];
              geo.origin.size.height = areaBottom - areaTop;
              geo.origin.size.width = areaRight - areaLeft;
              geo.origin.windowOffset.left += areaLeft;
              geo.origin.windowOffset.top += areaTop;
              break;
            case 'poly':
              var areaSmallestX = 0,
                areaSmallestY = 0,
                areaGreatestX = 0,
                areaGreatestY = 0,
                arrayAlternate = 'even';
              for (var i = 0; i < coords.length; i++) {
                var areaNumber = coords[i];
                if (arrayAlternate == 'even') {
                  if (areaNumber > areaGreatestX) {
                    areaGreatestX = areaNumber;
                    if (i === 0) {
                      areaSmallestX = areaGreatestX;
                    }
                  }
                  if (areaNumber < areaSmallestX) {
                    areaSmallestX = areaNumber;
                  }
                  arrayAlternate = 'odd';
                } else {
                  if (areaNumber > areaGreatestY) {
                    areaGreatestY = areaNumber;
                    if (i == 1) {
                      areaSmallestY = areaGreatestY;
                    }
                  }
                  if (areaNumber < areaSmallestY) {
                    areaSmallestY = areaNumber;
                  }
                  arrayAlternate = 'even';
                }
              }
              geo.origin.size.height = areaGreatestY - areaSmallestY;
              geo.origin.size.width = areaGreatestX - areaSmallestX;
              geo.origin.windowOffset.left += areaSmallestX;
              geo.origin.windowOffset.top += areaSmallestY;
              break;
          }
        }
      }

      // user callback through an event
      var edit = function (r) {
        geo.origin.size.height = r.height, geo.origin.windowOffset.left = r.left, geo.origin.windowOffset.top = r.top, geo.origin.size.width = r.width;
      };
      self._trigger({
        type: 'geometry',
        edit: edit,
        geometry: {
          height: geo.origin.size.height,
          left: geo.origin.windowOffset.left,
          top: geo.origin.windowOffset.top,
          width: geo.origin.size.width
        }
      });

      // calculate the remaining properties with what we got

      geo.origin.windowOffset.right = geo.origin.windowOffset.left + geo.origin.size.width;
      geo.origin.windowOffset.bottom = geo.origin.windowOffset.top + geo.origin.size.height;
      geo.origin.offset.left = geo.origin.windowOffset.left + geo.window.scroll.left;
      geo.origin.offset.top = geo.origin.windowOffset.top + geo.window.scroll.top;
      geo.origin.offset.bottom = geo.origin.offset.top + geo.origin.size.height;
      geo.origin.offset.right = geo.origin.offset.left + geo.origin.size.width;

      // the space that is available to display the tooltip relatively to the document
      geo.available.document = {
        bottom: {
          height: geo.document.size.height - geo.origin.offset.bottom,
          width: geo.document.size.width
        },
        left: {
          height: geo.document.size.height,
          width: geo.origin.offset.left
        },
        right: {
          height: geo.document.size.height,
          width: geo.document.size.width - geo.origin.offset.right
        },
        top: {
          height: geo.origin.offset.top,
          width: geo.document.size.width
        }
      };

      // the space that is available to display the tooltip relatively to the viewport
      // (the resulting values may be negative if the origin overflows the viewport)
      geo.available.window = {
        bottom: {
          // the inner max is here to make sure the available height is no bigger
          // than the viewport height (when the origin is off screen at the top).
          // The outer max just makes sure that the height is not negative (when
          // the origin overflows at the bottom).
          height: Math.max(geo.window.size.height - Math.max(geo.origin.windowOffset.bottom, 0), 0),
          width: geo.window.size.width
        },
        left: {
          height: geo.window.size.height,
          width: Math.max(geo.origin.windowOffset.left, 0)
        },
        right: {
          height: geo.window.size.height,
          width: Math.max(geo.window.size.width - Math.max(geo.origin.windowOffset.right, 0), 0)
        },
        top: {
          height: Math.max(geo.origin.windowOffset.top, 0),
          width: geo.window.size.width
        }
      };
      while ($parent[0].tagName.toLowerCase() != 'html') {
        if ($parent.css('position') == 'fixed') {
          geo.origin.fixedLineage = true;
          break;
        }
        $parent = $parent.parent();
      }
      return geo;
    },
    /**
     * Some options may need to be formated before being used
     * 
     * @returns {self}
     * @private
     */
    __optionsFormat: function () {
      if (typeof this.__options.animationDuration == 'number') {
        this.__options.animationDuration = [this.__options.animationDuration, this.__options.animationDuration];
      }
      if (typeof this.__options.delay == 'number') {
        this.__options.delay = [this.__options.delay, this.__options.delay];
      }
      if (typeof this.__options.delayTouch == 'number') {
        this.__options.delayTouch = [this.__options.delayTouch, this.__options.delayTouch];
      }
      if (typeof this.__options.theme == 'string') {
        this.__options.theme = [this.__options.theme];
      }

      // determine the future parent
      if (this.__options.parent === null) {
        this.__options.parent = $(env.window.document.body);
      } else if (typeof this.__options.parent == 'string') {
        this.__options.parent = $(this.__options.parent);
      }
      if (this.__options.trigger == 'hover') {
        this.__options.triggerOpen = {
          mouseenter: true,
          touchstart: true
        };
        this.__options.triggerClose = {
          mouseleave: true,
          originClick: true,
          touchleave: true
        };
      } else if (this.__options.trigger == 'click') {
        this.__options.triggerOpen = {
          click: true,
          tap: true
        };
        this.__options.triggerClose = {
          click: true,
          tap: true
        };
      }

      // for the plugins
      this._trigger('options');
      return this;
    },
    /**
     * Schedules or cancels the garbage collector task
     *
     * @returns {self}
     * @private
     */
    __prepareGC: function () {
      var self = this;

      // in case the selfDestruction option has been changed by a method call
      if (self.__options.selfDestruction) {
        // the GC task
        self.__garbageCollector = setInterval(function () {
          var now = new Date().getTime();

          // forget the old events
          self.__touchEvents = $.grep(self.__touchEvents, function (event, i) {
            // 1 minute
            return now - event.time > 60000;
          });

          // auto-destruct if the origin is gone
          if (!bodyContains(self._$origin)) {
            self.close(function () {
              self.destroy();
            });
          }
        }, 20000);
      } else {
        clearInterval(self.__garbageCollector);
      }
      return self;
    },
    /**
     * Sets listeners on the origin if the open triggers require them.
     * Unlike the listeners set at opening time, these ones
     * remain even when the tooltip is closed. It has been made a
     * separate method so it can be called when the triggers are
     * changed in the options. Closing is handled in _open()
     * because of the bindings that may be needed on the tooltip
     * itself
     *
     * @returns {self}
     * @private
     */
    __prepareOrigin: function () {
      var self = this;

      // in case we're resetting the triggers
      self._$origin.off('.' + self.__namespace + '-triggerOpen');

      // if the device is touch capable, even if only mouse triggers
      // are asked, we need to listen to touch events to know if the mouse
      // events are actually emulated (so we can ignore them)
      if (env.hasTouchCapability) {
        self._$origin.on('touchstart.' + self.__namespace + '-triggerOpen ' + 'touchend.' + self.__namespace + '-triggerOpen ' + 'touchcancel.' + self.__namespace + '-triggerOpen', function (event) {
          self._touchRecordEvent(event);
        });
      }

      // mouse click and touch tap work the same way
      if (self.__options.triggerOpen.click || self.__options.triggerOpen.tap && env.hasTouchCapability) {
        var eventNames = '';
        if (self.__options.triggerOpen.click) {
          eventNames += 'click.' + self.__namespace + '-triggerOpen ';
        }
        if (self.__options.triggerOpen.tap && env.hasTouchCapability) {
          eventNames += 'touchend.' + self.__namespace + '-triggerOpen';
        }
        self._$origin.on(eventNames, function (event) {
          if (self._touchIsMeaningfulEvent(event)) {
            self._open(event);
          }
        });
      }

      // mouseenter and touch start work the same way
      if (self.__options.triggerOpen.mouseenter || self.__options.triggerOpen.touchstart && env.hasTouchCapability) {
        var eventNames = '';
        if (self.__options.triggerOpen.mouseenter) {
          eventNames += 'mouseenter.' + self.__namespace + '-triggerOpen ';
        }
        if (self.__options.triggerOpen.touchstart && env.hasTouchCapability) {
          eventNames += 'touchstart.' + self.__namespace + '-triggerOpen';
        }
        self._$origin.on(eventNames, function (event) {
          if (self._touchIsTouchEvent(event) || !self._touchIsEmulatedEvent(event)) {
            self.__pointerIsOverOrigin = true;
            self._openShortly(event);
          }
        });
      }

      // info for the mouseleave/touchleave close triggers when they use a delay
      if (self.__options.triggerClose.mouseleave || self.__options.triggerClose.touchleave && env.hasTouchCapability) {
        var eventNames = '';
        if (self.__options.triggerClose.mouseleave) {
          eventNames += 'mouseleave.' + self.__namespace + '-triggerOpen ';
        }
        if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
          eventNames += 'touchend.' + self.__namespace + '-triggerOpen touchcancel.' + self.__namespace + '-triggerOpen';
        }
        self._$origin.on(eventNames, function (event) {
          if (self._touchIsMeaningfulEvent(event)) {
            self.__pointerIsOverOrigin = false;
          }
        });
      }
      return self;
    },
    /**
     * Do the things that need to be done only once after the tooltip
     * HTML element it has been created. It has been made a separate
     * method so it can be called when options are changed. Remember
     * that the tooltip may actually exist in the DOM before it is
     * opened, and present after it has been closed: it's the display
     * plugin that takes care of handling it.
     * 
     * @returns {self}
     * @private
     */
    __prepareTooltip: function () {
      var self = this,
        p = self.__options.interactive ? 'auto' : '';

      // this will be useful to know quickly if the tooltip is in
      // the DOM or not 
      self._$tooltip.attr('id', self.__namespace).css({
        // pointer events
        'pointer-events': p,
        zIndex: self.__options.zIndex
      });

      // themes
      // remove the old ones and add the new ones
      $.each(self.__previousThemes, function (i, theme) {
        self._$tooltip.removeClass(theme);
      });
      $.each(self.__options.theme, function (i, theme) {
        self._$tooltip.addClass(theme);
      });
      self.__previousThemes = $.merge([], self.__options.theme);
      return self;
    },
    /**
     * Handles the scroll on any of the parents of the origin (when the
     * tooltip is open)
     *
     * @param {object} event
     * @returns {self}
     * @private
     */
    __scrollHandler: function (event) {
      var self = this;
      if (self.__options.triggerClose.scroll) {
        self._close(event);
      } else {
        // if the origin or tooltip have been removed: do nothing, the tracker will
        // take care of it later
        if (bodyContains(self._$origin) && bodyContains(self._$tooltip)) {
          var geo = null;

          // if the scroll happened on the window
          if (event.target === env.window.document) {
            // if the origin has a fixed lineage, window scroll will have no
            // effect on its position nor on the position of the tooltip
            if (!self.__Geometry.origin.fixedLineage) {
              // we don't need to do anything unless repositionOnScroll is true
              // because the tooltip will already have moved with the window
              // (and of course with the origin)
              if (self.__options.repositionOnScroll) {
                self.reposition(event);
              }
            }
          }
          // if the scroll happened on another parent of the tooltip, it means
          // that it's in a scrollable area and now needs to have its position
          // adjusted or recomputed, depending ont the repositionOnScroll
          // option. Also, if the origin is partly hidden due to a parent that
          // hides its overflow, we'll just hide (not close) the tooltip.
          else {
            geo = self.__geometry();
            var overflows = false;

            // a fixed position origin is not affected by the overflow hiding
            // of a parent
            if (self._$origin.css('position') != 'fixed') {
              self.__$originParents.each(function (i, el) {
                var $el = $(el),
                  overflowX = $el.css('overflow-x'),
                  overflowY = $el.css('overflow-y');
                if (overflowX != 'visible' || overflowY != 'visible') {
                  var bcr = el.getBoundingClientRect();
                  if (overflowX != 'visible') {
                    if (geo.origin.windowOffset.left < bcr.left || geo.origin.windowOffset.right > bcr.right) {
                      overflows = true;
                      return false;
                    }
                  }
                  if (overflowY != 'visible') {
                    if (geo.origin.windowOffset.top < bcr.top || geo.origin.windowOffset.bottom > bcr.bottom) {
                      overflows = true;
                      return false;
                    }
                  }
                }

                // no need to go further if fixed, for the same reason as above
                if ($el.css('position') == 'fixed') {
                  return false;
                }
              });
            }
            if (overflows) {
              self._$tooltip.css('visibility', 'hidden');
            } else {
              self._$tooltip.css('visibility', 'visible');

              // reposition
              if (self.__options.repositionOnScroll) {
                self.reposition(event);
              }
              // or just adjust offset
              else {
                // we have to use offset and not windowOffset because this way,
                // only the scroll distance of the scrollable areas are taken into
                // account (the scrolltop value of the main window must be
                // ignored since the tooltip already moves with it)
                var offsetLeft = geo.origin.offset.left - self.__Geometry.origin.offset.left,
                  offsetTop = geo.origin.offset.top - self.__Geometry.origin.offset.top;

                // add the offset to the position initially computed by the display plugin
                self._$tooltip.css({
                  left: self.__lastPosition.coord.left + offsetLeft,
                  top: self.__lastPosition.coord.top + offsetTop
                });
              }
            }
          }
          self._trigger({
            type: 'scroll',
            event: event,
            geo: geo
          });
        }
      }
      return self;
    },
    /**
     * Changes the state of the tooltip
     *
     * @param {string} state
     * @returns {self}
     * @private
     */
    __stateSet: function (state) {
      this.__state = state;
      this._trigger({
        type: 'state',
        state: state
      });
      return this;
    },
    /**
     * Clear appearance timeouts
     *
     * @returns {self}
     * @private
     */
    __timeoutsClear: function () {
      // there is only one possible open timeout: the delayed opening
      // when the mouseenter/touchstart open triggers are used
      clearTimeout(this.__timeouts.open);
      this.__timeouts.open = null;

      // ... but several close timeouts: the delayed closing when the
      // mouseleave close trigger is used and the timer option
      $.each(this.__timeouts.close, function (i, timeout) {
        clearTimeout(timeout);
      });
      this.__timeouts.close = [];
      return this;
    },
    /**
     * Start the tracker that will make checks at regular intervals
     * 
     * @returns {self}
     * @private
     */
    __trackerStart: function () {
      var self = this,
        $content = self._$tooltip.find('.tooltipster-content');

      // get the initial content size
      if (self.__options.trackTooltip) {
        self.__contentBcr = $content[0].getBoundingClientRect();
      }
      self.__tracker = setInterval(function () {
        // if the origin or tooltip elements have been removed.
        // Note: we could destroy the instance now if the origin has
        // been removed but we'll leave that task to our garbage collector
        if (!bodyContains(self._$origin) || !bodyContains(self._$tooltip)) {
          self._close();
        }
        // if everything is alright
        else {
          // compare the former and current positions of the origin to reposition
          // the tooltip if need be
          if (self.__options.trackOrigin) {
            var g = self.__geometry(),
              identical = false;

            // compare size first (a change requires repositioning too)
            if (areEqual(g.origin.size, self.__Geometry.origin.size)) {
              // for elements that have a fixed lineage (see __geometry()), we track the
              // top and left properties (relative to window)
              if (self.__Geometry.origin.fixedLineage) {
                if (areEqual(g.origin.windowOffset, self.__Geometry.origin.windowOffset)) {
                  identical = true;
                }
              }
              // otherwise, track total offset (relative to document)
              else {
                if (areEqual(g.origin.offset, self.__Geometry.origin.offset)) {
                  identical = true;
                }
              }
            }
            if (!identical) {
              // close the tooltip when using the mouseleave close trigger
              // (see https://github.com/iamceege/tooltipster/pull/253)
              if (self.__options.triggerClose.mouseleave) {
                self._close();
              } else {
                self.reposition();
              }
            }
          }
          if (self.__options.trackTooltip) {
            var currentBcr = $content[0].getBoundingClientRect();
            if (currentBcr.height !== self.__contentBcr.height || currentBcr.width !== self.__contentBcr.width) {
              self.reposition();
              self.__contentBcr = currentBcr;
            }
          }
        }
      }, self.__options.trackerInterval);
      return self;
    },
    /**
     * Closes the tooltip (after the closing delay)
     * 
     * @param event
     * @param callback
     * @param force Set to true to override a potential refusal of the user's function
     * @returns {self}
     * @protected
     */
    _close: function (event, callback, force) {
      var self = this,
        ok = true;
      self._trigger({
        type: 'close',
        event: event,
        stop: function () {
          ok = false;
        }
      });

      // a destroying tooltip (force == true) may not refuse to close
      if (ok || force) {
        // save the method custom callback and cancel any open method custom callbacks
        if (callback) self.__callbacks.close.push(callback);
        self.__callbacks.open = [];

        // clear open/close timeouts
        self.__timeoutsClear();
        var finishCallbacks = function () {
          // trigger any close method custom callbacks and reset them
          $.each(self.__callbacks.close, function (i, c) {
            c.call(self, self, {
              event: event,
              origin: self._$origin[0]
            });
          });
          self.__callbacks.close = [];
        };
        if (self.__state != 'closed') {
          var necessary = true,
            d = new Date(),
            now = d.getTime(),
            newClosingTime = now + self.__options.animationDuration[1];

          // the tooltip may already already be disappearing, but if a new
          // call to close() is made after the animationDuration was changed
          // to 0 (for example), we ought to actually close it sooner than
          // previously scheduled. In that case it should be noted that the
          // browser will not adapt the animation duration to the new
          // animationDuration that was set after the start of the closing
          // animation.
          // Note: the same thing could be considered at opening, but is not
          // really useful since the tooltip is actually opened immediately
          // upon a call to _open(). Since it would not make the opening
          // animation finish sooner, its sole impact would be to trigger the
          // state event and the open callbacks sooner than the actual end of
          // the opening animation, which is not great.
          if (self.__state == 'disappearing') {
            if (newClosingTime > self.__closingTime
            // in case closing is actually overdue because the script
            // execution was suspended. See #679
            && self.__options.animationDuration[1] > 0) {
              necessary = false;
            }
          }
          if (necessary) {
            self.__closingTime = newClosingTime;
            if (self.__state != 'disappearing') {
              self.__stateSet('disappearing');
            }
            var finish = function () {
              // stop the tracker
              clearInterval(self.__tracker);

              // a "beforeClose" option has been asked several times but would
              // probably useless since the content element is still accessible
              // via ::content(), and because people can always use listeners
              // inside their content to track what's going on. For the sake of
              // simplicity, this has been denied. Bur for the rare people who
              // really need the option (for old browsers or for the case where
              // detaching the content is actually destructive, for file or
              // password inputs for example), this event will do the work.
              self._trigger({
                type: 'closing',
                event: event
              });

              // unbind listeners which are no longer needed

              self._$tooltip.off('.' + self.__namespace + '-triggerClose').removeClass('tooltipster-dying');

              // orientationchange, scroll and resize listeners
              $(env.window).off('.' + self.__namespace + '-triggerClose');

              // scroll listeners
              self.__$originParents.each(function (i, el) {
                $(el).off('scroll.' + self.__namespace + '-triggerClose');
              });
              // clear the array to prevent memory leaks
              self.__$originParents = null;
              $(env.window.document.body).off('.' + self.__namespace + '-triggerClose');
              self._$origin.off('.' + self.__namespace + '-triggerClose');
              self._off('dismissable');

              // a plugin that would like to remove the tooltip from the
              // DOM when closed should bind on this
              self.__stateSet('closed');

              // trigger event
              self._trigger({
                type: 'after',
                event: event
              });

              // call our constructor custom callback function
              if (self.__options.functionAfter) {
                self.__options.functionAfter.call(self, self, {
                  event: event,
                  origin: self._$origin[0]
                });
              }

              // call our method custom callbacks functions
              finishCallbacks();
            };
            if (env.hasTransitions) {
              self._$tooltip.css({
                '-moz-animation-duration': self.__options.animationDuration[1] + 'ms',
                '-ms-animation-duration': self.__options.animationDuration[1] + 'ms',
                '-o-animation-duration': self.__options.animationDuration[1] + 'ms',
                '-webkit-animation-duration': self.__options.animationDuration[1] + 'ms',
                'animation-duration': self.__options.animationDuration[1] + 'ms',
                'transition-duration': self.__options.animationDuration[1] + 'ms'
              });
              self._$tooltip
              // clear both potential open and close tasks
              .clearQueue().removeClass('tooltipster-show')
              // for transitions only
              .addClass('tooltipster-dying');
              if (self.__options.animationDuration[1] > 0) {
                self._$tooltip.delay(self.__options.animationDuration[1]);
              }
              self._$tooltip.queue(finish);
            } else {
              self._$tooltip.stop().fadeOut(self.__options.animationDuration[1], finish);
            }
          }
        }
        // if the tooltip is already closed, we still need to trigger
        // the method custom callbacks
        else {
          finishCallbacks();
        }
      }
      return self;
    },
    /**
     * For internal use by plugins, if needed
     * 
     * @returns {self}
     * @protected
     */
    _off: function () {
      this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
      return this;
    },
    /**
     * For internal use by plugins, if needed
     *
     * @returns {self}
     * @protected
     */
    _on: function () {
      this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
      return this;
    },
    /**
     * For internal use by plugins, if needed
     *
     * @returns {self}
     * @protected
     */
    _one: function () {
      this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
      return this;
    },
    /**
     * Opens the tooltip right away.
     *
     * @param event
     * @param callback Will be called when the opening animation is over
     * @returns {self}
     * @protected
     */
    _open: function (event, callback) {
      var self = this;

      // if the destruction process has not begun and if this was not
      // triggered by an unwanted emulated click event
      if (!self.__destroying) {
        // check that the origin is still in the DOM
        if (bodyContains(self._$origin)
        // if the tooltip is enabled
        && self.__enabled) {
          var ok = true;

          // if the tooltip is not open yet, we need to call functionBefore.
          // otherwise we can jst go on
          if (self.__state == 'closed') {
            // trigger an event. The event.stop function allows the callback
            // to prevent the opening of the tooltip
            self._trigger({
              type: 'before',
              event: event,
              stop: function () {
                ok = false;
              }
            });
            if (ok && self.__options.functionBefore) {
              // call our custom function before continuing
              ok = self.__options.functionBefore.call(self, self, {
                event: event,
                origin: self._$origin[0]
              });
            }
          }
          if (ok !== false) {
            // if there is some content
            if (self.__Content !== null) {
              // save the method callback and cancel close method callbacks
              if (callback) {
                self.__callbacks.open.push(callback);
              }
              self.__callbacks.close = [];

              // get rid of any appearance timeouts
              self.__timeoutsClear();
              var extraTime,
                finish = function () {
                  if (self.__state != 'stable') {
                    self.__stateSet('stable');
                  }

                  // trigger any open method custom callbacks and reset them
                  $.each(self.__callbacks.open, function (i, c) {
                    c.call(self, self, {
                      origin: self._$origin[0],
                      tooltip: self._$tooltip[0]
                    });
                  });
                  self.__callbacks.open = [];
                };

              // if the tooltip is already open
              if (self.__state !== 'closed') {
                // the timer (if any) will start (or restart) right now
                extraTime = 0;

                // if it was disappearing, cancel that
                if (self.__state === 'disappearing') {
                  self.__stateSet('appearing');
                  if (env.hasTransitions) {
                    self._$tooltip.clearQueue().removeClass('tooltipster-dying').addClass('tooltipster-show');
                    if (self.__options.animationDuration[0] > 0) {
                      self._$tooltip.delay(self.__options.animationDuration[0]);
                    }
                    self._$tooltip.queue(finish);
                  } else {
                    // in case the tooltip was currently fading out, bring it back
                    // to life
                    self._$tooltip.stop().fadeIn(finish);
                  }
                }
                // if the tooltip is already open, we still need to trigger the method
                // custom callback
                else if (self.__state == 'stable') {
                  finish();
                }
              }
              // if the tooltip isn't already open, open it
              else {
                // a plugin must bind on this and store the tooltip in this._$tooltip
                self.__stateSet('appearing');

                // the timer (if any) will start when the tooltip has fully appeared
                // after its transition
                extraTime = self.__options.animationDuration[0];

                // insert the content inside the tooltip
                self.__contentInsert();

                // reposition the tooltip and attach to the DOM
                self.reposition(event, true);

                // animate in the tooltip. If the display plugin wants no css
                // animations, it may override the animation option with a
                // dummy value that will produce no effect
                if (env.hasTransitions) {
                  // note: there seems to be an issue with start animations which
                  // are randomly not played on fast devices in both Chrome and FF,
                  // couldn't find a way to solve it yet. It seems that applying
                  // the classes before appending to the DOM helps a little, but
                  // it messes up some CSS transitions. The issue almost never
                  // happens when delay[0]==0 though
                  self._$tooltip.addClass('tooltipster-' + self.__options.animation).addClass('tooltipster-initial').css({
                    '-moz-animation-duration': self.__options.animationDuration[0] + 'ms',
                    '-ms-animation-duration': self.__options.animationDuration[0] + 'ms',
                    '-o-animation-duration': self.__options.animationDuration[0] + 'ms',
                    '-webkit-animation-duration': self.__options.animationDuration[0] + 'ms',
                    'animation-duration': self.__options.animationDuration[0] + 'ms',
                    'transition-duration': self.__options.animationDuration[0] + 'ms'
                  });
                  setTimeout(function () {
                    // a quick hover may have already triggered a mouseleave
                    if (self.__state != 'closed') {
                      self._$tooltip.addClass('tooltipster-show').removeClass('tooltipster-initial');
                      if (self.__options.animationDuration[0] > 0) {
                        self._$tooltip.delay(self.__options.animationDuration[0]);
                      }
                      self._$tooltip.queue(finish);
                    }
                  }, 0);
                } else {
                  // old browsers will have to live with this
                  self._$tooltip.css('display', 'none').fadeIn(self.__options.animationDuration[0], finish);
                }

                // checks if the origin is removed while the tooltip is open
                self.__trackerStart();

                // NOTE: the listeners below have a '-triggerClose' namespace
                // because we'll remove them when the tooltip closes (unlike
                // the '-triggerOpen' listeners). So some of them are actually
                // not about close triggers, rather about positioning.

                $(env.window)
                // reposition on resize
                .on('resize.' + self.__namespace + '-triggerClose', function (e) {
                  var $ae = $(document.activeElement);

                  // reposition only if the resize event was not triggered upon the opening
                  // of a virtual keyboard due to an input field being focused within the tooltip
                  // (otherwise the repositioning would lose the focus)
                  if (!$ae.is('input') && !$ae.is('textarea') || !$.contains(self._$tooltip[0], $ae[0])) {
                    self.reposition(e);
                  }
                })
                // same as below for parents
                .on('scroll.' + self.__namespace + '-triggerClose', function (e) {
                  self.__scrollHandler(e);
                });
                self.__$originParents = self._$origin.parents();

                // scrolling may require the tooltip to be moved or even
                // repositioned in some cases
                self.__$originParents.each(function (i, parent) {
                  $(parent).on('scroll.' + self.__namespace + '-triggerClose', function (e) {
                    self.__scrollHandler(e);
                  });
                });
                if (self.__options.triggerClose.mouseleave || self.__options.triggerClose.touchleave && env.hasTouchCapability) {
                  // we use an event to allow users/plugins to control when the mouseleave/touchleave
                  // close triggers will come to action. It allows to have more triggering elements
                  // than just the origin and the tooltip for example, or to cancel/delay the closing,
                  // or to make the tooltip interactive even if it wasn't when it was open, etc.
                  self._on('dismissable', function (event) {
                    if (event.dismissable) {
                      if (event.delay) {
                        timeout = setTimeout(function () {
                          // event.event may be undefined
                          self._close(event.event);
                        }, event.delay);
                        self.__timeouts.close.push(timeout);
                      } else {
                        self._close(event);
                      }
                    } else {
                      clearTimeout(timeout);
                    }
                  });

                  // now set the listeners that will trigger 'dismissable' events
                  var $elements = self._$origin,
                    eventNamesIn = '',
                    eventNamesOut = '',
                    timeout = null;

                  // if we have to allow interaction, bind on the tooltip too
                  if (self.__options.interactive) {
                    $elements = $elements.add(self._$tooltip);
                  }
                  if (self.__options.triggerClose.mouseleave) {
                    eventNamesIn += 'mouseenter.' + self.__namespace + '-triggerClose ';
                    eventNamesOut += 'mouseleave.' + self.__namespace + '-triggerClose ';
                  }
                  if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
                    eventNamesIn += 'touchstart.' + self.__namespace + '-triggerClose';
                    eventNamesOut += 'touchend.' + self.__namespace + '-triggerClose touchcancel.' + self.__namespace + '-triggerClose';
                  }
                  $elements
                  // close after some time spent outside of the elements
                  .on(eventNamesOut, function (event) {
                    // it's ok if the touch gesture ended up to be a swipe,
                    // it's still a "touch leave" situation
                    if (self._touchIsTouchEvent(event) || !self._touchIsEmulatedEvent(event)) {
                      var delay = event.type == 'mouseleave' ? self.__options.delay : self.__options.delayTouch;
                      self._trigger({
                        delay: delay[1],
                        dismissable: true,
                        event: event,
                        type: 'dismissable'
                      });
                    }
                  })
                  // suspend the mouseleave timeout when the pointer comes back
                  // over the elements
                  .on(eventNamesIn, function (event) {
                    // it's also ok if the touch event is a swipe gesture
                    if (self._touchIsTouchEvent(event) || !self._touchIsEmulatedEvent(event)) {
                      self._trigger({
                        dismissable: false,
                        event: event,
                        type: 'dismissable'
                      });
                    }
                  });
                }

                // close the tooltip when the origin gets a mouse click (common behavior of
                // native tooltips)
                if (self.__options.triggerClose.originClick) {
                  self._$origin.on('click.' + self.__namespace + '-triggerClose', function (event) {
                    // we could actually let a tap trigger this but this feature just
                    // does not make sense on touch devices
                    if (!self._touchIsTouchEvent(event) && !self._touchIsEmulatedEvent(event)) {
                      self._close(event);
                    }
                  });
                }

                // set the same bindings for click and touch on the body to close the tooltip
                if (self.__options.triggerClose.click || self.__options.triggerClose.tap && env.hasTouchCapability) {
                  // don't set right away since the click/tap event which triggered this method
                  // (if it was a click/tap) is going to bubble up to the body, we don't want it
                  // to close the tooltip immediately after it opened
                  setTimeout(function () {
                    if (self.__state != 'closed') {
                      var eventNames = '',
                        $body = $(env.window.document.body);
                      if (self.__options.triggerClose.click) {
                        eventNames += 'click.' + self.__namespace + '-triggerClose ';
                      }
                      if (self.__options.triggerClose.tap && env.hasTouchCapability) {
                        eventNames += 'touchend.' + self.__namespace + '-triggerClose';
                      }
                      $body.on(eventNames, function (event) {
                        if (self._touchIsMeaningfulEvent(event)) {
                          self._touchRecordEvent(event);
                          if (!self.__options.interactive || !$.contains(self._$tooltip[0], event.target)) {
                            self._close(event);
                          }
                        }
                      });

                      // needed to detect and ignore swiping
                      if (self.__options.triggerClose.tap && env.hasTouchCapability) {
                        $body.on('touchstart.' + self.__namespace + '-triggerClose', function (event) {
                          self._touchRecordEvent(event);
                        });
                      }
                    }
                  }, 0);
                }
                self._trigger('ready');

                // call our custom callback
                if (self.__options.functionReady) {
                  self.__options.functionReady.call(self, self, {
                    origin: self._$origin[0],
                    tooltip: self._$tooltip[0]
                  });
                }
              }

              // if we have a timer set, let the countdown begin
              if (self.__options.timer > 0) {
                var timeout = setTimeout(function () {
                  self._close();
                }, self.__options.timer + extraTime);
                self.__timeouts.close.push(timeout);
              }
            }
          }
        }
      }
      return self;
    },
    /**
     * When using the mouseenter/touchstart open triggers, this function will
     * schedule the opening of the tooltip after the delay, if there is one
     *
     * @param event
     * @returns {self}
     * @protected
    	 */
    _openShortly: function (event) {
      var self = this,
        ok = true;
      if (self.__state != 'stable' && self.__state != 'appearing') {
        // if a timeout is not already running
        if (!self.__timeouts.open) {
          self._trigger({
            type: 'start',
            event: event,
            stop: function () {
              ok = false;
            }
          });
          if (ok) {
            var delay = event.type.indexOf('touch') == 0 ? self.__options.delayTouch : self.__options.delay;
            if (delay[0]) {
              self.__timeouts.open = setTimeout(function () {
                self.__timeouts.open = null;

                // open only if the pointer (mouse or touch) is still over the origin.
                // The check on the "meaningful event" can only be made here, after some
                // time has passed (to know if the touch was a swipe or not)
                if (self.__pointerIsOverOrigin && self._touchIsMeaningfulEvent(event)) {
                  // signal that we go on
                  self._trigger('startend');
                  self._open(event);
                } else {
                  // signal that we cancel
                  self._trigger('startcancel');
                }
              }, delay[0]);
            } else {
              // signal that we go on
              self._trigger('startend');
              self._open(event);
            }
          }
        }
      }
      return self;
    },
    /**
     * Meant for plugins to get their options
     * 
     * @param {string} pluginName The name of the plugin that asks for its options
     * @param {object} defaultOptions The default options of the plugin
     * @returns {object} The options
     * @protected
     */
    _optionsExtract: function (pluginName, defaultOptions) {
      var self = this,
        options = $.extend(true, {}, defaultOptions);

      // if the plugin options were isolated in a property named after the
      // plugin, use them (prevents conflicts with other plugins)
      var pluginOptions = self.__options[pluginName];

      // if not, try to get them as regular options
      if (!pluginOptions) {
        pluginOptions = {};
        $.each(defaultOptions, function (optionName, value) {
          var o = self.__options[optionName];
          if (o !== undefined) {
            pluginOptions[optionName] = o;
          }
        });
      }

      // let's merge the default options and the ones that were provided. We'd want
      // to do a deep copy but not let jQuery merge arrays, so we'll do a shallow
      // extend on two levels, that will be enough if options are not more than 1
      // level deep
      $.each(options, function (optionName, value) {
        if (pluginOptions[optionName] !== undefined) {
          if (typeof value == 'object' && !(value instanceof Array) && value != null && typeof pluginOptions[optionName] == 'object' && !(pluginOptions[optionName] instanceof Array) && pluginOptions[optionName] != null) {
            $.extend(options[optionName], pluginOptions[optionName]);
          } else {
            options[optionName] = pluginOptions[optionName];
          }
        }
      });
      return options;
    },
    /**
     * Used at instantiation of the plugin, or afterwards by plugins that activate themselves
     * on existing instances
     * 
     * @param {object} pluginName
     * @returns {self}
     * @protected
     */
    _plug: function (pluginName) {
      var plugin = $.tooltipster._plugin(pluginName);
      if (plugin) {
        // if there is a constructor for instances
        if (plugin.instance) {
          // proxy non-private methods on the instance to allow new instance methods
          $.tooltipster.__bridge(plugin.instance, this, plugin.name);
        }
      } else {
        throw new Error('The "' + pluginName + '" plugin is not defined');
      }
      return this;
    },
    /**
     * This will return true if the event is a mouse event which was
     * emulated by the browser after a touch event. This allows us to
     * really dissociate mouse and touch triggers.
     * 
     * There is a margin of error if a real mouse event is fired right
     * after (within the delay shown below) a touch event on the same
     * element, but hopefully it should not happen often.
     * 
     * @returns {boolean}
     * @protected
     */
    _touchIsEmulatedEvent: function (event) {
      var isEmulated = false,
        now = new Date().getTime();
      for (var i = this.__touchEvents.length - 1; i >= 0; i--) {
        var e = this.__touchEvents[i];

        // delay, in milliseconds. It's supposed to be 300ms in
        // most browsers (350ms on iOS) to allow a double tap but
        // can be less (check out FastClick for more info)
        if (now - e.time < 500) {
          if (e.target === event.target) {
            isEmulated = true;
          }
        } else {
          break;
        }
      }
      return isEmulated;
    },
    /**
     * Returns false if the event was an emulated mouse event or
     * a touch event involved in a swipe gesture.
     * 
     * @param {object} event
     * @returns {boolean}
     * @protected
     */
    _touchIsMeaningfulEvent: function (event) {
      return this._touchIsTouchEvent(event) && !this._touchSwiped(event.target) || !this._touchIsTouchEvent(event) && !this._touchIsEmulatedEvent(event);
    },
    /**
     * Checks if an event is a touch event
     * 
     * @param {object} event
     * @returns {boolean}
     * @protected
     */
    _touchIsTouchEvent: function (event) {
      return event.type.indexOf('touch') == 0;
    },
    /**
     * Store touch events for a while to detect swiping and emulated mouse events
     * 
     * @param {object} event
     * @returns {self}
     * @protected
     */
    _touchRecordEvent: function (event) {
      if (this._touchIsTouchEvent(event)) {
        event.time = new Date().getTime();
        this.__touchEvents.push(event);
      }
      return this;
    },
    /**
     * Returns true if a swipe happened after the last touchstart event fired on
     * event.target.
     * 
     * We need to differentiate a swipe from a tap before we let the event open
     * or close the tooltip. A swipe is when a touchmove (scroll) event happens
     * on the body between the touchstart and the touchend events of an element.
     * 
     * @param {object} target The HTML element that may have triggered the swipe
     * @returns {boolean}
     * @protected
     */
    _touchSwiped: function (target) {
      var swiped = false;
      for (var i = this.__touchEvents.length - 1; i >= 0; i--) {
        var e = this.__touchEvents[i];
        if (e.type == 'touchmove') {
          swiped = true;
          break;
        } else if (e.type == 'touchstart' && target === e.target) {
          break;
        }
      }
      return swiped;
    },
    /**
     * Triggers an event on the instance emitters
     * 
     * @returns {self}
     * @protected
     */
    _trigger: function () {
      var args = Array.prototype.slice.apply(arguments);
      if (typeof args[0] == 'string') {
        args[0] = {
          type: args[0]
        };
      }

      // add properties to the event
      args[0].instance = this;
      args[0].origin = this._$origin ? this._$origin[0] : null;
      args[0].tooltip = this._$tooltip ? this._$tooltip[0] : null;

      // note: the order of emitters matters
      this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
      $.tooltipster._trigger.apply($.tooltipster, args);
      this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);
      return this;
    },
    /**
     * Deactivate a plugin on this instance
     * 
     * @returns {self}
     * @protected
     */
    _unplug: function (pluginName) {
      var self = this;

      // if the plugin has been activated on this instance
      if (self[pluginName]) {
        var plugin = $.tooltipster._plugin(pluginName);

        // if there is a constructor for instances
        if (plugin.instance) {
          // unbridge
          $.each(plugin.instance, function (methodName, fn) {
            // if the method exists (privates methods do not) and comes indeed from
            // this plugin (may be missing or come from a conflicting plugin).
            if (self[methodName] && self[methodName].bridged === self[pluginName]) {
              delete self[methodName];
            }
          });
        }

        // destroy the plugin
        if (self[pluginName].__destroy) {
          self[pluginName].__destroy();
        }

        // remove the reference to the plugin instance
        delete self[pluginName];
      }
      return self;
    },
    /**
     * @see self::_close
     * @returns {self}
     * @public
     */
    close: function (callback) {
      if (!this.__destroyed) {
        this._close(null, callback);
      } else {
        this.__destroyError();
      }
      return this;
    },
    /**
     * Sets or gets the content of the tooltip
     * 
     * @returns {mixed|self}
     * @public
     */
    content: function (content) {
      var self = this;

      // getter method
      if (content === undefined) {
        return self.__Content;
      }
      // setter method
      else {
        if (!self.__destroyed) {
          // change the content
          self.__contentSet(content);
          if (self.__Content !== null) {
            // update the tooltip if it is open
            if (self.__state !== 'closed') {
              // reset the content in the tooltip
              self.__contentInsert();

              // reposition and resize the tooltip
              self.reposition();

              // if we want to play a little animation showing the content changed
              if (self.__options.updateAnimation) {
                if (env.hasTransitions) {
                  // keep the reference in the local scope
                  var animation = self.__options.updateAnimation;
                  self._$tooltip.addClass('tooltipster-update-' + animation);

                  // remove the class after a while. The actual duration of the
                  // update animation may be shorter, it's set in the CSS rules
                  setTimeout(function () {
                    if (self.__state != 'closed') {
                      self._$tooltip.removeClass('tooltipster-update-' + animation);
                    }
                  }, 1000);
                } else {
                  self._$tooltip.fadeTo(200, 0.5, function () {
                    if (self.__state != 'closed') {
                      self._$tooltip.fadeTo(200, 1);
                    }
                  });
                }
              }
            }
          } else {
            self._close();
          }
        } else {
          self.__destroyError();
        }
        return self;
      }
    },
    /**
     * Destroys the tooltip
     * 
     * @returns {self}
     * @public
     */
    destroy: function () {
      var self = this;
      if (!self.__destroyed) {
        if (self.__state != 'closed') {
          // no closing delay
          self.option('animationDuration', 0)
          // force closing
          ._close(null, null, true);
        } else {
          // there might be an open timeout still running
          self.__timeoutsClear();
        }

        // send event
        self._trigger('destroy');
        self.__destroyed = true;
        self._$origin.removeData(self.__namespace)
        // remove the open trigger listeners
        .off('.' + self.__namespace + '-triggerOpen');

        // remove the touch listener
        $(env.window.document.body).off('.' + self.__namespace + '-triggerOpen');
        var ns = self._$origin.data('tooltipster-ns');

        // if the origin has been removed from DOM, its data may
        // well have been destroyed in the process and there would
        // be nothing to clean up or restore
        if (ns) {
          // if there are no more tooltips on this element
          if (ns.length === 1) {
            // optional restoration of a title attribute
            var title = null;
            if (self.__options.restoration == 'previous') {
              title = self._$origin.data('tooltipster-initialTitle');
            } else if (self.__options.restoration == 'current') {
              // old school technique to stringify when outerHTML is not supported
              title = typeof self.__Content == 'string' ? self.__Content : $('<div></div>').append(self.__Content).html();
            }
            if (title) {
              self._$origin.attr('title', title);
            }

            // final cleaning

            self._$origin.removeClass('tooltipstered');
            self._$origin.removeData('tooltipster-ns').removeData('tooltipster-initialTitle');
          } else {
            // remove the instance namespace from the list of namespaces of
            // tooltips present on the element
            ns = $.grep(ns, function (el, i) {
              return el !== self.__namespace;
            });
            self._$origin.data('tooltipster-ns', ns);
          }
        }

        // last event
        self._trigger('destroyed');

        // unbind private and public event listeners
        self._off();
        self.off();

        // remove external references, just in case
        self.__Content = null;
        self.__$emitterPrivate = null;
        self.__$emitterPublic = null;
        self.__options.parent = null;
        self._$origin = null;
        self._$tooltip = null;

        // make sure the object is no longer referenced in there to prevent
        // memory leaks
        $.tooltipster.__instancesLatestArr = $.grep($.tooltipster.__instancesLatestArr, function (el, i) {
          return self !== el;
        });
        clearInterval(self.__garbageCollector);
      } else {
        self.__destroyError();
      }

      // we return the scope rather than true so that the call to
      // .tooltipster('destroy') actually returns the matched elements
      // and applies to all of them
      return self;
    },
    /**
     * Disables the tooltip
     * 
     * @returns {self}
     * @public
     */
    disable: function () {
      if (!this.__destroyed) {
        // close first, in case the tooltip would not disappear on
        // its own (no close trigger)
        this._close();
        this.__enabled = false;
        return this;
      } else {
        this.__destroyError();
      }
      return this;
    },
    /**
     * Returns the HTML element of the origin
     *
     * @returns {self}
     * @public
     */
    elementOrigin: function () {
      if (!this.__destroyed) {
        return this._$origin[0];
      } else {
        this.__destroyError();
      }
    },
    /**
     * Returns the HTML element of the tooltip
     *
     * @returns {self}
     * @public
     */
    elementTooltip: function () {
      return this._$tooltip ? this._$tooltip[0] : null;
    },
    /**
     * Enables the tooltip
     * 
     * @returns {self}
     * @public
     */
    enable: function () {
      this.__enabled = true;
      return this;
    },
    /**
     * Alias, deprecated in 4.0.0
     * 
     * @param {function} callback
     * @returns {self}
     * @public
     */
    hide: function (callback) {
      return this.close(callback);
    },
    /**
     * Returns the instance
     * 
     * @returns {self}
     * @public
     */
    instance: function () {
      return this;
    },
    /**
     * For public use only, not to be used by plugins (use ::_off() instead)
     * 
     * @returns {self}
     * @public
     */
    off: function () {
      if (!this.__destroyed) {
        this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
      }
      return this;
    },
    /**
     * For public use only, not to be used by plugins (use ::_on() instead)
     *
     * @returns {self}
     * @public
     */
    on: function () {
      if (!this.__destroyed) {
        this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
      } else {
        this.__destroyError();
      }
      return this;
    },
    /**
     * For public use only, not to be used by plugins
     *
     * @returns {self}
     * @public
     */
    one: function () {
      if (!this.__destroyed) {
        this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
      } else {
        this.__destroyError();
      }
      return this;
    },
    /**
     * @see self::_open
     * @returns {self}
     * @public
     */
    open: function (callback) {
      if (!this.__destroyed) {
        this._open(null, callback);
      } else {
        this.__destroyError();
      }
      return this;
    },
    /**
     * Get or set options. For internal use and advanced users only.
     * 
     * @param {string} o Option name
     * @param {mixed} val optional A new value for the option
     * @return {mixed|self} If val is omitted, the value of the option
     * is returned, otherwise the instance itself is returned
     * @public
     */
    option: function (o, val) {
      // getter
      if (val === undefined) {
        return this.__options[o];
      }
      // setter
      else {
        if (!this.__destroyed) {
          // change value
          this.__options[o] = val;

          // format
          this.__optionsFormat();

          // re-prepare the triggers if needed
          if ($.inArray(o, ['trigger', 'triggerClose', 'triggerOpen']) >= 0) {
            this.__prepareOrigin();
          }
          if (o === 'selfDestruction') {
            this.__prepareGC();
          }
        } else {
          this.__destroyError();
        }
        return this;
      }
    },
    /**
     * This method is in charge of setting the position and size properties of the tooltip.
     * All the hard work is delegated to the display plugin.
     * Note: The tooltip may be detached from the DOM at the moment the method is called 
     * but must be attached by the end of the method call.
     * 
     * @param {object} event For internal use only. Defined if an event such as
     * window resizing triggered the repositioning
     * @param {boolean} tooltipIsDetached For internal use only. Set this to true if you
     * know that the tooltip not being in the DOM is not an issue (typically when the
     * tooltip element has just been created but has not been added to the DOM yet).
     * @returns {self}
     * @public
     */
    reposition: function (event, tooltipIsDetached) {
      var self = this;
      if (!self.__destroyed) {
        // if the tooltip is still open and the origin is still in the DOM
        if (self.__state != 'closed' && bodyContains(self._$origin)) {
          // if the tooltip has not been removed from DOM manually (or if it
          // has been detached on purpose)
          if (tooltipIsDetached || bodyContains(self._$tooltip)) {
            if (!tooltipIsDetached) {
              // detach in case the tooltip overflows the window and adds
              // scrollbars to it, so __geometry can be accurate
              self._$tooltip.detach();
            }

            // refresh the geometry object before passing it as a helper
            self.__Geometry = self.__geometry();

            // let a plugin fo the rest
            self._trigger({
              type: 'reposition',
              event: event,
              helper: {
                geo: self.__Geometry
              }
            });
          }
        }
      } else {
        self.__destroyError();
      }
      return self;
    },
    /**
     * Alias, deprecated in 4.0.0
     *
     * @param callback
     * @returns {self}
     * @public
     */
    show: function (callback) {
      return this.open(callback);
    },
    /**
     * Returns some properties about the instance
     * 
     * @returns {object}
     * @public
     */
    status: function () {
      return {
        destroyed: this.__destroyed,
        enabled: this.__enabled,
        open: this.__state !== 'closed',
        state: this.__state
      };
    },
    /**
     * For public use only, not to be used by plugins
     *
     * @returns {self}
     * @public
     */
    triggerHandler: function () {
      if (!this.__destroyed) {
        this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
      } else {
        this.__destroyError();
      }
      return this;
    }
  };
  $.fn.tooltipster = function () {
    // for using in closures
    var args = Array.prototype.slice.apply(arguments),
      // common mistake: an HTML element can't be in several tooltips at the same time
      contentCloningWarning = 'You are using a single HTML element as content for several tooltips. You probably want to set the contentCloning option to TRUE.';

    // this happens with $(sel).tooltipster(...) when $(sel) does not match anything
    if (this.length === 0) {
      // still chainable
      return this;
    }
    // this happens when calling $(sel).tooltipster('methodName or options')
    // where $(sel) matches one or more elements
    else {
      // method calls
      if (typeof args[0] === 'string') {
        var v = '#*$~&';
        this.each(function () {
          // retrieve the namepaces of the tooltip(s) that exist on that element.
          // We will interact with the first tooltip only.
          var ns = $(this).data('tooltipster-ns'),
            // self represents the instance of the first tooltipster plugin
            // associated to the current HTML object of the loop
            self = ns ? $(this).data(ns[0]) : null;

          // if the current element holds a tooltipster instance
          if (self) {
            if (typeof self[args[0]] === 'function') {
              if (this.length > 1 && args[0] == 'content' && (args[1] instanceof $ || typeof args[1] == 'object' && args[1] != null && args[1].tagName) && !self.__options.contentCloning && self.__options.debug) {
                console.log(contentCloningWarning);
              }

              // note : args[1] and args[2] may not be defined
              var resp = self[args[0]](args[1], args[2]);
            } else {
              throw new Error('Unknown method "' + args[0] + '"');
            }

            // if the function returned anything other than the instance
            // itself (which implies chaining, except for the `instance` method)
            if (resp !== self || args[0] === 'instance') {
              v = resp;

              // return false to stop .each iteration on the first element
              // matched by the selector
              return false;
            }
          } else {
            throw new Error('You called Tooltipster\'s "' + args[0] + '" method on an uninitialized element');
          }
        });
        return v !== '#*$~&' ? v : this;
      }
      // first argument is undefined or an object: the tooltip is initializing
      else {
        // reset the array of last initialized objects
        $.tooltipster.__instancesLatestArr = [];

        // is there a defined value for the multiple option in the options object ?
        var multipleIsSet = args[0] && args[0].multiple !== undefined,
          // if the multiple option is set to true, or if it's not defined but
          // set to true in the defaults
          multiple = multipleIsSet && args[0].multiple || !multipleIsSet && defaults.multiple,
          // same for content
          contentIsSet = args[0] && args[0].content !== undefined,
          content = contentIsSet && args[0].content || !contentIsSet && defaults.content,
          // same for contentCloning
          contentCloningIsSet = args[0] && args[0].contentCloning !== undefined,
          contentCloning = contentCloningIsSet && args[0].contentCloning || !contentCloningIsSet && defaults.contentCloning,
          // same for debug
          debugIsSet = args[0] && args[0].debug !== undefined,
          debug = debugIsSet && args[0].debug || !debugIsSet && defaults.debug;
        if (this.length > 1 && (content instanceof $ || typeof content == 'object' && content != null && content.tagName) && !contentCloning && debug) {
          console.log(contentCloningWarning);
        }

        // create a tooltipster instance for each element if it doesn't
        // already have one or if the multiple option is set, and attach the
        // object to it
        this.each(function () {
          var go = false,
            $this = $(this),
            ns = $this.data('tooltipster-ns'),
            obj = null;
          if (!ns) {
            go = true;
          } else if (multiple) {
            go = true;
          } else if (debug) {
            console.log('Tooltipster: one or more tooltips are already attached to the element below. Ignoring.');
            console.log(this);
          }
          if (go) {
            obj = new $.Tooltipster(this, args[0]);

            // save the reference of the new instance
            if (!ns) ns = [];
            ns.push(obj.__namespace);
            $this.data('tooltipster-ns', ns);

            // save the instance itself
            $this.data(obj.__namespace, obj);

            // call our constructor custom function.
            // we do this here and not in ::init() because we wanted
            // the object to be saved in $this.data before triggering
            // it
            if (obj.__options.functionInit) {
              obj.__options.functionInit.call(obj, obj, {
                origin: this
              });
            }

            // and now the event, for the plugins and core emitter
            obj._trigger('init');
          }
          $.tooltipster.__instancesLatestArr.push(obj);
        });
        return this;
      }
    }
  };

  // Utilities

  /**
   * A class to check if a tooltip can fit in given dimensions
   * 
   * @param {object} $tooltip The jQuery wrapped tooltip element, or a clone of it
   */
  function Ruler($tooltip) {
    // list of instance variables

    this.$container;
    this.constraints = null;
    this.__$tooltip;
    this.__init($tooltip);
  }
  Ruler.prototype = {
    /**
     * Move the tooltip into an invisible div that does not allow overflow to make
     * size tests. Note: the tooltip may or may not be attached to the DOM at the
     * moment this method is called, it does not matter.
     * 
     * @param {object} $tooltip The object to test. May be just a clone of the
     * actual tooltip.
     * @private
     */
    __init: function ($tooltip) {
      this.__$tooltip = $tooltip;
      this.__$tooltip.css({
        // for some reason we have to specify top and left 0
        left: 0,
        // any overflow will be ignored while measuring
        overflow: 'hidden',
        // positions at (0,0) without the div using 100% of the available width
        position: 'absolute',
        top: 0
      })
      // overflow must be auto during the test. We re-set this in case
      // it were modified by the user
      .find('.tooltipster-content').css('overflow', 'auto');
      this.$container = $('<div class="tooltipster-ruler"></div>').append(this.__$tooltip).appendTo(env.window.document.body);
    },
    /**
     * Force the browser to redraw (re-render) the tooltip immediately. This is required
     * when you changed some CSS properties and need to make something with it
     * immediately, without waiting for the browser to redraw at the end of instructions.
     *
     * @see http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
     * @private
     */
    __forceRedraw: function () {
      // note: this would work but for Webkit only
      //this.__$tooltip.close();
      //this.__$tooltip[0].offsetHeight;
      //this.__$tooltip.open();

      // works in FF too
      var $p = this.__$tooltip.parent();
      this.__$tooltip.detach();
      this.__$tooltip.appendTo($p);
    },
    /**
     * Set maximum dimensions for the tooltip. A call to ::measure afterwards
     * will tell us if the content overflows or if it's ok
     *
     * @param {int} width
     * @param {int} height
     * @return {Ruler}
     * @public
     */
    constrain: function (width, height) {
      this.constraints = {
        width: width,
        height: height
      };
      this.__$tooltip.css({
        // we disable display:flex, otherwise the content would overflow without
        // creating horizontal scrolling (which we need to detect).
        display: 'block',
        // reset any previous height
        height: '',
        // we'll check if horizontal scrolling occurs
        overflow: 'auto',
        // we'll set the width and see what height is generated and if there
        // is horizontal overflow
        width: width
      });
      return this;
    },
    /**
     * Reset the tooltip content overflow and remove the test container
     * 
     * @returns {Ruler}
     * @public
     */
    destroy: function () {
      // in case the element was not a clone
      this.__$tooltip.detach().find('.tooltipster-content').css({
        // reset to CSS value
        display: '',
        overflow: ''
      });
      this.$container.remove();
    },
    /**
     * Removes any constraints
     * 
     * @returns {Ruler}
     * @public
     */
    free: function () {
      this.constraints = null;

      // reset to natural size
      this.__$tooltip.css({
        display: '',
        height: '',
        overflow: 'visible',
        width: ''
      });
      return this;
    },
    /**
     * Returns the size of the tooltip. When constraints are applied, also returns
     * whether the tooltip fits in the provided dimensions.
     * The idea is to see if the new height is small enough and if the content does
     * not overflow horizontally.
     *
     * @param {int} width
     * @param {int} height
     * @returns {object} An object with a bool `fits` property and a `size` property
     * @public
     */
    measure: function () {
      this.__forceRedraw();
      var tooltipBcr = this.__$tooltip[0].getBoundingClientRect(),
        result = {
          size: {
            // bcr.width/height are not defined in IE8- but in this
            // case, bcr.right/bottom will have the same value
            // except in iOS 8+ where tooltipBcr.bottom/right are wrong
            // after scrolling for reasons yet to be determined.
            // tooltipBcr.top/left might not be 0, see issue #514
            height: tooltipBcr.height || tooltipBcr.bottom - tooltipBcr.top,
            width: tooltipBcr.width || tooltipBcr.right - tooltipBcr.left
          }
        };
      if (this.constraints) {
        // note: we used to use offsetWidth instead of boundingRectClient but
        // it returned rounded values, causing issues with sub-pixel layouts.

        // note2: noticed that the bcrWidth of text content of a div was once
        // greater than the bcrWidth of its container by 1px, causing the final
        // tooltip box to be too small for its content. However, evaluating
        // their widths one against the other (below) surprisingly returned
        // equality. Happened only once in Chrome 48, was not able to reproduce
        // => just having fun with float position values...

        var $content = this.__$tooltip.find('.tooltipster-content'),
          height = this.__$tooltip.outerHeight(),
          contentBcr = $content[0].getBoundingClientRect(),
          fits = {
            height: height <= this.constraints.height,
            width:
            // this condition accounts for min-width property that
            // may apply
            tooltipBcr.width <= this.constraints.width
            // the -1 is here because scrollWidth actually returns
            // a rounded value, and may be greater than bcr.width if
            // it was rounded up. This may cause an issue for contents
            // which actually really overflow  by 1px or so, but that
            // should be rare. Not sure how to solve this efficiently.
            // See http://blogs.msdn.com/b/ie/archive/2012/02/17/sub-pixel-rendering-and-the-css-object-model.aspx
            && contentBcr.width >= $content[0].scrollWidth - 1
          };
        result.fits = fits.height && fits.width;
      }

      // old versions of IE get the width wrong for some reason and it causes
      // the text to be broken to a new line, so we round it up. If the width
      // is the width of the screen though, we can assume it is accurate.
      if (env.IE && env.IE <= 11 && result.size.width !== env.window.document.documentElement.clientWidth) {
        result.size.width = Math.ceil(result.size.width) + 1;
      }
      return result;
    }
  };

  // quick & dirty compare function, not bijective nor multidimensional
  function areEqual(a, b) {
    var same = true;
    $.each(a, function (i, _) {
      if (b[i] === undefined || a[i] !== b[i]) {
        same = false;
        return false;
      }
    });
    return same;
  }

  /**
   * A fast function to check if an element is still in the DOM. It
   * tries to use an id as ids are indexed by the browser, or falls
   * back to jQuery's `contains` method. May fail if two elements
   * have the same id, but so be it
   *
   * @param {object} $obj A jQuery-wrapped HTML element
   * @return {boolean}
   */
  function bodyContains($obj) {
    var id = $obj.attr('id'),
      el = id ? env.window.document.getElementById(id) : null;
    // must also check that the element with the id is the one we want
    return el ? el === $obj[0] : $.contains(env.window.document.body, $obj[0]);
  }

  // detect IE versions for dirty fixes
  var uA = navigator.userAgent.toLowerCase();
  if (uA.indexOf('msie') != -1) env.IE = parseInt(uA.split('msie')[1]);else if (uA.toLowerCase().indexOf('trident') !== -1 && uA.indexOf(' rv:11') !== -1) env.IE = 11;else if (uA.toLowerCase().indexOf('edge/') != -1) env.IE = parseInt(uA.toLowerCase().split('edge/')[1]);

  // detecting support for CSS transitions
  function transitionSupport() {
    // env.window is not defined yet when this is called
    if (!win) return false;
    var b = win.document.body || win.document.documentElement,
      s = b.style,
      p = 'transition',
      v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];
    if (typeof s[p] == 'string') {
      return true;
    }
    p = p.charAt(0).toUpperCase() + p.substr(1);
    for (var i = 0; i < v.length; i++) {
      if (typeof s[v[i] + p] == 'string') {
        return true;
      }
    }
    return false;
  }

  // we'll return jQuery for plugins not to have to declare it as a dependency,
  // but it's done by a build task since it should be included only once at the
  // end when we concatenate the main file with a plugin
  // sideTip is Tooltipster's default plugin.
  // This file will be UMDified by a build task.

  var pluginName = 'tooltipster.sideTip';
  $.tooltipster._plugin({
    name: pluginName,
    instance: {
      /**
       * Defaults are provided as a function for an easy override by inheritance
       *
       * @return {object} An object with the defaults options
       * @private
       */
      __defaults: function () {
        return {
          // if the tooltip should display an arrow that points to the origin
          arrow: true,
          // the distance in pixels between the tooltip and the origin
          distance: 6,
          // allows to easily change the position of the tooltip
          functionPosition: null,
          maxWidth: null,
          // used to accomodate the arrow of tooltip if there is one.
          // First to make sure that the arrow target is not too close
          // to the edge of the tooltip, so the arrow does not overflow
          // the tooltip. Secondly when we reposition the tooltip to
          // make sure that it's positioned in such a way that the arrow is
          // still pointing at the target (and not a few pixels beyond it).
          // It should be equal to or greater than half the width of
          // the arrow (by width we mean the size of the side which touches
          // the side of the tooltip).
          minIntersection: 16,
          minWidth: 0,
          // deprecated in 4.0.0. Listed for _optionsExtract to pick it up
          position: null,
          side: 'top',
          // set to false to position the tooltip relatively to the document rather
          // than the window when we open it
          viewportAware: true
        };
      },
      /**
       * Run once: at instantiation of the plugin
       *
       * @param {object} instance The tooltipster object that instantiated this plugin
       * @private
       */
      __init: function (instance) {
        var self = this;

        // list of instance variables

        self.__instance = instance;
        self.__namespace = 'tooltipster-sideTip-' + Math.round(Math.random() * 1000000);
        self.__previousState = 'closed';
        self.__options;

        // initial formatting
        self.__optionsFormat();
        self.__instance._on('state.' + self.__namespace, function (event) {
          if (event.state == 'closed') {
            self.__close();
          } else if (event.state == 'appearing' && self.__previousState == 'closed') {
            self.__create();
          }
          self.__previousState = event.state;
        });

        // reformat every time the options are changed
        self.__instance._on('options.' + self.__namespace, function () {
          self.__optionsFormat();
        });
        self.__instance._on('reposition.' + self.__namespace, function (e) {
          self.__reposition(e.event, e.helper);
        });
      },
      /**
       * Called when the tooltip has closed
       * 
       * @private
       */
      __close: function () {
        // detach our content object first, so the next jQuery's remove()
        // call does not unbind its event handlers
        if (this.__instance.content() instanceof $) {
          this.__instance.content().detach();
        }

        // remove the tooltip from the DOM
        this.__instance._$tooltip.remove();
        this.__instance._$tooltip = null;
      },
      /**
       * Creates the HTML element of the tooltip.
       * 
       * @private
       */
      __create: function () {
        // note: we wrap with a .tooltipster-box div to be able to set a margin on it
        // (.tooltipster-base must not have one)
        var $html = $('<div class="tooltipster-base tooltipster-sidetip">' + '<div class="tooltipster-box">' + '<div class="tooltipster-content"></div>' + '</div>' + '<div class="tooltipster-arrow">' + '<div class="tooltipster-arrow-uncropped">' + '<div class="tooltipster-arrow-border"></div>' + '<div class="tooltipster-arrow-background"></div>' + '</div>' + '</div>' + '</div>');

        // hide arrow if asked
        if (!this.__options.arrow) {
          $html.find('.tooltipster-box').css('margin', 0).end().find('.tooltipster-arrow').hide();
        }

        // apply min/max width if asked
        if (this.__options.minWidth) {
          $html.css('min-width', this.__options.minWidth + 'px');
        }
        if (this.__options.maxWidth) {
          $html.css('max-width', this.__options.maxWidth + 'px');
        }
        this.__instance._$tooltip = $html;

        // tell the instance that the tooltip element has been created
        this.__instance._trigger('created');
      },
      /**
       * Used when the plugin is to be unplugged
       *
       * @private
       */
      __destroy: function () {
        this.__instance._off('.' + self.__namespace);
      },
      /**
       * (Re)compute this.__options from the options declared to the instance
       *
       * @private
       */
      __optionsFormat: function () {
        var self = this;

        // get the options
        self.__options = self.__instance._optionsExtract(pluginName, self.__defaults());

        // for backward compatibility, deprecated in v4.0.0
        if (self.__options.position) {
          self.__options.side = self.__options.position;
        }

        // options formatting

        // format distance as a four-cell array if it ain't one yet and then make
        // it an object with top/bottom/left/right properties
        if (typeof self.__options.distance != 'object') {
          self.__options.distance = [self.__options.distance];
        }
        if (self.__options.distance.length < 4) {
          if (self.__options.distance[1] === undefined) self.__options.distance[1] = self.__options.distance[0];
          if (self.__options.distance[2] === undefined) self.__options.distance[2] = self.__options.distance[0];
          if (self.__options.distance[3] === undefined) self.__options.distance[3] = self.__options.distance[1];
        }
        self.__options.distance = {
          top: self.__options.distance[0],
          right: self.__options.distance[1],
          bottom: self.__options.distance[2],
          left: self.__options.distance[3]
        };

        // let's transform:
        // 'top' into ['top', 'bottom', 'right', 'left']
        // 'right' into ['right', 'left', 'top', 'bottom']
        // 'bottom' into ['bottom', 'top', 'right', 'left']
        // 'left' into ['left', 'right', 'top', 'bottom']
        if (typeof self.__options.side == 'string') {
          var opposites = {
            'top': 'bottom',
            'right': 'left',
            'bottom': 'top',
            'left': 'right'
          };
          self.__options.side = [self.__options.side, opposites[self.__options.side]];
          if (self.__options.side[0] == 'left' || self.__options.side[0] == 'right') {
            self.__options.side.push('top', 'bottom');
          } else {
            self.__options.side.push('right', 'left');
          }
        }

        // misc
        // disable the arrow in IE6 unless the arrow option was explicitly set to true
        if ($.tooltipster._env.IE === 6 && self.__options.arrow !== true) {
          self.__options.arrow = false;
        }
      },
      /**
       * This method must compute and set the positioning properties of the
       * tooltip (left, top, width, height, etc.). It must also make sure the
       * tooltip is eventually appended to its parent (since the element may be
       * detached from the DOM at the moment the method is called).
       *
       * We'll evaluate positioning scenarios to find which side can contain the
       * tooltip in the best way. We'll consider things relatively to the window
       * (unless the user asks not to), then to the document (if need be, or if the
       * user explicitly requires the tests to run on the document). For each
       * scenario, measures are taken, allowing us to know how well the tooltip
       * is going to fit. After that, a sorting function will let us know what
       * the best scenario is (we also allow the user to choose his favorite
       * scenario by using an event).
       * 
       * @param {object} helper An object that contains variables that plugin
       * creators may find useful (see below)
       * @param {object} helper.geo An object with many layout properties
       * about objects of interest (window, document, origin). This should help
       * plugin users compute the optimal position of the tooltip
       * @private
       */
      __reposition: function (event, helper) {
        var self = this,
          finalResult,
          // to know where to put the tooltip, we need to know on which point
          // of the x or y axis we should center it. That coordinate is the target
          targets = self.__targetFind(helper),
          testResults = [];

        // make sure the tooltip is detached while we make tests on a clone
        self.__instance._$tooltip.detach();

        // we could actually provide the original element to the Ruler and
        // not a clone, but it just feels right to keep it out of the
        // machinery.
        var $clone = self.__instance._$tooltip.clone(),
          // start position tests session
          ruler = $.tooltipster._getRuler($clone),
          satisfied = false,
          animation = self.__instance.option('animation');

        // an animation class could contain properties that distort the size
        if (animation) {
          $clone.removeClass('tooltipster-' + animation);
        }

        // start evaluating scenarios
        $.each(['window', 'document'], function (i, container) {
          var takeTest = null;

          // let the user decide to keep on testing or not
          self.__instance._trigger({
            container: container,
            helper: helper,
            satisfied: satisfied,
            takeTest: function (bool) {
              takeTest = bool;
            },
            results: testResults,
            type: 'positionTest'
          });
          if (takeTest == true || takeTest != false && satisfied == false
          // skip the window scenarios if asked. If they are reintegrated by
          // the callback of the positionTest event, they will have to be
          // excluded using the callback of positionTested
          && (container != 'window' || self.__options.viewportAware)) {
            // for each allowed side
            for (var i = 0; i < self.__options.side.length; i++) {
              var distance = {
                  horizontal: 0,
                  vertical: 0
                },
                side = self.__options.side[i];
              if (side == 'top' || side == 'bottom') {
                distance.vertical = self.__options.distance[side];
              } else {
                distance.horizontal = self.__options.distance[side];
              }

              // this may have an effect on the size of the tooltip if there are css
              // rules for the arrow or something else
              self.__sideChange($clone, side);
              $.each(['natural', 'constrained'], function (i, mode) {
                takeTest = null;

                // emit an event on the instance
                self.__instance._trigger({
                  container: container,
                  event: event,
                  helper: helper,
                  mode: mode,
                  results: testResults,
                  satisfied: satisfied,
                  side: side,
                  takeTest: function (bool) {
                    takeTest = bool;
                  },
                  type: 'positionTest'
                });
                if (takeTest == true || takeTest != false && satisfied == false) {
                  var testResult = {
                    container: container,
                    // we let the distance as an object here, it can make things a little easier
                    // during the user's calculations at positionTest/positionTested
                    distance: distance,
                    // whether the tooltip can fit in the size of the viewport (does not mean
                    // that we'll be able to make it initially entirely visible, see 'whole')
                    fits: null,
                    mode: mode,
                    outerSize: null,
                    side: side,
                    size: null,
                    target: targets[side],
                    // check if the origin has enough surface on screen for the tooltip to
                    // aim at it without overflowing the viewport (this is due to the thickness
                    // of the arrow represented by the minIntersection length).
                    // If not, the tooltip will have to be partly or entirely off screen in
                    // order to stay docked to the origin. This value will stay null when the
                    // container is the document, as it is not relevant
                    whole: null
                  };

                  // get the size of the tooltip with or without size constraints
                  var rulerConfigured = mode == 'natural' ? ruler.free() : ruler.constrain(helper.geo.available[container][side].width - distance.horizontal, helper.geo.available[container][side].height - distance.vertical),
                    rulerResults = rulerConfigured.measure();
                  testResult.size = rulerResults.size;
                  testResult.outerSize = {
                    height: rulerResults.size.height + distance.vertical,
                    width: rulerResults.size.width + distance.horizontal
                  };
                  if (mode == 'natural') {
                    if (helper.geo.available[container][side].width >= testResult.outerSize.width && helper.geo.available[container][side].height >= testResult.outerSize.height) {
                      testResult.fits = true;
                    } else {
                      testResult.fits = false;
                    }
                  } else {
                    testResult.fits = rulerResults.fits;
                  }
                  if (container == 'window') {
                    if (!testResult.fits) {
                      testResult.whole = false;
                    } else {
                      if (side == 'top' || side == 'bottom') {
                        testResult.whole = helper.geo.origin.windowOffset.right >= self.__options.minIntersection && helper.geo.window.size.width - helper.geo.origin.windowOffset.left >= self.__options.minIntersection;
                      } else {
                        testResult.whole = helper.geo.origin.windowOffset.bottom >= self.__options.minIntersection && helper.geo.window.size.height - helper.geo.origin.windowOffset.top >= self.__options.minIntersection;
                      }
                    }
                  }
                  testResults.push(testResult);

                  // we don't need to compute more positions if we have one fully on screen
                  if (testResult.whole) {
                    satisfied = true;
                  } else {
                    // don't run the constrained test unless the natural width was greater
                    // than the available width, otherwise it's pointless as we know it
                    // wouldn't fit either
                    if (testResult.mode == 'natural' && (testResult.fits || testResult.size.width <= helper.geo.available[container][side].width)) {
                      return false;
                    }
                  }
                }
              });
            }
          }
        });

        // the user may eliminate the unwanted scenarios from testResults, but he's
        // not supposed to alter them at this point. functionPosition and the
        // position event serve that purpose.
        self.__instance._trigger({
          edit: function (r) {
            testResults = r;
          },
          event: event,
          helper: helper,
          results: testResults,
          type: 'positionTested'
        });

        /**
         * Sort the scenarios to find the favorite one.
         * 
         * The favorite scenario is when we can fully display the tooltip on screen,
         * even if it means that the middle of the tooltip is no longer centered on
         * the middle of the origin (when the origin is near the edge of the screen
         * or even partly off screen). We want the tooltip on the preferred side,
         * even if it means that we have to use a constrained size rather than a
         * natural one (as long as it fits). When the origin is off screen at the top
         * the tooltip will be positioned at the bottom (if allowed), if the origin
         * is off screen on the right, it will be positioned on the left, etc.
         * If there are no scenarios where the tooltip can fit on screen, or if the
         * user does not want the tooltip to fit on screen (viewportAware == false),
         * we fall back to the scenarios relative to the document.
         * 
         * When the tooltip is bigger than the viewport in either dimension, we stop
         * looking at the window scenarios and consider the document scenarios only,
         * with the same logic to find on which side it would fit best.
         * 
         * If the tooltip cannot fit the document on any side, we force it at the
         * bottom, so at least the user can scroll to see it.
        	 */
        testResults.sort(function (a, b) {
          // best if it's whole (the tooltip fits and adapts to the viewport)
          if (a.whole && !b.whole) {
            return -1;
          } else if (!a.whole && b.whole) {
            return 1;
          } else if (a.whole && b.whole) {
            var ai = self.__options.side.indexOf(a.side),
              bi = self.__options.side.indexOf(b.side);

            // use the user's sides fallback array
            if (ai < bi) {
              return -1;
            } else if (ai > bi) {
              return 1;
            } else {
              // will be used if the user forced the tests to continue
              return a.mode == 'natural' ? -1 : 1;
            }
          } else {
            // better if it fits
            if (a.fits && !b.fits) {
              return -1;
            } else if (!a.fits && b.fits) {
              return 1;
            } else if (a.fits && b.fits) {
              var ai = self.__options.side.indexOf(a.side),
                bi = self.__options.side.indexOf(b.side);

              // use the user's sides fallback array
              if (ai < bi) {
                return -1;
              } else if (ai > bi) {
                return 1;
              } else {
                // will be used if the user forced the tests to continue
                return a.mode == 'natural' ? -1 : 1;
              }
            } else {
              // if everything failed, this will give a preference to the case where
              // the tooltip overflows the document at the bottom
              if (a.container == 'document' && a.side == 'bottom' && a.mode == 'natural') {
                return -1;
              } else {
                return 1;
              }
            }
          }
        });
        finalResult = testResults[0];

        // now let's find the coordinates of the tooltip relatively to the window
        finalResult.coord = {};
        switch (finalResult.side) {
          case 'left':
          case 'right':
            finalResult.coord.top = Math.floor(finalResult.target - finalResult.size.height / 2);
            break;
          case 'bottom':
          case 'top':
            finalResult.coord.left = Math.floor(finalResult.target - finalResult.size.width / 2);
            break;
        }
        switch (finalResult.side) {
          case 'left':
            finalResult.coord.left = helper.geo.origin.windowOffset.left - finalResult.outerSize.width;
            break;
          case 'right':
            finalResult.coord.left = helper.geo.origin.windowOffset.right + finalResult.distance.horizontal;
            break;
          case 'top':
            finalResult.coord.top = helper.geo.origin.windowOffset.top - finalResult.outerSize.height;
            break;
          case 'bottom':
            finalResult.coord.top = helper.geo.origin.windowOffset.bottom + finalResult.distance.vertical;
            break;
        }

        // if the tooltip can potentially be contained within the viewport dimensions
        // and that we are asked to make it fit on screen
        if (finalResult.container == 'window') {
          // if the tooltip overflows the viewport, we'll move it accordingly (then it will
          // not be centered on the middle of the origin anymore). We only move horizontally
          // for top and bottom tooltips and vice versa.
          if (finalResult.side == 'top' || finalResult.side == 'bottom') {
            // if there is an overflow on the left
            if (finalResult.coord.left < 0) {
              // prevent the overflow unless the origin itself gets off screen (minus the
              // margin needed to keep the arrow pointing at the target)
              if (helper.geo.origin.windowOffset.right - this.__options.minIntersection >= 0) {
                finalResult.coord.left = 0;
              } else {
                finalResult.coord.left = helper.geo.origin.windowOffset.right - this.__options.minIntersection - 1;
              }
            }
            // or an overflow on the right
            else if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {
              if (helper.geo.origin.windowOffset.left + this.__options.minIntersection <= helper.geo.window.size.width) {
                finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
              } else {
                finalResult.coord.left = helper.geo.origin.windowOffset.left + this.__options.minIntersection + 1 - finalResult.size.width;
              }
            }
          } else {
            // overflow at the top
            if (finalResult.coord.top < 0) {
              if (helper.geo.origin.windowOffset.bottom - this.__options.minIntersection >= 0) {
                finalResult.coord.top = 0;
              } else {
                finalResult.coord.top = helper.geo.origin.windowOffset.bottom - this.__options.minIntersection - 1;
              }
            }
            // or at the bottom
            else if (finalResult.coord.top > helper.geo.window.size.height - finalResult.size.height) {
              if (helper.geo.origin.windowOffset.top + this.__options.minIntersection <= helper.geo.window.size.height) {
                finalResult.coord.top = helper.geo.window.size.height - finalResult.size.height;
              } else {
                finalResult.coord.top = helper.geo.origin.windowOffset.top + this.__options.minIntersection + 1 - finalResult.size.height;
              }
            }
          }
        } else {
          // there might be overflow here too but it's easier to handle. If there has
          // to be an overflow, we'll make sure it's on the right side of the screen
          // (because the browser will extend the document size if there is an overflow
          // on the right, but not on the left). The sort function above has already
          // made sure that a bottom document overflow is preferred to a top overflow,
          // so we don't have to care about it.

          // if there is an overflow on the right
          if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {
            // this may actually create on overflow on the left but we'll fix it in a sec
            finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
          }

          // if there is an overflow on the left
          if (finalResult.coord.left < 0) {
            // don't care if it overflows the right after that, we made our best
            finalResult.coord.left = 0;
          }
        }

        // submit the positioning proposal to the user function which may choose to change
        // the side, size and/or the coordinates

        // first, set the rules that corresponds to the proposed side: it may change
        // the size of the tooltip, and the custom functionPosition may want to detect the
        // size of something before making a decision. So let's make things easier for the
        // implementor
        self.__sideChange($clone, finalResult.side);

        // add some variables to the helper
        helper.tooltipClone = $clone[0];
        helper.tooltipParent = self.__instance.option('parent').parent[0];
        // move informative values to the helper
        helper.mode = finalResult.mode;
        helper.whole = finalResult.whole;
        // add some variables to the helper for the functionPosition callback (these
        // will also be added to the event fired by self.__instance._trigger but that's
        // ok, we're just being consistent)
        helper.origin = self.__instance._$origin[0];
        helper.tooltip = self.__instance._$tooltip[0];

        // leave only the actionable values in there for functionPosition
        delete finalResult.container;
        delete finalResult.fits;
        delete finalResult.mode;
        delete finalResult.outerSize;
        delete finalResult.whole;

        // keep only the distance on the relevant side, for clarity
        finalResult.distance = finalResult.distance.horizontal || finalResult.distance.vertical;

        // beginners may not be comfortable with the concept of editing the object
        //  passed by reference, so we provide an edit function and pass a clone
        var finalResultClone = $.extend(true, {}, finalResult);

        // emit an event on the instance
        self.__instance._trigger({
          edit: function (result) {
            finalResult = result;
          },
          event: event,
          helper: helper,
          position: finalResultClone,
          type: 'position'
        });
        if (self.__options.functionPosition) {
          var result = self.__options.functionPosition.call(self, self.__instance, helper, finalResultClone);
          if (result) finalResult = result;
        }

        // end the positioning tests session (the user might have had a
        // use for it during the position event, now it's over)
        ruler.destroy();

        // compute the position of the target relatively to the tooltip root
        // element so we can place the arrow and make the needed adjustments
        var arrowCoord, maxVal;
        if (finalResult.side == 'top' || finalResult.side == 'bottom') {
          arrowCoord = {
            prop: 'left',
            val: finalResult.target - finalResult.coord.left
          };
          maxVal = finalResult.size.width - this.__options.minIntersection;
        } else {
          arrowCoord = {
            prop: 'top',
            val: finalResult.target - finalResult.coord.top
          };
          maxVal = finalResult.size.height - this.__options.minIntersection;
        }

        // cannot lie beyond the boundaries of the tooltip, minus the
        // arrow margin
        if (arrowCoord.val < this.__options.minIntersection) {
          arrowCoord.val = this.__options.minIntersection;
        } else if (arrowCoord.val > maxVal) {
          arrowCoord.val = maxVal;
        }
        var originParentOffset;

        // let's convert the window-relative coordinates into coordinates relative to the
        // future positioned parent that the tooltip will be appended to
        if (helper.geo.origin.fixedLineage) {
          // same as windowOffset when the position is fixed
          originParentOffset = helper.geo.origin.windowOffset;
        } else {
          // this assumes that the parent of the tooltip is located at
          // (0, 0) in the document, typically like when the parent is
          // <body>.
          // If we ever allow other types of parent, .tooltipster-ruler
          // will have to be appended to the parent to inherit css style
          // values that affect the display of the text and such.
          originParentOffset = {
            left: helper.geo.origin.windowOffset.left + helper.geo.window.scroll.left,
            top: helper.geo.origin.windowOffset.top + helper.geo.window.scroll.top
          };
        }
        finalResult.coord = {
          left: originParentOffset.left + (finalResult.coord.left - helper.geo.origin.windowOffset.left),
          top: originParentOffset.top + (finalResult.coord.top - helper.geo.origin.windowOffset.top)
        };

        // set position values on the original tooltip element

        self.__sideChange(self.__instance._$tooltip, finalResult.side);
        if (helper.geo.origin.fixedLineage) {
          self.__instance._$tooltip.css('position', 'fixed');
        } else {
          // CSS default
          self.__instance._$tooltip.css('position', '');
        }
        self.__instance._$tooltip.css({
          left: finalResult.coord.left,
          top: finalResult.coord.top,
          // we need to set a size even if the tooltip is in its natural size
          // because when the tooltip is positioned beyond the width of the body
          // (which is by default the width of the window; it will happen when
          // you scroll the window horizontally to get to the origin), its text
          // content will otherwise break lines at each word to keep up with the
          // body overflow strategy.
          height: finalResult.size.height,
          width: finalResult.size.width
        }).find('.tooltipster-arrow').css({
          'left': '',
          'top': ''
        }).css(arrowCoord.prop, arrowCoord.val);

        // append the tooltip HTML element to its parent
        self.__instance._$tooltip.appendTo(self.__instance.option('parent'));
        self.__instance._trigger({
          type: 'repositioned',
          event: event,
          position: finalResult
        });
      },
      /**
       * Make whatever modifications are needed when the side is changed. This has
       * been made an independant method for easy inheritance in custom plugins based
       * on this default plugin.
       *
       * @param {object} $obj
       * @param {string} side
       * @private
       */
      __sideChange: function ($obj, side) {
        $obj.removeClass('tooltipster-bottom').removeClass('tooltipster-left').removeClass('tooltipster-right').removeClass('tooltipster-top').addClass('tooltipster-' + side);
      },
      /**
       * Returns the target that the tooltip should aim at for a given side.
       * The calculated value is a distance from the edge of the window
       * (left edge for top/bottom sides, top edge for left/right side). The
       * tooltip will be centered on that position and the arrow will be
       * positioned there (as much as possible).
       *
       * @param {object} helper
       * @return {integer}
       * @private
       */
      __targetFind: function (helper) {
        var target = {},
          rects = this.__instance._$origin[0].getClientRects();

        // these lines fix a Chrome bug (issue #491)
        if (rects.length > 1) {
          var opacity = this.__instance._$origin.css('opacity');
          if (opacity == 1) {
            this.__instance._$origin.css('opacity', 0.99);
            rects = this.__instance._$origin[0].getClientRects();
            this.__instance._$origin.css('opacity', 1);
          }
        }

        // by default, the target will be the middle of the origin
        if (rects.length < 2) {
          target.top = Math.floor(helper.geo.origin.windowOffset.left + helper.geo.origin.size.width / 2);
          target.bottom = target.top;
          target.left = Math.floor(helper.geo.origin.windowOffset.top + helper.geo.origin.size.height / 2);
          target.right = target.left;
        }
        // if multiple client rects exist, the element may be text split
        // up into multiple lines and the middle of the origin may not be
        // best option anymore. We need to choose the best target client rect
        else {
          // top: the first
          var targetRect = rects[0];
          target.top = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);

          // right: the middle line, rounded down in case there is an even
          // number of lines (looks more centered => check out the
          // demo with 4 split lines)
          if (rects.length > 2) {
            targetRect = rects[Math.ceil(rects.length / 2) - 1];
          } else {
            targetRect = rects[0];
          }
          target.right = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);

          // bottom: the last
          targetRect = rects[rects.length - 1];
          target.bottom = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);

          // left: the middle line, rounded up
          if (rects.length > 2) {
            targetRect = rects[Math.ceil((rects.length + 1) / 2) - 1];
          } else {
            targetRect = rects[rects.length - 1];
          }
          target.left = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);
        }
        return target;
      }
    }
  });

  /* a build task will add "return $;" here */
  return $;
});

/***/ }),

/***/ "./scripts/3rdparty/tooltipster/tooltipster-scrollableTip.js":
/*!*******************************************************************!*\
  !*** ./scripts/3rdparty/tooltipster/tooltipster-scrollableTip.js ***!
  \*******************************************************************/
/***/ (function() {

/**
 * tooltipster-scrollableTip v1.0.0
 * https://github.com/louisameline/tooltipster-scrollableTip/
 * Developed by Louis Ameline
 * MIT license
 */
(function (root, factory) {
  // if (typeof define === 'function' && define.amd) {
  // 	// AMD. Register as an anonymous module unless amdModuleId is set
  // 	define(['tooltipster'], function ($) {
  // 		return (factory($));
  // 	});
  // }
  // else if (typeof exports === 'object') {
  // 	// Node. Does not work with strict CommonJS, but
  // 	// only CommonJS-like environments that support module.exports,
  // 	// like Node.
  // 	module.exports = factory(require('tooltipster'));
  // }
  // else {
  factory(jQuery);
  // }
})(this, function ($) {
  $.tooltipster._plugin({
    name: 'laa.scrollableTip',
    instance: {
      __init: function (instance) {
        var self = this;

        // list of instance variables

        self.__instance = instance;
        self.__maxSize;
        self.__namespace = 'tooltipster-scrollableTip-' + Math.round(Math.random() * 1000000);

        // prevent the tests on the document to save time
        self.__instance._on('positionTest.' + self.__namespace, function (event) {
          if (event.container == 'document') {
            event.takeTest(false);
          }
        });

        // select the scenario that will give a maximum area to the tooltip
        self.__instance._on('positionTested.' + self.__namespace, function (event) {
          var whole = false;
          $.each(event.results, function (i, result) {
            // if the tooltip completely fits on screen on one of the
            // sides, there is nothing to do
            if (result.whole) {
              whole = true;
              return false;
            }
          });
          if (!whole) {
            var maxSizes = [],
              biggestArea,
              index;

            // find out on which side the tooltip would have the biggest area after we
            // restrain its size to the size of the viewport
            $.each(event.results, function (i, result) {
              // the available height may be greater than the viewport height if the
              // origin is off screen at the top or bottom
              maxSizes[i] = {
                height: Math.min(event.helper.geo.available.window[result.side].height - result.distance.vertical, event.helper.geo.window.size.height),
                width: Math.min(event.helper.geo.available.window[result.side].width - result.distance.horizontal, event.helper.geo.window.size.width)
              };

              // this dismisses natural size scenarios where the tooltip is too big
              // (the constrained scenario for that side will used instead), but not the
              // natural size scenarios where it's narrower than the available space (in
              // that cases there is no constrained test for that side because it wasn't
              // needed)
              if (result.size.width <= maxSizes[i].width) {
                var height = Math.min(result.size.height, maxSizes[i].height),
                  width = Math.min(result.size.width, maxSizes[i].width),
                  area = height * width;

                // if 2 areas are equal, the first one is preferred (came first because
                // it had a higher priority at the time of measuring)
                if (!biggestArea || area > biggestArea) {
                  biggestArea = area;
                  index = i;
                }
              }
            });

            // leave only the wanted scenario
            event.edit([event.results[index]]);

            // save for the position event listener
            self.__maxSize = maxSizes[index];
          } else {
            self.__maxSize = null;
          }
        });

        // restrain the size
        self.__instance._on('position.' + self.__namespace, function (event) {
          var pos = event.position;

          // in case there already was a listener.
          // Note: we don't need to unbind at closing time, sideTip already
          // clears the tooltip
          $(event.tooltip).off('.' + self.__namespace);
          if (self.__maxSize) {
            if (pos.size.height > self.__maxSize.height && pos.side !== 'bottom') {
              pos.coord.top = 0;
            }
            if (pos.size.width > self.__maxSize.width && pos.side !== 'right') {
              pos.coord.left = 0;
            }
            pos.size.height = Math.min(pos.size.height, self.__maxSize.height);
            pos.size.width = Math.min(pos.size.width, self.__maxSize.width);
            event.edit(pos);
            if (!self.__instance.option('interactive')) {
              // we have to make the tooltip interactive ourselves. Touch events will
              // emulate mouse events, we don't really care for the difference at this
              // point (unless somebody comes up with a good use case)
              $(event.tooltip).css('pointer-events', 'auto').on('mouseenter.' + self.__namespace, function (event) {
                self.__instance._trigger({
                  dismissable: false,
                  type: 'dismissable'
                });
              }).on('mouseleave.' + self.__namespace, function (event) {
                self.__instance._trigger({
                  // we don't bother to differentiate mouse and touch, so we'll just
                  // use the touch delay which is longer by default
                  delay: self.__instance.option('delayTouch')[1],
                  dismissable: true,
                  event: event,
                  type: 'dismissable'
                });
              });
            }
          } else {
            // in case we had previously made it interactive
            if (!self.__instance.option('interactive')) {
              $(event.tooltip).css('pointer-events', '');
            }
          }
        });
      },
      /**
       * Method used in case we need to unplug the scrollableTip plugin
       */
      __destroy: function () {
        this.__instance._off('.' + this.__namespace);
      }
    }
  });
  return $;
});

/***/ }),

/***/ "./scripts/appUtils/myWin.js":
/*!***********************************!*\
  !*** ./scripts/appUtils/myWin.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "myWin": () => (/* binding */ myWin)
/* harmony export */ });
let myWin;
if (typeof window !== 'undefined') {
  myWin = window;
} else {
  myWin = {};
}


/*
const myWin = {};

export { myWin };
*/

/***/ }),

/***/ "./scripts/chrome-extension-lib/ext-lib.js":
/*!*************************************************!*\
  !*** ./scripts/chrome-extension-lib/ext-lib.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extLib": () => (/* binding */ extLib)
/* harmony export */ });
/* global browser, chrome */

// https://github.com/coderaiser/itchy/blob/master/lib/itchy.js
var asyncEachSeries = (array, iterator, done) => {
  check(array, iterator, done);
  var i = -1,
    n = array.length;
  var loop = function (e) {
    i++;
    if (e || i === n) return done && done(e);
    iterator(array[i], loop);
  };
  loop();
};
function check(array, iterator, done) {
  if (!Array.isArray(array)) throw Error('array should be an array!');
  if (typeof iterator !== 'function') throw Error('iterator should be a function!');
  if (done && typeof done !== 'function') throw Error('done should be a function (when available)!');
}

// TODO: DUPLICATE: Code duplication for browser detection in commands.js, ext-lib.js, magicss.js and options.js
var isChrome = false,
  isEdge = false,
  isFirefox = false,
  isOpera = false,
  isChromiumBased = false;

// Note that we are checking for "Edg/" which is the test required for identifying Chromium based Edge browser
if (/Edg\//.test(navigator.appVersion)) {
  // Test for "Edge" before Chrome, because Microsoft Edge browser also adds "Chrome" in navigator.appVersion
  isEdge = true;
} else if (/OPR\//.test(navigator.appVersion)) {
  // Test for "Opera" before Chrome, because Opera browser also adds "Chrome" in navigator.appVersion
  isOpera = true;
} else if (/Chrome/.test(navigator.appVersion)) {
  isChrome = true;
} else if (/Firefox/.test(navigator.userAgent)) {
  // For Mozilla Firefox browser, navigator.appVersion is not useful, so we need to fallback to navigator.userAgent
  isFirefox = true;
}
if (isEdge || isOpera || isChrome) {
  isChromiumBased = true; // eslint-disable-line no-unused-vars
}

var extLib = {
  loadCss: function (href) {
    const link = document.createElement('link');
    link.setAttribute('rel', 'stylesheet');
    link.setAttribute('type', 'text/css');
    link.setAttribute('href', href);

    // link.onload = function() {
    //     callback();
    // };
    // link.onerror = function() {
    //     callback('Could not load: ' + link);
    // };

    document.body.appendChild(link);
  },
  // allFrames: true
  // to support webpages structured using <frameset> (eg: http://www.w3schools.com/tags/tryhtml_frame_cols.htm)
  insertCss: function (options) {
    var treatAsNormalWebpage = options.treatAsNormalWebpage,
      file = options.file,
      code = options.code,
      allFrames = options.allFrames === false ? false : true,
      tabId = options.tabId || null,
      frameId = options.frameId,
      // runAt = options.runAt || 'document_idle',
      callback = options.callback;
    if (!treatAsNormalWebpage && typeof chrome !== 'undefined' && chrome && chrome.tabs) {
      // chrome.tabs.insertCSS(tabId, { file, code, allFrames, frameId, runAt }, function () {
      //     callback();       // Somehow this callback is not getting called without this anonymous function wrapper
      // });
      chrome.scripting.insertCSS({
        target: {
          tabId,
          allFrames,
          frameIds: frameId ? [frameId] : undefined
        },
        // runAt,
        files: file ? [file] : undefined,
        css: code ? code : undefined
      });
      callback();
    } else {
      if (file) {
        extLib.loadCss(file);
      } else {
        console.log('Error: It appears that you are in normal webpage mode while trying to load CSS "code". Currently, that works only in extension mode.');
      }
      callback();
      // extLib.loadCss(file, function (err) {
      //     if (err) {
      //         console.error(err);
      //     } else {
      //         callback();
      //     }
      // });
    }
  },

  loadJs: function ({
    src,
    callback
  }) {
    const script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = src;
    script.onload = function () {
      if (callback) {
        callback();
      }
    };
    script.onerror = function () {
      if (callback) {
        callback('Could not load: ' + src);
      }
    };
    document.body.appendChild(script);
  },
  loadJsAsync: async function ({
    src
  }) {
    return new Promise(function (resolve, reject) {
      // eslint-disable-line no-unused-vars
      extLib.loadJs({
        src,
        callback: function (err) {
          if (err) {
            resolve([err]);
          } else {
            resolve([null]);
          }
        }
      });
    });
  },
  // allFrames: true
  // to support webpages structured using <frameset> (eg: http://www.w3schools.com/tags/tryhtml_frame_cols.htm)
  executeScript: function (options) {
    var treatAsNormalWebpage = options.treatAsNormalWebpage,
      file = options.file,
      code = options.code,
      allFrames = options.allFrames === false ? false : true,
      tabId = options.tabId || null,
      frameId = options.frameId,
      runAt = options.runAt || 'document_idle',
      callback = options.callback;
    if (!treatAsNormalWebpage && typeof chrome !== 'undefined' && chrome && chrome.tabs) {
      if (isFirefox) {
        const executing = browser.tabs.executeScript(tabId, {
          file,
          code,
          allFrames,
          frameId,
          runAt
        });
        executing.then(function () {
          callback();
        });
      } else {
        // chrome.tabs.executeScript(tabId, { file, code, allFrames, frameId, runAt }, function () {
        //     callback();       // Somehow this callback is not getting called without this anonymous function wrapper
        // });

        chrome.scripting.executeScript({
          target: {
            tabId,
            allFrames,
            frameIds: frameId ? [frameId] : undefined
          },
          // runAt,
          files: [file]
          // callback: function () {
          //     callback();       // Somehow this callback is not getting called without this anonymous function wrapper
          // }
        }, function () {
          callback();
        });
        // callback();
      }
    } else {
      if (file) {
        extLib.loadJs({
          src: file,
          callback: function (err) {
            if (err) {
              console.error(err);
            } else {
              callback();
            }
          }
        });
      } else {
        console.log('Error: It appears that you are in normal webpage mode while trying to execute JS "code". Currently, that works only in extension mode.');
        callback();
      }
    }
  },
  executeScriptAsync: async function (options) {
    return new Promise(function (resolve, reject) {
      // eslint-disable-line no-unused-vars
      extLib.executeScript({
        ...options,
        callback: function (err) {
          if (err) {
            resolve([err]);
          } else {
            resolve([null]);
          }
        }
      });
    });
  },
  loadJsCss: function ({
    treatAsNormalWebpage,
    source,
    allFrames,
    tabId,
    frameId,
    runAt,
    callback
  }) {
    var sourceText, type;
    // source can also be an object and can have "src" and "skip" parameters
    if (typeof source === 'object') {
      if (source.skip) {
        source = null;
      } else if (source.sourceText && source.type) {
        sourceText = source.sourceText;
        type = source.type;
      } else {
        source = source.src;
      }
    }
    if (type && sourceText) {
      if (type === 'js') {
        extLib.executeScript({
          treatAsNormalWebpage,
          code: sourceText,
          allFrames,
          tabId,
          frameId,
          runAt,
          callback
        });
      } else if (type === 'css') {
        extLib.insertCss({
          treatAsNormalWebpage,
          code: sourceText,
          allFrames,
          tabId,
          frameId,
          runAt,
          callback
        });
      } else {
        console.log('Error - Loading scripts like ' + type + '/' + source + ' is not supported by loadMultipleJsCss(). Please check the "type" for the "sourceText".');
        callback();
      }
    } else if (source) {
      if (source.match('.js$')) {
        extLib.executeScript({
          treatAsNormalWebpage,
          file: source,
          allFrames,
          tabId,
          frameId,
          runAt,
          callback
        });
      } else if (source.match('.css$')) {
        extLib.insertCss({
          treatAsNormalWebpage,
          file: source,
          allFrames,
          tabId,
          frameId,
          runAt,
          callback
        });
      } else {
        console.log('Error - Loading files like ' + source + ' is not supported by loadMultipleJsCss(). Please check the file extension.');
        callback();
      }
    } else {
      callback();
    }
  },
  loadJsCssAsync: async function ({
    treatAsNormalWebpage,
    source,
    allFrames,
    tabId,
    frameId,
    runAt
  }) {
    return new Promise(function (resolve, reject) {
      // eslint-disable-line no-unused-vars
      extLib.loadJsCss({
        treatAsNormalWebpage,
        source,
        allFrames,
        tabId,
        frameId,
        runAt,
        callback: function (err) {
          if (err) {
            resolve([err]);
          } else {
            resolve([null]);
          }
        }
      });
    });
  },
  loadMultipleJsCss: function ({
    treatAsNormalWebpage,
    arrSources,
    allFrames,
    tabId,
    frameId,
    runAt,
    done
  }) {
    asyncEachSeries(arrSources, function (source, callback) {
      extLib.loadJsCss({
        treatAsNormalWebpage,
        source,
        allFrames,
        tabId,
        frameId,
        runAt,
        callback: function () {
          callback();
        }
      });
    }, function () {
      if (done) {
        done();
      }
    });
  }
};


/***/ }),

/***/ "./scripts/loading-magic-css.js":
/*!**************************************!*\
  !*** ./scripts/loading-magic-css.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/alertNote.js */ "./scripts/utils/alertNote.js");

(0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_0__.alertNote)('Loading Magic CSS ... Please wait :-)', 10000);

/***/ }),

/***/ "./scripts/magicss/editor/editor.js":
/*!******************************************!*\
  !*** ./scripts/magicss/editor/editor.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils.js */ "./scripts/utils.js");
/* harmony import */ var _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/alertNote.js */ "./scripts/utils/alertNote.js");
/* harmony import */ var _utils_waterfall_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/waterfall.js */ "./scripts/utils/waterfall.js");
/* harmony import */ var _migrate_storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../migrate-storage.js */ "./scripts/migrate-storage.js");
/* harmony import */ var _metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../metrics/sendMessageForMetrics.js */ "./scripts/magicss/metrics/sendMessageForMetrics.js");
/* harmony import */ var _3rdparty_amplify_store_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../3rdparty/amplify-store.js */ "./scripts/3rdparty/amplify-store.js");
/* harmony import */ var _appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../appUtils/myWin.js */ "./scripts/appUtils/myWin.js");
/* global CodeMirror, jQuery, chrome */

// TODO: Remove turning off of this rule (require-atomic-updates)
/* eslint require-atomic-updates: "off" */









// TODO: If remember text option is on, detect text change in another instance of this extension in some different tab

// TODO: Share constants across files (like magicss.js, editor.js and options.js) (probably keep them in a separate file as global variables)
var USER_PREFERENCE_AUTOCOMPLETE_SELECTORS = 'autocomplete-css-selectors',
  USER_PREFERENCE_AUTOCOMPLETE_CSS_PROPERTIES_AND_VALUES = 'autocomplete-css-properties-and-values',
  USER_PREFERENCE_USE_CUSTOM_FONT_SIZE = 'use-custom-font-size',
  USER_PREFERENCE_FONT_SIZE_IN_PX = 'font-size-in-px',
  USER_PREFERENCE_STORAGE_MODE = 'storage-mode',
  USER_PREFERENCE_HIDE_ON_PAGE_MOUSEOUT = 'hide-on-page-mouseout';
var manageClassListForWidth = function ({
  classList,
  width
}) {
  const floorWidthTo50 = parseInt(width, 10) - parseInt(width, 10) % 50;
  switch (floorWidthTo50) {
    /* eslint-disable no-fallthrough */
    case 950:
      classList.add('magicss-w-950-plus');
    case 900:
      classList.add('magicss-w-900-plus');
    case 850:
      classList.add('magicss-w-850-plus');
    case 800:
      classList.add('magicss-w-800-plus');
    case 750:
      classList.add('magicss-w-750-plus');
    case 700:
      classList.add('magicss-w-700-plus');
    case 650:
      classList.add('magicss-w-650-plus');
    case 600:
      classList.add('magicss-w-600-plus');
    case 550:
      classList.add('magicss-w-550-plus');
    case 500:
      classList.add('magicss-w-500-plus');
    case 450:
      classList.add('magicss-w-450-plus');
    case 400:
      classList.add('magicss-w-400-plus');
    case 350:
      classList.add('magicss-w-350-plus');
    case 300:
      classList.add('magicss-w-300-plus');
    case 250:
      classList.add('magicss-w-250-plus');
    /* eslint-enable no-fallthrough */
  }

  switch (floorWidthTo50) {
    /* eslint-disable no-fallthrough */
    case 200:
      classList.remove('magicss-w-250-plus');
    case 250:
      classList.remove('magicss-w-300-plus');
    case 300:
      classList.remove('magicss-w-350-plus');
    case 350:
      classList.remove('magicss-w-400-plus');
    case 400:
      classList.remove('magicss-w-450-plus');
    case 450:
      classList.remove('magicss-w-500-plus');
    case 500:
      classList.remove('magicss-w-550-plus');
    case 550:
      classList.remove('magicss-w-600-plus');
    case 600:
      classList.remove('magicss-w-650-plus');
    case 650:
      classList.remove('magicss-w-700-plus');
    case 700:
      classList.remove('magicss-w-750-plus');
    case 750:
      classList.remove('magicss-w-800-plus');
    case 800:
      classList.remove('magicss-w-850-plus');
    case 850:
      classList.remove('magicss-w-900-plus');
    case 900:
      classList.remove('magicss-w-950-plus');
    /* eslint-enable no-fallthrough */
  }
};

(function ($) {
  'use strict';

  var runningInAndroidFirefox = false;
  if (window.platformInfoOs === 'android') {
    runningInAndroidFirefox = true;
  }
  var CONSTANTS = {
    USE_NORMAL_SIZE_EDITOR: 350,
    EDITOR_MIN_WIDTH: 291,
    EDITOR_MIN_HEIGHT: 40,
    EDITOR_DEFAULT_WIDTH: 351,
    EDITOR_DEFAULT_HEIGHT: runningInAndroidFirefox ? 140 : 249
  };
  var chromeStorageForExtensionData = chrome.storage.sync || chrome.storage.local;

  // This value is updated elsewhere in this file (after fetching the user selected option)
  var whichStoreToUse = 'chrome.storage.local';
  var runOnceFor = function (fn, delay) {
    clearTimeout(fn.timer);
    fn.timer = setTimeout(fn, delay);
  };
  var nodeExistsInDom = function (el) {
    while (el) {
      if (el.nodeName === 'HTML') {
        return true;
      }
      el = el.parentNode;
    }
    return false;
  };

  /*
  // https://stackoverflow.com/questions/13382516/getting-scroll-bar-width-using-javascript/13382873#13382873
  var getScrollbarWidth = function () {
      var outer = document.createElement("div");
      outer.style.visibility = "hidden";
      outer.style.width = "100px";
      outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps
       document.body.appendChild(outer);
       var widthNoScroll = outer.offsetWidth;
      // force scrollbars
      outer.style.overflow = "scroll";
       // add innerdiv
      var inner = document.createElement("div");
      inner.style.width = "100%";
      outer.appendChild(inner);
       var widthWithScroll = inner.offsetWidth;
       // remove divs
      outer.parentNode.removeChild(outer);
       return widthNoScroll - widthWithScroll;
  };
  var scrollbarWidth = getScrollbarWidth();
   // https://www.sitepoint.com/jquery-check-horizontal-scroll-present/
  var hasScroll = function (el, direction) {
      direction = (direction === 'vertical') ? 'scrollTop' : 'scrollLeft';
      var result = !! el[direction];
      if (!result) {
          el[direction] = 1;
          result = !!el[direction];
          el[direction] = 0;
      }
      return result;
  };
  /* */

  var flagUsingQuirksMode = function () {
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/compatMode
    // https://stackoverflow.com/questions/627097/how-to-tell-if-a-browser-is-in-quirks-mode/627124#627124
    // http://help.dottoro.com/ljteklnx.php
    var inQuirksMode = document.compatMode === "BackCompat" ? true : false;
    return inQuirksMode;
  }();

  // References:
  //     Why we need to use document.body.clientHeight in quirks mode - https://stackoverflow.com/questions/8052178/difference-between-document-documentelement-clientheight-and-document-body-clien/8053110#8053110
  //     General logic to get the viewport dimensions - https://stackoverflow.com/questions/1248081/get-the-browser-viewport-dimensions-with-javascript/36132694#36132694
  var getViewportHeightExcludingScroll = function () {
    var height;
    if (flagUsingQuirksMode) {
      // "(document.body || {})" and "|| Infinity" may not be required. Just using that for robustness.
      height = Math.min((document.body || {}).clientHeight || Infinity, window.innerHeight || Infinity);
    } else {
      // "|| window.innerHeight || 0" may not be required. Just using that for robustness.
      height = document.documentElement.clientHeight || window.innerHeight || 0;
    }

    // Alternative approach
    // height = window.innerHeight;
    // if (hasScroll(document.body, 'horizontal')) {
    //     height -= scrollbarWidth;
    // }
    return height;
  };
  var getViewportWidthExcludingScroll = function () {
    var width;
    if (flagUsingQuirksMode) {
      // "(document.body || {})" and "|| Infinity" may not be required. Just using that for robustness.
      width = Math.min((document.body || {}).clientWidth || Infinity, window.innerWidth || Infinity);
    } else {
      // "|| window.innerWidth || 0" may not be required. Just using that for robustness.
      width = document.documentElement.clientWidth || window.innerWidth || 0;
    }

    // Alternative approach
    // width = window.innerWidth;
    // if (hasScroll(document.body, 'vertical')) {
    //     width -= scrollbarWidth;
    // }
    return width;
  };
  var getRoundedBoundingClientRect = function (el) {
    var rect = el.getBoundingClientRect(),
      ob = {};
    for (var key in rect) {
      if (typeof rect[key] === 'number') {
        ob[key] = Math.round(rect[key]);
      }
    }
    return ob;
  };

  /*
  // Modified version of https://gist.github.com/davidtheclark/5515733
  // This modified version seems to work well with scrollbars based positioning for the floating editor
  function isElementInViewport(el) {
      var rect = getRoundedBoundingClientRect(el);
      return (
          rect.left >= 0 &&
          rect.top >= 0 &&
          rect.right <= getViewportWidthExcludingScroll() &&
          rect.bottom <= getViewportHeightExcludingScroll()
      );
  }
  /* */
  function isElementXInViewport(el) {
    var rect = getRoundedBoundingClientRect(el);
    return rect.left >= 0 && rect.right <= getViewportWidthExcludingScroll();
  }
  function isElementYInViewport(el) {
    var rect = getRoundedBoundingClientRect(el);
    return rect.top >= 0 && rect.bottom <= getViewportHeightExcludingScroll();
  }
  var mainAutoPositionEditor = async function (thisOb) {
    /*
        // The approach to be used in this function
         if (negative positioning is set) {
            clear negative positioning
        }
        if (element is not in viewport) {
            adjust positioning if possible
            decrease width and height if possible
        }
         if (element is in viewport) {
            increase width and height if possible
            adjust positioning if possible
        }
    /* */

    let minWidth = CONSTANTS.EDITOR_MIN_WIDTH,
      minHeight = CONSTANTS.EDITOR_MIN_HEIGHT;
    let viewportHeightExcludingScroll = getViewportHeightExcludingScroll(),
      viewportWidthExcludingScroll = getViewportWidthExcludingScroll();
    let mainElement = thisOb.container,
      $cmWrapperElement = $(thisOb.cm.getWrapperElement());
    let rect,
      updateRect = function () {
        rect = getRoundedBoundingClientRect(mainElement);
      };
    updateRect();
    // Remove negative X positioning
    if (rect.left < 0) {
      mainElement.style.left = '0px';
    }
    // Remove negative Y positioning
    if (rect.top < 0) {
      mainElement.style.top = '0px';
    }
    updateRect();
    // Adjust X positioning (when x-axis is not in viewport)
    if (rect.left >= 0 && !isElementXInViewport(mainElement)) {
      let appliedLeft = parseInt(mainElement.style.left, 10),
        deltaX = rect.right - viewportWidthExcludingScroll;
      if (deltaX > rect.left) {
        deltaX = rect.left;
      }
      mainElement.style.left = appliedLeft - deltaX + 'px';
    }
    // Adjust Y positioning (when y-axis is not in viewport)
    if (rect.top >= 0 && !isElementYInViewport(mainElement)) {
      let appliedTop = parseInt(mainElement.style.top, 10),
        deltaY = rect.bottom - viewportHeightExcludingScroll;
      if (deltaY > rect.top) {
        deltaY = rect.top;
      }
      mainElement.style.top = appliedTop - deltaY + 'px';
    }
    updateRect();
    // Adjust editor's width (when x-axis is not in viewport)
    if (rect.left >= 0 && !isElementXInViewport(mainElement)) {
      let appliedWidth = parseInt($cmWrapperElement.css('width'), 10),
        deltaX = rect.right - viewportWidthExcludingScroll,
        useWidth = Math.max(minWidth, appliedWidth - deltaX);
      $cmWrapperElement.css('width', useWidth);
    }
    // Adjust editor's height (when y-axis is not in viewport)
    if (rect.top >= 0 && !isElementYInViewport(mainElement)) {
      let appliedHeight = parseInt($cmWrapperElement.css('height'), 10),
        deltaY = rect.bottom - viewportHeightExcludingScroll,
        useHeight = Math.max(minHeight, appliedHeight - deltaY);
      $cmWrapperElement.css('height', useHeight);
    }
    updateRect();
    // Adjust editor's width (when x-axis is in viewport)
    if (rect.left >= 0 && isElementXInViewport(mainElement)) {
      let appliedWidth = parseInt($cmWrapperElement.css('width'), 10),
        userPreferredWidth = (await thisOb.getDimensions()).width;
      if (appliedWidth < userPreferredWidth) {
        let deltaX = viewportWidthExcludingScroll - rect.right,
          useWidth = Math.min(Math.max(minWidth, appliedWidth + deltaX), userPreferredWidth);
        $cmWrapperElement.css('width', useWidth);
      }
    }
    // Adjust editor's height (when y-axis is in viewport)
    if (rect.top >= 0 && isElementYInViewport(mainElement)) {
      let appliedHeight = parseInt($cmWrapperElement.css('height'), 10),
        userPreferredHeight = (await thisOb.getDimensions()).height;
      if (appliedHeight < userPreferredHeight) {
        let deltaY = viewportHeightExcludingScroll - rect.bottom,
          useHeight = Math.min(Math.max(minHeight, appliedHeight + deltaY), userPreferredHeight);
        $cmWrapperElement.css('height', useHeight);
      }
    }
    updateRect();
    // Adjust X positioning (when x-axis is in viewport)
    if (rect.left >= 0 && isElementXInViewport(mainElement)) {
      let appliedLeft = parseInt(mainElement.style.left, 10),
        userPreferredLeft = await thisOb.userPreference('ui-position-left');
      if (appliedLeft < userPreferredLeft) {
        let deltaX = viewportWidthExcludingScroll - rect.right;
        mainElement.style.left = Math.min(appliedLeft + deltaX, userPreferredLeft) + 'px';
      }
    }
    // Adjust Y positioning (when y-axis is in viewport)
    if (rect.top >= 0 && isElementYInViewport(mainElement)) {
      let appliedTop = parseInt(mainElement.style.top, 10),
        userPreferredTop = await thisOb.userPreference('ui-position-top');
      if (appliedTop < userPreferredTop) {
        let deltaY = viewportHeightExcludingScroll - rect.bottom;
        mainElement.style.top = Math.min(appliedTop + deltaY, userPreferredTop) + 'px';
      }
    }
  };
  var autoPositionEditor = function (thisOb) {
    if (autoPositionEditor.raf) {
      window.cancelAnimationFrame(autoPositionEditor.raf);
    }
    autoPositionEditor.raf = window.requestAnimationFrame(async function () {
      await mainAutoPositionEditor(thisOb);
    });
  };
  class Editor {
    /**
     * Constructor
     * @param {Object} options - The configuration object for the editor.
     * @param {string} [options.title=Text Editor] - The title of the editor.
     * @param {string} [options.tooltip=A simple text editor] - The tooltip of the editor.
     * TODO: Complete documentation
     */
    constructor(options) {
      _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.attachPublishSubscribe(this); // Used for event handling

      options = options || {};
      var defaults = {
        title: 'Text Editor',
        tooltip: 'A simple text editor',
        placeholder: 'Write your text here...',
        disableCloseIcon: false,
        disableResize: false,
        draggable: true,
        closeOnEscapeKey: true,
        rememberText: true,
        rememberDimensions: true,
        textareaWrapAttr: 'off',
        bgColor: '54,64,118,0.75'
      };
      this.passedOptions = options;
      this.options = $.extend({}, defaults, this.passedOptions);
      this.normalizeOptions(this.options); // Normalize the options object
      // this.addDerivedOptions(this.options);    // Add derived options

      this.events = this.events || {};

      // We intend to call create() via async/await. It cannot be done from within the constructor due to technical
      // limitation. So, we need to do that manually when we create the "Editor" object.
      // var _this = this;
      // setTimeout(async function () {
      //     await _this.create();
      // });
    }

    // Normalize the options object
    normalizeOptions(options) {
      if (!options.id) {
        // If options.id is not available, then the panel cannot be uniquely identified
        // and hence remembered text will not be useful in fetching it back
        console.warn('options.rememberDimensions may not behave properly because there is no options.id');
        console.warn('options.rememberText may not behave properly because there is no options.id');
      }
      options.draggable = !!options.draggable;
      options.placeholder = options.placeholder || '';
      options.rememberDimensions = !!options.rememberDimensions;
      options.rememberText = !!options.rememberText;
    }

    // addDerivedOptions(options) {
    //     if (options.rememberText || options.rememberDimensions) {
    //         // Add options.localDataKeyPrefix
    //         options.localDataKeyPrefix = options.id + '-';
    //     }
    // }

    getOption(option) {
      return this.options[option];
    }
    defaultPreference(pref) {
      var defaultPreferences = Editor.defaultPreferences;
      if (defaultPreferences[pref] !== undefined) {
        return defaultPreferences[pref];
      } else {
        return '';
      }
    }

    // Passing null as "value" would effectively delete the value from the store
    // Reference: http://amplifyjs.com/api/store/
    async userPreference(pref, value) {
      var _this = this;
      if (whichStoreToUse === 'chrome.storage.local' || whichStoreToUse === 'chrome.storage.sync') {
        let prefix = 'live-css-';
        var chromeStorage;
        if (whichStoreToUse === 'chrome.storage.sync') {
          chromeStorage = chrome.storage.sync;
        } else {
          chromeStorage = chrome.storage.local;
        }
        return new Promise(function (resolve, reject) {
          // eslint-disable-line no-unused-vars
          var propertyName = `(${window.location.origin}) ${prefix}${pref}`;
          if (value === undefined) {
            chromeStorage.get(propertyName, function (values) {
              resolve(values[propertyName] || _this.defaultPreference(pref));
            });
          } else {
            chromeStorage.set({
              [propertyName]: value
            }, function () {
              const lastError = chrome.runtime.lastError;
              if (lastError) {
                console.log(['Error reported by Magic CSS extension: An error occurred in saving your recent changes.', '', 'Error message: ' + (lastError && lastError.message), '', 'If you are using browser.storage.sync mode, kindly refer to https://developer.chrome.com/docs/extensions/reference/storage/#property-sync', '', 'Most likely, it is not a bug in the extension.', 'If you think it is a bug in the extension, kindly report this issue at https://github.com/webextensions/live-css-editor/issues'].join('\n'));
                var htmlEscape = function (str) {
                  return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                };
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(['Error! An error was encountered by Magic CSS extension while saving your changes.', '', htmlEscape(String(lastError && lastError.message)), '', '<div style="text-align:left;color:#000;">Possible solutions:', '&nbsp;&nbsp;&nbsp;&nbsp;* Try to store less data', '&nbsp;&nbsp;&nbsp;&nbsp;* Try to reduce frequency of your changes', '&nbsp;&nbsp;&nbsp;&nbsp;* Try again after 30 seconds', '&nbsp;&nbsp;&nbsp;&nbsp;* Try again after reloading the page', '&nbsp;&nbsp;&nbsp;&nbsp;* Switch away from chrome.storage.sync mode</div>'].join('<br />'), 15000, {
                  backgroundColor: '#f5bcae',
                  borderColor: '#e87457'
                });
                reject();
              }
              resolve();
            });
          }
        });
      } else {
        let prefix = 'MagiCSS-bookmarklet-';
        var propertyName = `${prefix}${pref}`;
        if (whichStoreToUse === 'sessionStorage') {
          return new Promise(function (resolve, reject) {
            // eslint-disable-line no-unused-vars
            if (value === undefined) {
              let dataToReturn;
              try {
                const valueFromStorage = sessionStorage.getItem(propertyName);
                dataToReturn = JSON.parse(valueFromStorage).data;
              } catch (e) {
                // Do nothing as such if an error happens
                // TODO: Add appropriate logging, if required
              }
              if (typeof dataToReturn === 'undefined') {
                dataToReturn = _this.defaultPreference(pref);
              }
              resolve(dataToReturn);
            } else {
              try {
                const dataToSet = JSON.stringify({
                  data: value
                });
                sessionStorage.setItem(propertyName, dataToSet);
              } catch (e) {
                // Do nothing as such if an error happens
                // TODO: Add appropriate logging, if required
              }
              resolve(_this);
            }
          });
        } else {
          return new Promise(function (resolve, reject) {
            // eslint-disable-line no-unused-vars
            if (value === undefined) {
              const dataToReturn = _3rdparty_amplify_store_js__WEBPACK_IMPORTED_MODULE_5__.amplify.store(propertyName) || _this.defaultPreference(pref);
              resolve(dataToReturn);
            } else {
              _3rdparty_amplify_store_js__WEBPACK_IMPORTED_MODULE_5__.amplify.store(propertyName, value);
              resolve(_this);
            }
          });
        }
      }
    }
    bringCursorToView(options) {
      options = options || {};
      var cm = this.cm,
        cursorPos = cm.getCursor();
      if (options.pleaseIgnoreCursorActivity) {
        this.pleaseIgnoreCursorActivity = true;
      }

      // Reset the cursor and then set again to bring the current line of text back to view (scroll to view)
      // (CodeMirror does not scroll to cursor position when the cursor is already
      // at the position where your ask it to be set)
      cm.setCursor(0, 0);

      // Scroll ahead by a few lines to give the user a view of lines near the current cursor position
      var aheadCursorPos = $.extend(true, {}, cursorPos);
      aheadCursorPos.line += 4;
      cm.setCursor(aheadCursorPos);

      // Set the cursor position back to original
      cm.setCursor(cursorPos);
      if (options.pleaseIgnoreCursorActivity) {
        this.pleaseIgnoreCursorActivity = false;
      }
    }
    async reposition(cb) {
      cb = cb || function () {};
      var thisOb = this,
        containerEl = thisOb.container;
      var isContainerHidden = $(thisOb.container).is(':visible') ? false : true,
        isContainerTrulyHidden = isContainerHidden && thisOb.container.style.display === 'none' && $(thisOb.container).parent().is(':visible');
      if (isContainerTrulyHidden) {
        await thisOb.options.editorOb.show();
        cb();
      } else {
        var defaultLeft = thisOb.defaultPreference('ui-position-left'),
          defaultTop = thisOb.defaultPreference('ui-position-top'),
          defaultWidth = thisOb.defaultPreference('ui-size-width'),
          defaultHeight = thisOb.defaultPreference('ui-size-height');
        var animationRequired = true;
        if (parseInt($(containerEl).css('top'), 10) === defaultTop && parseInt($(containerEl).css('left'), 10) === defaultLeft) {
          if ($(thisOb.cm.getWrapperElement()).width() === defaultWidth && $(thisOb.cm.getWrapperElement()).height() === defaultHeight) {
            animationRequired = false;
          }
        }
        if (animationRequired === false) {
          thisOb.focus(); /* This is required if the text editor panel is being opened through some
                             component which causes the textarea to lose focus. */
          await thisOb.triggerEvent('reInitialized', {
            animDuration: 0,
            targetWidth: defaultWidth,
            targetHeight: defaultHeight
          });
          cb();
        } else {
          var maxDuration = 750;
          var textareaLeft = parseInt($(containerEl).css('left'), 10),
            textareaTop = parseInt($(containerEl).css('top'), 10),
            gapToCoverForPositioning = Math.sqrt(Math.pow(defaultLeft - textareaLeft, 2) + Math.pow(defaultTop - textareaTop, 2)),
            $ta = $(containerEl).find('textarea.editor-editor'),
            textareaWidth = parseInt($ta.css('width'), 10),
            textareaHeight = parseInt($ta.css('height'), 10),
            gapToCoverForResizing = Math.sqrt(Math.pow(defaultWidth - textareaWidth, 2) + Math.pow(defaultHeight - textareaHeight, 2)),
            maxGapToCover = Math.max(gapToCoverForPositioning, gapToCoverForResizing),
            duration = 100 + maxDuration * (Math.sqrt(maxGapToCover) / Math.sqrt(maxDuration / 1.5));
          duration = parseInt(duration, 10);
          if (duration > maxDuration) {
            duration = maxDuration;
          }

          // TODO: Use better css specificity for identifying original textarea
          // Animate to initial position
          $(containerEl).css('width', '').css('height', '');
          $(containerEl).animate({
            top: defaultTop,
            left: defaultLeft
          }, duration, function () {
            setTimeout(async function () {
              await thisOb.savePosition({
                top: defaultTop,
                left: defaultLeft
              });
              thisOb.focus();
              cb();
            });
          });

          // TODO: Implement 'resizable' option

          try {
            await thisOb.triggerEvent('reInitialized', {
              animDuration: duration,
              targetWidth: defaultWidth,
              targetHeight: defaultHeight
            });
          } catch (e) {
            // TODO: Handle this error
          }
        }
      }
    }
    async create() {
      var thisOb = this,
        options = thisOb.options;

      // If it already exists
      if (options.id && document.getElementById(options.id)) {
        console.error('Error: Trying to create a new instance while an instance of "Editor" already exists with id: ' + options.id);
        return;
      }
      var top, left;
      if (options.rememberDimensions) {
        top = (await thisOb.userPreference('ui-position-top')) + 'px';
        left = (await thisOb.userPreference('ui-position-left')) + 'px';
      } else {
        top = '20px';
        left = '20px';
      }
      var strHTML = '<div' + (options.id ? ' id="' + options.id + '"' : '') +
      // "outline: 1px solid transparent" helps in avoiding the trails of movement which are left
      // when we auto-resize the component with motion when it is reinitialized
      // (which happens due to a Chrome/WebKit bug)
      ' style="outline: 1px solid transparent; top: ' + top + '; left: ' + left + '; font-family: Helvetica, &quot;Trebuchet MS&quot;, sans-serif">' + '</div>';
      var container = $(strHTML).get(0);
      thisOb.options.editorOb = thisOb;
      thisOb.container = container;
      document.getElementsByTagName('body')[0].appendChild(container);
      if (options.draggable) {
        thisOb._makeDraggable();
      }
      await thisOb.initialize(options);
      thisOb.container.style.visibility = 'hidden';
      await thisOb._addChildComponents();
      thisOb.container.style.visibility = '';
      if (!runningInAndroidFirefox) {
        // Set focus on editor
        thisOb.focus();
      }
      await thisOb.triggerEvent('launched');
      window.onresize = function (e) {
        if (e.target !== window) {
          return;
        }
        autoPositionEditor(thisOb);
      };
      autoPositionEditor(thisOb);
    }
    adjustUiPosition() {
      var thisOb = this;
      autoPositionEditor(thisOb);
    }
    _makeDraggable() {
      if (document.documentElement.classList.contains('full-screen-editor')) {
        return;
      }
      var thisOb = this,
        options = thisOb.options;
      thisOb.container.style.cursor = 'move';
      $(thisOb.container).draggable({
        distance: 5,
        cancel: '.cancelDragHandle, textarea',
        opacity: 0.35,
        scroll: false,
        // Do not auto scroll when dragging near the edges of the page
        start: function (evt, ui) {
          // When a matching/non-matching bracket was highlighted, and the user tried to select some other piece
          // of text, dragging was starting. This happened because the node was being removed from DOM, but jQuery UI's
          // draggable logic wasn't handling that correctly. So, we do that here manually.
          if (!nodeExistsInDom(evt.originalEvent.target)) {
            // Need to fix opacity manually because jQuery UI doesn't set it back when we return "false" inside "start()"
            ui.helper.css('opacity', 1);

            // Do not start dragging
            return false;
          }
          $(thisOb.container).addClass('noclick');
          // This code will be used for functionality of providing free style draggability
          // Clear corner positioning and allow free-style (jQuery uses top and left for draggable)
          $(thisOb.container).css('bottom', '').css('right', '');
          (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_4__.sendEventMessageForMetrics)({
            name: 'dragEditor',
            type: 'start'
          });
        },
        stop: function (event, ui) {
          setTimeout(async function () {
            // Unattach 'noclick' class with an immediate timeout
            // so that it executes after event (bubble) cycle is completed
            setTimeout(function () {
              $(thisOb.container).removeClass('noclick');
            }, 0);
            if (options.rememberDimensions) {
              await thisOb.savePosition({
                top: ui.position.top,
                left: ui.position.left
              });
            }
            if (!runningInAndroidFirefox) {
              thisOb.focus();
            }
            (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_4__.sendEventMessageForMetrics)({
              name: 'dragEditor',
              type: 'stop'
            });
          });
        }
      });
    }
    async _createSyntaxHighlighting() {
      var thisOb = this,
        options = thisOb.options;
      var newDiv = $('<div></div>').addClass('raw-codemirror-container');
      $(thisOb.textarea).parent().after(newDiv);
      var closeOnEscapeKey = true;
      if (options.closeOnEscapeKey === false || options.closeOnEscapeKey === null) {
        closeOnEscapeKey = false;
      }
      var indentWithTabs = (await thisOb.userPreference('use-tab-for-indentation')) === 'yes';
      window.indentWithTabs = indentWithTabs;
      var indentUnit = !indentWithTabs && parseInt(await thisOb.userPreference('indentation-spaces-count'), 10) || 4;
      window.indentUnit = indentUnit;
      var codemirrorOptions = {
        value: thisOb.textarea.value,
        placeholder: thisOb.getOption('placeholder'),
        gutters: [],
        lint: false,
        lineNumbers: (await thisOb.userPreference('show-line-numbers')) === 'yes' ? true : false,
        // Eventually, lineNumbers also adds a value in "gutters" array
        lineWrapping: (await thisOb.userPreference('enable-line-wrap')) === 'yes' ? true : false,
        styleActiveLine: {
          nonEmpty: true
        },
        matchBrackets: true,
        keyMap: "sublime",
        showCursorWhenSelecting: true,
        indentWithTabs: indentWithTabs,
        indentUnit,
        undoDepth: 1000,
        extraKeys: {
          // https://github.com/codemirror/CodeMirror/issues/988
          Tab: function (cm) {
            if (cm.doc.somethingSelected()) {
              return CodeMirror.Pass;
            }
            var emmetExpanded = cm.execCommand('emmetExpandAbbreviation');
            if (emmetExpanded === CodeMirror.Pass) {
              // If it didn't expand, then "emmetExpanded === CodeMirror.Pass function"
              if (indentWithTabs) {
                return CodeMirror.Pass;
              }
              var spacesPerTab = cm.getOption('indentUnit'),
                spacesToInsert = spacesPerTab - cm.doc.getCursor('start').ch % spacesPerTab,
                spaces = Array(spacesToInsert + 1).join(' ');
              cm.replaceSelection(spaces, 'end', '+input');
            }
          },
          Esc: async function () {
            if (thisOb.isPointAndClickActivated()) {
              thisOb.deactivatePointAndClick();
            } else if (thisOb.cm.getSelection()) {
              // If there is some selection
              // Clear selection
              thisOb.setCursorPosition(thisOb.getCursorPosition());
            } else {
              if (closeOnEscapeKey) {
                await thisOb.hide();
                await thisOb.triggerEvent('onClose', {
                  closeByKeyPress: true
                });
              }
            }
          },
          'Ctrl-P': async function () {
            thisOb.keyPressed('Ctrl-P');
          },
          'Cmd-P': async function () {
            thisOb.keyPressed('Cmd-P');
          },
          'Ctrl-O': async function () {
            thisOb.keyPressed('Ctrl-O');
          },
          'Cmd-O': async function () {
            thisOb.keyPressed('Cmd-O');
          }
        }
      };
      var passedOptionsCombined = $.extend(true, {}, options.codemirrorOptions, await options.codemirrorOptions.optionsBasedOnUserPreference(await thisOb.userPreference.bind(this)));
      delete passedOptionsCombined.optionsBasedOnUserPreference; // Just cleaning up the object (not a compulsory thing to do)
      codemirrorOptions = $.extend(true, {}, codemirrorOptions, passedOptionsCombined);
      await thisOb.triggerEvent('beforeInstantiatingCodeMirror');
      var cm = thisOb.cm = CodeMirror(newDiv.get(0), codemirrorOptions);
      cm.on('focus', async function (cm, evt) {
        // eslint-disable-line no-unused-vars
        // https://github.com/webextensions/live-css-editor/issues/4
        if (!thisOb.cmInputFieldHasFocus()) {
          // Most probably there is something problematic in focus behavior
          await thisOb.triggerEvent('problematicFocusDetected');
        }
      });
      var dimWH = await thisOb.getDimensions();
      cm.setSize(dimWH.width, dimWH.height);
      var t_timer;
      cm.on('change', function (cm, changeObj) {
        if (changeObj.origin === 'setValue') {
          thisOb.setTextValue(cm.getValue());
        } else {
          var delay = 500;
          clearTimeout(t_timer);
          t_timer = setTimeout(async function () {
            await thisOb.setTextValue(cm.getValue());
            await thisOb.triggerEvent('delayedtextchange');
          }, delay);
        }
      });
      cm.on('keydown', function (cm, evt) {
        evt.stopPropagation();
      });
      cm.on('keypress', function (cm, evt) {
        evt.stopPropagation();
      });
      cm.on('keyup', function (cm, evt) {
        evt.stopPropagation();
      });

      // http://stackoverflow.com/questions/4179708/how-to-detect-if-the-pressed-key-will-produce-a-character-inside-an-input-text/4180715#4180715
      var isCharacterKeyPress = function (evt) {
        if (typeof evt.which == "undefined") {
          // This is IE, which only fires keypress events for printable keys
          return true;
        } else if (typeof evt.which == "number" && evt.which > 0) {
          // In other browsers except old versions of WebKit, evt.which is
          // only greater than zero if the keypress is a printable key.
          // We need to filter out backspace and ctrl/alt/meta key combinations
          return !evt.ctrlKey && !evt.metaKey && !evt.altKey && evt.which != 8;
        }
        return false;
      };
      cm.on('keypress', function (cm, evt) {
        if (isCharacterKeyPress(evt)) {
          if (CodeMirror.showHint) {
            CodeMirror.showHint(cm);
          }
        }
      });
      var fnOnCursorActivity = async function () {
        await thisOb.triggerEvent('_delayedcursorprobablymoved');
      };
      cm.on('cursorActivity', function () {
        if (thisOb.pleaseIgnoreCursorActivity) {
          // do nothing
        } else {
          runOnceFor(fnOnCursorActivity, 500);
        }
      });
      $(cm.getWrapperElement()).addClass('cancelDragHandle');
      if (document.documentElement.classList.contains('full-screen-editor')) {
        // do nothing

        if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_6__.myWin.flagEditorInExternalWindow) {
          window.addEventListener('resize', function () {
            // https://stackoverflow.com/questions/3437786/get-the-size-of-the-screen-current-web-page-and-browser-window/11744120#11744120
            const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            manageClassListForWidth({
              classList: thisOb.container.classList,
              width
            });
          });
        }
      } else {
        $(cm.getWrapperElement()).resizable({
          handles: 'se',
          minWidth: CONSTANTS.EDITOR_MIN_WIDTH,
          minHeight: CONSTANTS.EDITOR_MIN_HEIGHT,
          start: function () {
            setTimeout(async function () {
              // Save editor's position.
              // It is useful when the user is resizing, but the position
              // is out of sync with the value in userPreference (this
              // out-of-sync is deliberate and useful for auto-positioning
              // on window resize)
              await thisOb.savePosition({
                top: parseInt(thisOb.container.style.top, 10),
                left: parseInt(thisOb.container.style.left, 10)
              });
            });
            (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_4__.sendEventMessageForMetrics)({
              name: 'resizeEditor',
              type: 'start'
            });
          },
          resize: function (event, ui) {
            if (ui.size.width < CONSTANTS.USE_NORMAL_SIZE_EDITOR) {
              thisOb.container.classList.add('magicss-editor-is-small');
            } else {
              thisOb.container.classList.remove('magicss-editor-is-small');
            }
            manageClassListForWidth({
              classList: thisOb.container.classList,
              width: ui.size.width
            });
          },
          stop: function (event, ui) {
            setTimeout(async function () {
              await thisOb.setTextContainerDimensions({
                width: ui.size.width,
                height: ui.size.height
              }, {
                propagateTo: 'codemirror'
              });
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_4__.sendEventMessageForMetrics)({
                name: 'resizeEditor',
                type: 'stop'
              });
            });
          }
        });
      }
    }
    async _addChildComponents() {
      var thisOb = this,
        options = thisOb.options;
      if (!thisOb.container) {
        console.warn('Warning: You might have used _addChildComponents() before using create().');
      }
      var rememberText = options.rememberText,
        rememberDimensions = options.rememberDimensions;
      var divHeader = document.createElement('div');
      divHeader.className = 'magic-css-header';
      thisOb.container.appendChild(divHeader);
      var parentDivRightAligned = divHeader;
      var divHeaderLeft = document.createElement('div');
      divHeaderLeft.className = 'magic-css-header-left-section';
      divHeader.appendChild(divHeaderLeft);
      var title = options.title || 'Editor';
      if (typeof title === 'function') {
        var $title = title($, thisOb);
        $(divHeaderLeft).append($title);
      } else {
        $(divHeaderLeft).append($('<div>' + title + '</div>'));
      }
      options.headerOtherIcons = (options.headerOtherIcons || []).filter(x => x).filter(function (item) {
        if (item.skip) {
          return false;
        } else {
          return true;
        }
      });
      const useOtherIcons = false;
      if (useOtherIcons && options.headerOtherIcons.length) {
        options.headerIcons = options.headerIcons || [];
        options.headerIcons.unshift({
          name: 'more',
          cls: 'editor-more-icons editor-gray-out cancelDragHandle',
          afterrender: function (editor, moreIcon) {
            var $moreIcon = $(moreIcon),
              tooltipContent = ['<ul>'];
            options.headerOtherIcons.forEach(function (iconOptions) {
              tooltipContent.push('<li class="' + (iconOptions.cls ? 'li-' + iconOptions.cls : '') + ' ' + (iconOptions.uniqCls ? 'li-' + iconOptions.uniqCls : '') + '">' + '<a' + ' class="more-icons ' + (iconOptions.cls || '') + ' ' + (iconOptions.uniqCls || '') + '"' + ' href="' + (iconOptions.href || 'javascript:void(0);') + '"' + (iconOptions.href ? ' target="_blank"' : '') + '>' + iconOptions.title + '</a>' + '</li>');
              if (iconOptions.uniqCls && iconOptions.onclick) {
                $('body').on('click', '.' + iconOptions.uniqCls, function (evt) {
                  evt.preventDefault(); // Useful in preventing the opening of a new tab in Firefox if the anchor-tag icon has target="_blank"
                  iconOptions.onclick(evt, editor, $moreIcon);
                  var originalSpeed = $moreIcon.tooltipster('option', 'speed');
                  $moreIcon.tooltipster('option', 'speed', 0);
                  $moreIcon.tooltipster('hide');
                  $moreIcon.tooltipster('option', 'speed', originalSpeed);
                });
              }
            });
            tooltipContent.push('</ul>');
            $moreIcon.tooltipster({
              plugins: ['tooltipster.sideTip', 'laa.scrollableTip'],
              content: tooltipContent.join(''),
              contentAsHTML: true,
              side: ['top', 'bottom'],
              // https://github.com/iamceege/tooltipster/blob/3.3.0/js/jquery.tooltipster.js#L338
              theme: 'tooltipster-default magic-css-tooltipster',
              interactive: true,
              interactiveTolerance: 350,
              functionReady: function (instance, helper) {
                setTimeout(async function () {
                  for (var i = 0; i < options.headerOtherIcons.length; i++) {
                    var ico = options.headerOtherIcons[i];
                    if (ico && ico.beforeShow) {
                      await ico.beforeShow(helper.origin, $(helper.tooltip), editor);
                    }
                  }

                  // The tooltip would have rendered in hidden mode, but its width might have changed
                  // due to some changes via .beforeShow(), so, we need to reposition it
                  $moreIcon.tooltipster('reposition');
                });
              }
            });
          }
        });
      }
      options.headerIcons = (options.headerIcons || []).filter(function (item) {
        return !!item;
      });
      var disableCloseIcon = !!options.disableCloseIcon;
      if (!disableCloseIcon) {
        options.headerIcons = options.headerIcons || [];
        options.headerIcons.push({
          name: 'close',
          title: 'Close',
          cls: 'editor-close editor-gray-out',
          onclick: async function (evt, editor) {
            await editor.hide();
            await editor.triggerEvent('onClose');
          }
        });
      }
      if (options.headerIcons.length) {
        options.headerIcons.forEach(function (iconOptions) {
          if (iconOptions.icons) {
            iconOptions.afterrender = function (editor, divIcon) {
              var $divIcon = $(divIcon),
                tooltipContent = ['<ul>'];
              iconOptions.icons = (iconOptions.icons || []).filter(function (item) {
                return !!item;
              });
              iconOptions.icons.forEach(function (iconOptions) {
                tooltipContent.push('<li ' + (iconOptions.hoverTitle ? 'title="' + iconOptions.hoverTitle + '" ' : '') + 'class="' + (iconOptions.cls ? 'li-' + iconOptions.cls : '') + ' ' + (iconOptions.uniqCls ? 'li-' + iconOptions.uniqCls : '') + '"' + '>' + '<a' + ' class="more-icons ' + (iconOptions.cls || '') + ' ' + (iconOptions.uniqCls || '') + '"' + ' href="' + (iconOptions.href || 'javascript:void(0)') + '"' + (iconOptions.href ? ' target="_blank"' : '') + '>' + iconOptions.title + '</a>' + '</li>');
                if (iconOptions.uniqCls && iconOptions.onclick) {
                  // $(document).on('click', '<selector>', callback(){...}) and
                  // $('body').on('click', '<selector>', callback(){...}) are generally equivalent
                  // and rather "$(document).on('click' ..." approach is more safe because that
                  // script can be placed even in <head> section, but some sites may have
                  // stopPropagation() like:
                  //     $("body").on("click", function(evt) {
                  //         evt.stopPropagation();
                  //         ...
                  //     }
                  // So, in those cases, delegating the event via "body" element works better
                  $('body').on('click', '.' + iconOptions.uniqCls, function (evt) {
                    evt.preventDefault(); // Useful in preventing the opening of a new tab in Firefox if the anchor-tag icon has target="_blank"
                    iconOptions.onclick(evt, editor, $divIcon);
                    var originalSpeed = $divIcon.tooltipster('option', 'speed');
                    $divIcon.tooltipster('option', 'speed', 0);
                    $divIcon.tooltipster('hide');
                    $divIcon.tooltipster('option', 'speed', originalSpeed);
                  });
                }
              });
              tooltipContent.push('</ul>');
              $divIcon.tooltipster({
                content: tooltipContent.join(''),
                contentAsHTML: true,
                side: ['top', 'bottom'],
                // https://github.com/iamceege/tooltipster/blob/3.3.0/js/jquery.tooltipster.js#L338
                theme: 'tooltipster-default magic-css-tooltipster',
                interactive: true,
                interactiveTolerance: 350,
                functionReady: function (instance, helper) {
                  setTimeout(async function () {
                    for (var i = 0; i < iconOptions.icons.length; i++) {
                      var ico = iconOptions.icons[i];
                      if (ico && ico.beforeShow) {
                        await ico.beforeShow(helper.origin, $(helper.tooltip), editor);
                      }
                    }
                    // The tooltip would have rendered in hidden mode, but its width might have changed
                    // due to some changes via .beforeShow(), so, we need to reposition it
                    $divIcon.tooltipster('reposition');
                  });
                }
              });
            };
          }
          var divIcon = document.createElement('div');
          divIcon.className = (iconOptions.cls || '') + ' ' + (iconOptions.uniqCls || '') + ' editor-icon';
          if (iconOptions.title) {
            divIcon.title = iconOptions.title;
          }
          if (iconOptions.href) {
            divIcon.innerHTML = '<a' + ' href="' + (iconOptions.href || 'javascript:void(0)') + '"' + (iconOptions.href ? ' target="_blank"' : '') + ' style="width:100%;height:100%;display:block;text-decoration:none;">&nbsp;</a>';
          }
          parentDivRightAligned.appendChild(divIcon);
          $(divIcon).click(function (evt) {
            if (!$(thisOb.container).hasClass('noclick')) {
              iconOptions.onclick && iconOptions.onclick(evt, thisOb, divIcon);
            }
          });
          iconOptions.afterrender && iconOptions.afterrender(thisOb, divIcon);
        });
      }

      // Recall text value from local storage
      // It would be done only when rememberText is true
      await thisOb.recallTextValue();
      var divContents = document.createElement('div');
      divContents.style.clear = 'both';
      divContents.className = 'raw-textarea-container';
      thisOb.container.appendChild(divContents);
      var textarea = document.createElement('textarea');
      thisOb.textarea = textarea;
      textarea.style.display = 'none';
      textarea.className = 'editor-editor';
      textarea.style.marginTop = '0';
      textarea.style.fontFamily = 'monospace';
      $(textarea).attr('spellcheck', 'false');
      textarea.style.minHeight = '1px'; // Fixes for issues where the site might have some custom CSS

      divContents.appendChild(textarea);
      var $textarea = $(textarea);
      if (rememberText) {
        $textarea.val(thisOb.getTextValue());
      }
      if (rememberDimensions) {
        textarea.style.width = (await thisOb.userPreference('ui-size-width')) + 'px';
        textarea.style.height = (await thisOb.userPreference('ui-size-height')) + 'px';
      } else {
        textarea.style.width = (await thisOb.defaultPreference('ui-size-width')) + 'px';
        textarea.style.height = (await thisOb.defaultPreference('ui-size-height')) + 'px';
      }
      if (parseInt(textarea.style.width, 10) < CONSTANTS.USE_NORMAL_SIZE_EDITOR) {
        thisOb.container.classList.add('magicss-editor-is-small');
      }
      if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_6__.myWin.flagEditorInExternalWindow) {
        // https://stackoverflow.com/questions/3437786/get-the-size-of-the-screen-current-web-page-and-browser-window/11744120#11744120
        const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        manageClassListForWidth({
          classList: thisOb.container.classList,
          width
        });
      } else {
        manageClassListForWidth({
          classList: thisOb.container.classList,
          width: parseInt(textarea.style.width, 10)
        });
      }
      var textareaWrapAttr = 'off';
      if (options.textareaWrapAttr) {
        textareaWrapAttr = options.textareaWrapAttr;
      }
      $textarea.attr('wrap', textareaWrapAttr);
      $textarea.attr('placeholder', thisOb.getOption('placeholder'));
      if (rememberText) {
        $textarea.keyup(async function () {
          await thisOb.setTextValue($textarea.val());
        });
      }
      if (runningInAndroidFirefox) {
        thisOb.container.style.padding = '0 12px 12px 12px';
      } else {
        thisOb.container.style.padding = '0 7px 7px 7px';
      }
      var disableResize = !!options.disableResize;
      if (!disableResize) {
        if (rememberDimensions) {
          thisOb.initialWidth = await thisOb.userPreference('ui-size-width');
          thisOb.initialHeight = await thisOb.userPreference('ui-size-height');
        } else {
          thisOb.initialWidth = await thisOb.defaultPreference('ui-size-width');
          thisOb.initialHeight = await thisOb.defaultPreference('ui-size-height');
        }
      } else {
        textarea.style.resize = 'none';
      }
      (function () {
        if (typeof options.footer === 'function') {
          var $footer = options.footer($, thisOb);
          $(thisOb.container).append($footer);
        }
      })();

      // Close on Escape key press
      (function () {
        var closeOnEscapeKey = true;
        if (options.closeOnEscapeKey === false || options.closeOnEscapeKey === null) {
          closeOnEscapeKey = false;
        }
        if (closeOnEscapeKey) {
          $textarea.keydown(async function (evt) {
            var keyCode = evt.keyCode || evt.which;
            if (keyCode === 27) {
              await thisOb.hide();
            }
          });
        }
      })();
      await thisOb._createSyntaxHighlighting();

      // Note: For editor in external window, it was observed that mouse wheel scrolling was getting blocked due
      //       to the following code. Didn't analyze the issue in the code below, but, since we don't need this
      //       code for external window, we are skipping its execution in that case.
      if (!_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_6__.myWin.flagEditorInExternalWindow) {
        // Prevent scrolling on page body when mouse is scrolling '.section.tags .section-contents'
        $(thisOb.container).bind('mousewheel DOMMouseScroll', function (e) {
          var that = this,
            $that = $(that),
            delta = e.originalEvent.wheelDelta || -e.originalEvent.detail,
            vScrollBar;
          vScrollBar = $that.find('.CodeMirror-vscrollbar');
          if (delta > 0) {
            if (vScrollBar[0].scrollTop === 0) {
              e.preventDefault();
            }
          } else {
            var originalScroll = vScrollBar.scrollTop();
            vScrollBar.scrollTop(originalScroll + 1);
            var newScroll = vScrollBar.scrollTop();
            vScrollBar.scrollTop(originalScroll);
            if (originalScroll === newScroll) {
              e.preventDefault();
            }
          }
        });
      }
    }
    async initialize(options) {
      var thisOb = this;
      if (!thisOb.container) {
        try {
          console.warn('You might have used initialize() before using create().');
        } catch (e) {
          // do nothing
        }
      }
      var rememberDimensions = thisOb.options.rememberDimensions;
      if (options.cls) {
        $(thisOb.container).addClass(options.cls);
      }
      $(thisOb.container).addClass('magic-css-container');
      $(thisOb.container).addClass('notranslate'); // https://stackoverflow.com/questions/12238396/how-to-disable-google-translate-from-html-in-chrome#comment28428600_12238414
      thisOb.container.style.position = 'fixed';
      if (rememberDimensions) {
        thisOb.container.style.top = (await thisOb.userPreference('ui-position-top')) + 'px';
        thisOb.container.style.left = (await thisOb.userPreference('ui-position-left')) + 'px';
      } else {
        thisOb.container.style.top = '20px';
        thisOb.container.style.left = '20px';
      }
      thisOb.container.style.width = 'auto';
      thisOb.container.style.height = 'auto';
      thisOb.container.style.borderRadius = '5px';
      thisOb.container.style.zIndex = '2147483600';
      thisOb.container.style.backgroundColor = 'rgba(' + options.bgColor + ')';
    }
    async triggerEvent(eventName, config) {
      var thisOb = this;
      var events = thisOb.options.events;
      switch (eventName) {
        case 'launched':
          if (events.launched) {
            await events.launched(thisOb);
          }
          break;
        case 'reInitialized':
          if (events.reInitialized) {
            await events.reInitialized(thisOb, config);
          }
          break;
        case 'beforeshow':
          if (events.beforeshow) {
            await events.beforeshow(thisOb);
          }
          break;
        case 'aftershow':
          if (events.aftershow) {
            events.aftershow(thisOb);
          }
          break;
        case 'beforehide':
          if (events.beforehide) {
            events.beforehide(thisOb);
          }
          break;
        case 'afterhide':
          if (events.afterhide) {
            events.afterhide(thisOb);
          }
          break;
        case 'onClose':
          if (events.onClose) {
            events.onClose(thisOb, config);
          }
          break;
        case 'clear':
          if (events.clear) {
            events.clear(thisOb);
          }
          await thisOb.triggerEvent('testfortextchange');
          break;
        case 'testfortextchange':
          await thisOb.triggerEvent('textchange');
          break;
        case 'delayedtestfortextchange':
          await thisOb.triggerEvent('delayedtextchange');
          break;
        case 'delayedcursormove':
          if (events.delayedcursormove) {
            events.delayedcursormove(thisOb);
          }
          break;
        case '_delayedcursorprobablymoved':
          if (thisOb.isVisible()) {
            if (thisOb.hasCursorMovedFromPreviousPosition()) {
              await thisOb.triggerEvent('delayedcursormove');
            }
            thisOb.recordCursorPosition();
          }
          break;
        case 'textchange':
          if (events.textchange) {
            events.textchange(thisOb);
          }
          break;
        case 'delayedtextchange':
          if (events.delayedtextchange) {
            await events.delayedtextchange(thisOb);
          }
          break;
        case 'keyup':
          if (events.keyup) {
            events.keyup(thisOb);
          }
          await thisOb.triggerEvent('testfortextchange');
          break;
        case 'delayedkeyup':
          if (events.delayedkeyup) {
            events.delayedkeyup(thisOb);
          }
          await thisOb.triggerEvent('delayedtestfortextchange');
          await thisOb.triggerEvent('_delayedcursorprobablymoved');
          break;
        case 'beforeInstantiatingCodeMirror':
          if (events.beforeInstantiatingCodeMirror) {
            await events.beforeInstantiatingCodeMirror(thisOb);
          }
          break;
        // There is a chance that something is problematic in focus behavior
        case 'problematicFocusDetected':
          if (events.problematicFocusDetected) {
            events.problematicFocusDetected(thisOb);
          }
          break;
        default:
          console.warn('An unexpected event was attempted to be triggered: ' + eventName);
      }
    }
    getCursorPosition() {
      return this.cm.getCursor('start');
    }
    setCursorPosition(position) {
      return this.cm.setCursor(position);
    }
    cmInputFieldHasFocus() {
      return this.cm.getInputField() === document.activeElement;
    }
    recordCursorPosition() {
      this.previousCodeMirrorPosition = this.getCursorPosition();
    }
    hasCursorMovedFromPreviousPosition() {
      var thisOb = this,
        previousCodeMirrorPosition = thisOb.previousCodeMirrorPosition || {},
        currentCursorPosition = thisOb.getCursorPosition();
      if (currentCursorPosition.line === previousCodeMirrorPosition.line && currentCursorPosition.ch === previousCodeMirrorPosition.ch) {
        return false;
      }
      return true;
    }
    focus() {
      var cm = this.cm;
      // TODO:
      // Previously, we were setting the focus on textarea after a delay, because
      // of the order of rendering and positioning of the container element.
      // Ideally (not necessarily practically), the code should be (without timeout).
      // Review and clear the setTimeout
      setTimeout(function () {
        cm.focus();
      }, 0);
    }
    focusTextComponent(options) {
      var thisOb = this,
        line = 0,
        ch = 0;
      if (options) {
        line = options.line || 0;
        ch = options.ch || 0;
      }
      thisOb.cm.setCursor({
        line: line,
        ch: ch
      });
    }
    async recallTextValue() {
      if (this.options.rememberText) {
        this.textValue = await this.userPreference('textarea-value');
      }
    }
    getTextValue() {
      return this.textValue || '';
    }
    async setTextValue(val) {
      if (this.options && this.options.rememberText) {
        await this.userPreference('textarea-value', val);
      }
      this.textValue = val;
      var events = (this.options || {}).events || {};
      if (events.onSetTextValue) {
        events.onSetTextValue(val);
      }
      return this;
    }
    getTextValueForNLines(line) {
      var textValue = this.getTextValue(),
        delimiter = '\n',
        start = line,
        tokens = textValue.split(delimiter).slice(0, start),
        result = tokens.join(delimiter);
      return result;
    }
    async savePosition(options) {
      await this.userPreference('ui-position-top', options.top);
      await this.userPreference('ui-position-left', options.left);
    }
    async getDimensions() {
      return {
        width: await this.userPreference('ui-size-width'),
        height: await this.userPreference('ui-size-height')
      };
    }
    async saveDimensions(options) {
      await this.userPreference('ui-size-width', options.width);
      await this.userPreference('ui-size-height', options.height);
    }
    async setTextContainerDimensions(options, propagateTo) {
      await this.saveDimensions(options);
      if (propagateTo && propagateTo.propagateTo === 'codemirror') {
        this.setCodeMirrorDimensions(options);
      }
    }
    async hide() {
      await this.triggerEvent('beforehide');
      this.container.style.display = 'none';
      this.hidden = true;
      await this.triggerEvent('afterhide');
    }
    async show() {
      await this.triggerEvent('beforeshow');
      this.container.style.display = '';
      this.hidden = false;
      this.focus();
      await this.triggerEvent('aftershow');
    }
    isVisible() {
      return this.hidden ? false : true;
    }
    splitTextByCursor() {
      var cm = this.cm,
        strBeforeCursor = cm.getRange({
          line: 0,
          ch: 0
        }, cm.getCursor('start')),
        strAfterCursor = cm.getValue().substr(strBeforeCursor.length);
      return {
        strBeforeCursor: strBeforeCursor,
        strAfterCursor: strAfterCursor
      };
    }
    setCodeMirrorValue(val) {
      this.cm.setValue(val);
    }
    setCodeMirrorDimensions(options) {
      this.cm.setSize(options.width, options.height);
    }
    async reInitCodeMirror() {
      var thisOb = this;
      thisOb.setCodeMirrorValue(await thisOb.getTextValue());
      thisOb.setCodeMirrorDimensions(await thisOb.getDimensions());
      var $that = $(thisOb.container);
      $that.addClass('mode-codeMirror');
      return this;
    }
    setCursor(cursorPosition, options) {
      options = options || {};
      if (options.pleaseIgnoreCursorActivity) {
        this.pleaseIgnoreCursorActivity = true;
      }
      this.cm.setCursor(cursorPosition);
      if (options.pleaseIgnoreCursorActivity) {
        this.pleaseIgnoreCursorActivity = false;
      }
    }
    async reInitTextComponent(options) {
      options = options || {};
      if (options.pleaseIgnoreCursorActivity) {
        this.pleaseIgnoreCursorActivity = true;
      }
      await this.reInitCodeMirror();
      if (options.pleaseIgnoreCursorActivity) {
        this.pleaseIgnoreCursorActivity = false;
      }
      return this;
    }
  }
  // TODO:
  // Move out the default preferences of Magic CSS into magicss.js
  Editor.defaultPreferences = {
    'file-to-edit': '',
    // TODO: Move this into Magic CSS code

    'language-mode': 'css',
    'use-css-linting': 'no',
    'disable-styles': 'no',
    'apply-styles-automatically': 'no',
    'watching-css-files': 'no',
    'use-tab-for-indentation': 'no',
    'indentation-spaces-count': '4',
    [USER_PREFERENCE_AUTOCOMPLETE_SELECTORS]: 'yes',
    [USER_PREFERENCE_AUTOCOMPLETE_CSS_PROPERTIES_AND_VALUES]: 'yes',
    [USER_PREFERENCE_HIDE_ON_PAGE_MOUSEOUT]: 'no',
    [USER_PREFERENCE_USE_CUSTOM_FONT_SIZE]: 'no',
    [USER_PREFERENCE_FONT_SIZE_IN_PX]: '12',
    'syntax-highlighting': 'yes',
    'show-line-numbers': 'no',
    'enable-line-wrap': 'no',
    'textarea-value': '',
    'ui-position-left': 20,
    'ui-position-top': 20,
    // Previously, we were using:
    //     'ui-size-width': 300,
    //     'ui-size-height': 250
    // But, some of the advertisement blocking extensions have logic like:
    //     [style*="width:300px; height:250px;"],
    //     [style*="width: 300px; height: 250px;"] {
    //         display: none !important;
    //     }
    // For example, one (or more) of the lists in uBlock Origin and Adblock Plus
    // was applying a style like the above for the page:
    //     https://www.msn.com/en-ae/
    // Now, we use 301x249 as the default size to avoid that
    'ui-size-width': CONSTANTS.EDITOR_DEFAULT_WIDTH,
    'ui-size-height': CONSTANTS.EDITOR_DEFAULT_HEIGHT
  };
  window.Editor = Editor;
  try {
    (0,_utils_waterfall_js__WEBPACK_IMPORTED_MODULE_2__.waterfall)([
    // If there is an error, it would get caught in the first function itself
    // With the waterfall() function being used currently, errors in any of
    // the upcoming functions are not caught or reported in the final callback
    function (callback) {
      // Note: In most of the practical scenarios, by the time the execution reaches here,
      // "runMigration()" call from elsewhere would have already completed. So, eventually,
      // this piece of code shouldn't live here
      setTimeout(async function () {
        await (0,_migrate_storage_js__WEBPACK_IMPORTED_MODULE_3__.runMigration)();
        callback(null);
      });
    }, function (callback) {
      if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_6__.myWin.flagEditorInExternalWindow) {
        whichStoreToUse = 'sessionStorage';
        return callback(null);
      }

      // TODO: The check for storage mode should be moved to the beginning of execution of this file
      chromeStorageForExtensionData.get(USER_PREFERENCE_STORAGE_MODE, function (values) {
        if (values && values[USER_PREFERENCE_STORAGE_MODE] === 'localStorage') {
          whichStoreToUse = 'localStorage';
        } else if (values && values[USER_PREFERENCE_STORAGE_MODE] === 'chrome.storage.sync') {
          whichStoreToUse = 'chrome.storage.sync';
        } else {
          whichStoreToUse = 'chrome.storage.local';
        }
        callback(null);
      });
    }, function (callback) {
      chromeStorageForExtensionData.get('default-language-mode', function (values) {
        if (values && values['default-language-mode'] === 'less') {
          Editor.defaultPreferences['language-mode'] = 'less';
        } else if (values && values['default-language-mode'] === 'sass') {
          Editor.defaultPreferences['language-mode'] = 'sass';
        }
        callback(null);
      });
    }, function (callback) {
      chromeStorageForExtensionData.get(USER_PREFERENCE_AUTOCOMPLETE_SELECTORS, function (values) {
        if (values && values[USER_PREFERENCE_AUTOCOMPLETE_SELECTORS] === 'no') {
          Editor.defaultPreferences[USER_PREFERENCE_AUTOCOMPLETE_SELECTORS] = 'no';
        }
        callback(null);
      });
    }, function (callback) {
      chromeStorageForExtensionData.get(USER_PREFERENCE_AUTOCOMPLETE_CSS_PROPERTIES_AND_VALUES, function (values) {
        if (values && values[USER_PREFERENCE_AUTOCOMPLETE_CSS_PROPERTIES_AND_VALUES] === 'no') {
          Editor.defaultPreferences[USER_PREFERENCE_AUTOCOMPLETE_CSS_PROPERTIES_AND_VALUES] = 'no';
        }
        callback(null);
      });
    }, function (callback) {
      chromeStorageForExtensionData.get(USER_PREFERENCE_HIDE_ON_PAGE_MOUSEOUT, function (values) {
        if (values && values[USER_PREFERENCE_HIDE_ON_PAGE_MOUSEOUT] === 'yes') {
          Editor.defaultPreferences[USER_PREFERENCE_HIDE_ON_PAGE_MOUSEOUT] = 'yes';
        }
        callback(null);
      });
    }, function (callback) {
      chromeStorageForExtensionData.get('use-tab-for-indentation', function (values) {
        if (values && values['use-tab-for-indentation'] === 'yes') {
          Editor.defaultPreferences['use-tab-for-indentation'] = 'yes';
        }
        callback(null);
      });
    }, function (callback) {
      chromeStorageForExtensionData.get('indentation-spaces-count', function (values) {
        var value = parseInt(values && values['indentation-spaces-count'], 10);
        if (!isNaN(value)) {
          Editor.defaultPreferences['indentation-spaces-count'] = '' + value;
        }
        callback(null);
      });
    }, function (callback) {
      chromeStorageForExtensionData.get(USER_PREFERENCE_USE_CUSTOM_FONT_SIZE, function (values) {
        if (values && values[USER_PREFERENCE_USE_CUSTOM_FONT_SIZE] === 'yes') {
          Editor.defaultPreferences[USER_PREFERENCE_USE_CUSTOM_FONT_SIZE] = 'yes';
        }
        callback(null);
      });
    }, function (callback) {
      chromeStorageForExtensionData.get(USER_PREFERENCE_FONT_SIZE_IN_PX, function (values) {
        var value = parseInt(values && values[USER_PREFERENCE_FONT_SIZE_IN_PX], 10);
        if (!isNaN(value)) {
          Editor.defaultPreferences[USER_PREFERENCE_FONT_SIZE_IN_PX] = '' + value;
        }
        callback(null);
      });
    }, function (callback) {
      chromeStorageForExtensionData.get('use-css-linting', function (values) {
        if (values && values['use-css-linting'] === 'yes') {
          Editor.defaultPreferences['use-css-linting'] = 'yes';
        }
        callback(null);
      });
    }], function () {
      Editor.usable = true;
    });
  } catch (e) {
    Editor.usable = true;
  }
})(jQuery);

/***/ }),

/***/ "./scripts/magicss/generate-selector.js":
/*!**********************************************!*\
  !*** ./scripts/magicss/generate-selector.js ***!
  \**********************************************/
/***/ (() => {

/* global jQuery */

(function () {
  var $ = jQuery;
  var tokenSetMayUseProperty = function (tokenSet, options) {
    var whichProperty = options.whichProperty;
    var skipUseItCheckForTokenCls = options.skipUseItCheckForTokenCls;
    if (whichProperty === 'class') {
      var numberOfMatches = 0;
      for (var i = 0; i < (tokenSet.classes || []).length; i++) {
        var tokenCls = tokenSet.classes[i];
        if (tokenCls === skipUseItCheckForTokenCls) {
          // do nothing
        } else {
          if (tokenCls.useIt) {
            numberOfMatches++;
          }
        }
      }
      return numberOfMatches;
    } else if (whichProperty === 'id') {
      return (tokenSet.id || {}).useIt ? 1 : 0;
    } else if (whichProperty === 'tag') {
      return (tokenSet.tag || {}).useIt ? 1 : 0;
    } else {
      console.log('Error: An unexpected value was passed to tokenSetMayUseProperty()');
    }
  };
  var tokenSetToMiniSelector = function (tokenSet) {
    var miniSelector = '';
    var tag = tokenSet.tag;
    if (tag && tag.useIt) {
      miniSelector += tag.value;
    }
    var id = tokenSet.id;
    if (id && id.useIt) {
      miniSelector += id.value;
    }
    var classes = tokenSet.classes;
    if (classes) {
      classes.forEach(function (cls) {
        if (cls.useIt) {
          miniSelector += cls.value;
        }
      });
    }
    var descendentSelector = tokenSet.descendentSelector;
    if (descendentSelector && descendentSelector.useIt) {
      miniSelector += descendentSelector.value;
    }
    return miniSelector;
  };
  var tokenSetsIntoSelector = function (tokenSets) {
    var selector = '';
    var miniSelectors = [];
    tokenSets.forEach(function (tokenSet) {
      var miniSelector = tokenSetToMiniSelector(tokenSet);
      if (miniSelector) {
        miniSelectors.push(miniSelector);
      }
    });
    for (var i = 0; i < miniSelectors.length; i++) {
      if (miniSelectors[i] === '>' && miniSelectors[i - 1] === '>') {
        miniSelectors[i - 1] = null;
      }
    }
    miniSelectors = miniSelectors.filter(function (n) {
      return n !== null;
    });
    selector = miniSelectors.join(' ');
    return selector;
  };
  var reduceTokenSets = function (tokenSets, options) {
    var mode = options.mode;
    var receivedSelector = tokenSetsIntoSelector(tokenSets);
    var $elementsMatchingReceivedSelector = $(receivedSelector);
    var countOfElementsMatchingReceivedSelector = $elementsMatchingReceivedSelector.length;
    var lastOperationWasWrong = function () {};
    var lastOperationWasCorrect = function () {};
    var i, limit;
    limit = tokenSets.length;
    for (i = 0; i < limit; i++) {
      var tokenSet = tokenSets[i];
      if (mode === 'tag') {
        if (tokenSet.tag && tokenSet.tag.useIt === 'not-specified') {
          if (i === limit - 1 && !tokenSetMayUseProperty(tokenSet, {
            whichProperty: 'id'
          }) && !tokenSetMayUseProperty(tokenSet, {
            whichProperty: 'class'
          })) {
            tokenSet.tag.useIt = true;
            break;
          }
          tokenSet.tag.useIt = null;
          lastOperationWasWrong = function () {
            var tag = tokenSet.tag;
            return function () {
              tag.useIt = true;
            };
          }();
          lastOperationWasCorrect = function () {
            var tag = tokenSet.tag;
            return function () {
              tag.useIt = false;
            };
          }();
          break;
        }
      } else if (mode === 'id') {
        if (tokenSet.id && tokenSet.id.useIt === 'not-specified') {
          if (i === limit - 1 && !tokenSetMayUseProperty(tokenSet, {
            whichProperty: 'tag'
          }) && !tokenSetMayUseProperty(tokenSet, {
            whichProperty: 'class'
          })) {
            tokenSet.id.useIt = true;
            break;
          }
          tokenSet.id.useIt = null;
          lastOperationWasWrong = function () {
            var id = tokenSet.id;
            return function () {
              id.useIt = true;
            };
          }();
          lastOperationWasCorrect = function () {
            var id = tokenSet.id;
            return function () {
              id.useIt = false;
            };
          }();
          break;
        }
      } else if (mode === 'class') {
        if (tokenSet.classes) {
          for (var j = 0; j < tokenSet.classes.length; j++) {
            var tokenCls = tokenSet.classes[j];
            if (tokenCls && tokenCls.useIt === 'not-specified') {
              if (i === limit - 1 && !tokenSetMayUseProperty(tokenSet, {
                whichProperty: 'tag'
              }) && !tokenSetMayUseProperty(tokenSet, {
                whichProperty: 'id'
              })) {
                if (!tokenSetMayUseProperty(tokenSet, {
                  whichProperty: 'class',
                  skipUseItCheckForTokenCls: tokenCls
                })) {
                  tokenCls.useIt = true;
                  break;
                }
              }
              tokenCls.useIt = null;
              lastOperationWasWrong = function () {
                var cls = tokenCls;
                return function () {
                  cls.useIt = true;
                };
              }();
              lastOperationWasCorrect = function () {
                var cls = tokenCls;
                return function () {
                  cls.useIt = false;
                };
              }();
              break;
            }
          }
          if (j === tokenSet.classes.length) {// If the loop completed
            // do nothing
          } else {
            break;
          }
        }
      } else if (mode === 'descendentSelector') {
        if (tokenSet.descendentSelector && tokenSet.descendentSelector.useIt === 'not-specified') {
          tokenSet.descendentSelector.useIt = null;
          lastOperationWasWrong = function () {
            var descendentSelector = tokenSet.descendentSelector;
            return function () {
              descendentSelector.useIt = true;
            };
          }();
          lastOperationWasCorrect = function () {
            var descendentSelector = tokenSet.descendentSelector;
            return function () {
              descendentSelector.useIt = false;
            };
          }();
          break;
        }
      } else {
        console.log('Error: Unexpected mode passed for reduceTokenSets()');
      }
    }
    if (i === limit) {// If the loop completed
      // do nothing
    } else {
      var reducedSelector = tokenSetsIntoSelector(tokenSets);
      var $elementsMatchingReducedSelector = $(reducedSelector);
      var countOfElementsMatchingReducedSelector = $elementsMatchingReducedSelector.length;
      if (countOfElementsMatchingReducedSelector > countOfElementsMatchingReceivedSelector || !$elementsMatchingReceivedSelector.is($elementsMatchingReducedSelector)) {
        lastOperationWasWrong();
      } else {
        lastOperationWasCorrect();
      }
      reduceTokenSets(tokenSets, options);
    }
    return tokenSets;
  };
  var selectorIntoTokenSets = function (selector) {
    var miniSelectors = selector.split(' ');
    miniSelectors.forEach(function (miniSelector, index) {
      var tagPart = null,
        idPart = null,
        clsParts = null,
        descendentSelector = null;
      var idMatch = miniSelector.match(/#[^.]*/);
      if (idMatch && idMatch.length) {
        idPart = idMatch[0];
      }
      var clsMatch = miniSelector.match(/\.[^.]*/g);
      if (clsMatch && clsMatch.length) {
        clsParts = clsMatch;
      }
      if (miniSelector === '>') {
        descendentSelector = miniSelector;
      } else {
        var tagMatch = miniSelector.match(/[^.#]*/);
        if (tagMatch && tagMatch.length) {
          tagPart = tagMatch[0];
        }
      }
      miniSelectors[index] = {
        tag: tagPart,
        id: idPart,
        classes: clsParts,
        descendentSelector: descendentSelector
      };
    });
    miniSelectors.forEach(function (miniSelector) {
      if (miniSelector.tag) {
        miniSelector.tag = {
          useIt: 'not-specified',
          value: miniSelector.tag
        };
      }
      if (miniSelector.id) {
        miniSelector.id = {
          useIt: 'not-specified',
          value: miniSelector.id
        };
      }
      if (miniSelector.classes) {
        miniSelector.classes.forEach(function (cls, index) {
          miniSelector.classes[index] = {
            useIt: 'not-specified',
            value: miniSelector.classes[index]
          };
        });
      }
      if (miniSelector.descendentSelector) {
        miniSelector.descendentSelector = {
          useIt: 'not-specified',
          value: '>'
        };
      }
    });
    var tokenSets = miniSelectors;
    return tokenSets;
  };
  var generateFullSelector = function (el, options) {
    options = options || {};
    var skipClass = options.skipClass || null;
    var useDescendentSyntax = options.useDescendentSyntax === undefined ? true : options.useDescendentSyntax;
    var useDescendentForLastSelector = options.useDescendentForLastSelector;
    var sortClasses = options.sortClasses;
    var reverseClasses = options.reverseClasses;
    var selector = '';
    var currentNode = el;
    while (currentNode && currentNode.tagName) {
      var selectorForThisNode = '';
      selectorForThisNode = currentNode.tagName.toLowerCase();
      var id = currentNode.getAttribute('id'); // An element like <input name="id"> might be returned as currentNode.id (for example when the <input> element belongs to a <form> element)
      if (id) {
        selectorForThisNode += '#' + CSS.escape(id);
      }
      var className = (typeof currentNode.className === 'string' ? currentNode.className : (currentNode.className || {}).baseVal).trim();
      if (skipClass) {
        className = className.replace(skipClass, '').trim();
      }
      if (className) {
        var classes = className.replace(/\s+/g, ' ').split(' ');
        var classesWhichNeedEscaping = [],
          classesWhichDoNotNeedEscaping = [];
        classes.forEach(function (item) {
          if (item === CSS.escape(item)) {
            classesWhichDoNotNeedEscaping.push(item);
          } else {
            classesWhichNeedEscaping.push(CSS.escape(item));
          }
        });

        // Sometimes the classes which come later are more important, sometimes the classes which come earlier, otherwise alphabetical order is also an intuitive option
        if (sortClasses) {
          classesWhichNeedEscaping = classesWhichNeedEscaping.sort();
          classesWhichDoNotNeedEscaping = classesWhichDoNotNeedEscaping.sort();
        }
        if (reverseClasses) {
          classesWhichNeedEscaping = classesWhichNeedEscaping.reverse();
          classesWhichDoNotNeedEscaping = classesWhichDoNotNeedEscaping.reverse();
        }
        classes = classesWhichNeedEscaping.concat(classesWhichDoNotNeedEscaping);
        classes = '.' + classes.join('.');
        selectorForThisNode += classes;
      }
      if (selector) {
        if (useDescendentSyntax) {
          selector = selectorForThisNode + ' > ' + selector;
        } else {
          if (useDescendentForLastSelector && el.parentNode === currentNode) {
            selector = selectorForThisNode + ' > ' + selector;
          } else {
            selector = selectorForThisNode + ' ' + selector;
          }
        }
      } else {
        selector = selectorForThisNode;
      }
      currentNode = currentNode.parentNode;
    }
    return selector;
  };
  window.generateFullSelector = generateFullSelector;
  var generateSelector = function (el, options) {
    options = options || {};
    var fullSelector = generateFullSelector(el, {
      skipClass: options.skipClass,
      useDescendentSyntax: true,
      useDescendentForLastSelector: true,
      sortClasses: options.sortClasses,
      reverseClasses: options.reverseClasses
    });
    var selector = fullSelector,
      tokenSets = selectorIntoTokenSets(selector),
      reducedTokenSets = tokenSets;
    reducedTokenSets = reduceTokenSets(reducedTokenSets, {
      mode: 'descendentSelector'
    });
    reducedTokenSets = reduceTokenSets(reducedTokenSets, {
      mode: 'tag'
    });
    reducedTokenSets = reduceTokenSets(reducedTokenSets, {
      mode: 'id'
    });
    reducedTokenSets = reduceTokenSets(reducedTokenSets, {
      mode: 'class'
    });
    var reducedSelector = tokenSetsIntoSelector(reducedTokenSets);
    selector = reducedSelector;
    return selector;
  };
  window.generateSelector = generateSelector;
})();

/***/ }),

/***/ "./scripts/magicss/magicss.js":
/*!************************************!*\
  !*** ./scripts/magicss/magicss.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _utils_i18n_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/i18n.js */ "./scripts/utils/i18n.js");
/* harmony import */ var _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/alertNote.js */ "./scripts/utils/alertNote.js");
/* harmony import */ var _utils_delayFunctionUntilTestFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/delayFunctionUntilTestFunction.js */ "./scripts/utils/delayFunctionUntilTestFunction.js");
/* harmony import */ var _utils_minifyCss_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/minifyCss.js */ "./scripts/utils/minifyCss.js");
/* harmony import */ var _utils_beautifyCss_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/beautifyCss.js */ "./scripts/utils/beautifyCss.js");
/* harmony import */ var _utils_sassToCss_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/sassToCss.js */ "./scripts/utils/sassToCss.js");
/* harmony import */ var _utils_lessToCss_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/lessToCss.js */ "./scripts/utils/lessToCss.js");
/* harmony import */ var _utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/StyleTag.js */ "./scripts/utils/StyleTag.js");
/* harmony import */ var _appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../appUtils/myWin.js */ "./scripts/appUtils/myWin.js");
/* harmony import */ var _chrome_extension_lib_ext_lib_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../chrome-extension-lib/ext-lib.js */ "./scripts/chrome-extension-lib/ext-lib.js");
/* harmony import */ var _3rdparty_source_map_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../3rdparty/source-map.js */ "./scripts/3rdparty/source-map.js");
/* harmony import */ var _3rdparty_source_map_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_source_map_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./metrics/sendMessageForMetrics.js */ "./scripts/magicss/metrics/sendMessageForMetrics.js");
/* global jQuery, chrome, CodeMirror, io, toastr */

// TODO: Remove turning off of this rule (require-atomic-updates)
/* eslint require-atomic-updates: "off" */

/*! https://webextensions.org/ by Priyank Parashar | MIT license */














// TODO: Share constants across files (like magicss.js, editor.js and options.js) (probably keep them in a separate file as global variables)
var USER_PREFERENCE_AUTOCOMPLETE_SELECTORS = 'autocomplete-css-selectors',
  USER_PREFERENCE_AUTOCOMPLETE_CSS_PROPERTIES_AND_VALUES = 'autocomplete-css-properties-and-values',
  USER_PREFERENCE_USE_CUSTOM_FONT_SIZE = 'use-custom-font-size',
  USER_PREFERENCE_FONT_SIZE_IN_PX = 'font-size-in-px',
  USER_PREFERENCE_THEME = 'theme',
  USER_PREFERENCE_HIDE_ON_PAGE_MOUSEOUT = 'hide-on-page-mouseout';
var USER_PREFERENCE_LAST_APPLIED_CSS = 'last-applied-css',
  USER_PREFERENCE_USE_CSS_LINTING = 'use-css-linting',
  USER_PREFERENCE_SHOW_LINE_NUMBERS = 'show-line-numbers',
  USER_PREFERENCE_ENABLE_LINE_WRAP = 'enable-line-wrap',
  USER_PREFERENCE_APPLY_STYLES_AUTOMATICALLY = 'apply-styles-automatically',
  USER_PREFERENCE_LANGUAGE_MODE_NON_FILE = 'language-mode-non-file',
  USER_PREFERENCE_LANGUAGE_MODE = 'language-mode',
  USER_PREFERENCE_TEXTAREA_VALUE = 'textarea-value',
  USER_PREFERENCE_DISABLE_STYLES = 'disable-styles',
  USER_PREFERENCE_USE_SASS_SYNTAX = 'use-sass-syntax';
var const_rateUsUsageCounterFrom = 20,
  const_rateUsUsageCounterTo = 100;
var tabId = function () {
  const urlParams = new URLSearchParams(window.location.search),
    tabId = urlParams.get('tabId');
  return parseInt(tabId);
}();

// https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid/2117523#2117523
var uuidv4 = function () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
      v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
};

// TODO: Handle more such unrecoverable cases through this function
var handleUnrecoverableError = function (e) {
  // Kind of HACK: Show note after a timeout, otherwise in a particular case with loading SASS, the note about
  //               matching existing selector might open up and override this
  //               and trying to solve it without timeout would be a bit tricky because currently, in CodeMirror, the select event
  //               always gets fired
  setTimeout(function () {
    // Note: Using console.trace(), rather than console.error() or console.warn() to mitigate those from showing up
    //       in the section for the extension at chrome://extensions/ (useful/applicable when working with unpacked
    //       extension mode)
    if (e.message === 'Extension context invalidated.') {
      console.info('An error was detected by Magic CSS!');
      console.trace(e);
      console.info('Warning: It appears that the Magic CSS extension has been updated or removed.\nYou may need to reload webpage & Magic CSS and try again.');
      (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Warning: It appears that the Magic CSS extension has been updated or removed.<br />You may need to reload webpage & Magic CSS and try again.', 10000);
    } else {
      console.info('An error was detected by Magic CSS!');
      console.trace(e);
      (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Error! Unexpected error encountered by Magic CSS extension.<br />You may need to reload webpage & Magic CSS and try again.', 10000);
    }
  }, 0);
};
var isFeatureEnabled = function (enabledOrConditions) {
  let flag = false;
  const instanceUuid = window.instanceUuid;
  const basisNumber = window.instanceBasisNumber;
  if (enabledOrConditions === true) {
    flag = true;
  } else if (Array.isArray(enabledOrConditions)) {
    const conditions = enabledOrConditions;
    for (const condition of conditions) {
      if (Array.isArray(condition)) {
        const [from, to] = condition;
        if (from <= basisNumber && basisNumber <= to) {
          flag = true;
          break;
        }
      } else if (typeof condition === 'string') {
        if (instanceUuid.indexOf(condition) >= 0) {
          flag = true;
          break;
        }
      }
    }
  }
  return flag;
};
window.magicssHostSessionUuid = window.magicssHostSessionUuid || function () {
  const urlParams = new URLSearchParams(window.location.search),
    magicssHostSessionUuid = urlParams.get('magicssHostSessionUuid');
  return magicssHostSessionUuid;
}() || uuidv4();
if (!window.loadedConfigFromBrowserStorage) {
  const loadedConfigFromBrowserStorage = {};
  window.loadedConfigFromBrowserStorage = loadedConfigFromBrowserStorage;
  setTimeout(async function () {
    const chromeStorageForExtensionData = chrome.storage.sync || chrome.storage.local;
    const chromeStorageForExtensionDataGet = async function (key) {
      return new Promise(resolve => {
        chromeStorageForExtensionData.get(key, function (values) {
          resolve(values && values[key]);
        });
      });
    };
    const USER_PREFERENCE_NOUN_PROJECT_API_ACCESS_KEY = 'noun-project-api-access-key';
    const USER_PREFERENCE_NOUN_PROJECT_API_SECRET = 'noun-project-api-secret';
    loadedConfigFromBrowserStorage[USER_PREFERENCE_NOUN_PROJECT_API_ACCESS_KEY] = String((await chromeStorageForExtensionDataGet(USER_PREFERENCE_NOUN_PROJECT_API_ACCESS_KEY)) || '');
    loadedConfigFromBrowserStorage[USER_PREFERENCE_NOUN_PROJECT_API_SECRET] = String((await chromeStorageForExtensionDataGet(USER_PREFERENCE_NOUN_PROJECT_API_SECRET)) || '');
  });
}
var loadIfNotAvailable = async function (dependencyToLoad) {
  const pathDist = 'dist/',
    pathScripts = 'scripts/',
    path3rdparty = pathScripts + '3rdparty/';
  if (dependencyToLoad === 'less') {
    if (typeof window.less === 'undefined') {
      if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.treatAsNormalWebpage) {
        const [err] = await _chrome_extension_lib_ext_lib_js__WEBPACK_IMPORTED_MODULE_9__.extLib.loadJsCssAsync({
          // eslint-disable-line no-unused-vars
          treatAsNormalWebpage: true,
          source: path3rdparty + 'basic-less-with-sourcemap-support.browserified.js'
        });
      } else {
        await chromeRuntimeMessageToBackgroundScript({
          type: 'magicss-dependency',
          subType: 'load-dependency',
          payload: path3rdparty + 'basic-less-with-sourcemap-support.browserified.js'
        });
      }
    }
    return window.less;
  } else if (dependencyToLoad === 'sass') {
    if (typeof window.Sass === 'undefined') {
      if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.treatAsNormalWebpage) {
        const [err] = await _chrome_extension_lib_ext_lib_js__WEBPACK_IMPORTED_MODULE_9__.extLib.loadJsCssAsync({
          // eslint-disable-line no-unused-vars
          treatAsNormalWebpage: true,
          source: path3rdparty + 'sass/sass.sync.min.js'
        });
      } else {
        await chromeRuntimeMessageToBackgroundScript({
          type: 'magicss-dependency',
          subType: 'load-dependency',
          payload: path3rdparty + 'sass/sass.sync.min.js'
        });
      }
    }
    return window.Sass;
  } else if (dependencyToLoad === 'main-bundle') {
    if (typeof window.reactMain === 'undefined') {
      if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.treatAsNormalWebpage) {
        const [errCss] = await _chrome_extension_lib_ext_lib_js__WEBPACK_IMPORTED_MODULE_9__.extLib.loadJsCssAsync({
          // eslint-disable-line no-unused-vars
          treatAsNormalWebpage: true,
          source: pathDist + 'main/main.bundle.css'
        });
        const [errJs] = await _chrome_extension_lib_ext_lib_js__WEBPACK_IMPORTED_MODULE_9__.extLib.loadJsCssAsync({
          // eslint-disable-line no-unused-vars
          treatAsNormalWebpage: true,
          source: pathDist + 'main/main.bundle.js'
        });
      } else {
        await chromeRuntimeMessageToBackgroundScript({
          type: 'magicss-dependency',
          subType: 'load-dependency',
          payload: pathDist + 'main/main.bundle.css'
        });
        await chromeRuntimeMessageToBackgroundScript({
          type: 'magicss-dependency',
          subType: 'load-dependency',
          payload: pathDist + 'main/main.bundle.js'
        });
      }
    }
    return window.reactMain;
  }
};
window.instanceUuid = window.instanceUuid || null;
window.instanceBasisNumber = window.instanceBasisNumber || null;
var fetchInstanceInfo = function () {
  return new Promise(resolve => {
    chrome.runtime.sendMessage({
      type: 'magicss-instance-info'
    }, function ([instanceUuid, instanceBasisNumber]) {
      return resolve([instanceUuid, instanceBasisNumber]);
    });
  });
};
var getInstanceInfo = async function () {
  let instanceUuid = null,
    instanceBasisNumber = null;
  if (window.instanceUuid && window.instanceBasisNumber) {
    instanceUuid = window.instanceUuid;
    instanceBasisNumber = window.instanceBasisNumber;
  } else {
    [instanceUuid, instanceBasisNumber] = await fetchInstanceInfo();
  }
  return [instanceUuid, instanceBasisNumber];
};
var initializeInstanceInfo = async function () {
  const [instanceUuid, instanceBasisNumber] = await getInstanceInfo();
  window.instanceUuid = instanceUuid;
  window.instanceBasisNumber = instanceBasisNumber;
};
var getConfigFromRemote = async function () {
  return new Promise(resolve => {
    chrome.runtime.sendMessage({
      type: 'magicss-config'
    }, function (remoteConfig) {
      return resolve(remoteConfig);
    });
  });
};
window.remoteConfig = window.remoteConfig || null;
window.basisNumber = window.basisNumber || -1;
var getConfig = async function () {
  const flagDebug = false; // DEV-HELPER: Useful when developing / debugging
  if (flagDebug || !window.remoteConfig) {
    window.remoteConfig = await getConfigFromRemote();
  }
  return window.remoteConfig;
};
var chromeRuntimeMessageIfRequired = async function ({
  type,
  subType,
  payload
}) {
  return new Promise(resolve => {
    if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
      chrome.runtime.sendMessage({
        tabId,
        magicssHostSessionUuid: window.magicssHostSessionUuid,
        type,
        subType,
        payload
      }, undefined, function (data) {
        return resolve(data);
      });
    } else {
      return resolve();
    }
  });
};
if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
  // This is just to keep the service worker active when the external editor window is open
  // To try alternative options: https://stackoverflow.com/questions/66618136/persistent-service-worker-in-chrome-extension
  // https://github.com/webextensions/live-css-editor/issues/106
  setInterval(() => {
    chromeRuntimeMessageIfRequired({
      type: 'magicss',
      subType: 'stay-awake'
    });
  }, 4000);
}
var chromeRuntimeMessageToBackgroundScript = async function ({
  type,
  subType,
  subTypeOptions,
  payload
}) {
  return new Promise(resolve => {
    chrome.runtime.sendMessage({
      type,
      subType,
      subTypeOptions,
      payload
    }, undefined, function (data) {
      return resolve(data);
    });
  });
};
window.chromeRuntimeMessageToBackgroundScript = chromeRuntimeMessageToBackgroundScript;
var sendMessageForMetrics = function (payload) {
  try {
    chrome.runtime.sendMessage({
      type: 'metrics',
      payload
    });
  } catch (e) {
    // do nothing
  }
};
(0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
  name: 'pageview',
  path: _appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow ? '/external-editor' : '/in-page-editor'
});
(0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
  name: 'loadedEditor',
  type: _appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow ? 'externalEditor' : 'inPageEditor'
});
if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
  chromeRuntimeMessageIfRequired({
    type: 'magicss',
    subType: 'external-editor-window-is-loading'
  });
  window.onbeforeunload = function () {
    chromeRuntimeMessageIfRequired({
      type: 'magicss',
      subType: 'external-editor-window-is-closing'
    });
  };
} else {
  window.onbeforeunload = function () {
    // https://stackoverflow.com/questions/53939205/how-to-avoid-extension-context-invalidated-errors-when-messaging-after-an-exte/69603416#69603416
    // This `if` condition is required for ignoring some unwanted errors (or rather error like warnings, eg: When this code gets executed from within a webpage after the extension is refreshed from chrome://extensions/)
    if (chrome.runtime?.id) {
      chrome.runtime.sendMessage({
        closeExternalEditor: true
      });
    }
  };
}
if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
  _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote.setup({
    paddingRight: '25px',
    paddingBottom: '25px',
    paddingLeft: '25px',
    verticalAlignment: 'bottom',
    horizontalAlignment: 'right',
    textAlignment: 'left'
  });
}
var chromePermissionsContains = function ({
  permissions,
  origins
}) {
  return new Promise(resolve => {
    chrome.permissions.contains({
      permissions,
      origins
    }, function (result) {
      if (result) {
        return resolve(true);
      } else {
        return resolve(false);
      }
    });
  });
};
(function ($) {
  var runningInAndroidFirefox = false;
  if (window.platformInfoOs === 'android') {
    runningInAndroidFirefox = true;
  }
  var asyncTimeout = function (delay) {
    return new Promise(resolve => {
      setTimeout(resolve, delay);
    });
  };
  var flagConnectedAtLeastOnce = false;
  window.currentlyConnected = false;
  var setCurrentlyConnected = function (value) {
    window.currentlyConnected = value;
  };
  var socketOb = {};
  window.socketOb = socketOb;
  socketOb.socket = null;
  socketOb.flagWatchingCssFiles = false;
  socketOb.setup = async function (asyncCallbackOnce) {
    var $backEndConnectivityOptions = window.$backEndConnectivityOptions;
    var editor = window.MagiCSSEditor;
    var serverHostnameValue = (await editor.userPreference('live-css-server-hostname')) || constants.liveCssServer.defaultHostname,
      serverPortValue = (await editor.userPreference('live-css-server-port')) || constants.liveCssServer.defaultPort;
    var protocolValue = 'http:';
    var backEndPath = protocolValue + '//' + serverHostnameValue + ':' + serverPortValue + constants.liveCssServer.apiVersionPath;
    var backEndPathToShowToUser = serverHostnameValue + ':' + serverPortValue;
    socketOb.socket = io(backEndPath, {
      timeout: 3000
    });
    var socket = socketOb.socket;
    socket.on('disconnect', function () {
      editor.markLiveCssServerConnectionStatus(false);
    });
    socket.on('connect', async function () {
      // This callback may lead to opening the "File to edit" input form. We wouldn't want it
      // to open again everytime disconnection / connection happens, due to some intermittent
      // issues like manual disconnection or network/debugging related causes.
      if (asyncCallbackOnce && !asyncCallbackOnce.alreadyCalled) {
        asyncCallbackOnce.alreadyCalled = true;
        await asyncCallbackOnce();
      }
      editor.markLiveCssServerConnectionStatus(true);
      setCurrentlyConnected(true);
      if ($backEndConnectivityOptions) {
        $backEndConnectivityOptions.removeClass('live-css-server-client-general-error').removeClass('live-css-server-client-incompatible-error').find('.magic-css-server-connectivity-status').removeClass('disconnected').removeClass('connecting').addClass('connected');
      }
      flagConnectedAtLeastOnce = true;
      if ($toastrReconnectAttempt) {
        $toastrReconnectAttempt.hide(); // Using jQuery's .hide() directly, rather than toastr.clear(), because there is no option to pass duration in the function call itself
        $toastrReconnectAttempt = null;
      }
      $toastrConnecting.hide(); // Using jQuery's .hide() directly, rather than toastr.clear(), because there is no option to pass duration in the function call itself
      $toastrConnected = toastr.success('<div style="display:block; text-align:center; margin-top:3px; margin-bottom:15px; font-weight:bold;">' + backEndPathToShowToUser + '</div>' + '<div>' + '<button type="button" class="magic-css-toastr-socket-ok" style="float:right;">OK</button>' + '<button type="button" class="magic-css-toastr-socket-configure">Settings</button>' + '</div>', 'Connected with live-css server at:', {
        onclick: async function (evt) {
          if ($(evt.target).hasClass('magic-css-toastr-socket-configure')) {
            toastr.clear($toastrConnected, {
              force: true
            });

            // TODO: Verify functionality
            await _getServerDetailsFromUser(editor);
          } else if ($(evt.target).hasClass('magic-css-toastr-socket-ok')) {
            toastr.clear($toastrConnected, {
              force: true
            });
          }
        }
      });
      var $toastrToHide = $toastrConnected;
      setTimeout(function () {
        toastr.clear($toastrToHide);
      }, 4000);
    });
    var errorHandler = function (err) {
      setCurrentlyConnected(false);
      editor.markLiveCssServerConnectionStatus(false);
      if ($backEndConnectivityOptions) {
        $backEndConnectivityOptions.find('.magic-css-server-connectivity-status').removeClass('connected').removeClass('connecting').addClass('disconnected');
        if (err === 'Invalid namespace') {
          $backEndConnectivityOptions.removeClass('live-css-server-client-general-error').addClass('live-css-server-client-incompatible-error');
        } else {
          $backEndConnectivityOptions.removeClass('live-css-server-client-incompatible-error').addClass('live-css-server-client-general-error');
        }
        // $backEndConnectivityOptions.find('.magicss-done-server-path-changes').prop('disabled', true);
      }
    };

    socket.on('connect_error', errorHandler);
    socket.on('error', errorHandler); // This would pass on the "Invalid namespace" error

    socket.on('reconnect_attempt', function () {
      setCurrentlyConnected(false);
      editor.markLiveCssServerConnectionStatus(false);
      if (flagConnectedAtLeastOnce) {
        if ($toastrReconnectAttempt) {
          // do nothing
        } else {
          if ($toastrConnected) {
            $toastrConnected.hide(); // Using jQuery's .hide() directly, rather than toastr.clear(), because there is no option to pass duration in the function call itself
          }

          $toastrReconnectAttempt = toastr.warning('<div style="display:block; text-align:center; margin-top:3px; margin-bottom:15px; font-weight:bold;">' + backEndPathToShowToUser + '</div>' + '<div>' + '<button type="button" class="magic-css-toastr-socket-cancel" style="float:right">Cancel</button>' + '<button type="button" class="magic-css-toastr-socket-configure">Settings</button>' + '</div>', 'Reconnecting with live-css server at:', {
            timeOut: 0,
            onclick: function (evt) {
              if ($(evt.target).hasClass('magic-css-toastr-socket-configure')) {
                // TODO: Verify functionality
                _getServerDetailsFromUser(editor);
              } else if ($(evt.target).hasClass('magic-css-toastr-socket-cancel')) {
                if (socket) {
                  editor.markLiveCssServerConnectionStatus(false);
                  socket.close();
                  socket = null;
                }
                toastr.clear($toastrReconnectAttempt, {
                  force: true
                });
                liveCssServerSessionClosedByUser(editor);
              }
            }
          });
        }
      }
    });
    socket.on('file-modified', function (changeDetails) {
      if (socketOb && socketOb.flagWatchingCssFiles) {
        if (changeDetails.useOnlyFileNamesForMatch) {
          reloadCSSResourceInPage({
            fullPath: changeDetails.fullPath,
            useOnlyFileNamesForMatch: true,
            fileName: changeDetails.fileName
          });
        } else if (changeDetails.fullPath.indexOf(changeDetails.root) === 0) {
          var pathWrtRoot = changeDetails.fullPath.substr(changeDetails.root.length);
          reloadCSSResourceInPage({
            fullPath: changeDetails.fullPath,
            url: resolveUrl(pathWrtRoot)
          });
        } else {
          // The code should never reach here
          (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Unexpected scenario occurred in reloading some CSS resources.' + '<br />Please report this bug at <a href="https://github.com/webextensions/live-css-editor/issues">https://github.com/webextensions/live-css-editor/issues</a>', 10000);
        }
      }
    });
  };
  socketOb.close = function () {
    if (socketOb.socket) {
      socketOb.socket.close();
      socketOb.socket = null;
    }
  };
  socketOb.reset = async function (asyncCallbackOnce) {
    socketOb.close();
    await socketOb.setup(asyncCallbackOnce);
  };
  socketOb._connectServerHelper = async function (editor, asyncCb) {
    await _getConnectedWithBackEnd(editor, async function () {
      await asyncCb();
    });
  };
  socketOb._disconnectIfRequiredServerHelper = async function () {
    if (socketOb.flagWatchingCssFiles || socketOb.flagEditingFile) {
      // do nothing
    } else {
      socketOb.close();
    }
  };
  socketOb.getConnected = async function (editor, asyncCb) {
    var socketIfAlreadyConnected = await _getConnectedWithBackEnd(editor, async function callback(err) {
      if (err) {
        // The user cancelled watching files
        (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('You cancelled watching CSS files for changes');
        await editor.userPreference('watching-css-files', 'no');
      } else {
        // TODO: This code is duplicated elsewhere
        if (!socketOb.flagWatchingCssFiles) {
          socketOb.flagWatchingCssFiles = true;
          (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Watching CSS files for changes.' + '<br />' + '<span style="font-weight:normal;">When a file gets saved, live-css server notifies Magic CSS to reload the CSS file\'s &lt;link&gt; tag.</span>', 20000, {
            unobtrusive: true
          });
          $(editor.container).addClass('watching-css-files');
          editor.adjustUiPosition();
          await editor.userPreference('watching-css-files', 'yes');
        }
        if (!socketIfAlreadyConnected && asyncCb) {
          await asyncCb();
        }
      }
    });
    if (socketIfAlreadyConnected) {
      if (asyncCb) {
        await asyncCb();
      }

      // TODO: This code is duplicated elsewhere
      if (!socketOb.flagWatchingCssFiles) {
        socketOb.flagWatchingCssFiles = true;
        (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Watching CSS files for changes.' + '<br />' + '<span style="font-weight:normal;">When a file gets saved, live-css server notifies Magic CSS to reload the CSS file\'s &lt;link&gt; tag.</span>', 20000, {
          unobtrusive: true
        });
        $(editor.container).addClass('watching-css-files');
        editor.adjustUiPosition();
        await editor.userPreference('watching-css-files', 'yes');
      }
    }
  };
  socketOb._startWatchingFiles = async function (editor) {
    if (!socketOb.flagWatchingCssFiles) {
      await socketOb._connectServerHelper(editor, async function () {
        if (!socketOb.flagWatchingCssFiles) {
          socketOb.flagWatchingCssFiles = true;
          (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Watching CSS files for changes.' + '<br />' + '<span style="font-weight:normal;">When a file gets saved, live-css server notifies Magic CSS to reload the CSS file\'s &lt;link&gt; tag.</span>', 20000, {
            unobtrusive: true
          });
          $(editor.container).addClass('watching-css-files');
          editor.adjustUiPosition();
          await editor.userPreference('watching-css-files', 'yes');
        }
      });
    }
  };
  socketOb._updateUiMentioningNotWatchingCssFiles = async function (editor, asyncCallback) {
    if (socketOb.flagWatchingCssFiles) {
      socketOb.flagWatchingCssFiles = false;
      (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Stopped watching CSS files for changes');
      $(editor.container).removeClass('watching-css-files');
      editor.adjustUiPosition();
      await editor.userPreference('watching-css-files', 'no');
    }
    if (asyncCallback) {
      await asyncCallback();
    }
  };
  socketOb._stopWatchingFiles = async function (editor) {
    await socketOb._updateUiMentioningNotWatchingCssFiles(editor, async function () {
      await socketOb._disconnectIfRequiredServerHelper();
    });
  };
  var chromeStorageForExtensionData = chrome.storage.sync || chrome.storage.local;
  const getExtensionDataAsync = function (property) {
    return new Promise(function (resolve) {
      chromeStorageForExtensionData.get(property, function (values) {
        resolve(values[property]);
      });
    });
  };
  var checkIfMagicCssLoadedFine = function (MagiCSSEditor) {
    if (!MagiCSSEditor.container.clientHeight) {
      // Cases where this condition would be true:
      //     - When the <body> element itself is implemented as shadow-dom. eg: http://www.firstpost.com (when this change was initially added)
      //     - If the user tries to use following CSS via this extension: #MagiCSS-bookmarklet {display: none !important;}
      (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Error: Unable to load Magic CSS properly' + '<br/>Kindly report this issue at <a target="_blank" href="https://github.com/webextensions/live-css-editor/issues">GitHub repository for Magic CSS</a>', 10000);
      return false;
    }
    return true;
  };
  var strAboutToBeInstantiated = '<about-to-be-instantiated>';
  if (window.MagiCSSEditor) {
    if (window.MagiCSSEditor === strAboutToBeInstantiated) {
      // do nothing
    } else {
      _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote.hide(); // Hide the note which says that Magic CSS is loading

      setTimeout(async function () {
        // 'Magic CSS window is already there. Repositioning it.'
        await window.MagiCSSEditor.reposition(function () {
          checkIfMagicCssLoadedFine(window.MagiCSSEditor);
        });
        chrome.runtime.sendMessage({
          closeExternalEditor: true
        });
        chromeStorageForExtensionData.set({
          'last-time-editor-was-in-external-window': false
        }, function () {
          // do nothing
        });
      });
    }
    return;
  } else {
    // Temporarily instantiating window.MagiCSSEditor as a truthy value
    // Without this, if a user quickly runs Magic CSS twice, then in both
    // the runs, window.MagiCSSEditor would be unavailable
    window.MagiCSSEditor = strAboutToBeInstantiated;
  }

  /* eslint-disable */
  // TODO: Move this functionality into utils.js
  // https://github.com/lydell/resolve-url/blob/master/resolve-url.js
  // Copyright 2014 Simon Lydell
  // X11 (“MIT”) Licensed. (See LICENSE.)
  function resolveUrl( /* ...urls */
  ) {
    var numUrls = arguments.length;
    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.");
    }
    var base = document.createElement("base");
    base.href = arguments[0];
    if (numUrls === 1) {
      return base.href;
    }
    var head = document.getElementsByTagName("head")[0];
    head.insertBefore(base, head.firstChild);
    var a = document.createElement("a");
    var resolved;
    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index];
      resolved = a.href;
      base.href = resolved;
    }
    head.removeChild(base);
    return resolved;
  }
  /* eslint-enable */

  // for HTML frameset pages, this value would be 'FRAMESET'
  // chrome.tabs.executeScript uses allFrames: true, to run inside all frames
  // TODO: Check if it is still the same for chrome.tabs.scripting
  if (document.body.tagName !== 'BODY') {
    return;
  }
  var constants = {};
  try {
    constants.appVersion = chrome.runtime.getManifest().version;
  } catch (e) {
    // Just being cautious to have a fallback.
    // In future, we may adopt just one of these two approaches to get the
    // version number, once stability is proven across platforms and environments.
    constants.appVersion = window.magicCssVersion;
  }
  constants.appMajorVersion = parseInt(constants.appVersion, 10);
  constants.liveCssServer = {
    // defaultProtocol: (window.location.protocol === 'https:') ? 'https:' : 'http:',
    // defaultHostname: window.location.hostname || '127.0.0.1',
    defaultProtocol: 'http:',
    defaultHostname: 'localhost',
    defaultPort: '3456',
    apiVersionPath: '/api/v' + constants.appMajorVersion
  };
  toastr.options.positionClass = 'toast-top-right magic-css-toastr magic-css-ui';
  toastr.options.newestOnTop = false;
  // toastr.options.closeButton = true;
  toastr.options.hideDuration = 300;
  toastr.options.timeOut = 5000;
  toastr.options.extendedTimeOut = 0;
  // toastr.options.tapToDismiss = false;

  var rememberLastAppliedCss = async function (css) {
    var editor = window.MagiCSSEditor;
    await editor.userPreference('last-applied-css', css);
  };
  var applyLastAppliedCss = async function (editor) {
    // TODO: Some of the code related to this function may be reused

    var userPreference = editor.userPreference.bind(editor);
    var localStorageDisableStyles = 'disable-styles';
    var disableStyles = (await userPreference(localStorageDisableStyles)) === 'yes';
    var localStorageLastAppliedCss = 'last-applied-css';
    var cssText = (await userPreference(localStorageLastAppliedCss)).trim();
    if (cssText) {
      var id = 'MagiCSS-bookmarklet',
        newStyleTagId = id + '-html-id',
        newStyleTag = new _utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__.StyleTag({
          id: newStyleTagId,
          parentTag: 'body',
          attributes: [{
            name: 'data-style-created-by',
            value: 'magicss'
          }],
          overwriteExistingStyleTagWithSameId: true
        });
      newStyleTag.cssText = cssText;
      newStyleTag.disabled = disableStyles;
      newStyleTag.applyTag();
    }
  };
  var ellipsis = function (str, limit) {
    limit = limit || 12;
    return str.length <= limit ? str : str.substring(0, limit - 3) + '...';
  };
  var getLocalISOTime = function () {
    // http://stackoverflow.com/questions/10830357/javascript-toisostring-ignores-timezone-offset/28149561#28149561
    var tzoffset = new Date().getTimezoneOffset() * 60000,
      //offset in milliseconds
      localISOTime = new Date(Date.now() - tzoffset).toISOString().slice(0, -1);
    localISOTime = localISOTime.replace('T', '_');
    return localISOTime;
  };
  var getActiveStylesheetLinkTags = function (options) {
    options = options || {};
    // The disabled <link> tags are not loaded when "href" is changed, so don't include them
    var linkTags = $('link[rel~="stylesheet"]:not([disabled])').filter(function () {
      if (this.reloadingActiveWithMagicCSS) {
        return false;
      }
      // Don't include the elements which don't have a value set for "href"
      if (!$(this).attr('href')) {
        return false;
      }
      if (!options.skipIntegrityCheck) {
        // Don't include the elements which have a value set for "integrity"
        if ($(this).attr('integrity')) {
          return false;
        }
      }
      return true;
    }).toArray();
    return linkTags;
  };
  var getFileNameFromPath = function (path) {
    path = path.split('?')[0];
    path = path.split('#')[0];
    path = path.split('/').pop();
    return path;
  };
  var findProbableMatchElementIndexes = function (arr, useOnlyFileNamesForMatch, itemToMatch) {
    var fileNameOfItemToMatch = getFileNameFromPath(itemToMatch);
    var matchedIndexes = [];
    arr.forEach(function (item, index) {
      item = item.replace(/[?&]reloadedAt=[\d-_:.]+/, '');
      if (useOnlyFileNamesForMatch) {
        if (getFileNameFromPath(item) === fileNameOfItemToMatch) {
          matchedIndexes.push(index);
        }
      } else {
        if (resolveUrl(item) === itemToMatch) {
          matchedIndexes.push(index);
        }
      }
    });
    return matchedIndexes;
  };
  var reloadCSSResourceInPage = function (config) {
    var useOnlyFileNamesForMatch = config.useOnlyFileNamesForMatch,
      fileName = config.fileName,
      fullUrl = config.url,
      fullPath = config.fullPath;
    var activeLinkTagsSkipIntegrityCheck = getActiveStylesheetLinkTags({
      skipIntegrityCheck: true
    });
    var arrLinkTags = [];
    activeLinkTagsSkipIntegrityCheck.forEach(function (linkTag) {
      arrLinkTags.push($(linkTag).attr('href'));
    });
    var indexes = findProbableMatchElementIndexes(arrLinkTags, useOnlyFileNamesForMatch, useOnlyFileNamesForMatch ? fileName : fullUrl);
    var linkTagsToReload = [];
    var linkTagsNotToReloadBecauseOfIntegrityAttribute = 0;
    indexes.forEach(function (index) {
      if (activeLinkTagsSkipIntegrityCheck[index].getAttribute('integrity')) {
        linkTagsNotToReloadBecauseOfIntegrityAttribute += 1;
      } else {
        linkTagsToReload.push(activeLinkTagsSkipIntegrityCheck[index]);
      }
    });
    if (linkTagsNotToReloadBecauseOfIntegrityAttribute) {
      console.log('Note: Magic CSS will not attempt to reload the link tags which use "integrity" attribute.');
    }
    reloadPassedLinkTags(linkTagsToReload, {
      noMatchesPrepend: 'Modified: <span style="font-weight:normal">' + function (str) {
        if (str.length >= 53) {
          return '...' + str.substr(-50);
        } else {
          return str;
        }
      }(fullPath) + '</span>'
    });
  };
  var recreateNodeCustomized = function (node, options) {
    options = options || {};
    var skipAttributes = options.skipAttributes || [];
    var nodeName = node.nodeName;
    var recreatedNode = document.createElement(nodeName);
    node.getAttributeNames().forEach(function (attributeName) {
      if (skipAttributes.indexOf(attributeName) === -1) {
        var attributeValue = node.getAttribute(attributeName);
        recreatedNode.setAttribute(attributeName, attributeValue);
      }
    });
    return recreatedNode;
  };
  var reloadPassedLinkTags = function (linkTags, extraInfo) {
    var localISOTime = getLocalISOTime();
    var successCount = 0,
      errorCount = 0;
    var checkCompletion = function () {
      (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('<span style="font-weight:normal;">' + htmlEscape('Reloading active CSS <link> tags.') + '</span>' + ' Success: ' + successCount + '/' + linkTags.length);
      if (linkTags.length === successCount + errorCount) {
        setTimeout(function () {
          if (errorCount) {
            var msg = '';
            if (errorCount === 1) {
              msg = htmlEscape(errorCount + ' of the CSS <link> tag failed to reload.');
            } else {
              msg = htmlEscape(errorCount + ' of the CSS <link> tags failed to reload.');
            }
            msg += '<br/><span style="font-weight:normal;">Please check availability of the CSS resources included in this page.</span>';
            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(msg, undefined, {
              backgroundColor: '#f5bcae',
              borderColor: '#e87457'
            });
          } else {
            if (successCount === 1) {
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(htmlEscape(successCount + ' active CSS <link> tag got reloaded successfully :-)'));
            } else {
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(htmlEscape(successCount + ' active CSS <link> tags got reloaded successfully :-)'));
            }
          }
        }, 750);
        var tagsToExclude = jQuery.makeArray(jQuery('[data-style-created-by="magicss"]'));
        updateExistingCSSSelectorsAndAutocomplete(tagsToExclude);
      }
    };
    if (linkTags.length) {
      checkCompletion();
      linkTags.forEach(function (linkTag) {
        var link = linkTag,
          $link = $(link),
          href = $link.attr('href');
        if (href.indexOf('reloadedAt=') >= 0) {
          href = href.replace(/[?&]reloadedAt=[\d-_:.]+/, '');
        }
        var newHref;
        if (href.indexOf('?') >= 0) {
          newHref = href + '&reloadedAt=' + localISOTime;
        } else {
          newHref = href + '?reloadedAt=' + localISOTime;
        }

        // For Edge extension, cloning the element seems to result in some form of CORS request which wouldn't work.
        // Hence, we recreate the element without the 'href' attribute and assign the 'href' later after inserting
        // that element in the DOM.
        var newLink = recreateNodeCustomized(link, {
            skipAttributes: ['href']
          }),
          $newLink = $(newLink);
        newLink.reloadingActiveWithMagicCSS = true;
        link.reloadingActiveWithMagicCSS = true;
        $link.after($newLink);
        newLink.onload = function (evt) {
          // eslint-disable-line no-unused-vars
          delete newLink.reloadingActiveWithMagicCSS;
          delete link.reloadingActiveWithMagicCSS;
          successCount++;
          $link.remove();
          checkCompletion();
        };
        newLink.onerror = function (evt) {
          // eslint-disable-line no-unused-vars
          delete newLink.reloadingActiveWithMagicCSS;
          delete link.reloadingActiveWithMagicCSS;
          errorCount++;
          $newLink.remove();
          checkCompletion();
        };
        $newLink.attr('href', newHref);
      });
    } else {
      (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)((extraInfo && extraInfo.noMatchesPrepend ? extraInfo.noMatchesPrepend + '<br />' : '') + htmlEscape('There are no active CSS <link> tags that need to be reloaded.'));
    }
  };
  var reloadAllCSSResourcesInPage = function () {
    var linkTags = getActiveStylesheetLinkTags();
    var activeLinkTagsSkipIntegrityCheck = getActiveStylesheetLinkTags({
      skipIntegrityCheck: true
    });
    if (linkTags.length !== activeLinkTagsSkipIntegrityCheck.length) {
      console.log('Note: Magic CSS will not attempt to reload the link tags which use "integrity" attribute.');
    }
    reloadPassedLinkTags(linkTags);
  };
  var getExistingCSSSelectors = function (tagsToExclude) {
    tagsToExclude = tagsToExclude || [];
    var selectorsOb = {};
    var handleErrorInReadingCSS = function (e) {
      if (e.name === 'SecurityError') {// This may happen due to cross-domain CSS resources
        // do nothing
      } else {
        console.log('If you are seeing this message, it means that Magic CSS extension encountered an unexpected error' + ' when trying to read the list of existing CSS selectors.' + '\n\nDon\'t worry :-) This would not cause any issue at all in usage of this extension.' + ' But we would be glad if you report about this error message at https://github.com/webextensions/live-css-editor/issues' + ' so that we can investigate this minor bug and provide better experience for you and other web developers.');
      }
    };
    try {
      var styleSheets = document.styleSheets;
      var getCSSSelectorsRecursively = function (cssRules, includeMediaTitle) {
        var cssSelectors = [];
        for (var i = 0; i < cssRules.length; i++) {
          var cssRule = cssRules[i] || {};
          try {
            if (cssRule.selectorText) {
              var selectorsFound = cssRule.selectorText.split(', ');
              for (var j = 0; j < selectorsFound.length; j++) {
                // cssSelectors.push(selectorsFound[j]);
                cssSelectors.push({
                  selector: selectorsFound[j],
                  source: cssRule.parentStyleSheet.href || cssRule.parentStyleSheet.ownerNode.tagName === 'STYLE' && '<style> tag' || ''
                });
              }
            }
          } catch (e) {
            handleErrorInReadingCSS(e);
          }
          try {
            if (includeMediaTitle && cssRule instanceof CSSMediaRule) {
              cssSelectors.push(cssRule.cssText.substring(0, cssRule.cssText.indexOf('{')).trim());
            }
          } catch (e) {
            handleErrorInReadingCSS(e);
          }
          try {
            if ((cssRule.styleSheet || {}).cssRules) {
              cssSelectors = cssSelectors.concat(getCSSSelectorsRecursively(cssRule.styleSheet.cssRules, includeMediaTitle));
            }
          } catch (e) {
            handleErrorInReadingCSS(e);
          }
          try {
            if (cssRule.cssRules) {
              cssSelectors = cssSelectors.concat(getCSSSelectorsRecursively(cssRule.cssRules, includeMediaTitle));
            }
          } catch (e) {
            handleErrorInReadingCSS(e);
          }
        }
        return cssSelectors;
      };
      for (var i = 0; i < styleSheets.length; i++) {
        var styleSheet = styleSheets[i];
        var shouldTagBeExcluded = tagsToExclude.some(function (tagsToExclude) {
          if (styleSheet.ownerNode === tagsToExclude) {
            return true;
          }
        });
        if (shouldTagBeExcluded) {
          continue;
        }
        var cssRules;
        try {
          cssRules = (styleSheet || {}).cssRules;
        } catch (e) {
          handleErrorInReadingCSS(e);
        }
        cssRules = cssRules || [];
        var cssSelectors = getCSSSelectorsRecursively(cssRules, true);
        cssSelectors.forEach(function (cssSelector) {
          selectorsOb[cssSelector.selector] = selectorsOb[cssSelector.selector] || [];
          if (selectorsOb[cssSelector.selector].indexOf(cssSelector.source) === -1) {
            selectorsOb[cssSelector.selector].push(cssSelector.source);
          }
        });
      }
    } catch (e) {
      handleErrorInReadingCSS(e);
      return {};
    }
    return selectorsOb;
  };
  var existingCSSSelectorsWithAutocompleteObjects = {};
  var updateExistingCSSSelectorsAndAutocomplete = function (tagsToExclude) {
    window.existingCSSSelectors = getExistingCSSSelectors(tagsToExclude);
    existingCSSSelectorsWithAutocompleteObjects = $.extend(true, {}, window.existingCSSSelectors);
    Object.keys(existingCSSSelectorsWithAutocompleteObjects).forEach(function (key) {
      var sources = '';
      existingCSSSelectorsWithAutocompleteObjects[key].forEach(function (source) {
        if (sources !== '') {
          sources += ', ';
        }
        sources += ellipsis(source.replace(/[?&]reloadedAt=[\d-_:.]+/, '').substr(source.lastIndexOf('/') + 1), 50);
      });
      existingCSSSelectorsWithAutocompleteObjects[key] = {
        sources: sources,
        originalSelector: key,
        text: key
      };
    });
  };
  if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
    setTimeout(async () => {
      const cssSelectorsAutocompleteObjects = await chromeRuntimeMessageIfRequired({
        type: 'magicss',
        subType: 'get-css-selectors-autocomplete-objects'
      });
      existingCSSSelectorsWithAutocompleteObjects = JSON.parse(JSON.stringify(cssSelectorsAutocompleteObjects));
    });
  } else {
    updateExistingCSSSelectorsAndAutocomplete();
  }

  // TODO: DUPLICATE: Code duplication for browser detection in commands.js, ext-lib.js, magicss.js and options.js
  var isChrome = false,
    isEdge = false,
    isFirefox = false,
    isOpera = false,
    isChromiumBased = false;

  // Note that we are checking for "Edg/" which is the test required for identifying Chromium based Edge browser
  if (/Edg\//.test(navigator.appVersion)) {
    // Test for "Edge" before Chrome, because Microsoft Edge browser also adds "Chrome" in navigator.appVersion
    isEdge = true;
  } else if (/OPR\//.test(navigator.appVersion)) {
    // Test for "Opera" before Chrome, because Opera browser also adds "Chrome" in navigator.appVersion
    isOpera = true;
  } else if (/Chrome/.test(navigator.appVersion)) {
    isChrome = true;
  } else if (/Firefox/.test(navigator.userAgent)) {
    // For Mozilla Firefox browser, navigator.appVersion is not useful, so we need to fallback to navigator.userAgent
    isFirefox = true;
  }
  if (isEdge || isOpera || isChrome) {
    isChromiumBased = true; // eslint-disable-line no-unused-vars
  }

  const flagAllowSassUi = isFirefox ? false : true;
  window.flagAllowSassUi = flagAllowSassUi;
  var extensionUrl = {
    chrome: 'https://chrome.google.com/webstore/detail/ifhikkcafabcgolfjegfcgloomalapol',
    edge: 'https://microsoftedge.microsoft.com/addons/detail/live-editor-for-css-less/ahibbdhoijcafelmfepfpcmmdifchpdg',
    firefox: 'https://addons.mozilla.org/firefox/addon/live-editor-for-css-less-sass/',
    opera: 'https://addons.opera.com/extensions/details/live-editor-for-css-and-less-magic-css/'
  };
  window.extensionUrl = extensionUrl;
  extensionUrl.forThisBrowser = function () {
    if (isEdge) {
      return extensionUrl.edge;
    } else if (isFirefox) {
      return extensionUrl.firefox;
    } else if (isOpera) {
      return extensionUrl.opera;
    } else {
      return extensionUrl.chrome;
    }
  }();

  /*
  // https://blog.github.com/2018-02-18-deprecation-notice-removing-anonymous-gist-creation/
   var strCreatedVia = 'Created via Magic CSS extension';
  if (isChrome) {
      strCreatedVia += ' for Chrome - ' + extensionUrl.chrome;
  } else if (isEdge) {
      strCreatedVia += ' for Edge - ' + extensionUrl.edge;
  } else if (isFirefox) {
      strCreatedVia += ' for Firefox - ' + extensionUrl.firefox;
  } else if (isOpera) {
      strCreatedVia += ' for Opera - ' + extensionUrl.opera;
  }
  var createGist = function (text, languageMode, cb) {
      var files = {};
      files[
          (function () {
              if (languageMode === 'less') {
                  return 'styles.less';
              } else if (languageMode === 'sass') {
                  return 'styles.scss';   // File extension for Sass is .scss (http://sass-lang.com/guide)
              } else {
                  return 'styles.css';
              }
          }())
      ] = {
          "content": text + '\r\n\r\n/* ' + strCreatedVia + ' *' + '/\r\n'
      };
      $.ajax({
          url: 'https://api.github.com/gists',
          type: 'POST',
          timeout: 20000,
          contentType: 'application/json',
          data: JSON.stringify({
              "description": window.location.origin + ' - via Magic CSS extension' + (function () {
                  if (isChrome) {
                      return ' for Chrome - ' + extensionUrl.chrome;
                  } else if (isEdge) {
                      return ' for Edge - ' + extensionUrl.edge;
                  } else if (isFirefox) {
                      return ' for Firefox - ' + extensionUrl.firefox;
                  } else if (isOpera) {
                      return ' for Opera - ' + extensionUrl.opera;
                  }
                  return '';
              }()),
              "public": true,
              "files": files
          }),
          error: function () {
              alertNote('An unexpected error has occured.<br />We could not reach GitHub Gist.', 10000);
          },
          success: function (json, textStatus) {
              if (textStatus === 'success') {
                  cb(json.html_url);
              } else {
                  alertNote('An unexpected error has occured.<br />We could not access GitHub Gist.', 10000);
              }
          }
      });
  };
  var createGistAndEmail = (function () {
      var lastMailedValue = null,
          lastSuccessNote = '';
      return function (text, languageMode) {
          text = $.trim(text);
          if (text === '') {
              alertNote('Please type some code to be shared', 5000);
          } else if (lastMailedValue === text) {
              alertNote(lastSuccessNote, 20000);
          } else {
              var wishToContinue = window.confirm('The code you have entered would be uploaded to\n        https://gist.github.com/\nand a link would be generated for sharing.\n\nDo you wish to continue?');
              if (!wishToContinue) {
                  return;
              }
              createGist(text, languageMode, function (gistUrl) {
                  var anchor = '<a target="_blank" href="' + gistUrl + '">' + gistUrl + '</a>';
                  lastMailedValue = text;
                  lastSuccessNote = 'The GitHub Gist was successfully created: ' +
                      anchor +
                      '<br/>Share code: <a href="' + 'mailto:?subject=Use this code for styling - ' + gistUrl + '&body=' +
                      encodeURIComponent(text.replace(/\t/g,'  ').substr(0,140) + '\r\n...\r\n...\r\n\r\n' + gistUrl + '\r\n\r\n-- ' + strCreatedVia + '') +
                      '">Send e-mail</a>';
                  alertNote(lastSuccessNote, 10000);
              });
              alertNote('Request initiated. It might take a few moments. Please wait.', 5000);
          }
      };
  }());
  /* */

  var htmlEscape = function (str) {
    return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  };
  var showCSSSelectorMatches = function (cssSelector, editor) {
    var cssSelectorString = cssSelector && cssSelector.originalSelector || cssSelector;
    if (!cssSelectorString) {
      _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote.hide();
    }
    if (!editor.styleHighlightingSelector) {
      editor.styleHighlightingSelector = new _utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__.StyleTag({
        id: 'magicss-highlight-by-selector',
        parentTag: 'body',
        attributes: [{
          name: 'data-style-created-by',
          value: 'magicss'
        }],
        overwriteExistingStyleTagWithSameId: true
      });
    }
    if (cssSelectorString) {
      // Helps in highlighting SVG elements
      editor.styleHighlightingSelector.cssText = cssSelectorString + '{outline: 1px dashed red !important; fill: red !important; }';
    } else {
      editor.styleHighlightingSelector.cssText = '';
    }
    editor.styleHighlightingSelector.applyTag();
    if (cssSelectorString) {
      var count;
      try {
        count = $(cssSelectorString).not('#MagiCSS-bookmarklet, #MagiCSS-bookmarklet *, #topCenterAlertNote, #topCenterAlertNote *').length;
      } catch (e) {
        return '';
      }
      var trunc = function (str, limit) {
        if (str.length > limit) {
          var separator = ' ... ';
          str = str.substr(0, limit / 2) + separator + str.substr(separator.length + str.length - limit / 2);
        }
        return str;
      };
      var cssSelectorToShow = htmlEscape(trunc(cssSelectorString, 100));
      var sourcesToShow = cssSelector && cssSelector.sources ? '<br /><span style="color:#888">Source: <span style="font-weight:normal;">' + htmlEscape(decodeURIComponent(cssSelector.sources)) + '</span></span>' : '';
      if (count) {
        (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(cssSelectorToShow + '&nbsp; &nbsp;<span style="font-weight:normal">(' + count + ' match' + (count === 1 ? '' : 'es') + ')</span>' + sourcesToShow, 2500);
      } else {
        (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(cssSelectorToShow + '&nbsp; &nbsp;<span style="font-weight:normal;">(No&nbsp;matches)</span>' + sourcesToShow, 2500);
      }
    }
  };
  var setCodeMirrorCSSLinting = async function (editor, enableOrDisable) {
    var cm = editor.cm,
      lint,
      gutters = [].concat(cm.getOption('gutters') || []);
    if (enableOrDisable === 'enable') {
      lint = true;
      gutters.unshift('CodeMirror-lint-markers'); // Using ".unshift()" rather than ".push()" to ensure that the "gutter" for "line-number" always comes after gutter for "linting"
      await editor.userPreference('use-css-linting', 'yes');
    } else {
      lint = false;
      var index = gutters.indexOf('CodeMirror-lint-markers');
      if (index > -1) {
        gutters.splice(index, 1);
      }
      await editor.userPreference('use-css-linting', 'no');
    }
    cm.setOption('gutters', gutters);
    cm.setOption('lint', lint);
  };
  var markAsPinnedOrNotPinned = async function (editor, pinnedOrNotPinned) {
    if (pinnedOrNotPinned === 'pinned') {
      editor.applyStylesAutomatically(true);
      await editor.userPreference('apply-styles-automatically', 'yes');
    } else {
      editor.applyStylesAutomatically(false);
      await editor.userPreference('apply-styles-automatically', 'no');
    }
  };
  var elementHadClassAttributeBeforePointAndSelect;
  // elementHadTitleAttributeBeforePointAndSelect,
  // titleValueOfElementBeforePointAndSelect;

  var removeMouseOverDomElementEffect = function (cb) {
    var $el = $('.magicss-mouse-over-dom-element');
    if ($el.length) {
      // if (!elementHadTitleAttributeBeforePointAndSelect) {
      //     var title = $el.attr('title');
      //     // If the title attribute is set by Magic CSS, it would start like:
      //     //     "Suggested CSS selector:" OR "Suggested CSS selectors:"
      //     if (title && title.indexOf('Suggested CSS selector') === 0) {
      //         $el.removeAttr('title');
      //     }
      // } else {
      //     if (titleValueOfElementBeforePointAndSelect) {
      //         $el.attr('title', titleValueOfElementBeforePointAndSelect);
      //     } else {
      //         $el.attr('title', '');
      //     }
      // }

      $el.removeClass('magicss-mouse-over-dom-element');
      if (!elementHadClassAttributeBeforePointAndSelect && !$el.attr('class')) {
        $el.removeAttr('class');
      }
    }
    if (cb) {
      cb();
    }
  };

  // Set testingDataIntegrityOfPointAndClickFunctionality as true for testing data integrity of point and click functionality
  var testingDataIntegrityOfPointAndClickFunctionality = false,
    forTestingOnly_InitialInnerHtml = '',
    forTestingOnly_FinalInnerHtml = '',
    forTestingOnly_getInnerHtml = function () {
      // Change the selctor depending on the webpage being tested
      return $('div').html(); // Return the innerHTML of the first available <div> element
    };

  var enablePointAndClick = false;
  var enablePointAndClickFunctionality = function (editor) {
    enablePointAndClick = true;
    if (testingDataIntegrityOfPointAndClickFunctionality) {
      forTestingOnly_InitialInnerHtml = forTestingOnly_getInnerHtml();
    }
    $(editor.container).addClass('magicss-point-and-click-activated');
  };
  var disablePointAndClickFunctionality = function (editor) {
    enablePointAndClick = false;
    $(editor.container).removeClass('magicss-point-and-click-activated');

    // This is useful when the user disables point-and-click using keyboard shortcut
    removeMouseOverDomElementEffect();
    if (testingDataIntegrityOfPointAndClickFunctionality) {
      forTestingOnly_FinalInnerHtml = forTestingOnly_getInnerHtml();
      if (forTestingOnly_FinalInnerHtml !== forTestingOnly_InitialInnerHtml) {
        console.log('Note: The data integrity of point and click functionality may have some minor issues.');
        console.log(forTestingOnly_InitialInnerHtml);
        console.log(forTestingOnly_FinalInnerHtml);
      } else {
        console.log('Note: The data integrity of point and click functionality is working fine.');
      }
    }
  };
  var enableAutocompleteSelectors = function (editor) {
    $(editor.container).removeClass('magicss-autocomplete-selectors-disabled').addClass('magicss-autocomplete-selectors-enabled');
  };
  var disableAutocompleteSelectors = function (editor) {
    $(editor.container).removeClass('magicss-autocomplete-selectors-enabled').addClass('magicss-autocomplete-selectors-disabled');
  };
  var highlightErroneousLineTemporarily = function (editor, errorInLine) {
    var lineHandle = editor.cm.addLineClass(errorInLine, 'background', 'line-has-parsing-error-transition-effect');
    editor.cm.addLineClass(errorInLine, 'background', 'line-has-parsing-error');
    var duration = 2000;
    setTimeout(async function () {
      editor.cm.removeLineClass(lineHandle, 'background', 'line-has-parsing-error');
      await asyncTimeout(500); /* 500ms delay matches the transition duration specified for the CSS selector ".line-has-parsing-error-transition-effect" */
      editor.cm.removeLineClass(lineHandle, 'background', 'line-has-parsing-error-transition-effect');
    }, duration);
  };

  // A pretty basic OS detection logic based on:
  // https://stackoverflow.com/questions/38241480/detect-macos-ios-windows-android-and-linux-os-with-js/38241481#38241481
  var getOS = function () {
    var platform = window.navigator.platform,
      os = null;
    if (platform.indexOf('Mac') === 0) {
      os = 'Mac OS';
    } else if (platform.indexOf('Win') === 0) {
      os = 'Windows';
    } else if (platform.indexOf('Linux') === 0) {
      os = 'Linux';
    }
    return os;
  };
  var getServerDetailsFromUserAlreadyOpen = false;
  var _getServerDetailsFromUser = async function (editor, cbGotServerDetailsFromUser) {
    if (getServerDetailsFromUserAlreadyOpen) {
      return;
    }
    getServerDetailsFromUserAlreadyOpen = true;

    /* eslint-disable indent */
    window.$backEndConnectivityOptions = $(
    // var $backEndConnectivityOptions = $(
    ['<div>', '<div class="magic-css-full-page-overlay">', '</div>', '<div class="magic-css-full-page-contents magic-css-ui" style="pointer-events:none;">', '<div style="display:flex;justify-content:center;align-items:center;height:100%;">', '<div class="magic-css-back-end-connectivity-options" style="pointer-events:initial;">', '<div class="magic-css-server-config-item" style="padding-bottom:0;">', '<div style="overflow-y:auto; max-height:calc(70vh - 70px);">', '<div style="margin-bottom:20px;">', 'This feature is meant for use during web development.', ' You need to run a development server, called', ' <a target="_blank" href="https://www.npmjs.com/package/@webextensions/live-css" style="font-weight:bold; text-decoration:underline; color:#000;">live-css</a>', ', for using the features', ' "Edit file"', ' and "Watch CSS files to apply changes automatically".', '</div>', '<div>', '<div style="font-weight:bold; float:left;">Step 1:</div>', '<div style="margin-left:50px;">', 'Install Node JS', ' <a target="_blank" href="https://nodejs.org/en/download/" style="margin-left:10px;">Download</a>', function () {
      var os = getOS(),
        link;
      if (os === 'Linux') {
        link = 'https://www.ostechnix.com/install-node-js-linux/';
      } else if (os === 'Windows') {
        link = 'https://www.wikihow.com/Install-Node.Js-on-Windows';
      } else if (os === 'Mac OS') {
        link = 'https://nodesource.com/blog/installing-nodejs-tutorial-mac-os-x/';
      }
      if (link) {
        return ' <a target="_blank" href="' + link + '" style="margin-left:10px;">Help</a>';
      } else {
        return '';
      }
    }(), '</div>', '</div>', '<div style="padding-top:4px;">', '<div style="font-weight:bold; float:left;">Step 2:</div>', '<div style="margin-left:50px;">', 'Install live-css server', ' <a target="_blank" href="https://www.npmjs.com/package/@webextensions/live-css" style="margin-left:10px;">Link</a>', ' <a target="_blank" href="https://docs.npmjs.com/cli/npm" style="margin-left:10px;">Help</a>', ' <a target="_blank" href="https://docs.npmjs.com/getting-started/fixing-npm-permissions" style="margin-left:10px;">Extra</a>', '<br />', '<div style="float:left; line-height:16px; background-color:#bbb; padding:3px 7px; border-radius:3px; margin-top:2px; font-family:monospace;">',
    // Source for SVG: https://www.npmjs.com/package/@webextensions/live-css
    '<svg viewBox="0 0 12.32 9.33" style="width:12px; height:16px; display:block; float:left;"><g><line class="st1" x1="7.6" y1="8.9" x2="7.6" y2="6.9"></line><rect width="1.9" height="1.9"></rect><rect x="1.9" y="1.9" width="1.9" height="1.9"></rect><rect x="3.7" y="3.7" width="1.9" height="1.9"></rect><rect x="1.9" y="5.6" width="1.9" height="1.9"></rect><rect y="7.5" width="1.9" height="1.9"></rect></g></svg>', '<span>npm install -g @webextensions/<span class="live-css-highlight-if-server-client-incompatible">live-css@', constants.appMajorVersion, '</span></span>', '</div>', '</div>', '</div>', '<div style="clear:both; padding-top:4px;">', '<div style="font-weight:bold; float:left;">Step 3:</div>', '<div style="margin-left:50px;">', 'Start live-css server in your project folder', '<br />', '<div style="float:left; line-height:16px; background-color:#bbb; padding:3px 7px; border-radius:3px; margin-top:2px; font-family:monospace;">',
    // Source for SVG: https://www.npmjs.com/package/@webextensions/live-css
    '<svg viewBox="0 0 12.32 9.33" style="width:12px; height:16px; display:block; float:left;"><g><line class="st1" x1="7.6" y1="8.9" x2="7.6" y2="6.9"></line><rect width="1.9" height="1.9"></rect><rect x="1.9" y="1.9" width="1.9" height="1.9"></rect><rect x="3.7" y="3.7" width="1.9" height="1.9"></rect><rect x="1.9" y="5.6" width="1.9" height="1.9"></rect><rect y="7.5" width="1.9" height="1.9"></rect></g></svg>', 'live-css', '</div>', '</div>', '</div>', '<div style="clear:both; padding-top:4px;">', '<div style="font-weight:bold; float:left;">Step 4:</div>', '<div style="margin-left:50px;">Enter following details based on previous command\'s output</div>', '</div>', '</div>', '<div class="magic-css-server-config-field-header" style="margin-top:20px;">', '<span style="color:#000; font-weight:bold;">Server path:</span> ', '<span style="color:#888;font-size:12px;">', '(eg: ', function () {
      var protocol = constants.liveCssServer.defaultProtocol,
        hostname = constants.liveCssServer.defaultHostname,
        port = constants.liveCssServer.defaultPort;
      return protocol + '//' + hostname + ':' + port;
    }(), ')', '</span>', '</div>', '<div>', '<div style="width:50px; height:20px; float:left;">', '<div class="magic-css-server-connectivity-status" style="float:right; margin-right:10px; display:block; margin-top:2px; width:16px; height:16px; background-repeat:no-repeat;"></div>', '</div>', '<div style="margin-left:50px;">', '<span style="display:inline-block; line-height:21px;">' + constants.liveCssServer.defaultProtocol + '//&nbsp;</span>', '<input type="text" spellcheck="false" class="magic-css-server-hostname" placeholder="', constants.liveCssServer.defaultHostname, '" style="width:' + (runningInAndroidFirefox ? 120 : 165) + 'px;"', ' />', '<span style="display:inline-block; line-height:21px;">&nbsp;:&nbsp;</span>', '<input type="number" min="1" max="65535" step="1" spellcheck="false" class="magic-css-server-port" placeholder="3456"', ' style="width:' + (runningInAndroidFirefox ? 40 : 80) + 'px;"', ' />', '</div>', '</div>', '<div style="min-height:35px; padding-top:3px; clear:both;">', '<div class="live-css-connectivity-error-message live-css-server-client-general-error-message" style="display:none;">', '<div>You are not connected. Is live-css server running?</div>',
    // '<div>',
    //     'Do you need to enable CORS? ',
    //     '<a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" style="margin-left:10px;">Learn more</a>',
    // '</div>',
    '</div>', '<div class="live-css-connectivity-error-message live-css-server-client-incompatible-error-message" style="display:none;">', 'Error: You need to use version ', constants.appMajorVersion, ' of the live-css server', '</div>', '</div>', '</div>', '<div class="magic-css-server-config-item">', '<div style="text-align:right">', '<button type="button" class="magicss-done-server-path-changes">Done</button>', '</div>', '</div>', '</div>', '</div>', '</div>', '</div>'].join(''));
    /* eslint-enable indent */

    var $serverHostname = window.$backEndConnectivityOptions.find('.magic-css-server-hostname'),
      serverHostnameValue = (await editor.userPreference('live-css-server-hostname')) || constants.liveCssServer.defaultHostname;
    var $serverPort = window.$backEndConnectivityOptions.find('.magic-css-server-port'),
      serverPortValue = (await editor.userPreference('live-css-server-port')) || constants.liveCssServer.defaultPort;
    $serverHostname.val(serverHostnameValue);
    $serverHostname.on('input', async function () {
      serverHostnameValue = $(this).val().trim().replace(/\/$/, '') || constants.liveCssServer.defaultHostname;
      await editor.userPreference('live-css-server-hostname', serverHostnameValue);
      await socketOb.reset();
    });
    $serverPort.val(serverPortValue);
    $serverPort.on('input', async function () {
      serverPortValue = $(this).val().trim().replace(/\/$/, '') || constants.liveCssServer.defaultPort;
      await editor.userPreference('live-css-server-port', serverPortValue);
      await socketOb.reset();
    });

    // Useful when developing/debugging
    // $backEndConnectivityOptions.find('.magic-css-back-end-connectivity-options').draggable();   // Note: jQuery UI .draggable() adds "position: relative" inline. Overriding that in CSS with "position: fixed !important;"

    window.$backEndConnectivityOptions.find('.magicss-done-server-path-changes').on('click', async function () {
      await editor.userPreference('live-css-server-hostname', serverHostnameValue);
      await editor.userPreference('live-css-server-port', serverPortValue);
      window.$backEndConnectivityOptions.remove();
      getServerDetailsFromUserAlreadyOpen = false;
      if (cbGotServerDetailsFromUser) {
        cbGotServerDetailsFromUser(null, {
          serverHostname: serverHostnameValue,
          serverPort: serverPortValue
        });
      }
    });
    window.$backEndConnectivityOptions.find('.magicss-save-server-path-changes').on('click', async function () {
      await editor.userPreference('live-css-server-hostname', serverHostnameValue);
      await editor.userPreference('live-css-server-port', serverPortValue);
      await socketOb.reset();
    });
    $('body').append(window.$backEndConnectivityOptions);
    if (serverHostnameValue && serverPortValue) {
      await socketOb.reset();
    }
  };
  var updateUiMentioningNotWatchingCssFiles = async function (editor) {
    if (socketOb.flagWatchingCssFiles) {
      socketOb.flagWatchingCssFiles = false;
      (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Stopped watching CSS files for changes');
      $(editor.container).removeClass('watching-css-files');
      editor.adjustUiPosition();
    }
    await editor.userPreference('watching-css-files', 'no');
  };
  var liveCssServerSessionClosedByUser = async function (editor) {
    // TODO:
    //     When file editing feature is available,
    //     disable editing file / notify user when
    //     the server session is disconnected

    await updateUiMentioningNotWatchingCssFiles(editor);
  };
  var $toastrConnecting, $toastrConnected, $toastrReconnectAttempt;
  var _getConnectedWithBackEnd = async function (editor, mainAsyncCallback) {
    var serverHostnameValue = (await editor.userPreference('live-css-server-hostname')) || constants.liveCssServer.defaultHostname,
      serverPortValue = (await editor.userPreference('live-css-server-port')) || constants.liveCssServer.defaultPort;
    if (socketOb.socket) {
      var socketOpts = (socketOb.socket.io || {}).opts || {};
      if (socketOpts.hostname === serverHostnameValue && socketOpts.port === serverPortValue && socketOb.socket.connected) {
        await mainAsyncCallback();
        return;
      } else {
        editor.markLiveCssServerConnectionStatus(false);
        socketOb.close();
      }
    }
    var backEndPathToShowToUser = serverHostnameValue + ':' + serverPortValue;
    if ($toastrConnecting) {
      $toastrConnecting.hide(); // Using jQuery's .hide() directly, rather than toastr.clear(), because there is no option to pass duration in the function call itself
    }

    if ($toastrConnected) {
      $toastrConnected.hide(); // Using jQuery's .hide() directly, rather than toastr.clear(), because there is no option to pass duration in the function call itself
    }

    if ($toastrReconnectAttempt) {
      $toastrReconnectAttempt.hide(); // Using jQuery's .hide() directly, rather than toastr.clear(), because there is no option to pass duration in the function call itself
    }

    $toastrConnecting = toastr.info('<div style="display:block; text-align:center; margin-top:3px; margin-bottom:15px; font-weight:bold;">' + backEndPathToShowToUser + '</div>' + '<div>' + '<button type="button" class="magic-css-toastr-socket-cancel" style="float:right;">Cancel</button>' + '<button type="button" class="magic-css-toastr-socket-configure">Settings</button>' + '</div>', 'Connecting with live-css server at: ', {
      timeOut: 0,
      onclick: async function (evt) {
        if ($(evt.target).hasClass('magic-css-toastr-socket-configure')) {
          // TODO: Verify functionality
          await _getServerDetailsFromUser(editor);
        } else if ($(evt.target).hasClass('magic-css-toastr-socket-cancel')) {
          await getDisconnectedWithBackEnd(editor, {}, async function asyncCallback() {
            await updateUiMentioningNotWatchingCssFiles(editor);
          });
        }
      }
    });

    // If the user is loading it for the first time on this domain,
    // show them the configuration options along with the guide/help
    // about the live-css server
    if (!(await editor.userPreference('live-css-server-hostname')) || !(await editor.userPreference('live-css-server-port'))) {
      await _getServerDetailsFromUser(editor, function (err) {
        if (!err) {
          setTimeout(async function () {
            await socketOb.reset(async function () {
              await mainAsyncCallback();
            });
          });
        }
      });
    } else {
      await socketOb.reset(async function () {
        await mainAsyncCallback();
      });
    }
  };
  var getDisconnectedWithBackEnd = async function (editor, options, asyncCallback) {
    socketOb.close();
    if ($toastrConnected) {
      toastr.clear($toastrConnected, {
        force: true
      });
    }
    if ($toastrConnecting) {
      toastr.clear($toastrConnecting, {
        force: true
      });
    }
    if ($toastrReconnectAttempt) {
      toastr.clear($toastrReconnectAttempt, {
        force: true
      });
    }
    await asyncCallback();
  };
  var isMac = false;
  try {
    isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0 || navigator.userAgent.indexOf('Mac') >= 0;
  } catch (e) {
    // do nothing
  }
  var noteForUndo = '<br />Note: You may press ' + (isMac ? 'Cmd' : 'Ctrl') + ' + Z to undo the change';

  // TODO: CLEANUP: This might not be required with Chromium based Edge
  // Seems to be required to unblock Ctrl-T in Microsoft Edge
  delete CodeMirror.keyMap.emacsy['Ctrl-T'];
  delete CodeMirror.keyMap.sublime['Ctrl-T'];

  // Use Alt-Up/Down to move lines up/down
  CodeMirror.keyMap.sublime['Alt-Down'] = 'swapLineDown';
  CodeMirror.keyMap.sublime['Alt-Up'] = 'swapLineUp';
  var main = async function () {
    let sessionStorageDataForInitialization = null;
    if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
      const sessionStorageData = await chromeRuntimeMessageIfRequired({
        type: 'magicss',
        subType: 'storage-data-to-initialize'
      });
      sessionStorageDataForInitialization = sessionStorageData;
    }
    const prefUseSassSyntax = await getExtensionDataAsync(USER_PREFERENCE_USE_SASS_SYNTAX);
    const flagUseSassSyntax = prefUseSassSyntax === 'yes';
    const sassCompileOptions = {};
    if (flagUseSassSyntax) {
      sassCompileOptions.indentedSyntax = true;
    }
    await (0,_utils_delayFunctionUntilTestFunction_js__WEBPACK_IMPORTED_MODULE_2__.delayFunctionUntilTestFunction)({
      tryLimit: 100,
      waitFor: 500,
      fnTest: function () {
        if ((window.Editor || {}).usable) {
          return true;
        }
        return false;
      },
      fnFirstFailure: function () {
        // do nothing
      },
      fnFailure: function () {
        // do nothing
      },
      fnSuccess: async function () {
        const remoteConfig = await getConfig();
        await initializeInstanceInfo();
        var beautifyCssWrapper = async function (cssCode) {
          var options = {};
          if ((await window.MagiCSSEditor.userPreference('use-tab-for-indentation')) === 'yes') {
            options.useTabs = true;
          } else {
            options.useSpaceCount = parseInt(await window.MagiCSSEditor.userPreference('indentation-spaces-count'), 10) || 4;
          }
          return (0,_utils_beautifyCss_js__WEBPACK_IMPORTED_MODULE_4__.beautifyCss)(cssCode, options);
        };
        window.execBeautifyCssAction = async function (editor) {
          var textValue = editor.getTextValue();
          if (!textValue.trim()) {
            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Please type some code to be beautified', 5000);
          } else {
            var beautifiedCss = await beautifyCssWrapper(textValue);
            if (textValue.trim() !== beautifiedCss.trim()) {
              await editor.setTextValue(beautifiedCss);
              await editor.reInitTextComponent({
                pleaseIgnoreCursorActivity: true
              });
              chromeRuntimeMessageIfRequired({
                type: 'magicss',
                subType: 'update-code-and-apply-css',
                payload: {
                  cssCodeToUse: beautifiedCss
                }
              });
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Your code has been beautified :-)', 5000);
            } else {
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Your code already looks beautiful :-)', 5000);
            }
          }
          editor.focus();
        };
        window.execMinifyCssAction = async function (editor) {
          var textValue = editor.getTextValue();
          if (!textValue.trim()) {
            await editor.setTextValue('');
            await editor.reInitTextComponent({
              pleaseIgnoreCursorActivity: true
            });
            chromeRuntimeMessageIfRequired({
              type: 'magicss',
              subType: 'update-code-and-apply-css',
              payload: {
                cssCodeToUse: ''
              }
            });
            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Please type some code to be minified', 5000);
          } else {
            var minifiedCSS = (0,_utils_minifyCss_js__WEBPACK_IMPORTED_MODULE_3__.minifyCss)(textValue);
            if (textValue !== minifiedCSS) {
              await editor.setTextValue(minifiedCSS);
              await editor.reInitTextComponent({
                pleaseIgnoreCursorActivity: true
              });
              chromeRuntimeMessageIfRequired({
                type: 'magicss',
                subType: 'update-code-and-apply-css',
                payload: {
                  cssCodeToUse: minifiedCSS
                }
              });
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Your code has been minified' + noteForUndo, 5000);
            } else {
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Your code is already minified', 5000);
            }
          }
          editor.focus();
        };
        window.execShowLineNumbersAction = async function (editor) {
          editor.cm.setOption('lineNumbers', true);
          await editor.userPreference('show-line-numbers', 'yes');
          chromeRuntimeMessageIfRequired({
            type: 'magicss',
            subType: 'showLineNumbers'
          });
          editor.focus();
        };
        window.execHideLineNumbersAction = async function (editor) {
          editor.cm.setOption('lineNumbers', false);
          await editor.userPreference('show-line-numbers', 'no');
          chromeRuntimeMessageIfRequired({
            type: 'magicss',
            subType: 'hideLineNumbers'
          });
          editor.focus();
        };
        window.execEnableLineWrapAction = async function (editor) {
          editor.cm.setOption('lineWrapping', true);
          await editor.userPreference('enable-line-wrap', 'yes');
          chromeRuntimeMessageIfRequired({
            type: 'magicss',
            subType: 'enableLineWrap'
          });
          editor.focus();
        };
        window.execDisableLineWrapAction = async function (editor) {
          editor.cm.setOption('lineWrapping', false);
          await editor.userPreference('enable-line-wrap', 'no');
          chromeRuntimeMessageIfRequired({
            type: 'magicss',
            subType: 'disableLineWrap'
          });
          editor.focus();
        };
        window.execEnableCssLintingAction = async function (editor) {
          if (getLanguageMode() === 'css') {
            await setCodeMirrorCSSLinting(editor, 'enable');
            chromeRuntimeMessageIfRequired({
              type: 'magicss',
              subType: 'enable-css-linting'
            });
          } else {
            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Please switch to editing code in CSS mode to enable this feature', 5000);
          }
          editor.focus();
        };
        window.execDisableCssLintingAction = async function (editor) {
          if (getLanguageMode() === 'css') {
            await setCodeMirrorCSSLinting(editor, 'disable');
            chromeRuntimeMessageIfRequired({
              type: 'magicss',
              subType: 'disable-css-linting'
            });
          } else {
            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Please switch to editing code in CSS mode to enable this feature', 5000);
          }
          editor.focus();
        };
        window.execMoreOptionsAction = function (editor) {
          try {
            chrome.runtime.sendMessage({
              openOptionsPage: true
            });
          } catch (e) {
            try {
              var href = chrome.runtime.getURL('options.html');
              if (href) {
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Configure more options for Magic CSS by going to the following address in a new tab:<br />' + href, 15000);
              }
            } catch (e) {
              handleUnrecoverableError(e);
            }
          }
          editor.focus();
        };
        window.execConvertToCssAction = async function (editor) {
          if (getLanguageMode() === 'less') {
            var lessCode = editor.getTextValue();
            if (!lessCode.trim()) {
              await editor.reInitTextComponent({
                pleaseIgnoreCursorActivity: true
              });
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Please type some LESS code to use this feature', 5000);
              editor.focus();
            } else {
              (0,_utils_lessToCss_js__WEBPACK_IMPORTED_MODULE_6__.lessToCss)(lessCode, async function asyncCallback(err, cssCode) {
                if (err) {
                  (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Invalid LESS syntax.' + '<br />Error in line: ' + err.line + ' column: ' + err.column + '<br />Error message: ' + err.message, 10000);
                  highlightErroneousLineTemporarily(editor, err.line - 1);
                  editor.setCursor({
                    line: err.line - 1,
                    ch: err.column
                  }, {
                    pleaseIgnoreCursorActivity: true
                  });
                } else {
                  let minifiedLessCode = lessCode ? (0,_utils_minifyCss_js__WEBPACK_IMPORTED_MODULE_3__.minifyCss)(lessCode) : '';
                  let beautifiedLessCode = minifiedLessCode ? await beautifyCssWrapper(minifiedLessCode) : '';
                  let minifiedCssCode = cssCode ? (0,_utils_minifyCss_js__WEBPACK_IMPORTED_MODULE_3__.minifyCss)(cssCode) : '';
                  cssCode = minifiedCssCode ? await beautifyCssWrapper(minifiedCssCode) : '';
                  if (cssCode === beautifiedLessCode) {
                    (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Your code is already CSS compatible', 5000);
                  } else {
                    await editor.setTextValue(cssCode);
                    await editor.reInitTextComponent({
                      pleaseIgnoreCursorActivity: true
                    });
                    (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Your code has been converted from Less to CSS :-)' + noteForUndo, 5000);
                  }
                }
                editor.focus();
              });
            }
          } else if (getLanguageMode() === 'sass') {
            var sassCode = editor.getTextValue();
            if (!sassCode.trim()) {
              await editor.reInitTextComponent({
                pleaseIgnoreCursorActivity: true
              });
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Please type some SASS code to use this feature', 5000);
              editor.focus();
            } else {
              (0,_utils_sassToCss_js__WEBPACK_IMPORTED_MODULE_5__.sassToCss)(sassCode, sassCompileOptions, async function asyncCallback(err, cssCode) {
                if (err) {
                  (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Invalid SASS syntax.' + '<br />Error in line: ' + err.line + ' column: ' + err.column + '<br />Error message: ' + err.message, 10000);
                  highlightErroneousLineTemporarily(editor, err.line - 1);
                  editor.setCursor({
                    line: err.line - 1,
                    ch: err.column
                  }, {
                    pleaseIgnoreCursorActivity: true
                  });
                } else {
                  let minifiedSassCode = sassCode ? (0,_utils_minifyCss_js__WEBPACK_IMPORTED_MODULE_3__.minifyCss)(sassCode) : '';
                  let beautifiedSassCode = minifiedSassCode ? await beautifyCssWrapper(minifiedSassCode) : '';
                  let minifiedCssCode = cssCode ? (0,_utils_minifyCss_js__WEBPACK_IMPORTED_MODULE_3__.minifyCss)(cssCode) : '';
                  cssCode = minifiedCssCode ? await beautifyCssWrapper(minifiedCssCode) : '';
                  if (cssCode === beautifiedSassCode) {
                    (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Your code is already CSS compatible', 5000);
                  } else {
                    await editor.setTextValue(cssCode);
                    await editor.reInitTextComponent({
                      pleaseIgnoreCursorActivity: true
                    });
                    (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Your code has been converted from Sass to CSS :-)' + noteForUndo, 5000);
                  }
                }
                editor.focus();
              });
            }
          } else {
            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Please switch to editing code in Less/Sass mode to enable this feature', 5000);
            editor.focus();
          }
        };
        var getMatchingAndSuggestedSelectors = function (targetElement) {
          var selector = window.generateFullSelector(targetElement);
          var workingSetOfSelectors = $.extend({}, window.existingCSSSelectors);
          var matchAll = function (fullSelector, smallSelector) {
            var tokens = smallSelector.split('.').join(' ').split('#').join(' ').split(' ');
            var tokenNotAvailable = tokens.some(function tokenNotInFullSelector(token) {
              return fullSelector.indexOf(token) === -1;
            });
            if (tokenNotAvailable === false) {
              return true;
            }
          };
          var matchingSelectors = [];
          var suggestedSelectors = [];
          try {
            suggestedSelectors = [window.generateSelector(targetElement, {
              skipClass: 'magicss-mouse-over-dom-element'
            }), window.generateSelector(targetElement, {
              skipClass: 'magicss-mouse-over-dom-element',
              reverseClasses: true
            }), window.generateSelector(targetElement, {
              skipClass: 'magicss-mouse-over-dom-element',
              sortClasses: true
            }), window.generateSelector(targetElement, {
              skipClass: 'magicss-mouse-over-dom-element',
              sortClasses: true,
              reverseClasses: true
            })];
          } catch (e) {
            var errorMessageHTML = 'Sorry! Magic CSS encountered an error in generating CSS selector!<br />Kindly report this issue at <a target="_blank" href="https://github.com/webextensions/live-css-editor/issues">GitHub repository for Magic CSS</a>';
            var errorMessageConsole = 'Sorry! Magic CSS encountered an error in generating CSS selector!\nKindly report this issue at https://github.com/webextensions/live-css-editor/issues (GitHub repository for Magic CSS)';
            // Kind of HACK: Show note after a timeout, otherwise the note about matching existing selector might open up and override this
            //               and trying to solve it without timeout would be a bit tricky because currently, in CodeMirror, the select event
            //               always gets fired
            setTimeout(function () {
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(errorMessageHTML, 10000);
            }, 0);
            console.log(errorMessageConsole);
            console.log(e); // The user might wish to add these detais for the report/issue in GitHub about this error.
          }

          suggestedSelectors = suggestedSelectors.filter(function (item, pos, self) {
            return self.indexOf(item) == pos;
          });
          matchingSelectors = matchingSelectors.concat(suggestedSelectors);
          Object.keys(workingSetOfSelectors).forEach(function (key) {
            var existingSelector = key;
            var matchesAll = matchAll(selector, existingSelector);
            if (matchesAll) {
              if ($(targetElement).is(existingSelector)) {
                if (matchingSelectors.indexOf(existingSelector) === -1) {
                  matchingSelectors.push(existingSelector);
                }
              }
            }
          });
          return {
            matchingAndSuggestedSelectors: matchingSelectors,
            // TODO: Fix variable naming
            suggestedSelectors: suggestedSelectors
          };
        };
        var currentNode = null;
        var timerActiveSelectorCalculation = null;
        $(document).on('mousemove', function (event) {
          if (!enablePointAndClick) {
            return;
          }
          if ($(event.target) !== currentNode) {
            currentNode = $(event.target);
            if ($(currentNode).hasClass('magicss-mouse-over-dom-element')) {
              // do nothing
            } else {
              removeMouseOverDomElementEffect();
              _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote.hide(); // Hide the suggestions shown previously (for other elements)
              if (currentNode.get(0) !== $('#MagiCSS-bookmarklet').get(0) && !$(currentNode).parents('#MagiCSS-bookmarklet').length) {
                window.clearTimeout(timerActiveSelectorCalculation);
                timerActiveSelectorCalculation = window.setTimeout(function () {
                  if (currentNode.get(0) !== event.target) {
                    return;
                  }
                  var matchingAndSuggestedSelectors = getMatchingAndSuggestedSelectors(currentNode.get(0)).matchingAndSuggestedSelectors;
                  elementHadClassAttributeBeforePointAndSelect = currentNode.get(0).hasAttribute('class');

                  // elementHadTitleAttributeBeforePointAndSelect = currentNode.get(0).hasAttribute('title');
                  // if (elementHadTitleAttributeBeforePointAndSelect) {
                  //     titleValueOfElementBeforePointAndSelect = currentNode.attr('title');
                  // } else {
                  //     titleValueOfElementBeforePointAndSelect = undefined;
                  // }

                  var title = '';
                  if (matchingAndSuggestedSelectors.length === 1) {
                    title = 'Suggested CSS selector:';
                  } else if (matchingAndSuggestedSelectors.length > 1) {
                    title = 'Suggested CSS selectors:';
                  }
                  // title += '\n    ' + matchingAndSuggestedSelectors.join('\n    ');
                  // $(currentNode).attr('title', title);
                  title += '<span style="font-weight:normal;">' + '<br />' + matchingAndSuggestedSelectors.join('<br />') + '</span>';
                  (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(title, 5000, {
                    textAlignment: 'left',
                    unobtrusive: true
                  });
                }, 500);
                $(currentNode).addClass('magicss-mouse-over-dom-element');
              }
            }
          }
        });
        $(document).on('mousedown', function (evt) {
          if (evt.which !== 1) {
            // If it is not left click
            return;
          }
          if (!enablePointAndClick) {
            return;
          } else {
            if ($(evt.target).hasClass('magicss-point-and-click')) {
              // do nothing
            } else {
              disablePointAndClickFunctionality(window.MagiCSSEditor);
            }
          }
          var currentNode = $(evt.target);
          if (currentNode.get(0) === $('#MagiCSS-bookmarklet').get(0) || $(currentNode).parents('#MagiCSS-bookmarklet').length) {
            return;
          }
          var $div = $('<div></div>');
          $('body').append($div);
          $div.attr('class', 'magicss-block-click');
          $div.css('position', 'fixed');
          $div.css('background-color', 'rgba(0,0,0,0)');
          $div.css('z-index', '2147483600');
          $div.css('width', '100%');
          $div.css('height', '100%');
          $div.css('left', '0px');
          $div.css('top', '0px');
          removeMouseOverDomElementEffect();
          $div.on('mouseup', function () {
            $div.remove();
          });
          var targetElement = evt.target;
          setTimeout(async function () {
            var selectorsOb = getMatchingAndSuggestedSelectors(targetElement);
            // TODO: Fix variable naming
            var matchingSelectors = selectorsOb.matchingAndSuggestedSelectors,
              suggestedSelectors = selectorsOb.suggestedSelectors;
            var cm = window.MagiCSSEditor.cm;
            var currentLine = cm.getLine(cm.getCursor().line);
            var whitespaceCharactersInCurrentLine = (currentLine.match(/^\s+/g) || [''])[0];
            var originalCursorPosition = cm.getCursor();
            var anyCharacterAfterCurrentCursorPosition = true;
            var anyNonWhitespaceCharacterBeforeCurrentCursorPosition = true;
            var indexOfFirstNonWhitespaceCharacter = currentLine.length - currentLine.trimLeft().length;
            if (indexOfFirstNonWhitespaceCharacter >= originalCursorPosition.ch) {
              anyNonWhitespaceCharacterBeforeCurrentCursorPosition = false;
            }
            if (originalCursorPosition.ch === currentLine.length) {
              anyCharacterAfterCurrentCursorPosition = false;
            }
            var useTabs = (await window.MagiCSSEditor.userPreference('use-tab-for-indentation')) === 'yes';
            var whitespaceToAdd;
            if (useTabs) {
              whitespaceToAdd = '\t';
            } else {
              var indentationSpacesCount = parseInt(await window.MagiCSSEditor.userPreference('indentation-spaces-count'), 10);
              whitespaceToAdd = ' '.repeat(indentationSpacesCount || 4);
            }
            var extraSpaces = whitespaceCharactersInCurrentLine;
            for (let i = 0; i < matchingSelectors.length; i++) {
              matchingSelectors[i] = {
                displayText: matchingSelectors[i],
                originalSelector: matchingSelectors[i],
                sources: function () {
                  var sources = [];
                  if (suggestedSelectors.indexOf(matchingSelectors[i]) >= 0) {
                    sources.push('Suggested by Magic CSS');
                  }
                  if (window.existingCSSSelectors[matchingSelectors[i]]) {
                    sources = sources.concat(window.existingCSSSelectors[matchingSelectors[i]].map(function (item) {
                      // Remove the "reloadedAt=..." part from the URL
                      return item.replace(/[?&]reloadedAt=[\d-_:.]+/, '');
                    }));
                  }
                  return sources;
                }(),
                text: (anyNonWhitespaceCharacterBeforeCurrentCursorPosition ? '\n' + extraSpaces : '') + matchingSelectors[i] + ' {' + '\n' + extraSpaces + whitespaceToAdd + '\n' + extraSpaces + '}' + (anyCharacterAfterCurrentCursorPosition ? '\n' + extraSpaces : '')
              };
            }
            for (let i = 0; i < matchingSelectors.length; i++) {
              var sources = '';
              matchingSelectors[i].sources.forEach(function (source) {
                if (sources !== '') {
                  sources += ', ';
                }
                sources += ellipsis(source.substr(source.lastIndexOf('/') + 1), 50);
              });
              matchingSelectors[i].sources = sources;
            }
            if (cm.showHint) {
              cm.focus();
              var ob = {
                from: cm.getDoc().getCursor(),
                to: cm.getDoc().getCursor(),
                list: matchingSelectors
              };
              CodeMirror.on(ob, 'select', function (selectedTextOb) {
                showCSSSelectorMatches(selectedTextOb, window.MagiCSSEditor);
              });
              CodeMirror.on(ob, 'pick', function () {
                var cursorPos = cm.getCursor();
                if (anyCharacterAfterCurrentCursorPosition) {
                  cm.setCursor({
                    line: cursorPos.line - 2
                  });
                } else {
                  cm.setCursor({
                    line: cursorPos.line - 1
                  });
                }
              });
              CodeMirror.on(ob, 'close', function () {
                window.MagiCSSEditor.styleHighlightingSelector.cssText = '';
                window.MagiCSSEditor.styleHighlightingSelector.applyTag();
              });
              cm.showHint({
                hint: function () {
                  return ob;
                }
              });
            }
          });
          return false;
        });
        var csSpec = CodeMirror.resolveMode('text/css'),
          cssPropertyKeywords = csSpec.propertyKeywords,
          cssPropertyKeywordsAutocompleteObject = {};
        Object.keys(cssPropertyKeywords).forEach(function (key) {
          cssPropertyKeywordsAutocompleteObject[key] = {
            displayText: key,
            text: key + ': '
          };
        });

        // Don't let mouse scroll on CodeMirror hints pass on to the parent elements
        // http://stackoverflow.com/questions/5802467/prevent-scrolling-of-parent-element/16324762#16324762
        $(document).on('DOMMouseScroll mousewheel', '.CodeMirror-hints', function (ev) {
          var $this = $(this),
            scrollTop = this.scrollTop,
            scrollHeight = this.scrollHeight,
            height = $this.innerHeight(),
            delta = ev.type == 'DOMMouseScroll' ? ev.originalEvent.detail * -40 : ev.originalEvent.wheelDelta,
            up = delta > 0;
          var prevent = function () {
            ev.stopPropagation();
            ev.preventDefault();
            ev.returnValue = false;
            return false;
          };
          if (!up && -delta > scrollHeight - height - scrollTop) {
            // Scrolling down, but this will take us past the bottom.
            $this.scrollTop(scrollHeight);
            return prevent();
          } else if (up && delta > scrollTop) {
            // Scrolling up, but this will take us past the top.
            $this.scrollTop(0);
            return prevent();
          }
        });
        var smc;
        var id = 'MagiCSS-bookmarklet',
          newStyleTagId = id + '-html-id',
          newStyleTag = new _utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__.StyleTag({
            id: newStyleTagId,
            parentTag: 'body',
            attributes: [{
              name: 'data-style-created-by',
              value: 'magicss'
            }],
            overwriteExistingStyleTagWithSameId: true
          });
        var saveStatusUpdateTimeout;
        var fnApplyTextAsCSS = async function (editor, options) {
          options = options || {};
          var disabled = false;
          if ((await editor.userPreference('disable-styles')) === 'yes') {
            disabled = true;
          }
          if (getLanguageMode() === 'file') {
            if (options.skipSavingFile) {
              // do nothing
            } else {
              var targetFileContents = editor.getTextValue();
              var $fileEditStatus = $('.footer-for-server-mode .file-edit-status');
              var saveInProgress = true;
              setTimeout(function () {
                if (saveInProgress) {
                  $fileEditStatus.html('<span style="top:-1px; position:relative;">◔</span> Saving');
                }
              }, 300);
              var filePath = await editor.userPreference('file-to-edit');
              socketOb.socket.emit('PUT', {
                url: '/live-css/edit-file/' + filePath,
                targetFileContents: targetFileContents
              }, function (status) {
                saveInProgress = false;
                if (status === 'success') {
                  $fileEditStatus.html('✔ Saved');
                  clearTimeout(saveStatusUpdateTimeout);
                  saveStatusUpdateTimeout = setTimeout(function () {
                    $fileEditStatus.html('');
                  }, 2500);
                } else {
                  $fileEditStatus.html('✘ Save failed');
                  (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('<span style="font-weight:normal">Your recent changes are not saved. Please try again.</span>' + '<br/>Probable cause: <span style="font-weight:normal">live-css server encountered an unexpected error in saving the file</span>', 7500, {
                    backgroundColor: '#f5bcae',
                    borderColor: '#e87457'
                  });
                }
              });
            }
          } else if (getLanguageMode() === 'less') {
            var lessCode = editor.getTextValue(),
              lessOptions = {
                sourceMap: true
              };
            try {
              const less = await loadIfNotAvailable('less');
              less.default.render(lessCode, lessOptions, async function asyncCallback(err, output) {
                smc = null; // Unset old SourceMapConsumer

                if (err) {
                  // FIXME: The following setTimeout is a temporary fix for alertNote getting hidden by 'delayedcursormove()'
                  setTimeout(function () {
                    (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Invalid LESS syntax.' + '<br />Error in line: ' + err.line + ' column: ' + err.column + '<br />Error message: ' + err.message, 10000);
                    highlightErroneousLineTemporarily(editor, err.line - 1);
                  }, 0);
                } else {
                  var strCssCode = output.css;
                  newStyleTag.cssText = strCssCode;
                  newStyleTag.disabled = disabled;
                  let appliedCssText = newStyleTag.applyTag();
                  await rememberLastAppliedCss(appliedCssText);
                  var rawSourceMap = output.map;
                  if (rawSourceMap) {
                    smc = new (_3rdparty_source_map_js__WEBPACK_IMPORTED_MODULE_10___default().SourceMapConsumer)(rawSourceMap);
                  }
                }
              });
            } catch (e) {
              handleUnrecoverableError(e);
            }
          } else if (getLanguageMode() === 'sass') {
            var fnSassToCssAndApply = function () {
              var SassParser = window.Sass || typeof Sass !== 'undefined' && Sass,
                sassCode = editor.getTextValue() || ' '; // Sass compiler throws an error for empty code string

              SassParser.compile(sassCode, sassCompileOptions, async function asyncCallback(result) {
                smc = null; // Unset old SourceMapConsumer

                if (result.status === 0) {
                  var strCssCode = result.text || '';
                  newStyleTag.cssText = strCssCode;
                  newStyleTag.disabled = disabled;
                  let appliedCssText = newStyleTag.applyTag();
                  await rememberLastAppliedCss(appliedCssText);
                  var rawSourceMap = result.map;
                  if (rawSourceMap) {
                    smc = new (_3rdparty_source_map_js__WEBPACK_IMPORTED_MODULE_10___default().SourceMapConsumer)(rawSourceMap);
                  }
                } else if (result.message) {
                  var err = result;
                  // FIXME: The following setTimeout is a temporary fix for alertNote getting hidden by 'delayedcursormove()'
                  setTimeout(function () {
                    (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Invalid SASS syntax.' + '<br />Error in line: ' + err.line + ' column: ' + err.column + '<br />Error message: ' + err.message, 10000);
                    highlightErroneousLineTemporarily(editor, err.line - 1);
                  }, 0);
                } else {
                  // FIXME: The following setTimeout is a temporary fix for alertNote getting hidden by 'delayedcursormove()'
                  setTimeout(function () {
                    (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Unexpected error in parsing Sass.' + '<br />Please report this bug at <a href="https://github.com/webextensions/live-css-editor/issues">https://github.com/webextensions/live-css-editor/issues</a>', 10000);
                  }, 0);
                }
              });
            };
            const Sass = await loadIfNotAvailable('sass');
            fnSassToCssAndApply();

            /*
            if (
                // isOpera || // Commented out so that Opera users can use Sass the way it is loaded in Chrome (when installed from Chrome Web Store)
                isFirefox ||
                window.Sass ||
                (typeof Sass !== 'undefined' && Sass)
            ) {
                fnSassToCssAndApply();
            } else {
                // Ensure that we don't send multiple load requests at once, by not sending request if previous one is still pending for succeess/failure
                if (!window.isActiveLoadSassRequest) {
                    window.isActiveLoadSassRequest = true;
                                    // https://github.com/medialize/sass.js
                                    // https://cdnjs.com/libraries/sass.js
                    var sassJsUrl = 'https://cdnjs.cloudflare.com/ajax/libs/sass.js/0.11.1/sass.sync.min.js',
                        preRunReplace = [{oldText: 'this,function', newText: 'window,function'}];   // Required for making Sass load in Firefox - Reference: https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Xray_vision
                    if (!options.skipNotifications) {
                        alertNote('Loading... Sass parser from:<br />' + sassJsUrl, 10000);
                    }
                     if (myWin.flagEditorInExternalWindow) {
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/sass.js/0.11.1/sass.sync.min.js';
                        script.onload = function () {
                            window.isActiveLoadSassRequest = false;
                            if (!options.skipNotifications) {
                                alertNote('Loaded Sass parser from:<br />' + sassJsUrl, 2000);
                            }
                            setTimeout(function () {
                                // Ensure that getLanguageMode() is still 'sass'
                                if (getLanguageMode() === 'sass') {
                                    fnSassToCssAndApply();
                                }
                            }, 300);
                        };
                        script.onerror = function () {
                            window.isActiveLoadSassRequest = false;
                            alertNote(
                                'Error! Failed to load Sass parser from:<br />' + sassJsUrl + '<br />Please ensure that you are connected to internet and Magic CSS will try again to load it when you make any code changes.',
                                10000
                            );
                        };
                        document.body.appendChild(script);
                    } else {
                        try {
                            chrome.runtime.sendMessage(
                                {
                                    loadRemoteJs: sassJsUrl,
                                    preRunReplace: preRunReplace
                                },
                                function (error) {
                                    window.isActiveLoadSassRequest = false;
                                    if (chrome.runtime.lastError) {
                                        console.log('Error message reported by Magic CSS:', chrome.runtime.lastError);
                                        alertNote(
                                            'Error! Unexpected error encountered by Magic CSS extension.<br />You may need to reload webpage & Magic CSS and try again.',
                                            10000
                                        );
                                    } else if (error) {
                                        alertNote(
                                            'Error! Failed to load Sass parser from:<br />' + sassJsUrl + '<br />Please ensure that you are connected to internet and Magic CSS will try again to load it when you make any code changes.',
                                            10000
                                        );
                                    } else {
                                        if (!options.skipNotifications) {
                                            alertNote('Loaded Sass parser from:<br />' + sassJsUrl, 2000);
                                        }
                                        setTimeout(function () {
                                            // Ensure that getLanguageMode() is still 'sass'
                                            if (getLanguageMode() === 'sass') {
                                                fnSassToCssAndApply();
                                            }
                                        }, 300);
                                    }
                                }
                            );
                        } catch (e) {
                            window.isActiveLoadSassRequest = false;
                            handleUnrecoverableError(e);
                        }
                    }
                }
            }
            /* */
          } else {
            var cssCode = editor.getTextValue();
            newStyleTag.cssText = cssCode;
            newStyleTag.disabled = disabled;
            let appliedCssText = newStyleTag.applyTag();
            await rememberLastAppliedCss(appliedCssText);
          }
          chromeRuntimeMessageIfRequired({
            type: 'magicss',
            subType: 'magicss-fnApplyTextAsCSS',
            payload: {
              options
            }
          });
        };
        window.fnApplyTextAsCSS = fnApplyTextAsCSS;
        var showFileEditOptions = async function (editor, callback) {
          /* eslint-disable indent */
          var $fileEditOptions = $(['<div>', '<div class="magic-css-full-page-overlay">', '</div>', '<div class="magic-css-full-page-contents magic-css-ui" style="pointer-events:none;">', '<div style="display:flex;justify-content:center;/*align-items:center;*/margin-top:38px;height:100%;">', '<div class="magic-css-edit-file-options" style="pointer-events:initial;">', '<div class="magic-css-row magic-css-file-config-item">', '<div class="magic-css-row-item-1 magic-css-file-field-header">File to edit</div>', '<div class="magic-css-row-item-2"><input class="magicss-file-to-edit" /></div>', '</div>', '<div class="magic-css-row magic-css-file-config-item" style="text-align:center">', '<button type="button" class="magicss-start-file-editing" disabled="disabled">Start Editing</button>', '<button type="button" class="magicss-cancel-file-mode" style="margin-left:20px">Cancel</button>', '</div>', '</div>', '</div>', '</div>', '</div>'].join(''));
          /* eslint-enable indent */

          var fileSuggestionValue = await editor.userPreference('file-to-edit');
          var fileSuggestions = $fileEditOptions.find('.magicss-file-to-edit').magicSuggest({
            method: 'GET',
            placeholder: 'Type file name or click here',
            // noSuggestionText: 'Could not find a matching file', // This option didn't seem to work
            allowFreeEntries: false,
            maxSelection: 1,
            typeDelay: 50,
            useZebraStyle: true,
            // expanded: true, // We may want it, but it seems more cleaner without expanded: true
            // expandOnFocus: true, // This option (when set to true) does not seem to work well with useTabKey: true
            useTabKey: true,
            toggleOnClick: true,
            inputCfg: {
              id: 'file-suggestion-input' // Useful for setting focus later on
            },

            value: function () {
              var ob = undefined;
              if (fileSuggestionValue) {
                ob = {
                  id: fileSuggestionValue,
                  name: fileSuggestionValue
                };
              }
              return ob;
            }(),
            data: await async function () {
              // var protocolValue = (window.location.protocol === 'https:') ? 'https:' : 'http:',
              var protocolValue = 'http:',
                serverHostnameValue = (await editor.userPreference('live-css-server-hostname')) || constants.liveCssServer.defaultHostname,
                serverPortValue = (await editor.userPreference('live-css-server-port')) || constants.liveCssServer.defaultPort,
                backEndPath = serverHostnameValue + ':' + serverPortValue + '/',
                url = protocolValue + '//' + backEndPath + 'live-css/list-of-editable-files';
              return url;
            }()

            // data: [{"id":"Paris", "name":"Paris"}, {"id":"New York", "name":"New York"}]
            // data: 'random.json',
            // renderer: function(data){
            //     return '<div style="padding: 5px; overflow:hidden;">' +
            //     // '<div style="float: left;"><img src="' + data.picture + '" /></div>' +
            //     '<div style="float: left; margin-left: 5px">' +
            //     '<div style="font-weight: bold; color: #333; font-size: 10px; line-height: 11px">' + data.name + '</div>' +
            //     '<div style="color: #999; font-size: 9px">' + data.name + '</div>' +
            //     '</div>' +
            //     '</div><div style="clear:both;"></div>'; // make sure we have closed our dom stuff
            // }
          });

          window.fileSuggestions = fileSuggestions;
          var $fileSuggestions = $(fileSuggestions);
          $fileSuggestions.on('selectionchange', async function (e, m) {
            // eslint-disable-line no-unused-vars
            var fileToEdit = this.getValue()[0] || '';
            if (fileToEdit) {
              $fileEditOptions.find('.magicss-start-file-editing').removeAttr('disabled');
            } else {
              $fileEditOptions.find('.magicss-start-file-editing').attr('disabled', 'disabled');
            }
          });

          // If we wish to make it draggable, then ideally, the height/direction of the files list would also
          // need to be adjusted. Hence, commenting it out for now.
          // console.log('TODO - Comment it out');
          // $fileEditOptions.find('.magic-css-edit-file-options').draggable();      // Note: jQuery UI .draggable() adds "position: relative" inline. Overriding that in CSS with "position: fixed !important;"

          // $fileEditOptions.find('.magic-css-full-page-overlay, .magicss-cancel-file-mode').on('click', function () {
          $fileEditOptions.find('.magicss-cancel-file-mode').on('click', function () {
            $fileEditOptions.remove();
          });
          $fileEditOptions.find('.magicss-start-file-editing').on('click', async function () {
            var filePath = fileSuggestions.getValue()[0] || '';
            await editor.userPreference('file-to-edit', filePath);
            $fileEditOptions.remove();
            callback(filePath);
          });
          $('body').append($fileEditOptions);
          await asyncTimeout(0); // Required for the focus functionality to work correctly
          $fileEditOptions.find('#file-suggestion-input').focus();
        };
        var loadFile = function (options) {
          var filePath = options.filePath,
            successCallback = options.successCallback,
            asyncErrorCallback = options.errorCallback;

          // Using a timeout of 0ms so that the "socket" gets initiated if it is required
          setTimeout(function () {
            socketOb.socket.emit('GET', {
              url: filePath
            }, async function (status, data) {
              if (status === 'success') {
                successCallback({
                  path: filePath,
                  contents: data.fileContents
                });
              } else {
                await asyncErrorCallback();
              }
            });
          }, 0);
        };
        var getDataForFileToEdit = async function (editor, options, cbWhenGotDataForFileToEdit) {
          options = options || {};
          var needInputThroughUi = true;
          var pathOfFileToEdit = await editor.userPreference('file-to-edit');
          if (pathOfFileToEdit) {
            needInputThroughUi = false;
          }
          socketOb.getConnected(editor, async function () {
            if (needInputThroughUi || options.showUi) {
              await showFileEditOptions(editor, function (filePath) {
                loadFile({
                  filePath: filePath,
                  successCallback: function (file) {
                    cbWhenGotDataForFileToEdit(file);
                  },
                  errorCallback: async function () {
                    await editor.userPreference('file-to-edit', null);
                    await getDataForFileToEdit(editor, options, cbWhenGotDataForFileToEdit);
                  }
                });
              });
            } else {
              loadFile({
                filePath: pathOfFileToEdit,
                successCallback: function (file) {
                  cbWhenGotDataForFileToEdit(file);
                },
                errorCallback: async function () {
                  await editor.userPreference('file-to-edit', null);
                  await getDataForFileToEdit(editor, options, cbWhenGotDataForFileToEdit);
                }
              });
            }
          });
        };
        var setLanguageModeClass = function (editor, cls) {
          $(editor.container).removeClass('magicss-selected-mode-css').removeClass('magicss-selected-mode-less').removeClass('magicss-selected-mode-sass').removeClass('magicss-selected-mode-file').addClass(cls);
          editor.adjustUiPosition();
        };
        var setLanguageMode = async function (newLanguageMode, editor, options) {
          options = options || {};
          if (newLanguageMode === 'file') {
            var fileEditingOptions = {};
            var previousLanguageMode = getLanguageMode();
            // If previous mode was also 'file' (meaning the user clicked again), then we prompt the user for selecting file (or related options)
            if (previousLanguageMode === 'file') {
              fileEditingOptions.showUi = true;
            }
            if (previousLanguageMode === 'file') {
              // do nothing
            } else {
              await editor.userPreference('language-mode-non-file', previousLanguageMode);
            }
            await getDataForFileToEdit(editor, fileEditingOptions, async function (file) {
              editor.options.rememberText = false;
              setLanguageModeClass(editor, 'magicss-selected-mode-file');
              await editor.userPreference('language-mode', 'file');
              editor.cm.setOption('mode', 'text/x-less');
              setCodeMirrorCSSLinting(editor, 'disable');
              socketOb.flagEditingFile = true;
              // $('.footer-for-server-mode').show();
              // editor.adjustUiPosition();

              // TODO: Fix this code related to "getFileNameFromPath" (it is not in a consistent state after the rebase operation)
              // TODO: Reuse code. Currently, the following piece of code is also copied for the scenario when user clicks on the footer in file mode
              $('.footer-for-server-mode .name-of-file-being-edited').html(htmlEscape(getFileNameFromPath(file.path))).attr('title', file.path).css({
                marginRight: 75
              }).animate({
                marginRight: 0
              }, 1000).fadeOut(100).fadeIn(750);
              if (!options.skipNotifications) {
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Auto-save changes for: <span style="font-weight:normal;">' + htmlEscape(file.path) + '</span>', 5000, {
                  backgroundColor: 'lightgreen',
                  borderColor: 'darkgreen'
                });
              }
              await editor.setTextValue(file.contents);
              await editor.reInitTextComponent({
                pleaseIgnoreCursorActivity: true
              });
              editor.focus();

              // Clear the undo-redo hstory
              editor.cm.clearHistory();
              window.languageModeIsIntermittent = false;
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'switchedSelectedMode',
                type: 'file'
              });
            });
          } else {
            editor.options.rememberText = true;

            // If previous mode was 'file'
            if (getLanguageMode() === 'file') {
              // Restore the saved code
              await editor.setTextValue(editor.userPreference('textarea-value'));
              await editor.reInitTextComponent({
                pleaseIgnoreCursorActivity: true
              });

              // Clear the undo-redo hstory
              editor.cm.clearHistory();
            }
            socketOb.flagEditingFile = false;
            await socketOb._disconnectIfRequiredServerHelper();
            // $('.footer-for-server-mode').hide();
            // editor.adjustUiPosition();

            if (newLanguageMode === 'less') {
              setLanguageModeClass(editor, 'magicss-selected-mode-less');
              await editor.userPreference('language-mode', 'less');
              editor.cm.setOption('mode', 'text/x-less');
              await setCodeMirrorCSSLinting(editor, 'disable');
              if (!options.skipNotifications) {
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Now editing code in LESS mode', 5000);
              }
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'switchedSelectedMode',
                type: 'less'
              });
            } else if (newLanguageMode === 'sass') {
              setLanguageModeClass(editor, 'magicss-selected-mode-sass');
              await editor.userPreference('language-mode', 'sass');
              editor.cm.setOption('mode', 'text/x-scss');
              await setCodeMirrorCSSLinting(editor, 'disable');
              if (!options.skipNotifications) {
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Now editing code in SASS mode', 5000);
              }
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'switchedSelectedMode',
                type: 'sass'
              });
            } else {
              setLanguageModeClass(editor, 'magicss-selected-mode-css');
              await editor.userPreference('language-mode', 'css');
              editor.cm.setOption('mode', 'text/css');
              if (!options.skipNotifications) {
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Now editing code in CSS mode', 5000);
              }
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'switchedSelectedMode',
                type: 'css'
              });
            }
            await fnApplyTextAsCSS(editor, {
              skipNotifications: options.skipNotifications
            });
          }
        };
        var getLanguageMode = function () {
          var $el = $('#' + id),
            mode;
          if ($el.hasClass('magicss-selected-mode-file')) {
            mode = 'file';
          } else if ($el.hasClass('magicss-selected-mode-less')) {
            mode = 'less';
          } else if ($el.hasClass('magicss-selected-mode-sass')) {
            mode = 'sass';
          } else {
            mode = 'css';
          }
          return mode;
        };
        var getMagicCSSForChrome = null,
          getMagicCSSForEdge = null,
          getMagicCSSForFirefox = null;
        if (!isChrome) {
          getMagicCSSForChrome = {
            skip: true,
            name: 'get-magic-css-for-chrome',
            title: 'Magic CSS for Chrome',
            uniqCls: 'get-magic-css-for-chrome',
            href: extensionUrl.chrome
          };
        }
        if (!isEdge) {
          getMagicCSSForEdge = {
            skip: true,
            name: 'get-magic-css-for-edge',
            title: 'Magic CSS for Edge',
            uniqCls: 'get-magic-css-for-edge',
            href: extensionUrl.edge
          };
        }

        // if (!isFirefox) {
        getMagicCSSForFirefox = {
          skip: true,
          name: 'get-magic-css-for-firefox',
          // title: 'Magic CSS for Firefox (Android)',
          title: 'Magic CSS for Android / Firefox',
          uniqCls: 'get-magic-css-for-firefox',
          href: extensionUrl.firefox
        };
        // }

        var iconForRateUs = function (options) {
          options = options || {};
          var icon = null;
          if (isChrome || isEdge || isFirefox || isOpera) {
            if (isChrome) {
              icon = {
                skip: true,
                name: 'rate-on-webstore',
                title: 'Rate us on Chrome Web Store',
                cls: 'magicss-rate-on-webstore',
                uniqCls: 'icon-chrome-web-store',
                href: extensionUrl.chrome + '/reviews'
              };
            } else if (isEdge) {
              icon = {
                skip: true,
                name: 'rate-on-webstore',
                title: 'Rate us on Microsoft Store',
                cls: 'magicss-rate-on-webstore',
                uniqCls: 'icon-microsoft-store',
                href: extensionUrl.edge
              };
            } else if (isFirefox) {
              icon = {
                skip: true,
                name: 'rate-on-webstore',
                title: 'Rate us on Firefox Add-ons Store',
                cls: 'magicss-rate-on-webstore',
                uniqCls: 'icon-firefox-add-ons-store',
                href: extensionUrl.firefox + 'reviews/'
              };
            } else if (isOpera) {
              icon = {
                skip: true,
                name: 'rate-on-webstore',
                title: 'Rate us on Opera Add-ons Store',
                cls: 'magicss-rate-on-webstore',
                uniqCls: 'icon-opera-add-ons-store',
                href: extensionUrl.opera + '#feedback-container'
              };
            }
            if (icon && icon.cls) {
              if (options.addOpaqueOnHoverClass) {
                icon.cls += ' editor-opaque-on-hover';
              }
              icon.cls += ' show-for-w-400-plus';
            }
          }
          return icon;
        };
        window.execIconToShowForRateUs = function () {
          var icon = null;
          if (isChrome || isEdge || isFirefox || isOpera) {
            if (isChrome) {
              icon = {
                browser: 'chrome',
                href: extensionUrl.chrome + '/reviews'
              };
            } else if (isEdge) {
              icon = {
                browser: 'edge',
                href: extensionUrl.edge
              };
            } else if (isFirefox) {
              icon = {
                browser: 'firefox',
                href: extensionUrl.firefox + 'reviews/'
              };
            } else if (isOpera) {
              icon = {
                browser: 'opera',
                href: extensionUrl.opera + '#feedback-container'
              };
            }
          }
          return icon;
        };
        var togglePointAndClick = function (editor) {
          if (enablePointAndClick) {
            disablePointAndClickFunctionality(editor);
          } else {
            var currentSelection = editor.cm.getSelection();
            if (currentSelection) {
              var currentCursorPosition = editor.cm.getCursor();
              editor.setCursor(currentCursorPosition, {
                pleaseIgnoreCursorActivity: true
              });
            }

            // Just a logical block
            {
              var cursorPosition = editor.cm.getCursor();
              var splitText = editor.splitTextByCursor();
              var lastIndexOfClosingBraceBeforeCursor = splitText.strBeforeCursor.lastIndexOf('}');
              var lastIndexOfOpeningBraceBeforeCursor = splitText.strBeforeCursor.lastIndexOf('{');
              var firstIndexOfClosingBraceAfterCursor = splitText.strAfterCursor.indexOf('}');
              var adjustCursorPosition = function (delta) {
                var targetPosition = editor.cm.findPosH(cursorPosition, delta, 'char', false);
                editor.setCursor(targetPosition, {
                  pleaseIgnoreCursorActivity: true
                });
              };
              var moveCursorToEndOfLineIfRequired = function () {
                // If there is any non-whitespace character before the cursor in the current line
                if (editor.cm.getLine(cursorPosition.line).substr(0, cursorPosition.ch).trim()) {
                  // Move the cursor to the end of the current line
                  // Which helps in avoiding the scenario that when the user does point-and-click,
                  // the text insertion does not happen in the middle of the text
                  editor.setCursor({
                    line: cursorPosition.line
                  }, {
                    pleaseIgnoreCursorActivity: true
                  });
                }
              };
              if (lastIndexOfOpeningBraceBeforeCursor >= 0 && lastIndexOfClosingBraceBeforeCursor < lastIndexOfOpeningBraceBeforeCursor) {
                if (firstIndexOfClosingBraceAfterCursor >= 0) {
                  adjustCursorPosition(firstIndexOfClosingBraceAfterCursor + 1);
                } else {
                  moveCursorToEndOfLineIfRequired();
                }
              } else {
                var anyNonWhitespaceCharacterBetweenLastClosingBracketAndCurrentCursorPosition = !!splitText.strBeforeCursor.substring(lastIndexOfClosingBraceBeforeCursor + 1).trim();
                if (anyNonWhitespaceCharacterBetweenLastClosingBracketAndCurrentCursorPosition) {
                  if (firstIndexOfClosingBraceAfterCursor >= 0) {
                    adjustCursorPosition(firstIndexOfClosingBraceAfterCursor + 1);
                  } else {
                    moveCursorToEndOfLineIfRequired();
                  }
                }
              }
            }
            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(runningInAndroidFirefox ? 'Select an element in the page to generate its CSS selector' : 'Select an element in the page to generate its CSS selector<br />(Shortcut: Alt + Shift + S)', 5000);
            enablePointAndClickFunctionality(editor);
          }
        };
        var focusChangeInformationLoggedInConsoleJustNow = false;
        var informUserAboutProblematicFocus = function () {
          (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Typing in the Magic CSS editor may not work well.' + '<br />It appears that some JavaScript code running on the page steals focus.' + '<br />Check the "Console" in "Developer tools" for more information.', 20000, {
            backgroundColor: '#f5bcae',
            borderColor: '#e87457'
          });
          if (!focusChangeInformationLoggedInConsoleJustNow) {
            // References:
            //    https://github.com/webextensions/live-css-editor/issues/4
            //    https://github.com/zenorocha/clipboard.js/wiki/Known-Issues
            console.log('************************* Note *************************' + '\nTyping in the Magic CSS editor may not work well.' + '\nIt appears that some JavaScript code running on the page steals focus.' + '\nYou may need to workaround the problematic JavaScript code to avoid this problem.' + '\n' + '\nHow to workaround this problem?' + '\n* If you are using jQuery UI, try executing:' +
            // eg: https://jqueryui.com/resources/demos/dialog/modal-message.html
            '\n    jQuery.ui.dialog.prototype._focusTabbable = jQuery.noop;' +
            // eg: Open modal at https://www.w3schools.com/bootstrap/bootstrap_modal.asp
            '\n* If you are using Bootstrap 3, try executing:' + '\n    jQuery.fn.modal.Constructor.prototype.enforceFocus = function() {};      // You may need to close and reopen the modal dialog' +
            // eg: Open modal at https://getbootstrap.com/docs/4.1/components/modal/
            '\n* If you are using Bootstrap 4 or later, try executing:' + '\n    jQuery.fn.modal.Constructor.prototype._enforceFocus = function() {};     // You may need to close and reopen the modal dialog' + '\n' + '\nFor more details, kindly refer to:' + '\n    https://github.com/webextensions/live-css-editor/issues/4' + '\n\n');
            focusChangeInformationLoggedInConsoleJustNow = true;
            setTimeout(function () {
              focusChangeInformationLoggedInConsoleJustNow = false;
            }, 100);
          }
        };
        var options = {
          id: id,
          title: function ($, editor) {
            var $outer = $('<div style="display:flex"></div>'),
              $titleItems = $('<div class="magicss-title"></div>');
            $outer.append($titleItems);
            $titleItems.append('<div class="magicss-mode-button magicss-mode-file" title="File mode">' +
            // '<span class="file-mode-is-beta">' +
            //     '&nbsp;This is a BETA feature&nbsp;' +
            // '</span>' +
            'f<span class="hide-when-magicss-editor-is-small">ile</span>' + '</div>' + '<div class="magicss-mode-button magicss-mode-css" title="CSS mode">c<span class="hide-when-magicss-editor-is-small">ss</span></div>' + '<div class="magicss-mode-button magicss-mode-less" title="Less mode">l<span class="hide-when-magicss-editor-is-small">ess</span></div>' + (flagAllowSassUi ? '<div class="magicss-mode-button magicss-mode-sass" title="Sass mode">s<span class="hide-when-magicss-editor-is-small">ass</span></div>' : ''));
            const showAccountStatusEnabled = (((remoteConfig || {}).features || {}).showAccountStatus || {}).enabled;
            const signInUrl = ((remoteConfig || {}).account || {}).signInUrl;
            if (isFeatureEnabled(showAccountStatusEnabled)) {
              /* eslint-disable indent */
              $outer.append(['<div class="webextensions-login-icon-in-header">', '<a', ' href="' + signInUrl + '"', ' title="Sign In"', ' target="_blank"', ' rel="nofollow noopener noreferrer"', '/>', '</div>'].join(''));
              /* eslint-enable indent */
            }

            $(document).on('click', '.webextensions-login-icon-in-header', async function () {
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'trigger-to-site',
                spot: 'login-icon-in-header'
              });
            });
            $(document).on('click', '.magicss-mode-css', async function () {
              await setLanguageMode('css', editor);
              editor.focus();
              chromeRuntimeMessageIfRequired({
                type: 'magicss',
                subType: 'set-language-mode-to-css'
              });
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'clickedSwitchSelectedMode',
                type: 'css'
              });
            });
            $(document).on('click', '.magicss-mode-less', async function () {
              await setLanguageMode('less', editor);
              editor.focus();
              chromeRuntimeMessageIfRequired({
                type: 'magicss',
                subType: 'set-language-mode-to-less'
              });
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'clickedSwitchSelectedMode',
                type: 'less'
              });
            });
            $(document).on('click', '.magicss-mode-sass', async function () {
              await setLanguageMode('sass', editor);
              editor.focus();
              chromeRuntimeMessageIfRequired({
                type: 'magicss',
                subType: 'set-language-mode-to-sass'
              });
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'clickedSwitchSelectedMode',
                type: 'sass'
              });
            });
            $(document).on('click', '.magicss-mode-file', async function () {
              await setLanguageMode('file', editor);
              editor.focus();
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'clickedSwitchSelectedMode',
                type: 'file'
              });
            });
            return $outer;
          },
          placeholder: runningInAndroidFirefox ? 'Write CSS/Less/Sass code here.\nThe code gets applied immediately.\n\nExample:' + '\nimg {\n    opacity: 0.5;\n}' + '\n\nKindly use a keyboard without autocorrect.' : 'Write CSS/Less/Sass code here.\nThe code gets applied immediately.\n\nExample:' + '\nimg {\n    opacity: 0.5;\n}' + '\n\nShortcut: Alt + Shift + C',
          codemirrorOptions: {
            colorpicker: {
              mode: 'edit'
            },
            autoCloseBrackets: true,
            /*
            hintOptions: {
                completeSingle: false,
                // closeCharacters: /[\s()\[\]{};:>,]/,     // This is the default value defined in show-hint.js
                closeCharacters: /[(){};:,]/,               // Custom override
                onAddingAutoCompleteOptionsForSelector: (
                    // FIXME: This would not work since window.MagiCSSEditor is not available yet
                    (await window.MagiCSSEditor.userPreference(USER_PREFERENCE_AUTOCOMPLETE_SELECTORS)) === 'no'
                        ? null
                        : (
                            function (add) {
                                if (existingCSSSelectorsWithAutocompleteObjects) {
                                    add(existingCSSSelectorsWithAutocompleteObjects, true);
                                }
                            }
                        )
                ),
                onAddingAutoCompleteOptionsForCSSProperty: function (add) {
                    add(cssPropertyKeywordsAutocompleteObject, true);
                },
                onCssHintSelectForSelector: function (selectedText) {
                    var editor = window.MagiCSSEditor;
                    showCSSSelectorMatches(selectedText, editor);
                },
                onCssHintShownForSelector: function () {    // As per current CodeMirror/css-hint architecture,
                                                            // "select" is called before "shown".
                                                            // The "select" operation would also show the number  e are hiding the alertNote
                    alertNote.hide();
                }
            },
            /* */
            extraKeys: {
              /*
              // https://blog.github.com/2018-02-18-deprecation-notice-removing-anonymous-gist-creation/
              'Ctrl-S': function () {
                  var editor = window.MagiCSSEditor;
                  createGistAndEmail(editor.getTextValue(), getLanguageMode());
                  editor.focus();
              }
              /* */
            },
            optionsBasedOnUserPreference: async function (userPreference) {
              var options = {};
              if ((await userPreference('use-css-linting')) === 'yes' && (await userPreference('language-mode')) === 'css') {
                options.gutters = ['CodeMirror-lint-markers'];
                options.lint = true;
              } else {
                options.gutters = [];
                options.lint = false;
              }
              if ((await userPreference('language-mode')) === 'sass') {
                options.mode = 'text/x-scss';
              } else if ((await userPreference('language-mode')) === 'less') {
                options.mode = 'text/x-less';
              } else {
                options.mode = 'text/css';
              }
              var theme = await getExtensionDataAsync(USER_PREFERENCE_THEME);
              options.theme = function () {
                if (theme === 'dark') {
                  return 'ambiance';
                } else {
                  return undefined;
                }
              }();
              options.hintOptions = {
                className: function () {
                  if (theme === 'dark') {
                    return 'cm-s-ambiance';
                  } else {
                    return undefined;
                  }
                }(),
                completeSingle: false,
                // closeCharacters: /[\s()\[\]{};:>,]/,     // This is the default value defined in show-hint.js
                closeCharacters: /[(){};:,]/,
                // Custom override
                onAddingAutoCompleteOptionsForSelector: (await userPreference(USER_PREFERENCE_AUTOCOMPLETE_SELECTORS)) === 'no' ? null : function (add) {
                  if (existingCSSSelectorsWithAutocompleteObjects) {
                    add(existingCSSSelectorsWithAutocompleteObjects, true);
                  }
                },
                onAddingAutoCompleteOptionsForCSSProperty: (await userPreference(USER_PREFERENCE_AUTOCOMPLETE_CSS_PROPERTIES_AND_VALUES)) === 'no' ? function noop() {
                  // do nothing
                } : function (add) {
                  add(cssPropertyKeywordsAutocompleteObject, true);
                },
                onCssHintSelectForSelector: function (selectedText) {
                  var editor = window.MagiCSSEditor;
                  if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                    setTimeout(async () => {
                      const cssSelector = selectedText.originalSelector;
                      var selectorMatchCount = await chromeRuntimeMessageIfRequired({
                        type: 'magicss',
                        subType: 'magicss-get-selector-match-count',
                        payload: {
                          cssSelector
                        }
                      });
                      if (selectorMatchCount === null) {
                        // do nothing
                      } else {
                        var trunc = function (str, limit) {
                          if (str.length > limit) {
                            var separator = ' ... ';
                            str = str.substr(0, limit / 2) + separator + str.substr(separator.length + str.length - limit / 2);
                          }
                          return str;
                        };
                        var cssSelectorToShow = htmlEscape(trunc(cssSelector, 100));
                        var sourcesToShow = selectedText && selectedText.sources ? '<br /><span style="color:#888">Source: <span style="font-weight:normal;">' + htmlEscape(decodeURIComponent(selectedText.sources)) + '</span></span>' : '';
                        if (selectorMatchCount) {
                          (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(cssSelectorToShow + '&nbsp; &nbsp;<span style="font-weight:normal;">(' + selectorMatchCount + ' match' + (selectorMatchCount === 1 ? '' : 'es') + ')</span>' + sourcesToShow, 2500);
                        } else {
                          (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(cssSelectorToShow + '&nbsp; &nbsp;<span style="font-weight:normal;">(No&nbsp;matches)</span>' + sourcesToShow, 2500);
                        }
                      }
                    });
                  } else {
                    showCSSSelectorMatches(selectedText, editor);
                  }
                },
                onCssHintShownForSelector: function () {
                  /* As per current CodeMirror/css-hint architecture,
                     "select" is called before "shown".
                     The "select" operation would also show the number  e are hiding the alertNote */
                  _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote.hide();
                }
              };
              return options;
            }
          },
          // bgColor: '68,88,174,0.85',
          bgColor: '42,74,117,1',
          headerIcons: [function () {
            const manifest = chrome.runtime.getManifest(),
              __custom__ = manifest.__custom__ || {},
              hideRateUsHeaderIcon = __custom__.hideRateUsHeaderIcon || false;
            // Hide rate us icon ; Useful for puppeteer based testing by maintaining screenshot consistency across different loads of the extension
            if (hideRateUsHeaderIcon) {
              return null;
            }
            const rateUsConfig = ((remoteConfig || {}).features || {}).rateUs || {};
            const rateUsEnabled = rateUsConfig.enabled;
            const rateUsRange = rateUsConfig.range || {};
            const from = rateUsRange.from || const_rateUsUsageCounterFrom;
            const to = rateUsRange.to || const_rateUsUsageCounterTo;
            if (rateUsEnabled && from <= executionCounter && executionCounter <= to) {
              return iconForRateUs({
                addOpaqueOnHoverClass: true
              });
            } else {
              return null;
            }
          }(),
          // Used for mounting the component
          {
            name: 'command-palette-invisible-root',
            cls: 'magicss-command-palette-root'
          }, {
            name: 'command-palette',
            title: function () {
              // const titleText = 'Show all available commands';
              const titleText = 'Show more commands';
              if (runningInAndroidFirefox) {
                return titleText;
              } else {
                const flagMacOs = (navigator.platform || '').toLowerCase().indexOf('mac') >= 0 ? true : false;
                if (flagMacOs) {
                  return `${titleText}\n\n(Cmd + Shift + P)`;
                } else {
                  return `${titleText}\n\n(Ctrl + Shift + P)`;
                }
              }
            }(),
            cls: 'magicss-command-palette editor-gray-out',
            onclick: async function (evt, editor, divIcon) {
              // eslint-disable-line no-unused-vars
              try {
                await loadIfNotAvailable('main-bundle');
                window.redux_store.dispatch({
                  type: 'APP_$_OPEN_COMMAND_PALETTE'
                });
                (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                  name: 'clickedShowMoreCommands',
                  spot: 'header'
                });
              } catch (e) {
                handleUnrecoverableError(e);
              }
            },
            afterrender: function () {
              document.addEventListener('keydown', function (event) {
                if (window.MagiCSSEditor.isVisible()) {
                  if ((event.ctrlKey || event.metaKey) && event.shiftKey && (event.key === 'p' || event.key === 'P' || event.code === 'KeyP' || event.keyCode === 80 || event.which === 80)) {
                    event.preventDefault();
                    (async () => {
                      try {
                        await loadIfNotAvailable('main-bundle');
                        const storeState = window.redux_store.getState();

                        // If any dialog is open, don't launch the command palette
                        if (storeState.app && storeState.app.searchIcons && (storeState.app.searchIcons.open || storeState.app.searchIcons.openConfiguration)) {
                          // do nothing
                        } else {
                          window.redux_store.dispatch({
                            type: 'APP_$_OPEN_COMMAND_PALETTE'
                          });
                        }
                      } catch (e) {
                        handleUnrecoverableError(e);
                      }
                    })();
                  }
                  if ((event.ctrlKey || event.metaKey) && event.shiftKey && (event.key === 'r' || event.key === 'R' || event.code === 'KeyR' || event.keyCode === 82 || event.which === 82)) {
                    event.preventDefault();
                    if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                      chromeRuntimeMessageIfRequired({
                        type: 'magicss',
                        subType: 'magicss-reload-all-css-resources'
                      });
                    } else {
                      reloadAllCSSResourcesInPage();
                    }
                    (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                      name: 'reloadCssResources',
                      spot: 'fromKeyboardShortcut'
                    });
                  }
                }
              }, {
                capture: true
              });
            }
          }, function () {
            // Currently, this feature has been tested only in Chrome, Opera and Edge browsers
            if (isChrome || isOpera || isEdge || isFirefox) {
              return {
                name: 'reapply',
                title: 'Apply styles automatically\n(without loading this extension, for pages on this domain)',
                cls: 'magicss-reapply-styles editor-gray-out',
                onclick: async function (evt, editor, divIcon) {
                  let tabOriginWithSlash;
                  if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                    const urlParams = new URLSearchParams(window.location.search);
                    tabOriginWithSlash = urlParams.get('tabOriginWithSlash');
                  } else {
                    tabOriginWithSlash =
                    // Even though the chrome.permissions.request API parameter is called "origins",
                    // it doesn't respect the origins without trailing slash. Hence, we append a slash, if required.
                    window.location.origin.match(/\/$/) ? window.location.origin : window.location.origin + '/';
                  }
                  if (tabOriginWithSlash === 'file://') {
                    tabOriginWithSlash = 'file://*';
                  }
                  if ($(divIcon).parents('#' + id).hasClass('magic-css-apply-styles-automatically')) {
                    (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                      name: 'applyStylesAutomaticallyUnpinInitiate',
                      spot: 'header'
                    });
                    await markAsPinnedOrNotPinned(editor, 'not-pinned');
                    if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                      chromeRuntimeMessageIfRequired({
                        type: 'magicss',
                        subType: 'mark-as-not-pinned-without-notification'
                      });
                    }
                    (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('<span style="font-weight:normal;">Now onwards,</span> styles would be applied only when you load this extension <span style="font-weight:normal;"><br/>(for pages on <span style="text-decoration:underline;">' + tabOriginWithSlash + '</span>)</span>', 5000);
                    (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                      name: 'applyStylesAutomaticallyUnpinComplete',
                      spot: 'header'
                    });
                  } else {
                    (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                      name: 'applyStylesAutomaticallyPinInitiate',
                      spot: 'header'
                    });
                    if (isFirefox) {
                      await markAsPinnedOrNotPinned(editor, 'pinned');
                      if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                        chromeRuntimeMessageIfRequired({
                          type: 'magicss',
                          subType: 'mark-as-pinned-without-notification'
                        });
                      }
                      (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('<span style="font-weight:normal;">Now onwards, </span>styles would be applied automatically  <span style="font-weight:normal;">even without loading this extension<br/>(for pages on <span style="text-decoration:underline;">' + tabOriginWithSlash + '</span>)</span>', 10000);
                      (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                        name: 'applyStylesAutomaticallyPinComplete',
                        spot: 'header'
                      });
                    } else {
                      // If the editor is in external window, then we may want to resize the window before requesting for permissions
                      if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                        const flagPermissions = await chromePermissionsContains({
                          permissions: ['webNavigation'],
                          origins: [tabOriginWithSlash]
                        });
                        if (flagPermissions) {
                          // do nothing
                        } else {
                          let targetWidth = window.outerWidth;
                          let targetHeight = window.outerHeight;
                          let doResize = false;
                          if (targetWidth < 500) {
                            targetWidth = 500;
                            doResize = true;
                          }
                          if (targetHeight < 300) {
                            targetHeight = 300;
                            doResize = true;
                          }
                          if (doResize) {
                            window.resizeTo(targetWidth, targetHeight);
                          }
                        }
                      }
                      try {
                        chrome.runtime.sendMessage({
                          requestPermissions: true,
                          requestWebNavigation: true,
                          tabOriginWithSlash
                        }, async function asyncCallback(status) {
                          if (chrome.runtime.lastError) {
                            console.log('Error message reported by Magic CSS:', chrome.runtime.lastError);
                            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Error! Unexpected error encountered by Magic CSS extension.<br />You may need to reload webpage & Magic CSS and try again.', 10000);
                          }
                          if (status === 'request-granted') {
                            await markAsPinnedOrNotPinned(editor, 'pinned');
                            if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                              chromeRuntimeMessageIfRequired({
                                type: 'magicss',
                                subType: 'mark-as-pinned-without-notification'
                              });
                            }
                            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('<span style="font-weight:normal;">Now onwards, </span>styles would be applied automatically <span style="font-weight:normal;">even without loading this extension<br/>(for pages on <span style="text-decoration:underline;">' + tabOriginWithSlash + '</span>)</span>', 10000);
                            (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                              name: 'applyStylesAutomaticallyPinComplete',
                              spot: 'header'
                            });
                          } else if (status === 'request-not-granted') {
                            (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('You need to provide permissions to reapply styles automatically', 10000);
                            (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                              name: 'applyStylesAutomaticallyPinIncompleteDueToPermission',
                              spot: 'header'
                            });
                          }
                        });
                      } catch (e) {
                        handleUnrecoverableError(e);
                      }
                    }
                  }
                  editor.focus();
                }
              };
            } else {
              return null;
            }
          }(), function () {
            if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
              return {
                name: 'edit-in-internal',
                title: 'Move editor inside page',
                cls: 'magicss-internal-window editor-gray-out',
                onclick: async function (evt, editor, divIcon) {
                  // eslint-disable-line no-unused-vars
                  await chromeRuntimeMessageIfRequired({
                    type: 'magicss',
                    subType: 'reopen-main-editor'
                  });
                  (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                    name: 'moveEditorInsidePage',
                    spot: 'header'
                  });
                  window.close();
                }
              };
            } else {
              return null;
            }
          }(), function () {
            if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
              return null;
            }
            if (isFirefox) {
              return null;
            }
            return {
              name: 'edit-in-external',
              title: 'Edit in external window\n\nNote: Available in CSS / LESS / SASS mode',
              cls: 'magicss-external-window-is-not-available-for-mode editor-gray-out-as-disabled',
              onclick: async function (evt, editor, divIcon) {
                // eslint-disable-line no-unused-vars
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Please switch to editing code in CSS / LESS / SASS mode to enable this feature', 5000);
                editor.focus();
                (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                  name: 'movingEditorNotAvailableInMode',
                  spot: 'header'
                });
              }
            };
          }(), function () {
            if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
              return null;
            }
            if (isFirefox) {
              return null;
            }
            window.loadEditorInExternalWindow = async function (editor) {
              try {
                chrome.runtime.sendMessage({
                  openExternalEditor: true,
                  magicssHostSessionUuid: window.magicssHostSessionUuid,
                  tabTitle: document.title,
                  width: editor.container.clientWidth,
                  height: editor.container.clientHeight
                });
                await editor.hide();
                editor.container.classList.add('external-editor-also-exists');
                if (!window.openExternalEditorListenerAdded) {
                  if (typeof chrome !== 'undefined' && chrome.runtime.onMessage) {
                    chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
                      // eslint-disable-line no-unused-vars
                      let flagAsyncResponse = false;
                      if (request.magicssHostSessionUuid === window.magicssHostSessionUuid && request.type === 'magicss') {
                        if (request.subType === 'magicss-set-text-value') {
                          setTimeout(async () => {
                            await editor.setTextValue(request.payload);
                            await editor.reInitTextComponent({
                              pleaseIgnoreCursorActivity: true
                            });
                          });
                        } else if (request.subType === 'magicss-fnApplyTextAsCSS') {
                          setTimeout(async () => {
                            await fnApplyTextAsCSS(editor, (request.payload || {}).options);
                          });
                        } else if (request.subType === 'storage-data-to-initialize') {
                          flagAsyncResponse = true;
                          setTimeout(async () => {
                            const propsToSync = [USER_PREFERENCE_LAST_APPLIED_CSS, USER_PREFERENCE_USE_CSS_LINTING, USER_PREFERENCE_SHOW_LINE_NUMBERS, USER_PREFERENCE_ENABLE_LINE_WRAP, USER_PREFERENCE_APPLY_STYLES_AUTOMATICALLY, USER_PREFERENCE_LANGUAGE_MODE_NON_FILE, USER_PREFERENCE_LANGUAGE_MODE, USER_PREFERENCE_TEXTAREA_VALUE, USER_PREFERENCE_DISABLE_STYLES];
                            const responseToSend = {};
                            for (const prop of propsToSync) {
                              responseToSend[prop] = await editor.userPreference(prop);
                            }
                            return sendResponse(responseToSend);
                          });
                        } else if (request.subType === 'update-code-and-apply-css') {
                          setTimeout(async () => {
                            await editor.setTextValue(request.payload.cssCodeToUse);
                            await editor.reInitTextComponent({
                              pleaseIgnoreCursorActivity: true
                            });
                            await fnApplyTextAsCSS(editor);
                          });
                        } else if (request.subType === 'reopen-main-editor') {
                          flagAsyncResponse = true;
                          window.focus();
                          setTimeout(async () => {
                            await window.MagiCSSEditor.reposition(function () {
                              // Since the editor would have been hidden, upon showing it again, it wouldn't have updated. Hence, this refresh is required, otherwise, the view would get updated upon clicking inside the editor in host tab.
                              window.MagiCSSEditor.cm.refresh();
                              checkIfMagicCssLoadedFine(window.MagiCSSEditor);
                              sendResponse(); // Note: This "sendResponse()" call is for indicating that the execution if this part is complete and we are not sending any data in the response
                            });

                            chromeStorageForExtensionData.set({
                              'last-time-editor-was-in-external-window': false
                            }, function () {
                              // do nothing
                            });
                          });
                        } else if (request.subType === 'enableCss') {
                          setTimeout(async () => {
                            await editor.disableEnableCSS('enable');
                          });
                        } else if (request.subType === 'disableCss') {
                          setTimeout(async () => {
                            await editor.disableEnableCSS('disable');
                          });
                        } else if (request.subType === 'magicss-handle-delayedcursormove') {
                          var cssSelector = processSplitText({
                            splitText: request.payload.theSplittedText,
                            useAlertNote: true
                          });
                          if (!cssSelector) {
                            _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote.hide();
                          }
                          if (!editor.styleHighlightingSelector) {
                            editor.styleHighlightingSelector = new _utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__.StyleTag({
                              id: 'magicss-highlight-by-selector',
                              parentTag: 'body',
                              attributes: [{
                                name: 'data-style-created-by',
                                value: 'magicss'
                              }],
                              overwriteExistingStyleTagWithSameId: true
                            });
                          }
                          if (cssSelector) {
                            // Helps in highlighting SVG elements
                            editor.styleHighlightingSelector.cssText = cssSelector + '{outline: 1px dashed red !important; fill: red !important; }';
                          } else {
                            editor.styleHighlightingSelector.cssText = '';
                          }
                          editor.styleHighlightingSelector.applyTag();
                        } else if (request.subType === 'magicss-get-selector-match-count') {
                          flagAsyncResponse = true;
                          setTimeout(async () => {
                            var count = null;
                            try {
                              const {
                                cssSelector
                              } = request.payload;
                              count = $(cssSelector).not('#MagiCSS-bookmarklet, #MagiCSS-bookmarklet *, #topCenterAlertNote, #topCenterAlertNote *').length;
                            } catch (e) {
                              // do nothing
                            }
                            return sendResponse(count);
                          });
                        } else if (request.subType === 'get-css-selectors-autocomplete-objects') {
                          flagAsyncResponse = true;
                          setTimeout(async () => {
                            return sendResponse(existingCSSSelectorsWithAutocompleteObjects);
                          });
                        } else if (request.subType === 'showLineNumbers') {
                          setTimeout(async () => {
                            editor.cm.setOption('lineNumbers', true);
                            await editor.userPreference('show-line-numbers', 'yes');
                          });
                        } else if (request.subType === 'hideLineNumbers') {
                          setTimeout(async () => {
                            editor.cm.setOption('lineNumbers', false);
                            await editor.userPreference('show-line-numbers', 'no');
                          });
                        } else if (request.subType === 'enableLineWrap') {
                          setTimeout(async () => {
                            editor.cm.setOption('lineWrapping', true);
                            await editor.userPreference('enable-line-wrap', 'yes');
                          });
                        } else if (request.subType === 'disableLineWrap') {
                          setTimeout(async () => {
                            editor.cm.setOption('lineWrapping', false);
                            await editor.userPreference('enable-line-wrap', 'no');
                          });
                        } else if (request.subType === 'enable-css-linting') {
                          if (getLanguageMode() === 'css') {
                            setTimeout(async () => {
                              await setCodeMirrorCSSLinting(editor, 'enable');
                            });
                          }
                        } else if (request.subType === 'disable-css-linting') {
                          if (getLanguageMode() === 'css') {
                            setTimeout(async () => {
                              await setCodeMirrorCSSLinting(editor, 'disable');
                            });
                          }
                        } else if (request.subType === 'external-editor-window-is-loading') {
                          editor.container.classList.add('external-editor-also-exists');
                        } else if (request.subType === 'magicss-closed-editor' || request.subType === 'external-editor-window-is-closing') {
                          editor.container.classList.remove('external-editor-also-exists');
                        } else if (request.subType === 'set-language-mode-to-css') {
                          setTimeout(async () => {
                            await setLanguageMode('css', editor, {
                              skipNotifications: true
                            });
                          });
                        } else if (request.subType === 'set-language-mode-to-less') {
                          setTimeout(async () => {
                            await setLanguageMode('less', editor, {
                              skipNotifications: true
                            });
                          });
                        } else if (request.subType === 'set-language-mode-to-sass') {
                          setTimeout(async () => {
                            await setLanguageMode('sass', editor, {
                              skipNotifications: true
                            });
                          });
                        } else if (request.subType === 'mark-as-pinned-without-notification') {
                          setTimeout(async () => {
                            await markAsPinnedOrNotPinned(editor, 'pinned');
                          });
                        } else if (request.subType === 'mark-as-not-pinned-without-notification') {
                          setTimeout(async () => {
                            await markAsPinnedOrNotPinned(editor, 'not-pinned');
                          });
                        } else if (request.subType === 'magicss-reload-all-css-resources') {
                          reloadAllCSSResourcesInPage();
                        } else if (request.subType === 'stay-awake') {
                          // Do nothing - This is just to keep the service worker active when the external editor window is open
                        } else {
                          console.log(`Received an unexpected event with subType: ${request.subType}`);
                        }

                        // Need to return true to run "sendResponse" in async manner
                        // Ref: https://developer.chrome.com/docs/extensions/mv2/messaging/#simple
                        return flagAsyncResponse;
                      }
                    });
                    window.openExternalEditorListenerAdded = true;
                  }
                }
                (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                  name: 'clickedEditInExternalWindow',
                  spot: 'header'
                });
              } catch (e) {
                handleUnrecoverableError(e);
                (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                  name: 'error',
                  type: 'couldNotEnableEditInExternalWindow',
                  spot: 'header'
                });
              }
            };
            return {
              name: 'edit-in-external',
              title: 'Edit in external window',
              cls: 'magicss-external-window editor-gray-out',
              onclick: async function (evt, editor, divIcon) {
                // eslint-disable-line no-unused-vars
                await window.loadEditorInExternalWindow(editor);
              }
            };
          }(),
          /*
          {
              name: 'beautify',
              title: 'Beautify code',
              cls: 'magicss-beautify editor-gray-out',
              onclick: async function (evt, editor) {
                  var textValue = editor.getTextValue();
                  if (!textValue.trim()) {
                      alertNote('Please type some code to be beautified', 5000);
                  } else {
                      var beautifiedCss = await beautifyCss(textValue);
                      if (textValue.trim() !== beautifiedCss.trim()) {
                          await editor.setTextValue(beautifiedCss);
                          await editor.reInitTextComponent({pleaseIgnoreCursorActivity: true});
                          alertNote('Your code has been beautified :-)', 5000);
                      } else {
                          alertNote('Your code already looks beautiful :-)', 5000);
                      }
                  }
                  editor.focus();
              }
          },
          /* */
          {
            name: 'css-reloader-and-file-changes-watcher',
            title: 'CSS reloader and watch file changes',
            cls: 'magicss-reload-css-resources editor-gray-out cancelDragHandle',
            icons: [function () {
              if (isChrome || isOpera || isEdge || isFirefox) {
                return {
                  name: 'stopWatchingCssFiles',
                  title: 'Stop watching CSS files',
                  // cls: 'magicss-watch-resources',
                  uniqCls: 'magicss-stop-watch-and-reload-link-tags',
                  onclick: async function (evt, editor) {
                    await socketOb._stopWatchingFiles(editor);
                    editor.focus();
                    (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                      name: 'clickedStopWatchingCssFiles',
                      spot: 'header'
                    });
                  }
                };
              } else {
                return null;
              }
            }(), function () {
              if (isChrome || isOpera || isEdge || isFirefox) {
                return {
                  name: 'watchCssFiles',
                  title: 'Watch CSS files to apply changes automatically',
                  // cls: 'magicss-watch-resources',
                  uniqCls: 'magicss-watch-and-reload-link-tags',
                  onclick: async function (evt, editor) {
                    await socketOb._startWatchingFiles(editor);
                    editor.focus();
                    (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                      name: 'clickedWatchCssFiles',
                      spot: 'header'
                    });
                  },
                  beforeShow: function (origin, tooltip) {
                    tooltip.addClass(socketOb.flagWatchingCssFiles ? 'tooltipster-watching-css-files-enabled' : 'tooltipster-watching-css-files-disabled');
                  }
                };
              } else {
                return null;
              }
            }(), {
              name: 'reload-css-resources',
              title: function () {
                const titleText = 'Reload all CSS resources';
                if (runningInAndroidFirefox) {
                  return titleText;
                } else {
                  const flagMacOs = (navigator.platform || '').toLowerCase().indexOf('mac') >= 0 ? true : false;
                  if (flagMacOs) {
                    return `${titleText} <span style="color:#ccc">(Cmd + Shift + R)</span>`;
                  } else {
                    return `${titleText} <span style="color:#ccc">(Ctrl + Shift + R)</span>`;
                  }
                }
              }(),
              // hoverTitle: 'Reload all CSS resources',
              cls: 'magicss-reload-all-css-resources',
              uniqCls: 'magicss-reload-all-css-resources',
              onclick: function (evt, editor) {
                if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                  chromeRuntimeMessageIfRequired({
                    type: 'magicss',
                    subType: 'magicss-reload-all-css-resources'
                  });
                } else {
                  reloadAllCSSResourcesInPage();
                }
                editor.focus();
                (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                  name: 'reloadCssResources',
                  spot: 'header'
                });
              }
            }]
          }, {
            name: 'disable',
            title: 'Deactivate code',
            cls: 'magicss-disable-css editor-gray-out',
            onclick: async function (evt, editor, divIcon) {
              if ($(divIcon).parents('#' + id).hasClass('indicate-disabled')) {
                await editor.disableEnableCSS('enable');
                chromeRuntimeMessageIfRequired({
                  type: 'magicss',
                  subType: 'enableCss'
                });
                (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                  name: 'enabledCss',
                  spot: 'header'
                });
              } else {
                await editor.disableEnableCSS('disable');
                chromeRuntimeMessageIfRequired({
                  type: 'magicss',
                  subType: 'disableCss'
                });
                (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                  name: 'disabledCss',
                  spot: 'header'
                });
              }
              if (!runningInAndroidFirefox) {
                editor.focus();
              }
            },
            afterrender: function (editor, divIcon) {
              // TODO: Make the code independent of this setTimeout logic.
              setTimeout(function () {
                if ($(divIcon).parents('#' + id).hasClass('indicate-disabled')) {
                  divIcon.title = 'Activate code';
                } else {
                  divIcon.title = 'Deactivate code';
                }
              }, 0);

              /* HACK: Remove this hack which is being used to handle "divIcon.title" change
                       for the case of "editor.disableEnableCSS('disable')" under "reInitialized()" */
              editor.originalDisableEnableCSS = editor.disableEnableCSS;
              editor.disableEnableCSS = async function (doWhat) {
                var state = await editor.originalDisableEnableCSS(doWhat);
                if (state === 'disabled') {
                  divIcon.title = 'Activate code';
                } else {
                  divIcon.title = 'Deactivate code';
                }
                return state;
              };
            }
          }, {
            name: 'point-and-click',
            title: runningInAndroidFirefox ? 'Select an element in the page to generate its CSS Selector' : 'Select an element in the page to generate its CSS Selector\n\n(Alt + Shift + S)',
            cls: 'magicss-point-and-click editor-gray-out',
            onclick: function (evt, editor) {
              togglePointAndClick(editor);
              editor.focus();
              (0,_metrics_sendMessageForMetrics_js__WEBPACK_IMPORTED_MODULE_11__.sendEventMessageForMetrics)({
                name: 'pointAndClickActivated',
                spot: 'header'
              });
            }
          }],
          headerOtherIcons: [function () {
            if (executionCounter < const_rateUsUsageCounterTo) {
              return null;
            } else {
              return iconForRateUs();
            }
          }(), getMagicCSSForChrome, getMagicCSSForEdge, getMagicCSSForFirefox, {
            skip: true,
            name: 'less-or-sass-to-css',
            title: flagAllowSassUi ? 'Convert this code from Less/Sass to CSS' : 'Convert this code from Less to CSS',
            uniqCls: 'magicss-less-or-sass-to-css',
            onclick: async function (evt, editor) {
              await window.execConvertToCssAction(editor);
            },
            beforeShow: async function (origin, tooltip, editor) {
              // TODO: Move the .addClass() calls to their corresponding .beforeShow()
              tooltip.addClass(function () {
                switch (getLanguageMode()) {
                  case 'file':
                    return 'tooltipster-selected-mode-file';
                  case 'less':
                    return 'tooltipster-selected-mode-less';
                  case 'sass':
                    return 'tooltipster-selected-mode-sass';
                  default:
                    return 'tooltipster-selected-mode-css';
                }
              }()).addClass(editor.cm.getOption('lineNumbers') ? 'tooltipster-line-numbers-enabled' : 'tooltipster-line-numbers-disabled').addClass(editor.cm.getOption('lint') ? 'tooltipster-css-linting-enabled' : 'tooltipster-css-linting-disabled')
              // FIXME: Probably tooltipster-autocomplete-selectors-disabled/enabled is not used anymore
              .addClass((await editor.userPreference(USER_PREFERENCE_AUTOCOMPLETE_SELECTORS)) === 'no' ? 'tooltipster-autocomplete-selectors-disabled' : 'tooltipster-autocomplete-selectors-enabled');
            }
          },
          /*
          {
              name: 'css-to-less',
              title: 'Convert this code from CSS to LESS',
              uniqCls: 'magicss-css-to-less',
              onclick: function () {
                  console.log('Step 1. Read the text');
                  console.log('Step 2. Try to convert that text from CSS to LESS');
                  console.log('Step 3. If successful, change editing mode from CSS to LESS');
                  console.log('Step 4. Notify the user about this change');
              },
              beforeShow: function (origin, tooltip) {
                  if (getLanguageMode() === 'css') {
                      tooltip.addClass('tooltipster-selected-mode-css');
                  }
              }
          },
          /* */

          /*
          {
              name: 'reload-css-resources',
              title: 'Reload CSS resources',
              uniqCls: 'magicss-reload-css-resources',
              onclick: function (evt, editor) {
                  reloadAllCSSResourcesInPage();
                  editor.focus();
              }
          },
          /* */
          {
            skip: true,
            name: 'beautify',
            title: 'Beautify code',
            uniqCls: 'magicss-beautify',
            onclick: async function (evt, editor) {
              await window.execBeautifyCssAction(editor);
            }
          }, {
            skip: true,
            name: 'minify',
            title: 'Minify code',
            uniqCls: 'magicss-minify',
            onclick: async function (evt, editor) {
              await window.execMinifyCssAction(editor);
            }
          }, {
            skip: true,
            name: 'showLineNumbers',
            title: 'Show line numbers',
            uniqCls: 'magicss-show-line-numbers',
            onclick: async function (evt, editor) {
              await window.execShowLineNumbersAction(editor);
            }
          }, {
            skip: true,
            name: 'hideLineNumbers',
            title: 'Hide line numbers',
            uniqCls: 'magicss-hide-line-numbers',
            onclick: async function (evt, editor) {
              await window.execHideLineNumbersAction(editor);
            }
          }, {
            skip: true,
            name: 'enableCSSLinting',
            title: 'Enable CSS linting',
            uniqCls: 'magicss-enable-css-linting',
            onclick: async function (evt, editor) {
              await window.execEnableCssLintingAction(editor);
            }
          }, {
            skip: true,
            name: 'disableCSSLinting',
            title: 'Disable CSS linting',
            uniqCls: 'magicss-disable-css-linting',
            onclick: async function (evt, editor) {
              await window.execDisableCssLintingAction(editor);
            }
          },
          /*
          // https://blog.github.com/2018-02-18-deprecation-notice-removing-anonymous-gist-creation/
          {
              name: 'gist',
              title: 'Mail code (via Gist)',
              uniqCls: 'magicss-email',
              onclick: function (evt, editor) {
                  createGistAndEmail(editor.getTextValue(), getLanguageMode());
                  editor.focus();
              }
          },
          /* */
          {
            skip: true,
            name: 'tweet',
            title: 'Tweet',
            uniqCls: 'magicss-tweet',
            href: 'http://twitter.com/intent/tweet?url=' + encodeURIComponent(extensionUrl.forThisBrowser) + '&text=' + encodeURIComponent((0,_utils_i18n_js__WEBPACK_IMPORTED_MODULE_0__.TR)('Extension_Name', 'Live editor for CSS, Less & Sass - Magic CSS')) + ' (for Chrome%2C Edge %26 Firefox) ... web devs check it out!&via=webextensions'
          }, {
            skip: true,
            name: 'share-on-facebook',
            title: 'Share',
            uniqCls: 'magicss-share-on-facebook',
            href: 'https://www.facebook.com/sharer/sharer.php?u=' + encodeURIComponent(extensionUrl.forThisBrowser)
          }, {
            skip: true,
            name: 'github-repo',
            title: 'Contribute / Report issue',
            uniqCls: 'magicss-github-repo',
            href: 'https://github.com/webextensions/live-css-editor'
          }, {
            skip: true,
            name: 'options',
            title: 'More options',
            uniqCls: 'magicss-options',
            onclick: function (evt, editor) {
              window.execMoreOptionsAction(editor);
            }
          }],
          footer: function ($, editor) {
            var $footerItems = $('<div></div>'),
              $status = $('<div class="magicss-status"></div>');
            $footerItems.append($status);
            var $footerForServerMode = $('<div class="footer-for-server-mode" style="display:none;margin-top:3px;margin-bottom:-4px;overflow:auto"></div>');
            $footerItems.append($footerForServerMode);
            var $fileToEdit = $('<div class="file-to-edit">' + '<div class="name-of-file-being-edited" style="color:#fff; cursor:pointer"></div>' + '</div>');
            var $fileEditStatus = $('<div class="file-edit-status" style="color:#fff"></div>');
            var $liveCssServerStatus = $('<div class="live-css-server-status"></div>');
            $footerForServerMode.append($fileToEdit);
            $footerForServerMode.append($liveCssServerStatus);
            $footerForServerMode.append($fileEditStatus);

            /*
            // Magic Suggest uses old jQuery code. Minor changes to fix that
            jQuery.fn.extend({
                size: function() {
                    return this.length;
                }
            });
            setTimeout(function () {
                // $.ajax({
                //     method: 'PUT',
                //     url: 'http://localhost:3456/magic-css/asdf.txt'
                //     // url: 'http://localhost:3456/magic-css/asdf.txt'
                //     // url: 'http://localhost:3456/asdf.txt'
                //     // url: 'http://localhost:3456/asdf.txt'
                // });
                var fileSuggestions = $('#magicss-file-to-edit').magicSuggest({
                    method: 'GET',
                    data: 'http://localhost:3456/magic-css?query=asdf'
                    // data: [{"id":"Paris", "name":"Paris"}, {"id":"New York", "name":"New York"}]
                    // data: 'random.json',
                    // renderer: function(data){
                    //     // debugger;
                    //     return '<div style="padding: 5px; overflow:hidden;">' +
                    //     // '<div style="float: left;"><img src="' + data.picture + '" /></div>' +
                    //     '<div style="float: left; margin-left: 5px">' +
                    //     '<div style="font-weight: bold; color: #333; font-size: 10px; line-height: 11px">' + data.name + '</div>' +
                    //     '<div style="color: #999; font-size: 9px">' + data.name + '</div>' +
                    //     '</div>' +
                    //     '</div><div style="clear:both;"></div>'; // make sure we have closed our dom stuff
                    // }
                });
                window.fileSuggestions = fileSuggestions;
                // fileSuggestions.expand();
                $(fileSuggestions).on('selectionchange', function(e, m){
                    $.ajax({
                        url: 'http://localhost:3456/' + this.getValue()[0],
                        success: function (data, textStatus) {
                            if (textStatus === 'success') {
                                await editor.setTextValue(data).reInitTextComponent({pleaseIgnoreCursorActivity: true});
                            }
                        }
                    });
                });
            }, 0);
            $selectLinkTag.on('mousedown', function (evt) {
                evt.stopPropagation();
            });
            // $selectLinkTag.on('click', function (evt) {
            //     $;
            //     $selectLinkTag;
            //     debugger;
            // });
            /* */

            // $footerItems.on('mousedown', function (evt) {
            //     evt.stopPropagation();
            // });

            $liveCssServerStatus.on('click', async function () {
              // TODO: Verify functionality
              await _getServerDetailsFromUser(editor);
            });
            $fileToEdit.on('click', async function () {
              await getDataForFileToEdit(editor, {
                showUi: true
              }, async function (file) {
                // TODO: Fix this code related to "getFileNameFromPath" (it is not in a consistent state after the rebase operation)
                // TODO: Reuse code. Currently, the following piece of code is also copied for the scenario when user switches the editing mode
                $('.footer-for-server-mode .name-of-file-being-edited').html(htmlEscape(getFileNameFromPath(file.path))).attr('title', file.path).css({
                  marginRight: 75
                }).animate({
                  marginRight: 0
                }, 1000).fadeOut(100).fadeIn(750);
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Auto-save changes for: <span style="font-weight:normal;">' + htmlEscape(file.path) + '</span>', 5000, {
                  backgroundColor: 'lightgreen',
                  borderColor: 'darkgreen'
                });
                await editor.setTextValue(file.contents);
                await editor.reInitTextComponent({
                  pleaseIgnoreCursorActivity: true
                });
                editor.focus();

                // Clear the undo-redo hstory
                editor.cm.clearHistory();
              });
            });

            // Magic Suggest uses old jQuery code. Minor changes to fix that
            jQuery.fn.extend({
              size: function () {
                return this.length;
              }
            });

            // The following DOM elements are added just to cache some Magic CSS icons/images which may otherwise fail to load on a
            // domain with CSP settings like:
            //     "Content-Security-Policy:default-src 'self'"
            // which may block the load of data URI based SVG images
            $footerItems.append('<div style="width:0;height:0;opacity:0">' +
            // Using display:none wouldn't help in caching the background-image style
            '<div class="magicss-cache-image-to-prevent-CSP-problem-point-and-click-hover"></div>' + '<div class="magicss-cache-image-to-prevent-CSP-problem-css-linting"></div>' + '<div class="magicss-cache-image-to-prevent-CSP-problem-disable-css-linting"></div>' + '<div class="magicss-cache-image-to-prevent-CSP-problem-hide-line-numbers"></div>' + '<div class="magicss-cache-image-to-prevent-CSP-problem-show-line-numbers"></div>' + '</div>');
            return $footerItems;
          },
          events: {
            beforeInstantiatingCodeMirror: async function (editor) {
              // TODO: Cleanup commented out code below and related code/variables elsewhere (code related
              //       to USER_PREFERENCE_USE_CUSTOM_FONT_SIZE)

              // Need to add font-styling before CodeMirror is instantiated
              // if (await editor.userPreference(USER_PREFERENCE_USE_CUSTOM_FONT_SIZE) === 'yes') {
              var userPrefFontSizeInPx;
              if ((await editor.userPreference(USER_PREFERENCE_USE_CUSTOM_FONT_SIZE)) === 'yes') {
                userPrefFontSizeInPx = parseInt(await editor.userPreference(USER_PREFERENCE_FONT_SIZE_IN_PX), 10);
              } else {
                userPrefFontSizeInPx = 12;
              }
              // if (userPrefFontSizeInPx !== 12) {
              var cssLintErrorWarningMarkerSize = 16;
              if (userPrefFontSizeInPx < 12) {
                cssLintErrorWarningMarkerSize = Math.round(userPrefFontSizeInPx * 1.2);
              }
              (0,_utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__.addStyleTag)({
                attributes: [{
                  name: 'data-style-created-by',
                  value: 'magicss'
                }],
                cssText: [`.full-screen-editor #${id} .CodeMirror {`, '    width: calc(100vw - 14px) !important;',
                // ' height: calc(100vh - 34px) !important;',
                `    height: calc(100vh - 34px - ((${userPrefFontSizeInPx}px - 12px) * 1.7) ) !important;`, '}', '', '#' + id + ' *,', '.alert-note-text,', '.alert-note-text *,', '.magic-css-ui,', '.magic-css-ui *,', '.tooltipster-content *,', '.tooltipster-base ul li a,', '.CodeMirror-hints *,', '.CodeMirror-lint-message-error,', '.CodeMirror-lint-message-warning {', '    font-size: ' + userPrefFontSizeInPx + 'px !important;', '}', '.CodeMirror-overwrite .CodeMirror-cursor {', '    width: ' + Math.round(userPrefFontSizeInPx * 62 / 100) + 'px;', '}', '.CodeMirror-lint-tooltip {', '    max-width: ' + Math.round(600 * userPrefFontSizeInPx / 12) + 'px;', '}', '.CodeMirror-lint-marker-error,', '.CodeMirror-lint-marker-warning {', '    padding: ' + Math.round((userPrefFontSizeInPx * 1.2 - cssLintErrorWarningMarkerSize) / 2) + 'px 0;', function () {
                  if (cssLintErrorWarningMarkerSize <= 16) {
                    var size = cssLintErrorWarningMarkerSize;
                    return 'width: ' + size + 'px; height: ' + size + 'px;';
                  }
                  return '';
                }(), '}', function () {
                  if (userPrefFontSizeInPx < 12) {
                    return '.CodeMirror-lint-message-error, .CodeMirror-lint-message-warning {' + '    background-size: contain;' + '}';
                  }
                  return '';
                }()].join('\n'),
                parentTag: 'body'
              });
              // }
              // }
            },

            launched: async function (editor) {
              (0,_utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__.addStyleTag)({
                attributes: [{
                  name: 'data-style-created-by',
                  value: 'magicss'
                }],
                cssText:
                // Setting display style for UI components generated using this extension
                '#' + id + ','
                // + 'html>body #' + id
                + 'html>body .magic-css-container#' + id // `.magic-css-container` is added for higher specificity for page https://www.bing.com/search?q=Bing+AI&showconv=1
                + '{' + 'display: block;' + '}',
                parentTag: 'body'
              });
              (0,_utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__.addStyleTag)({
                attributes: [{
                  name: 'data-style-created-by',
                  value: 'magicss'
                }],
                cssText:
                // Setting display style for UI components generated using this extension
                '#' + id + ' .cancelDragHandle' + '{' + 'cursor: default;' + '}',
                parentTag: 'body'
              });
              var languageMode = await editor.userPreference('language-mode');

              // Editing mode 'file' is handled outside this if...else block
              if (languageMode === 'less') {
                $(editor.container).addClass('magicss-selected-mode-less');
              } else if (languageMode === 'sass') {
                $(editor.container).addClass('magicss-selected-mode-sass');
              } else {
                $(editor.container).addClass('magicss-selected-mode-css');
              }
              if (languageMode === 'file') {
                await applyLastAppliedCss(editor);

                // FIXME: Improve the hard-coding done here for the fallback
                var previousNonFileLanguageMode = (await editor.userPreference('language-mode-non-file')) || 'css';
                await setLanguageMode(previousNonFileLanguageMode, editor, {
                  skipNotifications: true
                });

                // "window.languageModeIsIntermittent" would be set to false (or removed) inside setLanguageMode('file', ...)
                // TODO: Make "await setLanguageMode('file', ...)" async in proper manner so that
                //       "window.languageModeIsIntermittent" can be set to false from within this block of code.
                window.languageModeIsIntermittent = true;
                await setLanguageMode('file', editor, {
                  skipNotifications: true
                });
              } else {
                window.setTimeout(function () {
                  fnApplyTextAsCSS(editor);
                }, 100);
              }

              // If language mode is file, then it might auto-connect for watching files as well
              if (languageMode === 'file') {
                // do nothing
              } else {
                var watchingCssFiles = (await editor.userPreference('watching-css-files')) === 'yes';
                if (watchingCssFiles) {
                  await socketOb._startWatchingFiles(editor);
                }
              }
              var disableStyles = (await editor.userPreference('disable-styles')) === 'yes';
              if (disableStyles) {
                editor.indicateEnabledDisabled('disabled');
              } else {
                editor.indicateEnabledDisabled('enabled');
              }
              var applyStylesAutomatically = (await editor.userPreference('apply-styles-automatically')) === 'yes';
              if (applyStylesAutomatically) {
                editor.applyStylesAutomatically(true);
              } else {
                editor.applyStylesAutomatically(false);
              }

              // window.setTimeout(async function () {
              //     await fnApplyTextAsCSS(editor, {
              //         skipSavingFile: true    // Skip saving file since it is first launch
              //     });
              // }, 100);

              // FIXME: Probably this piece of code is not used anymore
              var autocompleteSelectors = await editor.userPreference(USER_PREFERENCE_AUTOCOMPLETE_SELECTORS);
              if (autocompleteSelectors === 'no') {
                $(editor.container).addClass('magicss-autocomplete-selectors-disabled');
              } else {
                $(editor.container).addClass('magicss-autocomplete-selectors-enabled');
              }
            },
            reInitialized: async function (editor, cfg) {
              await editor.disableEnableCSS('toggle');
              cfg = cfg || {};
              var duration = cfg.animDuration,
                targetWidth = cfg.targetWidth,
                targetHeight = cfg.targetHeight;
              $('#' + id + ' .CodeMirror').animate({
                'width': targetWidth,
                'height': targetHeight
              }, duration, function () {
                setTimeout(async function () {
                  await editor.saveDimensions({
                    width: targetWidth,
                    height: targetHeight
                  });
                  editor.bringCursorToView({
                    pleaseIgnoreCursorActivity: true
                  });
                });
              });
            },
            beforehide: function (editor) {
              if (editor.styleHighlightingSelector) {
                editor.styleHighlightingSelector.cssText = '';
                editor.styleHighlightingSelector.applyTag();
              }
            },
            afterhide: function () {
              // currently doing nothing
            },
            onClose: async function (editor, config) {
              if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                if (config && config.closeByKeyPress) {
                  chromeRuntimeMessageIfRequired({
                    type: 'magicss',
                    subType: 'reopen-main-editor'
                  });
                } else {
                  chromeRuntimeMessageIfRequired({
                    type: 'magicss',
                    subType: 'magicss-closed-editor'
                  });
                }
                window.close();
              }
            },
            onSetTextValue: function (val) {
              if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                chromeRuntimeMessageIfRequired({
                  type: 'magicss',
                  subType: 'magicss-set-text-value',
                  payload: val
                });
              }
            },
            delayedcursormove: function (editor) {
              if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                let cssSelector = processSplitText({
                  splitText: editor.splitTextByCursor(),
                  useAlertNote: false
                });
                if (!cssSelector) {
                  _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote.hide();
                }
                chromeRuntimeMessageIfRequired({
                  type: 'magicss',
                  subType: 'magicss-handle-delayedcursormove',
                  payload: {
                    theSplittedText: editor.splitTextByCursor()
                  }
                });
                if (cssSelector) {
                  setTimeout(async () => {
                    var selectorMatchCount = await chromeRuntimeMessageIfRequired({
                      type: 'magicss',
                      subType: 'magicss-get-selector-match-count',
                      payload: {
                        cssSelector
                      }
                    });
                    if (selectorMatchCount === null) {
                      // do nothing
                    } else {
                      var trunc = function (str, limit) {
                        if (str.length > limit) {
                          var separator = ' ... ';
                          str = str.substr(0, limit / 2) + separator + str.substr(separator.length + str.length - limit / 2);
                        }
                        return str;
                      };
                      if (selectorMatchCount) {
                        (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(trunc(cssSelector, 100) + '&nbsp; &nbsp;<span style="font-weight:normal;">(' + selectorMatchCount + ' match' + (selectorMatchCount === 1 ? '' : 'es') + ')</span>', 2500);
                      } else {
                        (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(trunc(cssSelector, 100) + '&nbsp; &nbsp;<span style="font-weight:normal;">(No&nbsp;matches)</span>', 2500);
                      }
                    }
                  });
                }
              } else {
                // TODO: FIXME: Currently, we do the "alertNote" for the matches for the selector inside processSplitText.
                //              We need to refactor it so that it becomes easier to manage with cross-window / cross-context
                //              communication.
                let cssSelector = processSplitText({
                  splitText: editor.splitTextByCursor(),
                  useAlertNote: true
                });
                if (!cssSelector) {
                  _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote.hide();
                }
                if (!editor.styleHighlightingSelector) {
                  editor.styleHighlightingSelector = new _utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__.StyleTag({
                    id: 'magicss-highlight-by-selector',
                    parentTag: 'body',
                    attributes: [{
                      name: 'data-style-created-by',
                      value: 'magicss'
                    }],
                    overwriteExistingStyleTagWithSameId: true
                  });
                }
                if (cssSelector) {
                  // Helps in highlighting SVG elements
                  editor.styleHighlightingSelector.cssText = cssSelector + '{outline: 1px dashed red !important; fill: red !important; }';
                } else {
                  editor.styleHighlightingSelector.cssText = '';
                }
                editor.styleHighlightingSelector.applyTag();
              }
            },
            keyup: function () {
              // Currently doing nothing
            },
            delayedtextchange: async function (editor) {
              await fnApplyTextAsCSS(editor);
            },
            problematicFocusDetected: function (editor) {
              // There is a chance that something is problematic in focus behavior
              // Waiting for extra 1500ms for 2 reasons:
              //     1. Confirming that the focus which was stolen hasn't been returned back
              //     2. When the user clicks at another cursor position (or moves the cursor around),
              //        we show the "alertNote" which mentions the current CSS selector (where user
              //        has placed the cursor) and the number of DOM elements matching that CSS
              //        selector. We also do "alertNote.hide()" if there is no CSS selector around.
              //        This is currently done after a delay of 500ms from when the user took that
              //        action. Waiting for 1500ms helps in letting the user see the "alertNote"
              //        showing the number of matches and also in avoiding hiding of the "alertNote"
              //        displayed by this function ("problematicFocusDetected")
              setTimeout(function () {
                // Confirming the focus problem
                if (!editor.cmInputFieldHasFocus()) {
                  // Informing the user about the focus problem
                  informUserAboutProblematicFocus();
                }
              }, 1500);
            },
            clear: async function (editor) {
              await fnApplyTextAsCSS(editor);
            }
          }
        };
        var fnReturnCssSelector = function ({
          splitText,
          useAlertNote
        }) {
          var strBeforeCursor = splitText.strBeforeCursor,
            strAfterCursor = splitText.strAfterCursor;
          if (strBeforeCursor.substr(-1) === '/' && strAfterCursor.substr(0, 1) === '*' || strBeforeCursor.substr(-1) === '*' && strAfterCursor.substr(0, 1) === '/') {
            return '';
          }
          var atSelector = true;
          for (var i = strBeforeCursor.length; i >= 0; i--) {
            if (strBeforeCursor.charAt(i - 1) === '{' || strBeforeCursor.charAt(i - 1) === '*' && strBeforeCursor.charAt(i - 2) === '/') {
              atSelector = false;
              break;
            } else if (strBeforeCursor.charAt(i - 1) === ',' || strBeforeCursor.charAt(i - 1) === '}' || strBeforeCursor.charAt(i - 1) === '/') {
              atSelector = true;
              break;
            }
          }
          if (atSelector) {// Positioned at a selector
            // do nothing
          } else {
            // Not positioned at a selector
            return '';
          }
          for (var j = 0; j <= strAfterCursor.length; j++) {
            var charJ = strAfterCursor.charAt(j - 1),
              charJNext = strAfterCursor.charAt(j);
            if (charJ === ',' || charJ === '{' || charJ === '}' || charJ === '*' && charJNext === '/' || charJ === '/' && charJNext === '*') {
              break;
            }
          }
          var cssSelector = strBeforeCursor.substring(i) + strAfterCursor.substring(0, j - 1);
          cssSelector = jQuery.trim(cssSelector);
          if (cssSelector) {
            var count;
            try {
              count = $(cssSelector).not('#MagiCSS-bookmarklet, #MagiCSS-bookmarklet *, #topCenterAlertNote, #topCenterAlertNote *').length;
            } catch (e) {
              return '';
            }
            var trunc = function (str, limit) {
              if (str.length > limit) {
                var separator = ' ... ';
                str = str.substr(0, limit / 2) + separator + str.substr(separator.length + str.length - limit / 2);
              }
              return str;
            };
            if (useAlertNote) {
              if (count) {
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(trunc(cssSelector, 100) + '&nbsp; &nbsp;<span style="font-weight:normal;">(' + count + ' match' + (count === 1 ? '' : 'es') + ')</span>', 2500);
              } else {
                (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)(trunc(cssSelector, 100) + '&nbsp; &nbsp;<span style="font-weight:normal;">(No&nbsp;matches)</span>', 2500);
              }
            }
          }
          return cssSelector;
        };
        var processSplitText = function ({
          splitText,
          useAlertNote
        }) {
          if (getLanguageMode() === 'sass' || getLanguageMode() === 'less') {
            if (!smc) {
              return '';
            }
            var beforeCursor = splitText.strBeforeCursor,
              rowNumber = (beforeCursor.match(/\n/g) || []).length,
              columnNumber = beforeCursor.substr(beforeCursor.lastIndexOf('\n') + 1).length,
              generatedPosition = smc.generatedPositionFor({
                source: getLanguageMode() === 'less' ? 'input' : 'root/stdin',
                // less('input') OR sass('root/stdin')
                line: rowNumber + 1,
                // Minimum value is 1 for line
                column: columnNumber // Minimum value is 0 for column
              });

            var cssCode = newStyleTag.cssText,
              cssTextInLines = cssCode.split('\n'),
              strFirstPart,
              strLastPart;
            if (generatedPosition.line) {
              cssTextInLines = cssTextInLines.splice(0, generatedPosition.line);
              var lastItem = cssTextInLines[cssTextInLines.length - 1];
              cssTextInLines[cssTextInLines.length - 1] = lastItem.substr(0, generatedPosition.column);
              strFirstPart = cssTextInLines.join('\n');
              strLastPart = newStyleTag.cssText.substr(strFirstPart.length);
              return fnReturnCssSelector({
                splitText: {
                  strBeforeCursor: strFirstPart,
                  strAfterCursor: strLastPart
                },
                useAlertNote
              });
            } else {
              return '';
            }
          } else {
            return fnReturnCssSelector({
              splitText,
              useAlertNote
            });
          }
        };
        class StylesEditor extends window.Editor {
          indicateEnabledDisabled(enabledDisabled) {
            if (enabledDisabled === 'enabled') {
              $(this.container).removeClass('indicate-disabled').addClass('indicate-enabled');
            } else {
              $(this.container).removeClass('indicate-enabled').addClass('indicate-disabled');
            }
          }
          applyStylesAutomatically(doApply) {
            if (doApply) {
              $(this.container).addClass('magic-css-apply-styles-automatically');
            } else {
              $(this.container).removeClass('magic-css-apply-styles-automatically');
            }
          }
          markLiveCssServerConnectionStatus(connected) {
            if (connected) {
              $(this.container).removeClass('magic-css-live-css-server-is-not-connected').addClass('magic-css-live-css-server-is-connected');
            } else {
              $(this.container).removeClass('magic-css-live-css-server-is-connected').addClass('magic-css-live-css-server-is-not-connected');
            }
            this.adjustUiPosition();
          }
          isPointAndClickActivated() {
            return enablePointAndClick;
          }
          deactivatePointAndClick() {
            disablePointAndClickFunctionality(this);
          }
          async keyPressed(keyCombination) {
            if (keyCombination === 'Ctrl-P' || keyCombination === 'Cmd-P' || keyCombination === 'Ctrl-O' || keyCombination === 'Cmd-O') {
              await setLanguageMode('file', this);
            }
          }
          async disableEnableCSS(doWhat) {
            var disabled;
            if (doWhat === 'disable') {
              disabled = true;
            } else if (doWhat === 'toggle') {
              if (newStyleTag.disabled) {
                disabled = false;
              } else {
                disabled = true;
              }
            } else {
              disabled = false;
            }
            newStyleTag.disabled = disabled;
            newStyleTag.applyTag();
            await this.userPreference('disable-styles', disabled ? 'yes' : 'no');
            if (disabled) {
              this.indicateEnabledDisabled('disabled');
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Deactivated the code', 5000);
              return 'disabled';
            } else {
              this.indicateEnabledDisabled('enabled');
              (0,_utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote)('Activated the code', 5000);
              return 'enabled';
            }
          }
        }
        _utils_alertNote_js__WEBPACK_IMPORTED_MODULE_1__.alertNote.hide(); // Hide the note which says that Magic CSS is loading
        window.MagiCSSEditor = new StylesEditor(options);

        // "myWin.flagEditorInExternalWindow" would also be true when "sessionStorageDataForInitialization" is truthy
        if (sessionStorageDataForInitialization) {
          for (const prop in sessionStorageDataForInitialization) {
            await window.MagiCSSEditor.userPreference(prop, sessionStorageDataForInitialization[prop]);
          }
        }
        await window.MagiCSSEditor.create();
        const magicCssLoadedFine = checkIfMagicCssLoadedFine(window.MagiCSSEditor);
        window.MagiCSSEditor.markLiveCssServerConnectionStatus(false);
        try {
          chromeStorageForExtensionData.get('use-autocomplete-for-css-selectors', function (values) {
            if (values && values['use-autocomplete-for-css-selectors'] === false) {
              disableAutocompleteSelectors(window.MagiCSSEditor);
            } else {
              enableAutocompleteSelectors(window.MagiCSSEditor);
            }
          });
        } catch (e) {
          enableAutocompleteSelectors(window.MagiCSSEditor);
        }
        if (executionCounter && !isNaN(executionCounter)) {
          try {
            chromeStorageForExtensionData.set({
              'magicss-execution-counter': executionCounter
            }, function () {
              sendMessageForMetrics({
                event: 'launch'
              });
            });
          } catch (e) {
            // do nothing
          }
        }
        document.addEventListener('keyup', function (evt) {
          if (evt.altKey && evt.shiftKey && evt.keyCode === 83) {
            if (window.MagiCSSEditor.isVisible()) {
              togglePointAndClick(window.MagiCSSEditor);
            }
          }
        }, false);
        if ((await window.MagiCSSEditor.userPreference(USER_PREFERENCE_HIDE_ON_PAGE_MOUSEOUT)) === 'yes') {
          var opacityCssAdded = false,
            opacityStyleTagId = id + '-opacity-id';
          var mousemoveListener = function () {
            // This check is not necessary as such since we are removing the mousemoveListener
            // once the code has been executed. This check is there just to prevent some possible
            // bugs that might come up later if we change the approach/code and miss out some cases
            if (opacityCssAdded) {
              return;
            }
            (0,_utils_StyleTag_js__WEBPACK_IMPORTED_MODULE_7__.addStyleTag)({
              id: opacityStyleTagId,
              attributes: [{
                name: 'data-style-created-by',
                value: 'magicss'
              }],
              cssText: ['html #' + id + ' {', '    transition: opacity 0.5s ease-in-out;', '    opacity: 0 !important;', '    pointer-events: none !important;', '}', 'html:hover #' + id + ' {',
              // Note that this opacity CSS would not let the editor hide in point-and-click mode (to generate CSS selector)
              '    opacity: 1 !important;', '    pointer-events: initial !important;', '}'].join('\n'),
              parentTag: 'body'
            });
            opacityCssAdded = true;
            document.removeEventListener('mousemove', mousemoveListener, false);
          };
          document.addEventListener('mousemove', mousemoveListener, false);
        }
        chromeStorageForExtensionData.get('last-time-editor-was-in-external-window', function (values) {
          setTimeout(async () => {
            const editor = window.MagiCSSEditor;
            const targetEditMode = await editor.userPreference('language-mode');
            const targetEditModeIsNotFile = !window.languageModeIsIntermittent && targetEditMode !== 'file';
            const notInsideIframe = window === window.parent;
            if (values && values['last-time-editor-was-in-external-window'] === true && targetEditModeIsNotFile && notInsideIframe) {
              if (!_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                window.loadEditorInExternalWindow(editor);
              }
            }
            if (magicCssLoadedFine) {
              if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_8__.myWin.flagEditorInExternalWindow) {
                chromeStorageForExtensionData.set({
                  'last-time-editor-was-in-external-window': true
                }, function () {
                  // do nothing
                });
              } else {
                chromeStorageForExtensionData.set({
                  'last-time-editor-was-in-external-window': false
                }, function () {
                  // do nothing
                });
              }
            }
          });
        });
      }
    });
  };
  var executionCounter = 0;
  try {
    chromeStorageForExtensionData.get('magicss-execution-counter', function (values) {
      try {
        executionCounter = parseInt(values && values['magicss-execution-counter'], 10);
        executionCounter = isNaN(executionCounter) ? 0 : executionCounter;
        executionCounter = executionCounter < 0 ? 0 : executionCounter;
        executionCounter++;
      } catch (e) {
        // do nothing
      }
      setTimeout(async function () {
        await main();
      });
    });
  } catch (e) {
    setTimeout(async function () {
      await main();
    });
  }
})(jQuery);

/***/ }),

/***/ "./scripts/magicss/metrics/sendMessageForMetrics.js":
/*!**********************************************************!*\
  !*** ./scripts/magicss/metrics/sendMessageForMetrics.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sendEventMessageForMetrics": () => (/* binding */ sendEventMessageForMetrics)
/* harmony export */ });
/* global chrome */

/*
    For example:
        sendEventMessageForMetrics({
            name: 'openGetIcon',
            spot: 'commandPalette'
        });
*/
const sendEventMessageForMetrics = function (payload) {
  try {
    if (payload) {
      if (typeof payload.metricsTarget === 'undefined' || payload.metricsTarget === 'mixpanel') {
        // eslint-disable-next-line no-unused-vars
        const {
          metricsTarget,
          ...evt
        } = payload;
        chrome.runtime.sendMessage({
          type: 'mixpanel',
          subType: 'event',
          payload: evt
        });
      }
    }
  } catch (e) {
    // do nothing
  }
};
window.sendEventMessageForMetrics = sendEventMessageForMetrics;


/***/ }),

/***/ "./scripts/migrate-storage.js":
/*!************************************!*\
  !*** ./scripts/migrate-storage.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "runMigration": () => (/* binding */ runMigration)
/* harmony export */ });
/* harmony import */ var _utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/chromeStorage.js */ "./scripts/utils/chromeStorage.js");
/* global chrome */

/* eslint-disable require-atomic-updates */


var USER_PREFERENCE_STORAGE_MODE = 'storage-mode';
var dataMigration = {
  arrPropNames: ['apply-styles-automatically', 'disable-styles', 'language-mode', 'language-mode-non-file', 'last-applied-css', 'live-css-server-hostname', 'live-css-server-port', 'show-line-numbers', 'enable-line-wrap', 'textarea-value', 'ui-position-left', 'ui-position-top', 'ui-size-height', 'ui-size-width', 'use-css-linting', 'file-to-edit', 'watching-css-files'],
  oldDataPrefix: 'MagiCSS-bookmarklet-',
  newDataPrefix: 'live-css-'
};
dataMigration.arrPropNamesForLocalStorage = dataMigration.arrPropNames.map(function (propName) {
  return `__amplify__${dataMigration.oldDataPrefix}${propName}`;
});
dataMigration.arrPropNamesForChromeStorage = dataMigration.arrPropNames.map(function (propName) {
  return `(${window.location.origin}) ${dataMigration.newDataPrefix}${propName}`;
});
var chromeStorageForExtensionData = chrome.storage.sync || chrome.storage.local;
var runMigration = async function () {
  var whichStoreToUse = await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageGet)(chromeStorageForExtensionData, USER_PREFERENCE_STORAGE_MODE);
  if (whichStoreToUse === 'localStorage') {
    // do nothing
  } else if (whichStoreToUse === 'chrome.storage.sync') {
    // do nothing
  } else {
    whichStoreToUse = 'chrome.storage.local';
  }
  const migrateDataFromLocalStorageToChromeStorage = async function (chromeStorageType) {
    for (let i = 0; i < dataMigration.arrPropNames.length; i++) {
      let propNameForLocalStorage = dataMigration.arrPropNamesForLocalStorage[i];
      let propNameForChromeStorage = dataMigration.arrPropNamesForChromeStorage[i];
      let valueFromLocalStorage = localStorage[propNameForLocalStorage];
      let valueFromChromeStorage;
      if (chromeStorageType === 'chrome.storage.sync') {
        valueFromChromeStorage = await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageSyncGet)(propNameForChromeStorage);
      } else {
        valueFromChromeStorage = await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageLocalGet)(propNameForChromeStorage);
      }
      if (!valueFromChromeStorage) {
        let json = {};
        try {
          json = JSON.parse(valueFromLocalStorage);
        } catch (e) {
          // TODO: Handle this error
        }
        if (json.data) {
          if (chromeStorageType === 'chrome.storage.sync') {
            await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageSyncSet)(propNameForChromeStorage, json.data);
          } else {
            await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageLocalSet)(propNameForChromeStorage, json.data);
          }
        }
      }
      delete localStorage[propNameForLocalStorage];
    }
  };
  const migrateDataFromChromeStorageToLocalStorage = async function (chromeStorageType) {
    for (let i = 0; i < dataMigration.arrPropNames.length; i++) {
      let propNameForLocalStorage = dataMigration.arrPropNamesForLocalStorage[i];
      let propNameForChromeStorage = dataMigration.arrPropNamesForChromeStorage[i];
      let valueFromLocalStorage = localStorage[propNameForLocalStorage];
      let valueFromChromeStorage;
      if (chromeStorageType === 'chrome.storage.sync') {
        valueFromChromeStorage = await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageSyncGet)(propNameForChromeStorage);
      } else {
        valueFromChromeStorage = await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageLocalGet)(propNameForChromeStorage);
      }
      if (!valueFromLocalStorage) {
        if (valueFromChromeStorage) {
          localStorage[propNameForLocalStorage] = JSON.stringify({
            data: valueFromChromeStorage,
            expires: null
          });
        }
      }
      if (typeof valueFromChromeStorage !== 'undefined') {
        if (chromeStorageType === 'chrome.storage.sync') {
          await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageSyncRemove)(propNameForChromeStorage);
        } else {
          await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageLocalRemove)(propNameForChromeStorage);
        }
      }
    }
  };
  const migrateDataFromChromeStorageToChromeStorage = async function (sourceChromeStorageType, destinationChromeStorageType) {
    for (let i = 0; i < dataMigration.arrPropNames.length; i++) {
      let propNameForChromeStorage = dataMigration.arrPropNamesForChromeStorage[i];
      let valueFromSourceStorage;
      if (sourceChromeStorageType === 'chrome.storage.sync') {
        valueFromSourceStorage = await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageSyncGet)(propNameForChromeStorage);
      } else {
        valueFromSourceStorage = await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageLocalGet)(propNameForChromeStorage);
      }
      let valueFromDestinationStorage;
      if (destinationChromeStorageType === 'chrome.storage.sync') {
        valueFromDestinationStorage = await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageSyncGet)(propNameForChromeStorage);
      } else {
        valueFromDestinationStorage = await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageLocalGet)(propNameForChromeStorage);
      }
      if (!valueFromDestinationStorage) {
        if (valueFromSourceStorage) {
          if (destinationChromeStorageType === 'chrome.storage.sync') {
            await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageSyncSet)(propNameForChromeStorage, valueFromSourceStorage);
          } else {
            await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageLocalSet)(propNameForChromeStorage, valueFromSourceStorage);
          }
        }
      }
      if (typeof valueFromSourceStorage !== 'undefined') {
        if (sourceChromeStorageType === 'chrome.storage.sync') {
          await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageSyncRemove)(propNameForChromeStorage);
        } else {
          await (0,_utils_chromeStorage_js__WEBPACK_IMPORTED_MODULE_0__.chromeStorageLocalRemove)(propNameForChromeStorage);
        }
      }
    }
  };
  try {
    if (whichStoreToUse === 'chrome.storage.local') {
      await migrateDataFromLocalStorageToChromeStorage('chrome.storage.local');
      await migrateDataFromChromeStorageToChromeStorage('chrome.storage.sync', 'chrome.storage.local');
    } else if (whichStoreToUse === 'chrome.storage.sync') {
      await migrateDataFromLocalStorageToChromeStorage('chrome.storage.sync');
      await migrateDataFromChromeStorageToChromeStorage('chrome.storage.local', 'chrome.storage.sync');
    } else {
      await migrateDataFromChromeStorageToLocalStorage('chrome.storage.local');
      await migrateDataFromChromeStorageToLocalStorage('chrome.storage.sync');
    }
  } catch (e) {
    // TODO: Handle this error
  }
};
(async function () {
  await runMigration();
})();


/***/ }),

/***/ "./scripts/utils.js":
/*!**************************!*\
  !*** ./scripts/utils.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utils": () => (/* binding */ utils)
/* harmony export */ });
/* global jQuery */



var utils = window.utils || {};
if (!utils.defined) {
  utils.defined = true;
  utils.attachPublishSubscribe = function (attachToObject) {
    var o = jQuery({});
    jQuery.each({
      trigger: 'publish',
      on: 'subscribe',
      off: 'unsubscribe'
    }, function (key, val) {
      attachToObject[val] = function () {
        o[key].apply(o, arguments);
      };
    });
  };
}
if (!utils.attachPublishSubscribeDone) {
  if (typeof jQuery !== 'undefined') {
    utils.attachPublishSubscribeDone = true;
    utils.attachPublishSubscribe(jQuery);
  }
}

// // The following line has been commented out temporarily. See: FIXME.md
// 'This string is added to the end of this file to handle a weird bug/behavior for Firefox. Without this, if "reapply styles automatically" feature is activated, then it would not work and an error would occur in the background script. Reference: https://stackoverflow.com/questions/44567525/inject-scripts-error-script-returned-non-structured-clonable-data-on-firefox-ex/56597154#56597154';



/***/ }),

/***/ "./scripts/utils/StyleTag.js":
/*!***********************************!*\
  !*** ./scripts/utils/StyleTag.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyleTag": () => (/* binding */ StyleTag),
/* harmony export */   "addStyleTag": () => (/* binding */ addStyleTag)
/* harmony export */ });
/* harmony import */ var _appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../appUtils/myWin.js */ "./scripts/appUtils/myWin.js");


/*
Parameters:
    config.cssText (required): The CSS style
    config.doc (optional): Which "document" object to use
    config.id (optional): ID attribute for the style tag
    config.parentTag (optional): 'body' (default) or 'head' or 'html' (the "parentTag" value would be used if that element is available)
    config.overwriteExistingStyleTagWithSameId: Overwrite definition of existing style tag with same id, true or false (default)
    config.removeExistingStyleTagWithSameId (optional): true or false (default),
        applicable only if "id" parameter is also specified
*/
const addStyleTag = function (config) {
  var doc = config.doc || document,
    id = config.id;
  if (id) {
    var removeExistingStyleTag = config.removeExistingStyleTagWithSameId;
    if (removeExistingStyleTag === true) {
      var existingStyleTag = document.getElementById(id);
      existingStyleTag.parentNode.removeChild(existingStyleTag);
    }
  }
  var overwriteExistingStyleTag = config.overwriteExistingStyleTagWithSameId,
    styleNode;
  if (overwriteExistingStyleTag && id) {
    styleNode = document.getElementById(id);
  }
  if (styleNode) {
    // do nothing
  } else {
    styleNode = doc.createElement('style');
    styleNode.type = 'text/css';
    if (id) {
      styleNode.id = id;
    }
  }
  var attributes = config.attributes || [];
  attributes.forEach(function (attribute) {
    styleNode.setAttribute(attribute.name, attribute.value);
  });
  var cssText = config.cssText;
  styleNode.innerHTML = '';
  styleNode.appendChild(doc.createTextNode(cssText));
  var parent = function () {
    var parentTag = config.parentTag || 'body';
    if (parentTag === 'html') {
      return 'documentElement';
    } else if (parentTag === 'head') {
      return 'head';
    } else {
      return 'body';
    }
  }();
  var parentEl = doc[parent] || doc['body'] || doc['head'] || doc['documentElement'];
  parentEl.appendChild(styleNode);
  var disabled = config.disabled;

  // TODO: FIXME: HACK: This 'if' condition should be converted into some standard implementation
  if (_appUtils_myWin_js__WEBPACK_IMPORTED_MODULE_0__.myWin.flagEditorInExternalWindow && id === 'MagiCSS-bookmarklet-html-id') {
    disabled = true;
  }
  if (disabled) {
    styleNode.disabled = true;
  } else {
    styleNode.disabled = false;
  }
};
const StyleTag = function (config) {
  this.cssText = config.cssText;
  this.id = config.id;
  this.parentTag = config.parentTag;
  this.overwriteExistingStyleTagWithSameId = config.overwriteExistingStyleTagWithSameId;
  this.removeExistingStyleTagWithSameId = config.removeExistingStyleTagWithSameId;
  var proto = StyleTag.prototype;
  if (typeof proto.firstExecution == 'undefined') {
    proto.firstExecution = true;
    proto.applyTag = function () {
      addStyleTag({
        attributes: config.attributes,
        cssText: this.cssText,
        id: this.id,
        parentTag: this.parentTag,
        overwriteExistingStyleTagWithSameId: this.overwriteExistingStyleTagWithSameId,
        removeExistingStyleTagWithSameId: this.removeExistingStyleTagWithSameId,
        disabled: this.disabled
      });
      var appliedCssText = this.cssText;
      return appliedCssText;
    };
    proto.disable = function () {
      // TODO
    };
  } else {
    proto.firstExecution = false;
  }
};


/***/ }),

/***/ "./scripts/utils/alertNote.js":
/*!************************************!*\
  !*** ./scripts/utils/alertNote.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "alertNote": () => (/* binding */ alertNote)
/* harmony export */ });
const alertNote = function () {
  var w = window,
    d = document,
    dE = d.documentElement,
    div = d.createElement('div'),
    t;
  div.id = 'topCenterAlertNote';

  // Hide functionality
  var h = function (div) {
    div.style.display = 'none';
  };
  var clearTimeout = function () {
    w.clearTimeout(t);
  };
  const defaults = {
    paddingTop: '',
    paddingRight: '',
    paddingBottom: '',
    paddingLeft: '',
    verticalAlignment: 'top',
    horizontalAlignment: 'center',
    textAlignment: 'center'
  };
  var alertNote = function (msg, hideDelay, options) {
    options = options || {};
    var verticalAlignment = options.verticalAlignment || defaults.verticalAlignment || 'top',
      horizontalAlignment = options.horizontalAlignment || defaults.horizontalAlignment || 'center',
      textAlignment = options.textAlignment || defaults.textAlignment || 'center',
      backgroundColor = options.backgroundColor || '#f9edbe',
      borderColor = options.borderColor || '#eb7',
      opacity = options.opacity || '1',
      paddingTop = options.paddingTop || defaults.paddingTop || '',
      paddingRight = options.paddingRight || defaults.paddingRight || '',
      paddingBottom = options.paddingBottom || defaults.paddingBottom || '',
      paddingLeft = options.paddingLeft || defaults.paddingLeft || '',
      unobtrusive = options.unobtrusive || false;
    // TODO:
    // - Apply !important for various inline styles (otherwise, it might get over-ridden by some previously present !important CSS styles)
    // - "OK" button functionality

    /*eslint-disable indent */
    div.innerHTML = ['<div ' + 'style="' + 'pointer-events:none;' +
    // To avoid it from stealing hover (the pointer-events will be enabled for a child element)
    'position:fixed;width:100%;z-index:2147483600;' + (paddingTop ? `padding-top:   ${paddingTop};` : '') + (paddingBottom ? `padding-bottom:${paddingBottom};` : '') + (verticalAlignment === 'bottom' ? 'bottom:0;' : 'top:0;') + function () {
      if (horizontalAlignment === 'left') {
        return 'left:0;';
      } else if (horizontalAlignment === 'right') {
        return 'right:0;';
      } else {
        /* Even for center aligning, we need to set left or right as 0, without that
            it would try to center align whithout considering the width taken by vertical scrollbar */
        return 'left:0;';
      }
    }() + 'text-align:' + horizontalAlignment + ';' +
    // TODO: Check if we need this
    'opacity:' + opacity + ';' + '"' + '>', '<div ' + 'style="' + 'display:flex;width:auto;margin:0;padding:0;border:0;' + (paddingRight ? `padding-right:${paddingRight};` : '') + (paddingLeft ? `padding-left: ${paddingLeft};` : '') + function () {
      if (horizontalAlignment === 'left') {
        return 'justify-content:flex-start;';
      } else if (horizontalAlignment === 'right') {
        return 'justify-content:flex-end;';
      } else {
        return 'justify-content:center;';
      }
    }() +
    // margin:0 is useful for some sites (eg: https://developer.chrome.com/home)
    '"' + '>', '<div ' + 'style="' + 'pointer-events:initial;' +
    // To gain back the pointer-events which were disabled in one of the parent elements
    'border:1px solid ' + borderColor + ';' + 'background-color:' + backgroundColor + ';' +
    // background-color:#feb;
    // TODO: Check if we need "text-align: left". Maybe it helps to set the default style.
    'padding:2px 10px;max-width:980px;overflow:hidden;text-align:left;font-family:Arial,sans-serif;font-weight:bold;font-size:12px' + '"' + '>', '<div class="alert-note-text" style="color:#000;text-align:' + textAlignment + ';word-wrap:break-word;">', msg, '</div>', '</div>', '</div>', '</div>'].join('');
    /*eslint-enable indent */

    if (unobtrusive) {
      try {
        var firstChild = div.firstChild.firstChild.firstChild;
        firstChild.addEventListener('mouseenter', function () {
          // Note:
          //      If we wish to directly apply the opacity changes to the parent "div",
          //      which is currently a direct child of <html> tag, then, on some sites (eg:
          //      gmail.com) somehow, as soon as we reduce its opacity to a value less than
          //      1 (eg: 0.99), it gets hidden immediately. The fact that it is appended to
          //      <html> tag and not to <body> is somehow causing this behavior. Since we
          //      are using that parent div's inner child, the opacity transition works fine.
          firstChild.style.transition = 'opacity 0.3s ease-out';
          firstChild.style.opacity = '0';
          firstChild.style.pointerEvents = 'none';
        }, false);
      } catch (e) {
        // do nothing
      }
    }
    div.style.display = ''; // Required when the same div element is being reused

    dE.appendChild(div);
    clearTimeout();
    t = w.setTimeout(function () {
      h(div);
    }, hideDelay || 5000);
  };
  alertNote.hide = function () {
    h(div);
    clearTimeout();
  };
  alertNote.setup = function (defaultsToSet) {
    if (typeof defaultsToSet.verticalAlignment !== 'undefined') {
      defaults.verticalAlignment = defaultsToSet.verticalAlignment;
    }
    if (typeof defaultsToSet.horizontalAlignment !== 'undefined') {
      defaults.horizontalAlignment = defaultsToSet.horizontalAlignment;
    }
    if (typeof defaultsToSet.textAlignment !== 'undefined') {
      defaults.textAlignment = defaultsToSet.textAlignment;
    }
    if (typeof defaultsToSet.paddingTop !== 'undefined') {
      defaults.paddingTop = defaultsToSet.paddingTop;
    }
    if (typeof defaultsToSet.paddingRight !== 'undefined') {
      defaults.paddingRight = defaultsToSet.paddingRight;
    }
    if (typeof defaultsToSet.paddingBottom !== 'undefined') {
      defaults.paddingBottom = defaultsToSet.paddingBottom;
    }
    if (typeof defaultsToSet.paddingLeft !== 'undefined') {
      defaults.paddingLeft = defaultsToSet.paddingLeft;
    }
  };
  return alertNote;
}();


/***/ }),

/***/ "./scripts/utils/beautifyCss.js":
/*!**************************************!*\
  !*** ./scripts/utils/beautifyCss.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "beautifyCss": () => (/* binding */ beautifyCss)
/* harmony export */ });
/* harmony import */ var helpmate_css_dist_format_csspretty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! helpmate-css/dist/format/csspretty.js */ "../node_modules/helpmate-css/dist/format/csspretty.js");

const beautifyCss = function (cssCode, options) {
  var useTabs = options.useTabs,
    useSpaceCount = options.useSpaceCount;
  var inchar, insize;
  if (useTabs) {
    inchar = '\t';
    insize = 1;
  } else {
    inchar = ' ';
    insize = useSpaceCount || 4;
  }
  return (0,helpmate_css_dist_format_csspretty_js__WEBPACK_IMPORTED_MODULE_0__.csspretty)({
    mode: 'beautify',
    /* Doing beautify twice, otherwise it doesn't beautify code like the following one in single go:
           .box-shadow(@style,@alpha: 50%) when (isnumber(@alpha)){.box-shadow(@style, rgba(0, 0, 0, @alpha))} */
    insize: insize,
    inchar: inchar,
    source: (0,helpmate_css_dist_format_csspretty_js__WEBPACK_IMPORTED_MODULE_0__.csspretty)({
      mode: 'beautify',
      insize: insize,
      inchar: inchar,
      source: cssCode
    })
  });

  // Alternatively, use cssbeautify library:
  //     return cssbeautify(
  //         cssCode,
  //         {
  //             indent: '    ',
  //             autosemicolon: true
  //         }
  //     );
};



/***/ }),

/***/ "./scripts/utils/chromeStorage.js":
/*!****************************************!*\
  !*** ./scripts/utils/chromeStorage.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "chromeStorageGet": () => (/* binding */ chromeStorageGet),
/* harmony export */   "chromeStorageLocalGet": () => (/* binding */ chromeStorageLocalGet),
/* harmony export */   "chromeStorageLocalRemove": () => (/* binding */ chromeStorageLocalRemove),
/* harmony export */   "chromeStorageLocalSet": () => (/* binding */ chromeStorageLocalSet),
/* harmony export */   "chromeStorageSyncGet": () => (/* binding */ chromeStorageSyncGet),
/* harmony export */   "chromeStorageSyncRemove": () => (/* binding */ chromeStorageSyncRemove),
/* harmony export */   "chromeStorageSyncSet": () => (/* binding */ chromeStorageSyncSet)
/* harmony export */ });
/* unused harmony exports chromeStorageSet, chromeStorageRemove */
/* global chrome */

const chromeStorageGet = function (storageObject, prop) {
  return new Promise(function (resolve, reject) {
    // eslint-disable-line no-unused-vars
    storageObject.get(prop, function (values) {
      if (prop === null) {
        resolve(values);
      } else {
        resolve(values[prop]);
      }
    });
  });
};
const chromeStorageSet = function (storageObject, prop, value) {
  return new Promise(function (resolve, reject) {
    // eslint-disable-line no-unused-vars
    storageObject.set({
      [prop]: value
    }, function () {
      resolve();
    });
  });
};
const chromeStorageRemove = function (storageObject, prop) {
  return new Promise(function (resolve, reject) {
    // eslint-disable-line no-unused-vars
    storageObject.remove(prop, function () {
      resolve();
    });
  });
};
const chromeStorageLocalGet = async function (prop) {
  const value = await chromeStorageGet(chrome.storage.local, prop);
  return value;
};
const chromeStorageLocalSet = async function (prop, value) {
  await chromeStorageSet(chrome.storage.local, prop, value);
};
const chromeStorageLocalRemove = async function (prop, value) {
  await chromeStorageRemove(chrome.storage.local, prop, value);
};
const chromeStorageSyncGet = async function (prop) {
  const value = await chromeStorageGet(chrome.storage.sync, prop);
  return value;
};
const chromeStorageSyncSet = async function (prop, value) {
  await chromeStorageSet(chrome.storage.sync, prop, value);
};
const chromeStorageSyncRemove = async function (prop, value) {
  await chromeStorageRemove(chrome.storage.sync, prop, value);
};

/***/ }),

/***/ "./scripts/utils/delayFunctionUntilTestFunction.js":
/*!*********************************************************!*\
  !*** ./scripts/utils/delayFunctionUntilTestFunction.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "delayFunctionUntilTestFunction": () => (/* binding */ delayFunctionUntilTestFunction)
/* harmony export */ });
const delayFunctionUntilTestFunction = async function (config) {
  var fnSuccess = config.fnSuccess,
    fnTest = config.fnTest,
    fnFirstFailure = config.fnFirstFailure,
    fnEachFailure = config.fnEachFailure,
    fnFailure = config.fnFailure,
    tryLimit = typeof config.tryLimit === 'undefined' ? 120 : config.tryLimit;
  config['tryLimit-Running-Cycle-Number'] = typeof config['tryLimit-Running-Cycle-Number'] === 'undefined' ? 0 : config['tryLimit-Running-Cycle-Number'] + 1;
  var tryLimitRunningCycleNumber = config['tryLimit-Running-Cycle-Number'],
    waitFor = config.waitFor || 750;
  if (fnTest()) {
    return (await fnSuccess()) === false ? false : true;
  } else {
    if (tryLimitRunningCycleNumber === 0 && typeof fnFirstFailure === 'function') {
      fnFirstFailure();
    }
    if (typeof fnEachFailure === 'function') {
      fnEachFailure();
    }
    if (tryLimitRunningCycleNumber < tryLimit - 1) {
      window.setTimeout(async function () {
        await delayFunctionUntilTestFunction(config);
      }, waitFor);
    } else {
      if (typeof fnFailure === 'function') {
        fnFailure();
      }
    }
    return false;
  }
};


/***/ }),

/***/ "./scripts/utils/i18n.js":
/*!*******************************!*\
  !*** ./scripts/utils/i18n.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TR": () => (/* binding */ TR)
/* harmony export */ });
/* global chrome */

const TR = function (key, defaultValue) {
  if (typeof chrome !== 'undefined' && chrome?.i18n?.getMessage) {
    return chrome.i18n.getMessage(key);
  } else {
    if (defaultValue) {
      return defaultValue;
    } else {
      console.warn('No default value available for key: ' + key);
      return '';
    }
  }
};


/***/ }),

/***/ "./scripts/utils/lessToCss.js":
/*!************************************!*\
  !*** ./scripts/utils/lessToCss.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lessToCss": () => (/* binding */ lessToCss)
/* harmony export */ });
/* global less */

const lessToCss = function (lessCode, cb) {
  less.default.render(lessCode, function (err, output) {
    if (err) {
      cb(err);
    } else {
      var cssCode = output.css;
      cb(null, cssCode);
    }
  });

  // With older versions of less:
  //     less.Parser().parse(lessCode, function (err, tree) {
  //         if (err) {
  //             cb(err);
  //         } else {
  //             var cssCode = tree.toCSS();
  //             cb(null, cssCode);
  //         }
  //     });
};



/***/ }),

/***/ "./scripts/utils/minifyCss.js":
/*!************************************!*\
  !*** ./scripts/utils/minifyCss.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "minifyCss": () => (/* binding */ minifyCss)
/* harmony export */ });
/* harmony import */ var helpmate_css_dist_format_csspretty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! helpmate-css/dist/format/csspretty.js */ "../node_modules/helpmate-css/dist/format/csspretty.js");

const minifyCss = function (cssCode) {
  return (0,helpmate_css_dist_format_csspretty_js__WEBPACK_IMPORTED_MODULE_0__.csspretty)({
    mode: 'minify',
    source: cssCode
  });

  // Alternatively, use Yahoo's CSS Min library:
  //     return YAHOO.compressor.cssmin(cssCode);
};



/***/ }),

/***/ "./scripts/utils/sassToCss.js":
/*!************************************!*\
  !*** ./scripts/utils/sassToCss.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sassToCss": () => (/* binding */ sassToCss)
/* harmony export */ });
/* global Sass */

const sassToCss = function (sassCode, options, cb) {
  Sass.compile(sassCode, options, function (output) {
    if (output.message) {
      cb(output);
    } else {
      var cssCode = output.text;
      cb(null, cssCode);
    }
  });
};


/***/ }),

/***/ "./scripts/utils/waterfall.js":
/*!************************************!*\
  !*** ./scripts/utils/waterfall.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "waterfall": () => (/* binding */ waterfall)
/* harmony export */ });
// https://github.com/hydiak/a-sync-waterfall/blob/master/index.js
// MIT license (by Elan Shanker).

var executeSync = function () {
  var args = Array.prototype.slice.call(arguments);
  if (typeof args[0] === 'function') {
    args[0].apply(null, args.splice(1));
  }
};
var executeAsync = function (fn) {
  if (typeof setImmediate === 'function') {
    setImmediate(fn);
  } else if (typeof process !== 'undefined' && process.nextTick) {
    process.nextTick(fn);
  } else {
    setTimeout(fn, 0);
  }
};
var makeIterator = function (tasks) {
  var makeCallback = function (index) {
    var fn = function () {
      if (tasks.length) {
        tasks[index].apply(null, arguments);
      }
      return fn.next();
    };
    fn.next = function () {
      return index < tasks.length - 1 ? makeCallback(index + 1) : null;
    };
    return fn;
  };
  return makeCallback(0);
};
var _isArray = Array.isArray || function (maybeArray) {
  return Object.prototype.toString.call(maybeArray) === '[object Array]';
};
var waterfall = function (tasks, callback, forceAsync) {
  var nextTick = forceAsync ? executeAsync : executeSync;
  callback = callback || function () {};
  if (!_isArray(tasks)) {
    var err = new Error('First argument to waterfall must be an array of functions');
    return callback(err);
  }
  if (!tasks.length) {
    return callback();
  }
  var wrapIterator = function (iterator) {
    return function (err) {
      if (err) {
        callback.apply(null, arguments);
        callback = function () {};
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        var next = iterator.next();
        if (next) {
          args.push(wrapIterator(next));
        } else {
          args.push(callback);
        }
        nextTick(function () {
          iterator.apply(null, args);
        });
      }
    };
  };
  wrapIterator(makeIterator(tasks))();
};


/***/ }),

/***/ "../node_modules/codemirror/lib/codemirror.js":
/*!****************************************************!*\
  !*** ../node_modules/codemirror/lib/codemirror.js ***!
  \****************************************************/
/***/ (function(module) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
   true ? module.exports = factory() : 0;
})(this, function () {
  'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;
  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);
  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);
  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) {
    presto_version = Number(presto_version[1]);
  }
  if (presto_version && presto_version >= 15) {
    presto = false;
    webkit = true;
  }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || ie && ie_version >= 9;
  function classTest(cls) {
    return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
  }
  var rmClass = function (node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count) {
      e.removeChild(e.firstChild);
    }
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) {
      e.className = className;
    }
    if (style) {
      e.style.cssText = style;
    }
    if (typeof content == "string") {
      e.appendChild(document.createTextNode(content));
    } else if (content) {
      for (var i = 0; i < content.length; ++i) {
        e.appendChild(content[i]);
      }
    }
    return e;
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e;
  }
  var range;
  if (document.createRange) {
    range = function (node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r;
    };
  } else {
    range = function (node, start, end) {
      var r = document.body.createTextRange();
      try {
        r.moveToElementText(node.parentNode);
      } catch (e) {
        return r;
      }
      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r;
    };
  }
  function contains(parent, child) {
    if (child.nodeType == 3)
      // Android browser always returns false when child is a textnode
      {
        child = child.parentNode;
      }
    if (parent.contains) {
      return parent.contains(child);
    }
    do {
      if (child.nodeType == 11) {
        child = child.host;
      }
      if (child == parent) {
        return true;
      }
    } while (child = child.parentNode);
  }
  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch (e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
      activeElement = activeElement.shadowRoot.activeElement;
    }
    return activeElement;
  }
  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) {
      node.className += (current ? " " : "") + cls;
    }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++) {
      if (as[i] && !classTest(as[i]).test(b)) {
        b += " " + as[i];
      }
    }
    return b;
  }
  var selectInput = function (node) {
    node.select();
  };
  if (ios)
    // Mobile Safari apparently has a bug where select() is broken.
    {
      selectInput = function (node) {
        node.selectionStart = 0;
        node.selectionEnd = node.value.length;
      };
    } else if (ie)
    // Suppress mysterious IE10 errors
    {
      selectInput = function (node) {
        try {
          node.select();
        } catch (_e) {}
      };
    }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }
  function copyObj(obj, target, overwrite) {
    if (!target) {
      target = {};
    }
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
        target[prop] = obj[prop];
      }
    }
    return target;
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) {
        end = string.length;
      }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end) {
        return n + (end - i);
      }
      n += nextTab - i;
      n += tabSize - n % tabSize;
      i = nextTab + 1;
    }
  }
  var Delayed = function () {
    this.id = null;
  };
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };
  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i) {
      if (array[i] == elt) {
        return i;
      }
    }
    return -1;
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {
    toString: function () {
      return "CodeMirror.Pass";
    }
  };

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {
    scroll: false
  };
  var sel_mouse = {
    origin: "*mouse"
  };
  var sel_move = {
    origin: "+move"
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) {
        nextTab = string.length;
      }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal) {
        return pos + Math.min(skipped, goal - col);
      }
      col += nextTab - pos;
      col += tabSize - col % tabSize;
      pos = nextTab + 1;
      if (col >= goal) {
        return pos;
      }
    }
  }
  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n) {
      spaceStrs.push(lst(spaceStrs) + " ");
    }
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) {
      out[i] = f(array[i], i);
    }
    return out;
  }
  function insertSorted(array, value, score) {
    var pos = 0,
      priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) {
      pos++;
    }
    array.splice(pos, 0, value);
  }
  function nothing() {}
  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) {
      copyObj(props, inst);
    }
    return inst;
  }
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }
  function isWordChar(ch, helper) {
    if (!helper) {
      return isWordCharBasic(ch);
    }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
      return true;
    }
    return helper.test(ch);
  }
  function isEmpty(obj) {
    for (var n in obj) {
      if (obj.hasOwnProperty(n) && obj[n]) {
        return false;
      }
    }
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) {
    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
  }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
      pos += dir;
    }
    return pos;
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) {
        return from;
      }
      var midF = (from + to) / 2,
        mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) {
        return pred(mid) ? from : to;
      }
      if (pred(mid)) {
        to = mid;
      } else {
        from = mid + dir;
      }
    }
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    if (!webkit && !(gecko && mobile)) {
      d.scroller.draggable = true;
    }
    if (place) {
      if (place.appendChild) {
        place.appendChild(d.wrapper);
      } else {
        place(d.wrapper);
      }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;
    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;
    d.activeTouch = null;
    input.init(d);
  }

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) {
      throw new Error("There is no line " + (n + doc.first) + " in the document.");
    }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i],
          sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [],
      n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) {
        text = text.slice(0, end.ch);
      }
      if (n == start.line) {
        text = text.slice(start.ch);
      }
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    }); // iter aborts when callback returns truthy value
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) {
      for (var n = line; n; n = n.parent) {
        n.height += diff;
      }
    }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) {
      return null;
    }
    var cur = line.parent,
      no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) {
          break;
        }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1],
          ch = child.height;
        if (h < ch) {
          chunk = child;
          continue outer;
        }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i],
        lh = line.height;
      if (h < lh) {
        break;
      }
      h -= lh;
    }
    return n + i;
  }
  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }
  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if (sticky === void 0) sticky = null;
    if (!(this instanceof Pos)) {
      return new Pos(line, ch, sticky);
    }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }
  function equalCursorPos(a, b) {
    return a.sticky == b.sticky && cmp(a, b) == 0;
  }
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function maxPos(a, b) {
    return cmp(a, b) < 0 ? b : a;
  }
  function minPos(a, b) {
    return cmp(a, b) < 0 ? a : b;
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function clipPos(doc, pos) {
    if (pos.line < doc.first) {
      return Pos(doc.first, 0);
    }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) {
      return Pos(last, getLine(doc, last).text.length);
    }
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) {
      return Pos(pos.line, linelen);
    } else if (ch < 0) {
      return Pos(pos.line, 0);
    } else {
      return pos;
    }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) {
      out[i] = clipPos(doc, array[i]);
    }
    return out;
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false;
  var sawCollapsedSpans = false;
  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }
  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from;
    this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) {
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker) {
          return span;
        }
      }
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i] != span) {
        (r || (r = [])).push(spans[i]);
      }
    }
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
          marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
          marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
        }
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) {
      return null;
    }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) {
      return null;
    }
    var startCh = change.from.ch,
      endCh = change.to.ch,
      isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1,
      offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) {
            span.to = startCh;
          } else if (sameLine) {
            span.to = found.to == null ? null : found.to + offset;
          }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) {
          span$1.to += offset;
        }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        } else {
          span$1.from += offset;
          if (sameLine) {
            (first || (first = [])).push(span$1);
          }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) {
      first = clearEmptySpans(first);
    }
    if (last && last != first) {
      last = clearEmptySpans(last);
    }
    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2,
        gapMarkers;
      if (gap > 0 && first) {
        for (var i$2 = 0; i$2 < first.length; ++i$2) {
          if (first[i$2].to == null) {
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
          }
        }
      }
      for (var i$3 = 0; i$3 < gap; ++i$3) {
        newMarkers.push(gapMarkers);
      }
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
        spans.splice(i--, 1);
      }
    }
    if (!spans.length) {
      return null;
    }
    return spans;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
            (markers || (markers = [])).push(mark);
          }
        }
      }
    });
    if (!markers) {
      return null;
    }
    var parts = [{
      from: from,
      to: to
    }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i],
        m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
          continue;
        }
        var newParts = [j, 1],
          dfrom = cmp(p.from, m.from),
          dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
          newParts.push({
            from: p.from,
            to: m.from
          });
        }
        if (dto > 0 || !mk.inclusiveRight && !dto) {
          newParts.push({
            from: m.to,
            to: p.to
          });
        }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) {
      return;
    }
    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.detachLine(line);
    }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) {
      return;
    }
    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.attachLine(line);
    }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) {
    return marker.inclusiveLeft ? -1 : 0;
  }
  function extraRight(marker) {
    return marker.inclusiveRight ? 1 : 0;
  }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) {
      return lenDiff;
    }
    var aPos = a.find(),
      bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) {
      return -fromCmp;
    }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) {
      return toCmp;
    }
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans,
      found;
    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAtSide(line, true);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAtSide(line, false);
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (!sp.marker.collapsed) {
          continue;
        }
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
          continue;
        }
        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
          return true;
        }
      }
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line)) {
      line = merged.find(-1, true).line;
    }
    return line;
  }
  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN),
      vis = visualLine(line);
    if (line == vis) {
      return lineN;
    }
    return lineNo(vis);
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) {
      return lineN;
    }
    var line = getLine(doc, lineN),
      merged;
    if (!lineIsHidden(doc, line)) {
      return lineN;
    }
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed) {
          continue;
        }
        if (sp.from == null) {
          return true;
        }
        if (sp.marker.widgetNode) {
          continue;
        }
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
          return true;
        }
      }
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length) {
      return true;
    }
    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
        return true;
      }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);
    var h = 0,
      chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) {
        break;
      } else {
        h += line.height;
      }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) {
          break;
        } else {
          h += cur.height;
        }
      }
    }
    return h;
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) {
      return 0;
    }
    var len = line.text.length,
      merged,
      cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display,
      doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) {
      return f(from, to, "ltr", 0);
    }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) {
      f(from, to, "ltr");
    }
  }
  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) {
        return i;
      }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }
    }
    return found != null ? found : bidiOther;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = function () {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) {
        return lowTypes.charAt(code);
      } else if (0x590 <= code && code <= 0x5f4) {
        return "R";
      } else if (0x600 <= code && code <= 0x6f9) {
        return arabicTypes.charAt(code - 0x600);
      } else if (0x6ee <= code && code <= 0x8ac) {
        return "r";
      } else if (0x2000 <= code && code <= 0x200b) {
        return "w";
      } else if (code == 0x200c) {
        return "b";
      } else {
        return "L";
      }
    }
    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/,
      isStrong = /[LRr]/,
      countsAsLeft = /[Lb1n]/,
      countsAsNum = /[1n]/;
    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from;
      this.to = to;
    }
    return function (str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";
      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
        return false;
      }
      var len = str.length,
        types = [];
      for (var i = 0; i < len; ++i) {
        types.push(charType(str.charCodeAt(i)));
      }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") {
          types[i$1] = prev;
        } else {
          prev = type;
        }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") {
          types[i$2] = "n";
        } else if (isStrong.test(type$1)) {
          cur = type$1;
          if (type$1 == "r") {
            types[i$2] = "R";
          }
        }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
          types[i$3] = "1";
        } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
          types[i$3] = prev$1;
        }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") {
          types[i$4] = "N";
        } else if (type$3 == "%") {
          var end = void 0;
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
          for (var j = i$4; j < end; ++j) {
            types[j] = replace;
          }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") {
          types[i$5] = "L";
        } else if (isStrong.test(type$4)) {
          cur$1 = type$4;
        }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = void 0;
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? before ? "L" : "R" : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) {
            types[j$1] = replace$1;
          }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [],
        m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7,
            at = order.length;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) {
                order.splice(at, 0, new BidiSpan(1, pos, j$2));
              }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else {
              ++j$2;
            }
          }
          if (pos < i$7) {
            order.splice(at, 0, new BidiSpan(1, pos, i$7));
          }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }
      return direction == "rtl" ? order.reverse() : order;
    };
  }();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) {
      order = line.order = bidiOrdering(line.text, direction);
    }
    return order;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];
  var on = function (emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };
  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers;
  }
  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers,
        arr = map$$1 && map$$1[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1) {
          map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1));
        }
      }
    }
  }
  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) {
      handlers[i].apply(null, args);
    }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string") {
      e = {
        type: e,
        preventDefault: function () {
          this.defaultPrevented = true;
        }
      };
    }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }
  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) {
      return;
    }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) {
      if (indexOf(set, arr[i]) == -1) {
        set.push(arr[i]);
      }
    }
  }
  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function (type, f) {
      on(this, type, f);
    };
    ctor.prototype.off = function (type, f) {
      off(this, type, f);
    };
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) {
        b = 1;
      } else if (e.button & 2) {
        b = 3;
      } else if (e.button & 4) {
        b = 2;
      }
    }
    if (mac && e.ctrlKey && b == 1) {
      b = 3;
    }
    return b;
  }

  // Detect drag-and-drop
  var dragAndDrop = function () {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) {
      return false;
    }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0) {
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
      }
    }
    var node = zwspSupported ? elt("span", "\u200b") : elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) {
      return badBidiRects;
    }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) {
      return false;
    } // Safari returns null in some cases (#2780)
    return badBidiRects = r1.right - r0.right < 3;
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0,
      result = [],
      l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) {
        nl = string.length;
      }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function (string) {
    return string.split(/\r\n?|\n/);
  };
  var hasSelection = window.getSelection ? function (te) {
    try {
      return te.selectionStart != te.selectionEnd;
    } catch (e) {
      return false;
    }
  } : function (te) {
    var range$$1;
    try {
      range$$1 = te.ownerDocument.selection.createRange();
    } catch (e) {}
    if (!range$$1 || range$$1.parentElement() != te) {
      return false;
    }
    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0;
  };
  var hasCopyEvent = function () {
    var e = elt("div");
    if ("oncopy" in e) {
      return true;
    }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  }();
  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) {
      return badZoomedRects;
    }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // Known modes, by name and by MIME
  var modes = {};
  var mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2) {
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    }
    modes[name] = mode;
  }
  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") {
        found = {
          name: found
        };
      }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml");
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json");
    }
    if (typeof spec == "string") {
      return {
        name: spec
      };
    } else {
      return spec || {
        name: "null"
      };
    }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) {
      return getMode(options, "text/plain");
    }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) {
          continue;
        }
        if (modeObj.hasOwnProperty(prop)) {
          modeObj["_" + prop] = modeObj[prop];
        }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) {
      modeObj.helperType = spec.helperType;
    }
    if (spec.modeProps) {
      for (var prop$1 in spec.modeProps) {
        modeObj[prop$1] = spec.modeProps[prop$1];
      }
    }
    return modeObj;
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  }
  function copyState(mode, state) {
    if (state === true) {
      return state;
    }
    if (mode.copyState) {
      return mode.copyState(state);
    }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) {
        val = val.concat([]);
      }
      nstate[n] = val;
    }
    return nstate;
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) {
        break;
      }
      state = info.state;
      mode = info.mode;
    }
    return info || {
      mode: mode,
      state: state
    };
  }
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function (string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };
  StringStream.prototype.eol = function () {
    return this.pos >= this.string.length;
  };
  StringStream.prototype.sol = function () {
    return this.pos == this.lineStart;
  };
  StringStream.prototype.peek = function () {
    return this.string.charAt(this.pos) || undefined;
  };
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length) {
      return this.string.charAt(this.pos++);
    }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") {
      ok = ch == match;
    } else {
      ok = ch && (match.test ? match.test(ch) : match(ch));
    }
    if (ok) {
      ++this.pos;
      return ch;
    }
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)) {}
    return this.pos > start;
  };
  StringStream.prototype.eatSpace = function () {
    var this$1 = this;
    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
      ++this$1.pos;
    }
    return this.pos > start;
  };
  StringStream.prototype.skipToEnd = function () {
    this.pos = this.string.length;
  };
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {
      this.pos = found;
      return true;
    }
  };
  StringStream.prototype.backUp = function (n) {
    this.pos -= n;
  };
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) {
        return caseInsensitive ? str.toLowerCase() : str;
      };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) {
          this.pos += pattern.length;
        }
        return true;
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) {
        return null;
      }
      if (match && consume !== false) {
        this.pos += match[0].length;
      }
      return match;
    }
  };
  StringStream.prototype.current = function () {
    return this.string.slice(this.start, this.pos);
  };
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try {
      return inner();
    } finally {
      this.lineStart -= n;
    }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n);
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos);
  };
  var SavedContext = function (state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };
  var Context = function (doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };
  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) {
      this.maxLookAhead = n;
    }
    return line;
  };
  Context.prototype.baseToken = function (n) {
    var this$1 = this;
    if (!this.baseTokens) {
      return null;
    }
    while (this.baseTokens[this.baseTokenPos] <= n) {
      this$1.baseTokenPos += 2;
    }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: type && type.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - n
    };
  };
  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) {
      this.maxLookAhead--;
    }
  };
  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext) {
      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
    } else {
      return new Context(doc, copyState(doc.mode, saved), line);
    }
  };
  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
  };

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen],
      lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) {
      return st.push(end, style);
    }, lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function (o) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o],
        i = 1,
        at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end) {
            st.splice(i, 1, end, st[i + 1], i_end);
          }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) {
          return;
        }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };
    for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);
    return {
      styles: st,
      classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
    };
  }
  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) {
        context.state = resetState;
      }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) {
        line.styleClasses = result.classes;
      } else if (line.styleClasses) {
        line.styleClasses = null;
      }
      if (updateFrontier === cm.doc.highlightFrontier) {
        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
      }
    }
    return line.styles;
  }
  function getContextBefore(cm, n, precise) {
    var doc = cm.doc,
      display = cm.display;
    if (!doc.mode.startState) {
      return new Context(doc, true, n);
    }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) {
      doc.modeFrontier = context.line;
    }
    return context;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") {
      callBlankLine(mode, context.state);
    }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }
  function callBlankLine(mode, state) {
    if (mode.blankLine) {
      return mode.blankLine(state);
    }
    if (!mode.innerMode) {
      return;
    }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) {
      return inner.mode.blankLine(inner.state);
    }
  }
  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) {
        inner[0] = innerMode(mode, state).mode;
      }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) {
        return style;
      }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }
  var Token = function (stream, type, state) {
    this.start = stream.start;
    this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc,
      mode = doc.mode,
      style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line),
      context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context),
      tokens;
    if (asArray) {
      tokens = [];
    }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) {
        tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
      }
    }
    return asArray ? tokens : new Token(stream, style, context.state);
  }
  function extractLineClasses(type, output) {
    if (type) {
      for (;;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
        if (!lineClass) {
          break;
        }
        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? "bgClass" : "textClass";
        if (output[prop] == null) {
          output[prop] = lineClass[2];
        } else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(output[prop])) {
          output[prop] += " " + lineClass[2];
        }
      }
    }
    return type;
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) {
      flattenSpans = cm.options.flattenSpans;
    }
    var curStart = 0,
      curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context),
      style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") {
      extractLineClasses(callBlankLine(mode, context.state), lineClasses);
    }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) {
          processLine(cm, text, context, stream.pos);
        }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) {
          style = "m-" + (style ? mName + " " + style : mName);
        }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent,
      minline,
      doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) {
        return doc.first;
      }
      var line = getLine(doc, search - 1),
        after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
        return search;
      }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) {
      return;
    }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break;
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function (text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  Line.prototype.lineNo = function () {
    return lineNo(this);
  };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    if (line.styles) {
      line.styles = null;
    }
    if (line.order != null) {
      line.order = null;
    }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) {
      updateLineHeight(line, estHeight);
    }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {};
  var styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) {
      return null;
    }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {
      pre: eltP("pre", [content], "CodeMirror-line"),
      content: content,
      col: 0,
      pos: 0,
      cm: cm,
      trailingSpace: false,
      splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
    };
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line,
        order = void 0;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass) {
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        }
        if (line.styleClasses.textClass) {
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
        }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0) {
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
      }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
        builder.content.className = "cm-tab-wrap-hack";
      }
    }
    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className) {
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
    }
    return builder;
  }
  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) {
      return;
    }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars,
      mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) {
        mustWrap = true;
      }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt]));
          } else {
            content.appendChild(txt);
          }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) {
          break;
        }
        pos += skipped + 1;
        var txt$1 = void 0;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize,
            tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt$1]));
          } else {
            content.appendChild(txt$1);
          }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) {
        fullStyle += startStyle;
      }
      if (endStyle) {
        fullStyle += endStyle;
      }
      var token = elt("span", [content], fullStyle, css);
      if (title) {
        token.title = title;
      }
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) {
      return text;
    }
    var spaceBefore = trailingBefore,
      result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
        ch = "\u00a0";
      }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos,
        end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = void 0;
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) {
            break;
          }
        }
        if (part.to >= end) {
          return inner(builder, text, style, startStyle, endStyle, title, css);
        }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }
  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
    }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget) {
        widget = builder.content.appendChild(document.createElement("span"));
      }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans,
      allText = line.text,
      at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
        builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
      }
      return;
    }
    var len = allText.length,
      pos = 0,
      i = 1,
      text = "",
      style,
      css;
    var nextChange = 0,
      spanStyle,
      spanEndStyle,
      spanStartStyle,
      title,
      collapsed;
    for (;;) {
      if (nextChange == pos) {
        // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null;
        nextChange = Infinity;
        var foundBookmarks = [],
          endStyles = void 0;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j],
            m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) {
              spanStyle += " " + m.className;
            }
            if (m.css) {
              css = (css ? css + ";" : "") + m.css;
            }
            if (m.startStyle && sp.from == pos) {
              spanStartStyle += " " + m.startStyle;
            }
            if (m.endStyle && sp.to == nextChange) {
              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
            }
            if (m.title && !title) {
              title = m.title;
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
              collapsed = sp;
            }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) {
          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
            if (endStyles[j$1 + 1] == nextChange) {
              spanEndStyle += " " + endStyles[j$1];
            }
          }
        }
        if (!collapsed || collapsed.from == pos) {
          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
            buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
          }
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) {
            return;
          }
          if (collapsed.to == pos) {
            collapsed = false;
          }
        }
      }
      if (pos >= len) {
        break;
      }
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [],
      nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }
  var operationGroup = null;
  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }
  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks,
      i = 0;
    do {
      for (; i < callbacks.length; i++) {
        callbacks[i].call(null);
      }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers) {
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        }
      }
    } while (i < callbacks.length);
  }
  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) {
      return;
    }
    try {
      fireCallbacksForOps(group);
    } finally {
      operationGroup = null;
      endCb(group);
    }
  }
  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2),
      list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function (i) {
      list.push(function () {
        return arr[i].apply(null, args);
      });
    };
    for (var i = 0; i < arr.length; ++i) loop(i);
  }
  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) {
      delayed[i]();
    }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") {
        updateLineText(cm, lineView);
      } else if (type == "gutter") {
        updateLineGutter(cm, lineView, lineN, dims);
      } else if (type == "class") {
        updateLineClasses(cm, lineView);
      } else if (type == "widget") {
        updateLineWidgets(cm, lineView, dims);
      }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode) {
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) {
        lineView.node.style.zIndex = 2;
      }
    }
    return lineView.node;
  }
  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) {
      cls += " CodeMirror-linebackground";
    }
    if (lineView.background) {
      if (cls) {
        lineView.background.className = cls;
      } else {
        lineView.background.parentNode.removeChild(lineView.background);
        lineView.background = null;
      }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) {
      lineView.node = built.pre;
    }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }
  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass) {
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    } else if (lineView.node != lineView.text) {
      lineView.node.className = "";
    }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }
  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass) {
        gutterWrap.className += " " + lineView.line.gutterClass;
      }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
        lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
      }
      if (markers) {
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k],
            found = markers.hasOwnProperty(id) && markers[id];
          if (found) {
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
          }
        }
      }
    }
  }
  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) {
      lineView.alignable = null;
    }
    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
      next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget") {
        lineView.node.removeChild(node);
      }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) {
      lineView.bgClass = built.bgClass;
    }
    if (built.textClass) {
      lineView.textClass = built.textClass;
    }
    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++) {
        insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
      }
    }
  }
  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) {
      return;
    }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i],
        node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) {
        node.setAttribute("cm-ignore-events", "true");
      }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above) {
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      } else {
        wrap.appendChild(node);
      }
      signalLater(widget, "redraw");
    }
  }
  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) {
        node.style.marginLeft = -dims.gutterTotalWidth + "px";
      }
    }
  }
  function widgetHeight(widget) {
    if (widget.height != null) {
      return widget.height;
    }
    var cm = widget.doc.cm;
    if (!cm) {
      return 0;
    }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter) {
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      }
      if (widget.noHScroll) {
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
        return true;
      }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingH(display) {
    if (display.cachedPaddingH) {
      return display.cachedPaddingH;
    }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {
      left: parseInt(style.paddingLeft),
      right: parseInt(style.paddingRight)
    };
    if (!isNaN(data.left) && !isNaN(data.right)) {
      display.cachedPaddingH = data;
    }
    return data;
  }
  function scrollGap(cm) {
    return scrollerGap - cm.display.nativeBarWidth;
  }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i],
            next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2) {
            heights.push((cur.bottom + next.top) / 2 - rect.top);
          }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line) {
      return {
        map: lineView.measure.map,
        cache: lineView.measure.cache
      };
    }
    for (var i = 0; i < lineView.rest.length; i++) {
      if (lineView.rest[i] == line) {
        return {
          map: lineView.measure.maps[i],
          cache: lineView.measure.caches[i]
        };
      }
    }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
      if (lineNo(lineView.rest[i$1]) > lineN) {
        return {
          map: lineView.measure.maps[i$1],
          cache: lineView.measure.caches[i$1],
          before: true
        };
      }
    }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
      return cm.display.view[findViewIndex(cm, lineN)];
    }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
      return ext;
    }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view) {
      view = updateExternalMeasurement(cm, line);
    }
    var info = mapFromLineView(view, line, lineN);
    return {
      line: line,
      view: view,
      rect: null,
      map: info.map,
      cache: info.cache,
      before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) {
      ch = -1;
    }
    var key = ch + (bias || ""),
      found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect) {
        prepared.rect = prepared.view.text.getBoundingClientRect();
      }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) {
        prepared.cache[key] = found;
      }
    }
    return {
      left: found.left,
      right: found.right,
      top: varHeight ? found.rtop : found.top,
      bottom: varHeight ? found.rbottom : found.bottom
    };
  }
  var nullRect = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];
      if (ch < mStart) {
        start = 0;
        end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) {
          collapse = "right";
        }
      }
      if (start != null) {
        node = map$$1[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
          collapse = bias;
        }
        if (bias == "left" && start == 0) {
          while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          }
        }
        if (bias == "right" && start == mEnd - mStart) {
          while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          }
        }
        break;
      }
    }
    return {
      node: node,
      start: start,
      end: end,
      collapse: collapse,
      coverStart: mStart,
      coverEnd: mEnd
    };
  }
  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") {
      for (var i = 0; i < rects.length; i++) {
        if ((rect = rects[i]).left != rect.right) {
          break;
        }
      }
    } else {
      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
        if ((rect = rects[i$1]).left != rect.right) {
          break;
        }
      }
    }
    return rect;
  }
  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node,
      start = place.start,
      end = place.end,
      collapse = place.collapse;
    var rect;
    if (node.nodeType == 3) {
      // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) {
        // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
          --start;
        }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
          ++end;
        }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else {
          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
        }
        if (rect.left || rect.right || start == 0) {
          break;
        }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) {
        rect = maybeUpdateRectForZooming(cm.display.measure, rect);
      }
    } else {
      // If it is a widget, simply get the box for the whole widget.
      if (start > 0) {
        collapse = bias = "right";
      }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      } else {
        rect = node.getBoundingClientRect();
      }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan) {
        rect = {
          left: rSpan.left,
          right: rSpan.left + charWidth(cm.display),
          top: rSpan.top,
          bottom: rSpan.bottom
        };
      } else {
        rect = nullRect;
      }
    }
    var rtop = rect.top - prepared.rect.top,
      rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++) {
      if (mid < heights[i]) {
        break;
      }
    }
    var top = i ? heights[i - 1] : 0,
      bot = heights[i];
    var result = {
      left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
      top: top,
      bottom: bot
    };
    if (!rect.left && !rect.right) {
      result.bogus = true;
    }
    if (!cm.options.singleCursorHeightPerLine) {
      result.rtop = rtop;
      result.rbottom = rbot;
    }
    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
      return rect;
    }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {
      left: rect.left * scaleX,
      right: rect.right * scaleX,
      top: rect.top * scaleY,
      bottom: rect.bottom * scaleY
    };
  }
  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) {
        for (var i = 0; i < lineView.rest.length; i++) {
          lineView.measure.caches[i] = {};
        }
      }
    }
  }
  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++) {
      clearLineMeasurementCacheFor(cm.display.view[i]);
    }
  }
  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) {
      cm.display.maxLineChanged = true;
    }
    cm.display.lineNumChars = null;
  }
  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
    }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
  }
  function pageScrollY() {
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
    }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop;
  }
  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) {
      for (var i = 0; i < lineObj.widgets.length; ++i) {
        if (lineObj.widgets[i].above) {
          height += widgetHeight(lineObj.widgets[i]);
        }
      }
    }
    return height;
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height;
      rect.bottom += height;
    }
    if (context == "line") {
      return rect;
    }
    if (!context) {
      context = "local";
    }
    var yOff = heightAtLine(lineObj);
    if (context == "local") {
      yOff += paddingTop(cm.display);
    } else {
      yOff -= cm.display.viewOffset;
    }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") {
      return coords;
    }
    var left = coords.left,
      top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }
    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {
      left: left - lineSpaceBox.left,
      top: top - lineSpaceBox.top
    };
  }
  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) {
      lineObj = getLine(cm.doc, pos.line);
    }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) {
        m.left = m.right;
      } else {
        m.right = m.left;
      }
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj, cm.doc.direction),
      ch = pos.ch,
      sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) {
      return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
    }
    function getBidi(ch, partPos, invert) {
      var part = order[partPos],
        right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert);
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) {
      val.other = getBidi(ch, other, sticky != "before");
    }
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) {
      left = charWidth(cm.display) * pos.ch;
    }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {
      left: left,
      right: left,
      top: top,
      bottom: top + lineObj.height
    };
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) {
      pos.outside = true;
    }
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) {
      return PosWithInfo(doc.first, 0, null, true, -1);
    }
    var lineN = lineAtHeight(doc, y),
      last = doc.first + doc.size - 1;
    if (lineN > last) {
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1);
    }
    if (x < 0) {
      x = 0;
    }
    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) {
        lineN = lineNo(lineObj = mergedPos.to.line);
      } else {
        return found;
      }
    }
  }
  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
    }, end, 0);
    end = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch).top > y;
    }, begin, end);
    return {
      begin: begin,
      end: end
    };
  }
  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
  }
  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight$$1 = widgetTopHeight(lineObj);
    var begin = 0,
      end = lineObj.text.length,
      ltr = true;
    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null,
      boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight$$1;
      box.bottom += widgetHeight$$1;
      if (!boxIsAfter(box, x, y, false)) {
        return false;
      }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true;
    }, begin, end);
    var baseX,
      sticky,
      outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x,
        atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) {
        ch++;
      }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y == ltr ? "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top || y >= coords.bottom;
    }
    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX);
  }
  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i],
        ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y) {
        part = order[index - 1];
      }
    }
    return part;
  }
  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) {
      end--;
    }
    var part = null,
      closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) {
        continue;
      }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) {
      part = order[order.length - 1];
    }
    // Clip the part to the wrapped line.
    if (part.from < begin) {
      part = {
        from: begin,
        to: part.to,
        level: part.level
      };
    }
    if (part.to > end) {
      part = {
        from: part.from,
        to: end,
        level: part.level
      };
    }
    return part;
  }
  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) {
      return display.cachedTextHeight;
    }
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) {
      display.cachedTextHeight = height;
    }
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) {
      return display.cachedCharWidth;
    }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(),
      width = (rect.right - rect.left) / 10;
    if (width > 2) {
      display.cachedCharWidth = width;
    }
    return width || 10;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display,
      left = {},
      width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display),
      wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) {
        return 0;
      }
      var widgetsHeight = 0;
      if (line.widgets) {
        for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height) {
            widgetsHeight += line.widgets[i].height;
          }
        }
      }
      if (wrapping) {
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      } else {
        return widgetsHeight + th;
      }
    };
  }
  function estimateLineHeights(cm) {
    var doc = cm.doc,
      est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
      return null;
    }
    var x,
      y,
      space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try {
      x = e.clientX - space.left;
      y = e.clientY - space.top;
    } catch (e) {
      return null;
    }
    var coords = coordsChar(cm, x, y),
      line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) {
      return null;
    }
    n -= cm.display.viewFrom;
    if (n < 0) {
      return null;
    }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) {
        return i;
      }
    }
  }
  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }
  function prepareSelection(cm, primary) {
    if (primary === void 0) primary = true;
    var doc = cm.doc,
      result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) {
        continue;
      }
      var range$$1 = doc.sel.ranges[i];
      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) {
        continue;
      }
      var collapsed = range$$1.empty();
      if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range$$1.head, curFragment);
      }
      if (!collapsed) {
        drawSelectionRange(cm, range$$1, selFragment);
      }
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }
  function cmpCoords(a, b) {
    return a.top - b.top || a.left - b.left;
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display,
      doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display),
      leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";
    function add(left, top, width, bottom) {
      if (top < 0) {
        top = 0;
      }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
    }
    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }
      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = dir == "ltr" == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop];
      }
      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");
        var openStart = fromArg == null && from == 0,
          openEnd = toArg == null && to == lineLen;
        var first = i == 0,
          last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) {
          // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else {
          // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) {
            add(leftSide, fromPos.bottom, null, toPos.top);
          }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }
        if (!start || cmpCoords(fromPos, start) < 0) {
          start = fromPos;
        }
        if (cmpCoords(toPos, start) < 0) {
          start = toPos;
        }
        if (!end || cmpCoords(fromPos, end) < 0) {
          end = fromPos;
        }
        if (cmpCoords(toPos, end) < 0) {
          end = toPos;
        }
      });
      return {
        start: start,
        end: end
      };
    }
    var sFrom = range$$1.from(),
      sTo = range$$1.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line),
        toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top) {
        add(leftSide, leftEnd.bottom, null, rightStart.top);
      }
    }
    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) {
      return;
    }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0) {
      display.blinker = setInterval(function () {
        return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    } else if (cm.options.cursorBlinkRate < 0) {
      display.cursorDiv.style.visibility = "hidden";
    }
  }
  function ensureFocus(cm) {
    if (!cm.state.focused) {
      cm.display.input.focus();
      onFocus(cm);
    }
  }
  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }
  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
    }
    if (cm.options.readOnly == "nocursor") {
      return;
    }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) {
          setTimeout(function () {
            return cm.display.input.reset(true);
          }, 20);
        } // Issue #1730
      }

      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) {
      return;
    }
    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused) {
        cm.display.shift = false;
      }
    }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i],
        height = void 0;
      if (cur.hidden) {
        continue;
      }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) {
        height = textHeight(display);
      }
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) {
          for (var j = 0; j < cur.rest.length; j++) {
            updateWidgetHeight(cur.rest[j]);
          }
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) {
      for (var i = 0; i < line.widgets.length; ++i) {
        var w = line.widgets[i],
          parent = w.node.parentNode;
        if (parent) {
          w.height = parent.offsetHeight;
        }
      }
    }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
    var from = lineAtHeight(doc, top),
      to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line,
        ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {
      from: from,
      to: Math.max(to, from + 1)
    };
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display,
      view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
      return;
    }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth,
      left = comp + "px";
    for (var i = 0; i < view.length; i++) {
      if (!view[i].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i].gutter) {
            view[i].gutter.style.left = left;
          }
          if (view[i].gutterBackground) {
            view[i].gutterBackground.style.left = left;
          }
        }
        var align = view[i].alignable;
        if (align) {
          for (var j = 0; j < align.length; j++) {
            align[j].style.left = left;
          }
        }
      }
    }
    if (cm.options.fixedGutter) {
      display.gutters.style.left = comp + gutterW + "px";
    }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) {
      return false;
    }
    var doc = cm.doc,
      last = lineNumberFor(cm.options, doc.first + doc.size - 1),
      display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth,
        padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) {
      return;
    }
    var display = cm.display,
      box = display.sizer.getBoundingClientRect(),
      doScroll = null;
    if (rect.top + box.top < 0) {
      doScroll = true;
    } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
      doScroll = false;
    }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) {
      margin = 0;
    }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {
        left: Math.min(coords.left, endCoords.left),
        top: Math.min(coords.top, endCoords.top) - margin,
        right: Math.max(coords.left, endCoords.left),
        bottom: Math.max(coords.bottom, endCoords.bottom) + margin
      };
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop,
        startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
          changed = true;
        }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
          changed = true;
        }
      }
      if (!changed) {
        break;
      }
    }
    return rect;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
    }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display,
      snapMargin = textHeight(cm.display);
    if (rect.top < 0) {
      rect.top = 0;
    }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm),
      result = {};
    if (rect.bottom - rect.top > screen) {
      rect.bottom = rect.top + screen;
    }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin,
      atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) {
        result.scrollTop = newTop;
      }
    }
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) {
      rect.right = rect.left + screenw;
    }
    if (rect.left < 10) {
      result.scrollLeft = 0;
    } else if (rect.left < screenleft) {
      result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10));
    } else if (rect.right > screenw + screenleft - 3) {
      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
    }
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) {
      return;
    }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {
      from: cur,
      to: cur,
      margin: cm.options.cursorScrollMargin
    };
  }
  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) {
      resolveScrollToPos(cm);
    }
    if (x != null) {
      cm.curOp.scrollLeft = x;
    }
    if (y != null) {
      cm.curOp.scrollTop = y;
    }
  }
  function scrollToRange(cm, range$$1) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range$$1;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;
    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from),
        to = estimateCoords(cm, range$$1.to);
      scrollToCoordsRange(cm, from, to, range$$1.margin);
    }
  }
  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) {
      return;
    }
    if (!gecko) {
      updateDisplaySimple(cm, {
        top: val
      });
    }
    setScrollTop(cm, val, true);
    if (gecko) {
      updateDisplaySimple(cm);
    }
    startWorker(cm, 100);
  }
  function setScrollTop(cm, val, forceScroll) {
    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
    if (cm.display.scroller.scrollTop == val && !forceScroll) {
      return;
    }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) {
      cm.display.scroller.scrollTop = val;
    }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
      return;
    }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) {
      cm.display.scroller.scrollLeft = val;
    }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display,
      gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth,
      clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }
  var NativeScrollbars = function (place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert);
    place(horiz);
    on(vert, "scroll", function () {
      if (vert.clientHeight) {
        scroll(vert.scrollTop, "vertical");
      }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) {
        scroll(horiz.scrollLeft, "horizontal");
      }
    });
    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) {
      this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
    }
  };
  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;
    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }
    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }
    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) {
        this.zeroWidthHack();
      }
      this.checkedZeroWidth = true;
    }
    return {
      right: needsV ? sWidth : 0,
      bottom: needsH ? sWidth : 0
    };
  };
  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) {
      this.horiz.scrollLeft = pos;
    }
    if (this.disableHoriz) {
      this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
    }
  };
  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) {
      this.vert.scrollTop = pos;
    }
    if (this.disableVert) {
      this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
    }
  };
  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed();
    this.disableVert = new Delayed();
  };
  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt$$1 != bar) {
        bar.style.pointerEvents = "none";
      } else {
        delay.set(1000, maybeDisable);
      }
    }
    delay.set(1000, maybeDisable);
  };
  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };
  var NullScrollbars = function () {};
  NullScrollbars.prototype.update = function () {
    return {
      bottom: 0,
      right: 0
    };
  };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};
  function updateScrollbars(cm, measure) {
    if (!measure) {
      measure = measureForScrollbars(cm);
    }
    var startWidth = cm.display.barWidth,
      startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
        updateHeightsInViewport(cm);
      }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth;
      startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);
    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else {
      d.scrollbarFiller.style.display = "";
    }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else {
      d.gutterFiller.style.display = "";
    }
  }
  var scrollbarModel = {
    "native": NativeScrollbars,
    "null": NullScrollbars
  };
  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass) {
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }
    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) {
          setTimeout(function () {
            return cm.display.input.focus();
          }, 0);
        }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") {
        setScrollLeft(cm, pos);
      } else {
        updateScrollTop(cm, pos);
      }
    }, cm);
    if (cm.display.scrollbars.addClass) {
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,
      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height,
      // Used to detect need to update scrollbar
      forceUpdate: false,
      // Used to force a redraw
      updateInput: null,
      // Whether to reset the input textarea
      typing: false,
      // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,
      // Accumulated changes, for firing change events
      cursorActivityHandlers: null,
      // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0,
      // Tracks which cursorActivity handlers have been called already
      selectionChanged: false,
      // Whether the selection needs to be redrawn
      updateMaxLine: false,
      // Set when the widest line needs to be determined anew
      scrollLeft: null,
      scrollTop: null,
      // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,
      // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId // Unique ID
    };

    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++) {
        group.ops[i].cm.curOp = null;
      }
      endOperations(group);
    });
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++)
    // Read DOM
    {
      endOperation_R1(ops[i]);
    }
    for (var i$1 = 0; i$1 < ops.length; i$1++)
    // Write DOM (maybe)
    {
      endOperation_W1(ops[i$1]);
    }
    for (var i$2 = 0; i$2 < ops.length; i$2++)
    // Read DOM
    {
      endOperation_R2(ops[i$2]);
    }
    for (var i$3 = 0; i$3 < ops.length; i$3++)
    // Write DOM (maybe)
    {
      endOperation_W2(ops[i$3]);
    }
    for (var i$4 = 0; i$4 < ops.length; i$4++)
    // Read DOM
    {
      endOperation_finish(ops[i$4]);
    }
  }
  function endOperation_R1(op) {
    var cm = op.cm,
      display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) {
      findMaxLine(cm);
    }
    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
      top: op.scrollTop,
      ensure: op.scrollToPos
    }, op.forceUpdate);
  }
  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }
  function endOperation_R2(op) {
    var cm = op.cm,
      display = cm.display;
    if (op.updatedDisplay) {
      updateHeightsInViewport(cm);
    }
    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }
    if (op.updatedDisplay || op.selectionChanged) {
      op.preparedSelection = display.input.prepareSelection();
    }
  }
  function endOperation_W2(op) {
    var cm = op.cm;
    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft) {
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      }
      cm.display.maxLineChanged = false;
    }
    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection) {
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    }
    if (op.updatedDisplay || op.startHeight != cm.doc.height) {
      updateScrollbars(cm, op.barMeasure);
    }
    if (op.updatedDisplay) {
      setDocumentHeight(cm, op.barMeasure);
    }
    if (op.selectionChanged) {
      restartBlink(cm);
    }
    if (cm.state.focused && op.updateInput) {
      cm.display.input.reset(op.typing);
    }
    if (takeFocus) {
      ensureFocus(op.cm);
    }
  }
  function endOperation_finish(op) {
    var cm = op.cm,
      display = cm.display,
      doc = cm.doc;
    if (op.updatedDisplay) {
      postUpdateDisplay(cm, op.update);
    }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
      display.wheelStartX = display.wheelStartY = null;
    }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) {
      setScrollTop(cm, op.scrollTop, op.forceScroll);
    }
    if (op.scrollLeft != null) {
      setScrollLeft(cm, op.scrollLeft, true, true);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers,
      unhidden = op.maybeUnhiddenMarkers;
    if (hidden) {
      for (var i = 0; i < hidden.length; ++i) {
        if (!hidden[i].lines.length) {
          signal(hidden[i], "hide");
        }
      }
    }
    if (unhidden) {
      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
        if (unhidden[i$1].lines.length) {
          signal(unhidden[i$1], "unhide");
        }
      }
    }
    if (display.wrapper.offsetHeight) {
      doc.scrollTop = cm.display.scroller.scrollTop;
    }

    // Fire change events, and delayed event handlers
    if (op.changeObjs) {
      signal(cm, "changes", cm, op.changeObjs);
    }
    if (op.update) {
      op.update.finish();
    }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) {
      return f();
    }
    startOperation(cm);
    try {
      return f();
    } finally {
      endOperation(cm);
    }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function () {
      if (cm.curOp) {
        return f.apply(cm, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(cm, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function () {
      if (this.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(this);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(this);
      }
    };
  }
  function docMethodOp(f) {
    return function () {
      var cm = this.cm;
      if (!cm || cm.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) {
      from = cm.doc.first;
    }
    if (to == null) {
      to = cm.doc.first + cm.doc.size;
    }
    if (!lendiff) {
      lendiff = 0;
    }
    var display = cm.display;
    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
      display.updateLineNumbers = from;
    }
    cm.curOp.viewChanged = true;
    if (from >= display.viewTo) {
      // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
        resetView(cm);
      }
    } else if (to <= display.viewFrom) {
      // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) {
      // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) {
      // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) {
      // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else {
      // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }
    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN) {
        ext.lineN += lendiff;
      } else if (from < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display,
      ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
      display.externalMeasured = null;
    }
    if (line < display.viewFrom || line >= display.viewTo) {
      return;
    }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) {
      return;
    }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) {
      arr.push(type);
    }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }
  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN),
      diff,
      view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
      return {
        index: index,
        lineN: newN
      };
    }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++) {
      n += view[i].size;
    }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) {
          return null;
        }
        diff = n + view[index].size - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff;
      newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) {
        return null;
      }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {
      index: index,
      lineN: newN
    };
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display,
      view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from) {
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      } else if (display.viewFrom < from) {
        display.view = display.view.slice(findViewIndex(cm, from));
      }
      display.viewFrom = from;
      if (display.viewTo < to) {
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      } else if (display.viewTo > to) {
        display.view = display.view.slice(0, findViewIndex(cm, to));
      }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view,
      dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) {
        ++dirty;
      }
    }
    return dirty;
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo) {
      cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
  }
  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) {
      return;
    }
    var end = +new Date() + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];
    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) {
        // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) {
          context.state = resetState;
        }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses,
          newCls = highlighted.classes;
        if (newCls) {
          line.styleClasses = newCls;
        } else if (oldCls) {
          line.styleClasses = null;
        }
        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) {
          ischange = oldStyles[i] != line.styles[i];
        }
        if (ischange) {
          changedLines.push(context.line);
        }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength) {
          processLine(cm, line.text, context);
        }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) {
      runInOp(cm, function () {
        for (var i = 0; i < changedLines.length; i++) {
          regLineChange(cm, changedLines[i], "text");
        }
      });
    }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function (cm, viewport, force) {
    var display = cm.display;
    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };
  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type)) {
      this.events.push(arguments);
    }
  };
  DisplayUpdate.prototype.finish = function () {
    var this$1 = this;
    for (var i = 0; i < this.events.length; i++) {
      signal.apply(null, this$1.events[i]);
    }
  };
  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }
  function selectionSnapshot(cm) {
    if (cm.hasFocus()) {
      return null;
    }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) {
      return null;
    }
    var result = {
      activeElt: active
    };
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result;
  }
  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
      return;
    }
    snapshot.activeElt.focus();
    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(),
        range$$1 = document.createRange();
      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range$$1.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range$$1);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display,
      doc = cm.doc;
    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
      return false;
    }
    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) {
      from = Math.max(doc.first, display.viewFrom);
    }
    if (display.viewTo > to && display.viewTo - to < 20) {
      to = Math.min(end, display.viewTo);
    }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }
    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);
    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";
    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
      return false;
    }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "none";
    }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "";
    }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;
    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }
    display.updateLineNumbers = null;
    return true;
  }
  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;
    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null) {
          viewport = {
            top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
          };
        }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
          break;
        }
      }
      if (!updateDisplayIfNeeded(cm, update)) {
        break;
      }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }
    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom;
      cm.display.reportedViewTo = cm.display.viewTo;
    }
  }
  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display,
      lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv,
      cur = container.firstChild;
    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }
    var view = display.view,
      lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {} else if (!lineView.node || lineView.node.parentNode != container) {
        // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else {
        // Already drawn
        while (cur != lineView.node) {
          cur = rm(cur);
        }
        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) {
            updateNumber = false;
          }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) {
      cur = rm(cur);
    }
  }
  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }
  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters,
      specs = cm.options.gutters;
    removeChildren(gutters);
    var i = 0;
    for (; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0;
  var wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) {
    wheelPixelsPerUnit = -.53;
  } else if (gecko) {
    wheelPixelsPerUnit = 15;
  } else if (chrome) {
    wheelPixelsPerUnit = -.7;
  } else if (safari) {
    wheelPixelsPerUnit = -1 / 3;
  }
  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX,
      dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
      dx = e.detail;
    }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
      dy = e.detail;
    } else if (dy == null) {
      dy = e.wheelDelta;
    }
    return {
      x: dx,
      y: dy
    };
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  }
  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e),
      dx = delta.x,
      dy = delta.y;
    var display = cm.display,
      scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) {
      return;
    }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY) {
        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
      }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || dy && canScrollY) {
        e_preventDefault(e);
      }
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop,
        bot = top + display.wrapper.clientHeight;
      if (pixels < 0) {
        top = Math.max(0, top + pixels - 50);
      } else {
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      }
      updateDisplaySimple(cm, {
        top: top,
        bottom: bot
      });
    }
    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) {
            return;
          }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) {
            return;
          }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function (ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };
  Selection.prototype.primary = function () {
    return this.ranges[this.primIndex];
  };
  Selection.prototype.equals = function (other) {
    var this$1 = this;
    if (other == this) {
      return true;
    }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
      return false;
    }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this$1.ranges[i],
        there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
        return false;
      }
    }
    return true;
  };
  Selection.prototype.deepCopy = function () {
    var this$1 = this;
    var out = [];
    for (var i = 0; i < this.ranges.length; i++) {
      out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
    }
    return new Selection(out, this.primIndex);
  };
  Selection.prototype.somethingSelected = function () {
    var this$1 = this;
    for (var i = 0; i < this.ranges.length; i++) {
      if (!this$1.ranges[i].empty()) {
        return true;
      }
    }
    return false;
  };
  Selection.prototype.contains = function (pos, end) {
    var this$1 = this;
    if (!end) {
      end = pos;
    }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this$1.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
        return i;
      }
    }
    return -1;
  };
  var Range = function (anchor, head) {
    this.anchor = anchor;
    this.head = head;
  };
  Range.prototype.from = function () {
    return minPos(this.anchor, this.head);
  };
  Range.prototype.to = function () {
    return maxPos(this.anchor, this.head);
  };
  Range.prototype.empty = function () {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) {
      return cmp(a.from(), b.from());
    });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i],
        prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()),
          to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) {
          --primIndex;
        }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }
  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) {
      return change.to;
    }
    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) {
      return pos;
    }
    if (cmp(pos, change.to) <= 0) {
      return changeEnd(change);
    }
    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
      ch = pos.ch;
    if (pos.line == change.to.line) {
      ch += changeEnd(change).ch - change.to.ch;
    }
    return Pos(line, ch);
  }
  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }
  function offsetPos(pos, old, nw) {
    if (pos.line == old.line) {
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    } else {
      return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0),
      newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i],
          inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }
  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) {
      regChange(cm);
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i) {
        result.push(new Line(text[i], spansFor(i), estimateHeight$$1));
      }
      return result;
    }
    var from = change.from,
      to = change.to,
      text = change.text;
    var firstLine = getLine(doc, from.line),
      lastLine = getLine(doc, to.line);
    var lastText = lst(text),
      lastSpans = spansFor(text.length - 1),
      nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) {
        doc.remove(from.line, nlines);
      }
      if (added.length) {
        doc.insert(from.line, added);
      }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) {
        doc.remove(from.line + 1, nlines - 1);
      }
      doc.insert(from.line + 1, added$2);
    }
    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) {
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip) {
            continue;
          }
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared) {
            continue;
          }
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) {
      throw new Error("This document is already in use.");
    }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) {
      findMaxLine(cm);
    }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }
  function setDirectionClass(cm) {
    (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }
  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }
  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = [];
    this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {
      from: copyPos(change.from),
      to: changeEnd(change),
      text: getBetween(doc, change.from, change.to)
    };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) {
        array.pop();
      } else {
        break;
      }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(),
      cur;
    var last;
    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges) {
        pushSelectionToHistory(doc.sel, hist.done);
      }
      cur = {
        changes: [historyChangeFromChange(doc, change)],
        generation: hist.generation
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) {
          hist.done.shift();
        }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;
    if (!last) {
      signal(doc, "historyAdded");
    }
  }
  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history,
      origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
      hist.done[hist.done.length - 1] = sel;
    } else {
      pushSelectionToHistory(sel, hist.done);
    }
    hist.lastSelTime = +new Date();
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false) {
      clearSelectionEvents(hist.undone);
    }
  }
  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel))) {
      dest.push(sel);
    }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id],
      n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans) {
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) {
      return null;
    }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out) {
          out = spans.slice(0, i);
        }
      } else if (out) {
        out.push(spans[i]);
      }
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) {
      return null;
    }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i) {
      nw.push(removeClearedSpans(found[i]));
    }
    return nw;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) {
      return stretched;
    }
    if (!stretched) {
      return old;
    }
    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i],
        stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k) {
            if (oldCur[k].marker == span.marker) {
              continue spans;
            }
          }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes,
        newChanges = [];
      copy.push({
        changes: newChanges
      });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j],
          m = void 0;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });
        if (newGroup) {
          for (var prop in change) {
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
          }
        }
      }
    }
    return copy;
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != cmp(other, anchor) < 0) {
          anchor = head;
          head = other;
        } else if (posBefore != cmp(head, other) < 0) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) {
      extend = doc.cm && (doc.cm.display.shift || doc.extend);
    }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
    }
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function (ranges) {
        var this$1 = this;
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++) {
          this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
        }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) {
      signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    }
    if (obj.ranges != sel.ranges) {
      return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    } else {
      return sel;
    }
  }
  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done,
      last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }
  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      sel = filterSelectionChange(doc, sel, options);
    }
    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
    if (!(options && options.scroll === false) && doc.cm) {
      ensureCursorVisible(doc.cm);
    }
  }
  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) {
      return;
    }
    doc.sel = sel;
    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) {
          out = sel.ranges.slice(0, i);
        }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }
  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) {
      for (var i = 0; i < line.markedSpans.length; ++i) {
        var sp = line.markedSpans[i],
          m = sp.marker;
        if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");
            if (m.explicitlyCleared) {
              if (!line.markedSpans) {
                break;
              } else {
                --i;
                continue;
              }
            }
          }
          if (!m.atomic) {
            continue;
          }
          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1),
              diff = void 0;
            if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) {
              near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
            }
            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
              return skipAtomicInner(doc, near, pos, dir, mayClear);
            }
          }
          var far = m.find(dir < 0 ? -1 : 1);
          if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) {
            far = movePos(doc, far, dir, far.line == pos.line ? line : null);
          }
          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
        }
      }
    }
    return pos;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }
    return found;
  }
  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) {
        return clipPos(doc, Pos(pos.line - 1));
      } else {
        return null;
      }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) {
        return Pos(pos.line + 1, 0);
      } else {
        return null;
      }
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }
  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () {
        return obj.canceled = true;
      }
    };
    if (update) {
      obj.update = function (from, to, text, origin) {
        if (from) {
          obj.from = clipPos(doc, from);
        }
        if (to) {
          obj.to = clipPos(doc, to);
        }
        if (text) {
          obj.text = text;
        }
        if (origin !== undefined) {
          obj.origin = origin;
        }
      };
    }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) {
      signal(doc.cm, "beforeChange", doc.cm, obj);
    }
    if (obj.canceled) {
      return null;
    }
    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) {
        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      }
      if (doc.cm.state.suppressEdits) {
        return;
      }
    }
    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) {
        return;
      }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i) {
        makeChangeInner(doc, {
          from: split[i].from,
          to: split[i].to,
          text: i ? [""] : change.text,
          origin: change.origin
        });
      }
    } else {
      makeChangeInner(doc, change);
    }
  }
  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
      return;
    }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) {
      return;
    }
    var hist = doc.history,
      event,
      selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone,
      dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
        break;
      }
    }
    if (i == source.length) {
      return;
    }
    hist.lastOrigin = hist.lastSelOrigin = null;
    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {
            clearRedo: false
          });
          return;
        }
        selAfter = event;
      } else {
        break;
      }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({
      changes: antiChanges,
      generation: hist.generation
    });
    hist.generation = event.generation || ++hist.maxGeneration;
    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
    var loop = function (i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {};
      }
      antiChanges.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) {
        doc.cm.scrollIntoView({
          from: change.from,
          to: changeEnd(change)
        });
      }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };
    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop(i$1);
      if (returned) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) {
      return;
    }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
        regLineChange(doc.cm, l, "gutter");
      }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    }
    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) {
      return;
    }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc, change.from, change.to);
    if (!selAfter) {
      selAfter = computeSelAfterChange(doc, change);
    }
    if (doc.cm) {
      makeChangeSingleDocInEditor(doc.cm, change, spans);
    } else {
      updateDoc(doc, change, spans);
    }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc,
      display = cm.display,
      from = change.from,
      to = change.to;
    var recomputeMaxLength = false,
      checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (doc.sel.contains(change.from, change.to) > -1) {
      signalCursorActivity(cm);
    }
    updateDoc(doc, change, spans, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) {
        cm.curOp.updateMaxLine = true;
      }
    }
    retreatFrontier(doc, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full) {
      regChange(cm);
    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
      regLineChange(cm, from.line, "text");
    } else {
      regChange(cm, from.line, to.line + 1, lendiff);
    }
    var changesHandler = hasHandler(cm, "changes"),
      changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from,
        to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) {
        signalLater(cm, "change", cm, obj);
      }
      if (changesHandler) {
        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
      }
    }
    cm.display.selForContextMenu = null;
  }
  function replaceRange(doc, code, from, to, origin) {
    if (!to) {
      to = from;
    }
    if (cmp(to, from) < 0) {
      var assign;
      assign = [to, from], from = assign[0], to = assign[1], assign;
    }
    if (typeof code == "string") {
      code = doc.splitLines(code);
    }
    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    });
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i],
        ok = true;
      if (sub.ranges) {
        if (!sub.copied) {
          sub = array[i] = sub.deepCopy();
          sub.copied = true;
        }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line,
      to = change.to.line,
      diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle,
      line = handle;
    if (typeof handle == "number") {
      line = getLine(doc, clipLine(doc, handle));
    } else {
      no = lineNo(handle);
    }
    if (no == null) {
      return null;
    }
    if (op(line, no) && doc.cm) {
      regLineChange(doc.cm, no, changeType);
    }
    return line;
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    var this$1 = this;
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.lines.length;
    },
    // Remove the n lines at offset 'at'.
    removeInner: function removeInner(at, n) {
      var this$1 = this;
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function collapse(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function insertInner(at, lines, height) {
      var this$1 = this;
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) {
        lines[i].parent = this$1;
      }
    },
    // Used to iterate over a part of the tree.
    iterN: function iterN(at, n, op) {
      var this$1 = this;
      for (var e = at + n; at < e; ++at) {
        if (op(this$1.lines[at])) {
          return true;
        }
      }
    }
  };
  function BranchChunk(children) {
    var this$1 = this;
    this.children = children;
    var size = 0,
      height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this$1;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.size;
    },
    removeInner: function removeInner(at, n) {
      var this$1 = this;
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
          sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at),
            oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;
          if (sz == rm) {
            this$1.children.splice(i--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function collapse(lines) {
      var this$1 = this;
      for (var i = 0; i < this.children.length; ++i) {
        this$1.children[i].collapse(lines);
      }
    },
    insertInner: function insertInner(at, lines, height) {
      var this$1 = this;
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
          sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }
            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function maybeSpill() {
      if (this.children.length <= 10) {
        return;
      }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function iterN(at, n, op) {
      var this$1 = this;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
          sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) {
            return true;
          }
          if ((n -= used) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function (doc, node, options) {
    var this$1 = this;
    if (options) {
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          this$1[opt] = options[opt];
        }
      }
    }
    this.doc = doc;
    this.node = node;
  };
  LineWidget.prototype.clear = function () {
    var this$1 = this;
    var cm = this.doc.cm,
      ws = this.line.widgets,
      line = this.line,
      no = lineNo(line);
    if (no == null || !ws) {
      return;
    }
    for (var i = 0; i < ws.length; ++i) {
      if (ws[i] == this$1) {
        ws.splice(i--, 1);
      }
    }
    if (!ws.length) {
      line.widgets = null;
    }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };
  LineWidget.prototype.changed = function () {
    var this$1 = this;
    var oldH = this.height,
      cm = this.doc.cm,
      line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) {
      return;
    }
    updateLineHeight(line, line.height + diff);
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);
  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
      addToScrollTop(cm, diff);
    }
  }
  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) {
      cm.display.alignWidgets = true;
    }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) {
        widgets.push(widget);
      } else {
        widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) {
          addToScrollTop(cm, widget.height);
        }
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
    return widget;
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;
  var TextMarker = function (doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    var this$1 = this;
    if (this.explicitlyCleared) {
      return;
    }
    var cm = this.doc.cm,
      withOp = cm && !cm.curOp;
    if (withOp) {
      startOperation(cm);
    }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) {
        signalLater(this, "clear", found.from, found.to);
      }
    }
    var min = null,
      max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (cm && !this$1.collapsed) {
        regLineChange(cm, lineNo(line), "text");
      } else if (cm) {
        if (span.to != null) {
          max = lineNo(line);
        }
        if (span.from != null) {
          min = lineNo(line);
        }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm) {
        updateLineHeight(line, textHeight(cm.display));
      }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) {
      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
        var visual = visualLine(this$1.lines[i$1]),
          len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (min != null && cm && this.collapsed) {
      regChange(cm, min, max + 1);
    }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) {
        reCheckSelection(cm.doc);
      }
    }
    if (cm) {
      signalLater(cm, "markerCleared", cm, this, min, max);
    }
    if (withOp) {
      endOperation(cm);
    }
    if (this.parent) {
      this.parent.clear();
    }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    var this$1 = this;
    if (side == null && this.type == "bookmark") {
      side = 1;
    }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) {
          return from;
        }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) {
          return to;
        }
      }
    }
    return from && {
      from: from,
      to: to
    };
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
    var this$1 = this;
    var pos = this.find(-1, true),
      widget = this,
      cm = this.doc.cm;
    if (!pos || !cm) {
      return;
    }
    runInOp(cm, function () {
      var line = pos.line,
        lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight) {
          updateLineHeight(line, line.height + dHeight);
        }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };
  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
      }
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) {
      return markTextShared(doc, from, to, options, type);
    }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, markText)(doc, from, to, options, type);
    }
    var marker = new TextMarker(doc, type),
      diff = cmp(from, to);
    if (options) {
      copyObj(options, marker, false);
    }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
      return marker;
    }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) {
        marker.widgetNode.setAttribute("cm-ignore-events", "true");
      }
      if (options.insertLeft) {
        marker.widgetNode.insertLeft = true;
      }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      }
      seeCollapsedSpans();
    }
    if (marker.addToHistory) {
      addChangeToHistory(doc, {
        from: from,
        to: to,
        origin: "markText"
      }, doc.sel, NaN);
    }
    var curLine = from.line,
      cm = doc.cm,
      updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
        updateMaxLine = true;
      }
      if (marker.collapsed && curLine != from.line) {
        updateLineHeight(line, 0);
      }
      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) {
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line)) {
          updateLineHeight(line, 0);
        }
      });
    }
    if (marker.clearOnEnter) {
      on(marker, "beforeCursorEnter", function () {
        return marker.clear();
      });
    }
    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length) {
        doc.clearHistory();
      }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) {
        cm.curOp.updateMaxLine = true;
      }
      if (marker.collapsed) {
        regChange(cm, from.line, to.line + 1);
      } else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css) {
        for (var i = from.line; i <= to.line; i++) {
          regLineChange(cm, i, "text");
        }
      }
      if (marker.atomic) {
        reCheckSelection(cm.doc);
      }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function (markers, primary) {
    var this$1 = this;
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i) {
      markers[i].parent = this$1;
    }
  };
  SharedTextMarker.prototype.clear = function () {
    var this$1 = this;
    if (this.explicitlyCleared) {
      return;
    }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i) {
      this$1.markers[i].clear();
    }
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj);
  };
  eventMixin(SharedTextMarker);
  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)],
      primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) {
        options.widgetNode = widget.cloneNode(true);
      }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i) {
        if (doc.linked[i].isParent) {
          return;
        }
      }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
      return m.parent;
    });
  }
  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i],
        pos = marker.find();
      var mFrom = doc.clipPos(pos.from),
        mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }
  function detachSharedMarkers(markers) {
    var loop = function (i) {
      var marker = markers[i],
        linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) {
        return linked.push(d);
      });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };
    for (var i = 0; i < markers.length; i++) loop(i);
  }
  var nextDocId = 0;
  var Doc = function (text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) {
      return new Doc(text, mode, firstLine, lineSep, direction);
    }
    if (firstLine == null) {
      firstLine = 0;
    }
    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = direction == "rtl" ? "rtl" : "ltr";
    this.extend = false;
    if (typeof text == "string") {
      text = this.splitLines(text);
    }
    updateDoc(this, {
      from: start,
      to: start,
      text: text
    });
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };
  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function (from, to, op) {
      if (op) {
        this.iterN(from - this.first, to - from, op);
      } else {
        this.iterN(this.first, this.first + this.size, from);
      }
    },
    // Non-public interface for adding and removing lines.
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) {
        height += lines[i].height;
      }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) {
      this.removeInner(at - this.first, n);
    },
    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function (code) {
      var top = Pos(this.first, 0),
        last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: this.splitLines(code),
        origin: "setValue",
        full: true
      }, true);
      if (this.cm) {
        scrollToCoords(this.cm, 0, 0);
      }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    getLine: function (line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    getLineHandle: function (line) {
      if (isLine(this, line)) {
        return getLine(this, line);
      }
    },
    getLineNumber: function (line) {
      return lineNo(line);
    },
    getLineHandleVisualStart: function (line) {
      if (typeof line == "number") {
        line = getLine(this, line);
      }
      return visualLine(line);
    },
    lineCount: function () {
      return this.size;
    },
    firstLine: function () {
      return this.first;
    },
    lastLine: function () {
      return this.first + this.size - 1;
    },
    clipPos: function (pos) {
      return clipPos(this, pos);
    },
    getCursor: function (start) {
      var range$$1 = this.sel.primary(),
        pos;
      if (start == null || start == "head") {
        pos = range$$1.head;
      } else if (start == "anchor") {
        pos = range$$1.anchor;
      } else if (start == "end" || start == "to" || start === false) {
        pos = range$$1.to();
      } else {
        pos = range$$1.from();
      }
      return pos;
    },
    listSelections: function () {
      return this.sel.ranges;
    },
    somethingSelected: function () {
      return this.sel.somethingSelected();
    },
    setCursor: docMethodOp(function (line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function (anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function (head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function (heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function (f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function (ranges, primary, options) {
      var this$1 = this;
      if (!ranges.length) {
        return;
      }
      var out = [];
      for (var i = 0; i < ranges.length; i++) {
        out[i] = new Range(clipPos(this$1, ranges[i].anchor), clipPos(this$1, ranges[i].head));
      }
      if (primary == null) {
        primary = Math.min(ranges.length - 1, this.sel.primIndex);
      }
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function (anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),
    getSelection: function (lineSep) {
      var this$1 = this;
      var ranges = this.sel.ranges,
        lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) {
        return lines;
      } else {
        return lines.join(lineSep || this.lineSeparator());
      }
    },
    getSelections: function (lineSep) {
      var this$1 = this;
      var parts = [],
        ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) {
          sel = sel.join(lineSep || this$1.lineSeparator());
        }
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function (code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++) {
        dup[i] = code;
      }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function (code, collapse, origin) {
      var this$1 = this;
      var changes = [],
        sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = {
          from: range$$1.from(),
          to: range$$1.to(),
          text: this$1.splitLines(code[i]),
          origin: origin
        };
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
        makeChange(this$1, changes[i$1]);
      }
      if (newSel) {
        setSelectionReplaceHistory(this, newSel);
      } else if (this.cm) {
        ensureCursorVisible(this.cm);
      }
    }),
    undo: docMethodOp(function () {
      makeChangeFromHistory(this, "undo");
    }),
    redo: docMethodOp(function () {
      makeChangeFromHistory(this, "redo");
    }),
    undoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "undo", true);
    }),
    redoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "redo", true);
    }),
    setExtending: function (val) {
      this.extend = val;
    },
    getExtending: function () {
      return this.extend;
    },
    historySize: function () {
      var hist = this.history,
        done = 0,
        undone = 0;
      for (var i = 0; i < hist.done.length; i++) {
        if (!hist.done[i].ranges) {
          ++done;
        }
      }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
        if (!hist.undone[i$1].ranges) {
          ++undone;
        }
      }
      return {
        undo: done,
        redo: undone
      };
    },
    clearHistory: function () {
      this.history = new History(this.history.maxGeneration);
    },
    markClean: function () {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function (forceSplit) {
      if (forceSplit) {
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      }
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },
    getHistory: function () {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function (histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },
    setGutterMarker: docMethodOp(function (line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) {
          line.gutterMarkers = null;
        }
        return true;
      });
    }),
    clearGutter: docMethodOp(function (gutterID) {
      var this$1 = this;
      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) {
              line.gutterMarkers = null;
            }
            return true;
          });
        }
      });
    }),
    lineInfo: function (line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) {
          return null;
        }
        n = line;
        line = getLine(this, line);
        if (!line) {
          return null;
        }
      } else {
        n = lineNo(line);
        if (n == null) {
          return null;
        }
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    addLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) {
          line[prop] = cls;
        } else if (classTest(cls).test(line[prop])) {
          return false;
        } else {
          line[prop] += " " + cls;
        }
        return true;
      });
    }),
    removeLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) {
          return false;
        } else if (cls == null) {
          line[prop] = null;
        } else {
          var found = cur.match(classTest(cls));
          if (!found) {
            return false;
          }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),
    addLineWidget: docMethodOp(function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function (widget) {
      widget.clear();
    },
    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function (pos, options) {
      var realOpts = {
        replacedWith: options && (options.nodeType == null ? options.widget : options),
        insertLeft: options && options.insertLeft,
        clearWhenEmpty: false,
        shared: options && options.shared,
        handleMouseEvents: options && options.handleMouseEvents
      };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [],
        spans = getLine(this, pos.line).markedSpans;
      if (spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
            markers.push(span.marker.parent || span.marker);
          }
        }
      }
      return markers;
    },
    findMarks: function (from, to, filter) {
      from = clipPos(this, from);
      to = clipPos(this, to);
      var found = [],
        lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) {
          for (var i = 0; i < spans.length; i++) {
            var span = spans[i];
            if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to || span.from == null && lineNo$$1 != from.line || span.from != null && lineNo$$1 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
              found.push(span.marker.parent || span.marker);
            }
          }
        }
        ++lineNo$$1;
      });
      return found;
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            if (sps[i].from != null) {
              markers.push(sps[i].marker);
            }
          }
        }
      });
      return markers;
    },
    posFromIndex: function (off) {
      var ch,
        lineNo$$1 = this.first,
        sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) {
          ch = off;
          return true;
        }
        off -= sz;
        ++lineNo$$1;
      });
      return clipPos(this, Pos(lineNo$$1, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) {
        return 0;
      }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) {
        // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index;
    },
    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },
    linkedDoc: function (options) {
      if (!options) {
        options = {};
      }
      var from = this.first,
        to = this.first + this.size;
      if (options.from != null && options.from > from) {
        from = options.from;
      }
      if (options.to != null && options.to < to) {
        to = options.to;
      }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) {
        copy.history = this.history;
      }
      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
        doc: this,
        isParent: true,
        sharedHist: options.sharedHist
      }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function (other) {
      var this$1 = this;
      if (other instanceof CodeMirror$1) {
        other = other.doc;
      }
      if (this.linked) {
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this$1.linked[i];
          if (link.doc != other) {
            continue;
          }
          this$1.linked.splice(i, 1);
          other.unlinkDoc(this$1);
          detachSharedMarkers(findSharedMarkers(this$1));
          break;
        }
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          return splitIds.push(doc.id);
        }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) {
      linkedDocs(this, f);
    },
    getMode: function () {
      return this.mode;
    },
    getEditor: function () {
      return this.cm;
    },
    splitLines: function (str) {
      if (this.lineSep) {
        return str.split(this.lineSep);
      }
      return splitLinesAuto(str);
    },
    lineSeparator: function () {
      return this.lineSep || "\n";
    },
    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") {
        dir = "ltr";
      }
      if (dir == this.direction) {
        return;
      }
      this.direction = dir;
      this.iter(function (line) {
        return line.order = null;
      });
      if (this.cm) {
        directionChanged(this.cm);
      }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;
  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e_preventDefault(e);
    if (ie) {
      lastDrop = +new Date();
    }
    var pos = posFromMouse(cm, e, true),
      files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) {
      return;
    }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length,
        text = Array(n),
        read = 0;
      var loadFile = function (file, i) {
        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          return;
        }
        var reader = new FileReader();
        reader.onload = operation(cm, function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            content = "";
          }
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {
              from: pos,
              to: pos,
              text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
              origin: "paste"
            };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) {
        loadFile(files[i], i);
      }
    } else {
      // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () {
          return cm.display.input.focus();
        }, 20);
        return;
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy) {
            selected = cm.listSelections();
          }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) {
            for (var i$1 = 0; i$1 < selected.length; ++i$1) {
              replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
            }
          }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      } catch (e) {}
    }
  }
  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
      e_stop(e);
      return;
    }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) {
        img.parentNode.removeChild(img);
      }
    }
  }
  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) {
      return;
    }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }
  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) {
      return;
    }
    var byClass = document.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) {
        f(cm);
      }
    }
  }
  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) {
      return;
    }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) {
        resizeTimer = setTimeout(function () {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100);
      }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () {
      return forEachCodeMirror(onBlur);
    });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth) {
      return;
    }
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }
  var keyNames = {
    3: "Pause",
    8: "Backspace",
    9: "Tab",
    13: "Enter",
    16: "Shift",
    17: "Ctrl",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Esc",
    32: "Space",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    44: "PrintScrn",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Mod",
    92: "Mod",
    93: "Mod",
    106: "*",
    107: "=",
    109: "-",
    110: ".",
    111: "/",
    127: "Delete",
    145: "ScrollLock",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    63232: "Up",
    63233: "Down",
    63234: "Left",
    63235: "Right",
    63272: "Delete",
    63273: "Home",
    63275: "End",
    63276: "PageUp",
    63277: "PageDown",
    63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) {
    keyNames[i + 48] = keyNames[i + 96] = String(i);
  }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) {
    keyNames[i$1] = String.fromCharCode(i$1);
  }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) {
    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
  }
  var keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft",
    "Right": "goCharRight",
    "Up": "goLineUp",
    "Down": "goLineDown",
    "End": "goLineEnd",
    "Home": "goLineStartSmart",
    "PageUp": "goPageUp",
    "PageDown": "goPageDown",
    "Delete": "delCharAfter",
    "Backspace": "delCharBefore",
    "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab",
    "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent",
    "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll",
    "Ctrl-D": "deleteLine",
    "Ctrl-Z": "undo",
    "Shift-Ctrl-Z": "redo",
    "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart",
    "Ctrl-End": "goDocEnd",
    "Ctrl-Up": "goLineUp",
    "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft",
    "Ctrl-Right": "goGroupRight",
    "Alt-Left": "goLineStart",
    "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore",
    "Ctrl-Delete": "delGroupAfter",
    "Ctrl-S": "save",
    "Ctrl-F": "find",
    "Ctrl-G": "findNext",
    "Shift-Ctrl-G": "findPrev",
    "Shift-Ctrl-F": "replace",
    "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess",
    "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection",
    "Shift-Ctrl-U": "redoSelection",
    "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight",
    "Ctrl-B": "goCharLeft",
    "Ctrl-P": "goLineUp",
    "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight",
    "Alt-B": "goWordLeft",
    "Ctrl-A": "goLineStart",
    "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown",
    "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter",
    "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter",
    "Alt-Backspace": "delWordBefore",
    "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll",
    "Cmd-D": "deleteLine",
    "Cmd-Z": "undo",
    "Shift-Cmd-Z": "redo",
    "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart",
    "Cmd-Up": "goDocStart",
    "Cmd-End": "goDocEnd",
    "Cmd-Down": "goDocEnd",
    "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight",
    "Cmd-Left": "goLineLeft",
    "Cmd-Right": "goLineRight",
    "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter",
    "Alt-Delete": "delGroupAfter",
    "Cmd-S": "save",
    "Cmd-F": "find",
    "Cmd-G": "findNext",
    "Shift-Cmd-G": "findPrev",
    "Cmd-Alt-F": "replace",
    "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess",
    "Cmd-]": "indentMore",
    "Cmd-Backspace": "delWrappedLineLeft",
    "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection",
    "Shift-Cmd-U": "redoSelection",
    "Ctrl-Up": "goDocStart",
    "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        cmd = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift = true;
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }
    if (alt) {
      name = "Alt-" + name;
    }
    if (ctrl) {
      name = "Ctrl-" + name;
    }
    if (cmd) {
      name = "Cmd-" + name;
    }
    if (shift) {
      name = "Shift-" + name;
    }
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) {
      if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];
        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
          continue;
        }
        if (value == "...") {
          delete keymap[keyname];
          continue;
        }
        var keys = map(keyname.split(" "), normalizeKeyName);
        for (var i = 0; i < keys.length; i++) {
          var val = void 0,
            name = void 0;
          if (i == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i + 1).join(" ");
            val = "...";
          }
          var prev = copy[name];
          if (!prev) {
            copy[name] = val;
          } else if (prev != val) {
            throw new Error("Inconsistent bindings for " + name);
          }
        }
        delete keymap[keyname];
      }
    }
    for (var prop in copy) {
      keymap[prop] = copy[prop];
    }
    return keymap;
  }
  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
    if (found === false) {
      return "nothing";
    }
    if (found === "...") {
      return "multi";
    }
    if (found != null && handle(found)) {
      return "handled";
    }
    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]") {
        return lookupKey(key, map$$1.fallthrough, handle, context);
      }
      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
        if (result) {
          return result;
        }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }
  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") {
      name = "Alt-" + name;
    }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
      name = "Ctrl-" + name;
    }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") {
      name = "Cmd-" + name;
    }
    if (!noShift && event.shiftKey && base != "Shift") {
      name = "Shift-" + name;
    }
    return name;
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) {
      return false;
    }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) {
      return false;
    }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) {
      name = event.code;
    }
    return addModifierNames(name, event, noShift);
  }
  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges,
      kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--) {
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      }
      ensureCursorVisible(cm);
    });
  }
  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target;
  }
  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
  }
  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = dir < 0 == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) {
            return measureCharPrepared(cm, prep, ch).top == targetTop;
          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") {
            ch = moveCharLogically(lineObj, ch, 1);
          }
        } else {
          ch = dir < 0 ? part.to : part.from;
        }
        return new Pos(lineNo, ch, sticky);
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
  }
  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) {
      return moveLogically(line, start, dir);
    }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
      part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir);
    }
    var mv = function (pos, dir) {
      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
    };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) {
        return {
          begin: 0,
          end: line.text.length
        };
      }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch);
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = part.level == 1 == dir < 0;
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky);
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) {
        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
      };
      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = dir > 0 == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) {
          return getRes(ch, moveInStorageOrder);
        }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
          return getRes(ch, moveInStorageOrder);
        }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) {
      return res;
    }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) {
        return res;
      }
    }

    // Case 4: Nowhere to move
    return null;
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) {
      return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function (cm) {
      return deleteNearSelection(cm, function (range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine()) {
            return {
              from: range.head,
              to: Pos(range.head.line + 1, 0)
            };
          } else {
            return {
              from: range.head,
              to: Pos(range.head.line, len)
            };
          }
        } else {
          return {
            from: range.from(),
            to: range.to()
          };
        }
      });
    },
    deleteLine: function (cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
        };
      });
    },
    delLineLeft: function (cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: range.from()
        };
      });
    },
    delWrappedLineLeft: function (cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({
          left: 0,
          top: top
        }, "div");
        return {
          from: leftPos,
          to: range.from()
        };
      });
    },
    delWrappedLineRight: function (cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, "div");
        return {
          from: range.from(),
          to: rightPos
        };
      });
    },
    undo: function (cm) {
      return cm.undo();
    },
    redo: function (cm) {
      return cm.redo();
    },
    undoSelection: function (cm) {
      return cm.undoSelection();
    },
    redoSelection: function (cm) {
      return cm.redoSelection();
    },
    goDocStart: function (cm) {
      return cm.extendSelection(Pos(cm.firstLine(), 0));
    },
    goDocEnd: function (cm) {
      return cm.extendSelection(Pos(cm.lastLine()));
    },
    goLineStart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStart(cm, range.head.line);
      }, {
        origin: "+move",
        bias: 1
      });
    },
    goLineStartSmart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStartSmart(cm, range.head);
      }, {
        origin: "+move",
        bias: 1
      });
    },
    goLineEnd: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineEnd(cm, range.head.line);
      }, {
        origin: "+move",
        bias: -1
      });
    },
    goLineRight: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, "div");
      }, sel_move);
    },
    goLineLeft: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({
          left: 0,
          top: top
        }, "div");
      }, sel_move);
    },
    goLineLeftSmart: function (cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({
          left: 0,
          top: top
        }, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
          return lineStartSmart(cm, range.head);
        }
        return pos;
      }, sel_move);
    },
    goLineUp: function (cm) {
      return cm.moveV(-1, "line");
    },
    goLineDown: function (cm) {
      return cm.moveV(1, "line");
    },
    goPageUp: function (cm) {
      return cm.moveV(-1, "page");
    },
    goPageDown: function (cm) {
      return cm.moveV(1, "page");
    },
    goCharLeft: function (cm) {
      return cm.moveH(-1, "char");
    },
    goCharRight: function (cm) {
      return cm.moveH(1, "char");
    },
    goColumnLeft: function (cm) {
      return cm.moveH(-1, "column");
    },
    goColumnRight: function (cm) {
      return cm.moveH(1, "column");
    },
    goWordLeft: function (cm) {
      return cm.moveH(-1, "word");
    },
    goGroupRight: function (cm) {
      return cm.moveH(1, "group");
    },
    goGroupLeft: function (cm) {
      return cm.moveH(-1, "group");
    },
    goWordRight: function (cm) {
      return cm.moveH(1, "word");
    },
    delCharBefore: function (cm) {
      return cm.deleteH(-1, "char");
    },
    delCharAfter: function (cm) {
      return cm.deleteH(1, "char");
    },
    delWordBefore: function (cm) {
      return cm.deleteH(-1, "word");
    },
    delWordAfter: function (cm) {
      return cm.deleteH(1, "word");
    },
    delGroupBefore: function (cm) {
      return cm.deleteH(-1, "group");
    },
    delGroupAfter: function (cm) {
      return cm.deleteH(1, "group");
    },
    indentAuto: function (cm) {
      return cm.indentSelection("smart");
    },
    indentMore: function (cm) {
      return cm.indentSelection("add");
    },
    indentLess: function (cm) {
      return cm.indentSelection("subtract");
    },
    insertTab: function (cm) {
      return cm.replaceSelection("\t");
    },
    insertSoftTab: function (cm) {
      var spaces = [],
        ranges = cm.listSelections(),
        tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) {
        cm.indentSelection("add");
      } else {
        cm.execCommand("insertTab");
      }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) {
      return runInOp(cm, function () {
        var ranges = cm.listSelections(),
          newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) {
            continue;
          }
          var cur = ranges[i].head,
            line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) {
              cur = new Pos(cur.line, cur.ch - 1);
            }
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
              }
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function (cm) {
      return runInOp(cm, function () {
        var sels = cm.listSelections();
        for (var i = sels.length - 1; i >= 0; i--) {
          cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
        }
        sels = cm.listSelections();
        for (var i$1 = 0; i$1 < sels.length; i$1++) {
          cm.indentLine(sels[i$1].from().line, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    openLine: function (cm) {
      return cm.replaceSelection("\n", "start");
    },
    toggleOverwrite: function (cm) {
      return cm.toggleOverwrite();
    }
  };
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, visual, lineN, 1);
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, line, lineN, -1);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
    }
    return start;
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) {
        return false;
      }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift,
      done = false;
    try {
      if (cm.isReadOnly()) {
        cm.state.suppressEdits = true;
      }
      if (dropShift) {
        cm.display.shift = false;
      }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) {
        return result;
      }
    }
    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed();
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) {
        return "handled";
      }
      if (/\'$/.test(name)) {
        cm.state.keySeq = null;
      } else {
        stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        });
      }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
        return true;
      }
    }
    return dispatchKeyInner(cm, name, e, handle);
  }
  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);
    if (result == "multi") {
      cm.state.keySeq = name;
    }
    if (result == "handled") {
      signalLater(cm, "keyHandled", cm, name, e);
    }
    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) {
      return false;
    }
    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) {
        return doHandleBinding(cm, b, true);
      }) || dispatchKey(cm, name, e, function (b) {
        if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
          return doHandleBinding(cm, b);
        }
      });
    } else {
      return dispatchKey(cm, name, e, function (b) {
        return doHandleBinding(cm, b);
      });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) {
      return doHandleBinding(cm, b, true);
    });
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) {
      return;
    }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) {
      e.returnValue = false;
    }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
        cm.replaceSelection("", null, "cut");
      }
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
      showCrossHair(cm);
    }
  }
  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");
    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }
  function onKeyUp(e) {
    if (e.keyCode == 16) {
      this.doc.sel.shift = false;
    }
    signalDOMEvent(this, e);
  }
  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
      return;
    }
    var keyCode = e.keyCode,
      charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
      return;
    }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") {
      return;
    }
    if (handleCharBinding(cm, e, ch)) {
      return;
    }
    cm.display.input.onKeyPress(e);
  }
  var DOUBLECLICK_DELAY = 400;
  var PastClick = function (time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };
  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
  };
  var lastClick;
  var lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date();
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple";
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double";
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single";
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this,
      display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
      return;
    }
    display.input.ensurePolled();
    display.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () {
          return display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) {
      return;
    }
    var pos = posFromMouse(cm, e),
      button = e_button(e),
      repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText) {
      cm.state.selectingText(e);
    }
    if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
      return;
    }
    if (button == 1) {
      if (pos) {
        leftButtonDown(cm, pos, repeat, e);
      } else if (e_target(e) == display.scroller) {
        e_preventDefault(e);
      }
    } else if (button == 2) {
      if (pos) {
        extendSelection(cm.doc, pos);
      }
      setTimeout(function () {
        return display.input.focus();
      }, 20);
    } else if (button == 3) {
      if (captureRightClick) {
        onContextMenu(cm, e);
      } else {
        delayBlurEvent(cm);
      }
    }
  }
  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") {
      name = "Double" + name;
    } else if (repeat == "triple") {
      name = "Triple" + name;
    }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") {
        bound = commands[bound];
      }
      if (!bound) {
        return false;
      }
      var done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done;
    });
  }
  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) {
      value.extend = cm.doc.extend || event.shiftKey;
    }
    if (value.addNew == null) {
      value.addNew = mac ? event.metaKey : event.ctrlKey;
    }
    if (value.moveOnDrag == null) {
      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
    }
    return value;
  }
  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) {
      setTimeout(bind(ensureFocus, cm), 0);
    } else {
      cm.curOp.focus = activeElt();
    }
    var behavior = configureMouse(cm, repeat, event);
    var sel = cm.doc.sel,
      contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
      leftButtonStartDrag(cm, event, pos, behavior);
    } else {
      leftButtonSelect(cm, event, pos, behavior);
    }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display,
      moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) {
        display.scroller.draggable = false;
      }
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(document, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew) {
          extendSelection(cm.doc, pos, null, null, behavior.extend);
        }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9) {
          setTimeout(function () {
            document.body.focus();
            display.input.focus();
          }, 20);
        } else {
          display.input.focus();
        }
      }
    });
    var mouseMove = function (e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () {
      return moved = true;
    };
    // Let the drag handler handle this.
    if (webkit) {
      display.scroller.draggable = true;
    }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    // IE's approach to draggable
    if (display.scroller.dragDrop) {
      display.scroller.dragDrop();
    }
    on(document, "mouseup", dragEnd);
    on(document, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);
    delayBlurEvent(cm);
    setTimeout(function () {
      return display.input.focus();
    }, 20);
  }
  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") {
      return new Range(pos, pos);
    }
    if (unit == "word") {
      return cm.findWordAt(pos);
    }
    if (unit == "line") {
      return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
    }
    var result = unit(cm, pos);
    return new Range(result.from, result.to);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display,
      doc = cm.doc;
    e_preventDefault(event);
    var ourRange,
      ourIndex,
      startSel = doc.sel,
      ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1) {
        ourRange = ranges[ourIndex];
      } else {
        ourRange = new Range(start, start);
      }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }
    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) {
        ourRange = new Range(start, start);
      }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range$$1 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend) {
        ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend);
      } else {
        ourRange = range$$1;
      }
    }
    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), {
        scroll: false,
        origin: "*mouse"
      });
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
        scroll: false,
        origin: "*mouse"
      });
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }
    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) {
        return;
      }
      lastPos = pos;
      if (behavior.unit == "rectangle") {
        var ranges = [],
          tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol),
          right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
          var text = getLine(doc, line).text,
            leftPos = findColumn(text, left, tabSize);
          if (left == right) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          } else if (text.length > leftPos) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
          }
        }
        if (!ranges.length) {
          ranges.push(new Range(start, start));
        }
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
          origin: "*mouse",
          scroll: false
        });
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range$$1 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor,
          head;
        if (cmp(range$$1.anchor, anchor) > 0) {
          head = range$$1.head;
          anchor = minPos(oldRange.from(), range$$1.anchor);
        } else {
          head = range$$1.anchor;
          anchor = maxPos(oldRange.to(), range$$1.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
      }
    }
    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) {
        return;
      }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from) {
          setTimeout(operation(cm, function () {
            if (counter == curCount) {
              extend(e);
            }
          }), 150);
        }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) {
          setTimeout(operation(cm, function () {
            if (counter != curCount) {
              return;
            }
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }
    }
    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }
    var move = operation(cm, function (e) {
      if (!e_button(e)) {
        done(e);
      } else {
        extend(e);
      }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range$$1) {
    var anchor = range$$1.anchor;
    var head = range$$1.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
      return range$$1;
    }
    var order = getOrder(anchorLine);
    if (!order) {
      return range$$1;
    }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
      part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) {
      return range$$1;
    }
    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) {
      return range$$1;
    }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary) {
        leftSide = dir < 0;
      } else {
        leftSide = dir > 0;
      }
    }
    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to,
      sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try {
        mX = e.clientX;
        mY = e.clientY;
      } catch (e) {
        return false;
      }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
      return false;
    }
    if (prevent) {
      e_preventDefault(e);
    }
    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();
    if (mY > lineBox.bottom || !hasHandler(cm, type)) {
      return e_defaultPrevented(e);
    }
    mY -= lineBox.top - display.viewOffset;
    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }
  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
      return;
    }
    if (signalDOMEvent(cm, e, "contextmenu")) {
      return;
    }
    cm.display.input.onContextMenu(e);
  }
  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) {
      return false;
    }
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }
  var Init = {
    toString: function () {
      return "CodeMirror.Init";
    }
  };
  var defaults = {};
  var optionHandlers = {};
  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;
    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) {
        optionHandlers[name] = notOnInit ? function (cm, val, old) {
          if (old != Init) {
            handle(cm, val, old);
          }
        } : handle;
      }
    }
    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) {
      return cm.setValue(val);
    }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);
    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);
    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) {
        return;
      }
      var newBreaks = [],
        lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) {
            break;
          }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--) {
        replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
      }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) {
        cm.refresh();
      }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
      return cm.refresh();
    }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) {
      return cm.getInputField().spellcheck = val;
    }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);
    option("theme", "default", function (cm) {
      themeChanged(cm);
      guttersChanged(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) {
        prev.detach(cm, next);
      }
      if (next.attach) {
        next.attach(cm, prev || null);
      }
    });
    option("extraKeys", null);
    option("configureMouse", null);
    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) {
      return updateScrollbars(cm);
    }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("firstLineNumber", 1, guttersChanged, true);
    option("lineNumberFormatter", function (integer) {
      return integer;
    }, guttersChanged, true);
    option("showCursorWhenSelecting", false, updateSelection, true);
    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {
      if (!val) {
        cm.display.input.reset();
      }
    }, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);
    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) {
      return cm.doc.history.undoDepth = val;
    });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) {
      return cm.refresh();
    }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) {
        cm.display.input.resetPosition();
      }
    });
    option("tabindex", null, function (cm, val) {
      return cm.display.input.getField().tabIndex = val || "";
    });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) {
      return cm.doc.setDirection(val);
    }, true);
  }
  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    alignHorizontally(cm);
  }
  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      return updateScrollbars(cm);
    }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror$1(place, options) {
    var this$1 = this;
    if (!(this instanceof CodeMirror$1)) {
      return new CodeMirror$1(place, options);
    }
    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);
    var doc = options.value;
    if (typeof doc == "string") {
      doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
    }
    this.doc = doc;
    var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping) {
      this.display.wrapper.className += " CodeMirror-wrap";
    }
    initScrollbars(this);
    this.state = {
      keyMaps: [],
      // stores maps added by addKeyMap
      overlays: [],
      // highlighting overlays, as added by addOverlay
      modeGen: 0,
      // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false,
      // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false,
      cutIncoming: false,
      // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(),
      // stores highlight worker timeout
      keySeq: null,
      // Unfinished key sequence
      specialChars: null
    };
    if (options.autofocus && !mobile) {
      display.input.focus();
    }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) {
      setTimeout(function () {
        return this$1.display.input.reset(true);
      }, 20);
    }
    registerEventHandlers(this);
    ensureGlobalHandlers();
    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);
    if (options.autofocus && !mobile || this.hasFocus()) {
      setTimeout(bind(onFocus, this), 20);
    } else {
      onBlur(this);
    }
    for (var opt in optionHandlers) {
      if (optionHandlers.hasOwnProperty(opt)) {
        optionHandlers[opt](this$1, options[opt], Init);
      }
    }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) {
      options.finishInit(this);
    }
    for (var i = 0; i < initHooks.length; ++i) {
      initHooks[i](this$1);
    }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
      display.lineDiv.style.textRendering = "auto";
    }
  }

  // The default configuration options.
  CodeMirror$1.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror$1.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11) {
      on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    } else {
      on(d.scroller, "dblclick", function (e) {
        return signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) {
      on(d.scroller, "contextmenu", function (e) {
        return onContextMenu(cm, e);
      });
    }

    // Used to suppress mouse event handling when a touch happens
    var touchFinished,
      prevTouch = {
        end: 0
      };
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () {
          return d.activeTouch = null;
        }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date();
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) {
        return false;
      }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) {
        return true;
      }
      var dx = other.left - touch.left,
        dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date();
        d.activeTouch = {
          start: now,
          moved: false,
          prev: now - prevTouch.end <= 300 ? prevTouch : null
        };
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) {
        d.activeTouch.moved = true;
      }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"),
          range;
        if (!touch.prev || farAway(touch, touch.prev))
          // Single tap
          {
            range = new Range(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev))
          // Double tap
          {
            range = cm.findWordAt(pos);
          } else
          // Triple tap
          {
            range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) {
      return onScrollWheel(cm, e);
    });
    on(d.scroller, "DOMMouseScroll", function (e) {
      return onScrollWheel(cm, e);
    });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () {
      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    d.dragFunctions = {
      enter: function (e) {
        if (!signalDOMEvent(cm, e)) {
          e_stop(e);
        }
      },
      over: function (e) {
        if (!signalDOMEvent(cm, e)) {
          onDragOver(cm, e);
          e_stop(e);
        }
      },
      start: function (e) {
        return onDragStart(cm, e);
      },
      drop: operation(cm, onDrop),
      leave: function (e) {
        if (!signalDOMEvent(cm, e)) {
          clearDragCursor(cm);
        }
      }
    };
    var inp = d.input.getField();
    on(inp, "keyup", function (e) {
      return onKeyUp.call(cm, e);
    });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) {
      return onFocus(cm, e);
    });
    on(inp, "blur", function (e) {
      return onBlur(cm, e);
    });
  }
  var initHooks = [];
  CodeMirror$1.defineInitHook = function (f) {
    return initHooks.push(f);
  };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc,
      state;
    if (how == null) {
      how = "add";
    }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) {
        how = "prev";
      } else {
        state = getContextBefore(cm, n).state;
      }
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n),
      curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    var curSpaceString = line.text.match(/^\s*/)[0],
      indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) {
          return;
        }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) {
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      } else {
        indentation = 0;
      }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);
    var indentString = "",
      pos = 0;
    if (cm.options.indentWithTabs) {
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += "\t";
      }
    }
    if (pos < indentation) {
      indentString += spaceStr(indentation - pos);
    }
    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break;
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;
  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }
  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) {
      sel = doc.sel;
    }
    var paste = cm.state.pasteIncoming || origin == "paste";
    var textLines = splitLinesAuto(inserted),
      multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++) {
            multiPaste.push(doc.splitLines(lastCopied.text[i]));
          }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) {
          return [l];
        });
      }
    }
    var updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(),
        to = range$$1.to();
      if (range$$1.empty()) {
        if (deleted && deleted > 0)
          // Handle deletion
          {
            from = Pos(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste)
          // Handle overwrite
          {
            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          } else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted) {
          from = to = Pos(from.line, 0);
        }
      }
      updateInput = cm.curOp.updateInput;
      var changeEvent = {
        from: from,
        to: to,
        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
        origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
      };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste) {
      triggerElectric(cm, inserted);
    }
    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }
  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput) {
        runInOp(cm, function () {
          return applyTextInput(cm, pasted, 0, null, "paste");
        });
      }
      return true;
    }
  }
  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) {
      return;
    }
    var sel = cm.doc.sel;
    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];
      if (range$$1.head.ch > 100 || i && sel.ranges[i - 1].head.line == range$$1.head.line) {
        continue;
      }
      var mode = cm.getModeAt(range$$1.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++) {
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break;
          }
        }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch))) {
          indented = indentLine(cm, range$$1.head.line, "smart");
        }
      }
      if (indented) {
        signalLater(cm, "electricInput", cm, range$$1.head.line);
      }
    }
  }
  function copyableRanges(cm) {
    var text = [],
      ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {
        anchor: Pos(line, 0),
        head: Pos(line + 1, 0)
      };
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {
      text: text,
      ranges: ranges
    };
  }
  function disableBrowserMagic(field, spellcheck) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }
  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) {
      te.style.width = "1000px";
    } else {
      te.setAttribute("wrap", "off");
    }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) {
      te.style.border = "1px solid black";
    }
    disableBrowserMagic(te);
    return div;
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  var addEditorMethods = function (CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;
    var helpers = CodeMirror.helpers = {};
    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function () {
        window.focus();
        this.display.input.focus();
      },
      setOption: function (option, value) {
        var options = this.options,
          old = options[option];
        if (options[option] == value && option != "mode") {
          return;
        }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option)) {
          operation(this, optionHandlers[option])(this, value, old);
        }
        signal(this, "optionChange", this, option);
      },
      getOption: function (option) {
        return this.options[option];
      },
      getDoc: function () {
        return this.doc;
      },
      addKeyMap: function (map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function (map$$1) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i) {
          if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true;
          }
        }
      },
      addOverlay: methodOp(function (spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) {
          throw new Error("Overlays may not be stateful.");
        }
        insertSorted(this.state.overlays, {
          mode: mode,
          modeSpec: spec,
          opaque: options && options.opaque,
          priority: options && options.priority || 0
        }, function (overlay) {
          return overlay.priority;
        });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function (spec) {
        var this$1 = this;
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return;
          }
        }
      }),
      indentLine: methodOp(function (n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) {
            dir = this.options.smartIndent ? "smart" : "prev";
          } else {
            dir = dir ? "add" : "subtract";
          }
        }
        if (isLine(this.doc, n)) {
          indentLine(this, n, dir, aggressive);
        }
      }),
      indentSelection: methodOp(function (how) {
        var this$1 = this;
        var ranges = this.doc.sel.ranges,
          end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];
          if (!range$$1.empty()) {
            var from = range$$1.from(),
              to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j) {
              indentLine(this$1, j, how);
            }
            var newRanges = this$1.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
              replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
            }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;
            if (i == this$1.doc.sel.primIndex) {
              ensureCursorVisible(this$1);
            }
          }
        }
      }),
      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function (pos, precise) {
        return takeToken(this, pos, precise);
      },
      getLineTokens: function (line, precise) {
        return takeToken(this, Pos(line), precise, true);
      },
      getTokenTypeAt: function (pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0,
          after = (styles.length - 1) / 2,
          ch = pos.ch;
        var type;
        if (ch == 0) {
          type = styles[2];
        } else {
          for (;;) {
            var mid = before + after >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
              after = mid;
            } else if (styles[mid * 2 + 1] < ch) {
              before = mid + 1;
            } else {
              type = styles[mid * 2 + 2];
              break;
            }
          }
        }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
      },
      getModeAt: function (pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) {
          return mode;
        }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
      },
      getHelper: function (pos, type) {
        return this.getHelpers(pos, type)[0];
      },
      getHelpers: function (pos, type) {
        var this$1 = this;
        var found = [];
        if (!helpers.hasOwnProperty(type)) {
          return found;
        }
        var help = helpers[type],
          mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) {
            found.push(help[mode[type]]);
          }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) {
              found.push(val);
            }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1) {
            found.push(cur.val);
          }
        }
        return found;
      },
      getStateAfter: function (line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
        return getContextBefore(this, line + 1, precise).state;
      },
      cursorCoords: function (start, mode) {
        var pos,
          range$$1 = this.doc.sel.primary();
        if (start == null) {
          pos = range$$1.head;
        } else if (typeof start == "object") {
          pos = clipPos(this.doc, start);
        } else {
          pos = start ? range$$1.from() : range$$1.to();
        }
        return cursorCoords(this, pos, mode || "page");
      },
      charCoords: function (pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page");
      },
      coordsChar: function (coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top);
      },
      lineAtHeight: function (height, mode) {
        height = fromCoordSystem(this, {
          top: height,
          left: 0
        }, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset);
      },
      heightAtLine: function (line, mode, includeWidgets) {
        var end = false,
          lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) {
            line = this.doc.first;
          } else if (line > last) {
            line = last;
            end = true;
          }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {
          top: 0,
          left: 0
        }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
      },
      defaultTextHeight: function () {
        return textHeight(this.display);
      },
      defaultCharWidth: function () {
        return charWidth(this.display);
      },
      getViewport: function () {
        return {
          from: this.display.viewFrom,
          to: this.display.viewTo
        };
      },
      addWidget: function (pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom,
          left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
            hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
            top = pos.top - node.offsetHeight;
          } else if (pos.bottom + node.offsetHeight <= vspace) {
            top = pos.bottom;
          }
          if (left + node.offsetWidth > hspace) {
            left = hspace - node.offsetWidth;
          }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") {
            left = 0;
          } else if (horiz == "middle") {
            left = (display.sizer.clientWidth - node.offsetWidth) / 2;
          }
          node.style.left = left + "px";
        }
        if (scroll) {
          scrollIntoView(this, {
            left: left,
            top: top,
            right: left + node.offsetWidth,
            bottom: top + node.offsetHeight
          });
        }
      },
      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),
      execCommand: function (cmd) {
        if (commands.hasOwnProperty(cmd)) {
          return commands[cmd].call(null, this);
        }
      },
      triggerElectric: methodOp(function (text) {
        triggerElectric(this, text);
      }),
      findPosH: function (from, amount, unit, visually) {
        var this$1 = this;
        var dir = 1;
        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this$1.doc, cur, dir, unit, visually);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },
      moveH: methodOp(function (dir, unit) {
        var this$1 = this;
        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty()) {
            return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually);
          } else {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }
        }, sel_move);
      }),
      deleteH: methodOp(function (dir, unit) {
        var sel = this.doc.sel,
          doc = this.doc;
        if (sel.somethingSelected()) {
          doc.replaceSelection("", null, "+delete");
        } else {
          deleteNearSelection(this, function (range$$1) {
            var other = findPosH(doc, range$$1.head, dir, unit, false);
            return dir < 0 ? {
              from: other,
              to: range$$1.head
            } : {
              from: range$$1.head,
              to: other
            };
          });
        }
      }),
      findPosV: function (from, amount, unit, goalColumn) {
        var this$1 = this;
        var dir = 1,
          x = goalColumn;
        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this$1, cur, "div");
          if (x == null) {
            x = coords.left;
          } else {
            coords.left = x;
          }
          cur = findPosV(this$1, coords, dir, unit);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },
      moveV: methodOp(function (dir, unit) {
        var this$1 = this;
        var doc = this.doc,
          goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse) {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }
          var headPos = cursorCoords(this$1, range$$1.head, "div");
          if (range$$1.goalColumn != null) {
            headPos.left = range$$1.goalColumn;
          }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range$$1 == doc.sel.primary()) {
            addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
          }
          return pos;
        }, sel_move);
        if (goals.length) {
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            doc.sel.ranges[i].goalColumn = goals[i];
          }
        }
      }),
      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function (pos) {
        var doc = this.doc,
          line = getLine(doc, pos.line).text;
        var start = pos.ch,
          end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) {
            --start;
          } else {
            ++end;
          }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper) ? function (ch) {
            return isWordChar(ch, helper);
          } : /\s/.test(startChar) ? function (ch) {
            return /\s/.test(ch);
          } : function (ch) {
            return !/\s/.test(ch) && !isWordChar(ch);
          };
          while (start > 0 && check(line.charAt(start - 1))) {
            --start;
          }
          while (end < line.length && check(line.charAt(end))) {
            ++end;
          }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end));
      },
      toggleOverwrite: function (value) {
        if (value != null && value == this.state.overwrite) {
          return;
        }
        if (this.state.overwrite = !this.state.overwrite) {
          addClass(this.display.cursorDiv, "CodeMirror-overwrite");
        } else {
          rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
        }
        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function () {
        return this.display.input.getField() == activeElt();
      },
      isReadOnly: function () {
        return !!(this.options.readOnly || this.doc.cantEdit);
      },
      scrollTo: methodOp(function (x, y) {
        scrollToCoords(this, x, y);
      }),
      getScrollInfo: function () {
        var scroller = this.display.scroller;
        return {
          left: scroller.scrollLeft,
          top: scroller.scrollTop,
          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
          clientHeight: displayHeight(this),
          clientWidth: displayWidth(this)
        };
      },
      scrollIntoView: methodOp(function (range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = {
            from: this.doc.sel.primary().head,
            to: null
          };
          if (margin == null) {
            margin = this.options.cursorScrollMargin;
          }
        } else if (typeof range$$1 == "number") {
          range$$1 = {
            from: Pos(range$$1, 0),
            to: null
          };
        } else if (range$$1.from == null) {
          range$$1 = {
            from: range$$1,
            to: null
          };
        }
        if (!range$$1.to) {
          range$$1.to = range$$1.from;
        }
        range$$1.margin = margin || 0;
        if (range$$1.from.line != null) {
          scrollToRange(this, range$$1);
        } else {
          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
        }
      }),
      setSize: methodOp(function (width, height) {
        var this$1 = this;
        var interpret = function (val) {
          return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
        };
        if (width != null) {
          this.display.wrapper.style.width = interpret(width);
        }
        if (height != null) {
          this.display.wrapper.style.height = interpret(height);
        }
        if (this.options.lineWrapping) {
          clearLineMeasurementCache(this);
        }
        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].noHScroll) {
                regLineChange(this$1, lineNo$$1, "widget");
                break;
              }
            }
          }
          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),
      operation: function (f) {
        return runInOp(this, f);
      },
      startOperation: function () {
        return startOperation(this);
      },
      endOperation: function () {
        return endOperation(this);
      },
      refresh: methodOp(function () {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5) {
          estimateLineHeights(this);
        }
        signal(this, "refresh", this);
      }),
      swapDoc: methodOp(function (doc) {
        var old = this.doc;
        old.cm = null;
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old;
      }),
      getInputField: function () {
        return this.display.input.getField();
      },
      getWrapperElement: function () {
        return this.display.wrapper;
      },
      getScrollerElement: function () {
        return this.display.scroller;
      },
      getGutterElement: function () {
        return this.display.gutters;
      }
    };
    eventMixin(CodeMirror);
    CodeMirror.registerHelper = function (type, name, value) {
      if (!helpers.hasOwnProperty(type)) {
        helpers[type] = CodeMirror[type] = {
          _global: []
        };
      }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({
        pred: predicate,
        val: value
      });
    };
  };

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    function findNextLine() {
      var l = pos.line + dir;
      if (l < doc.first || l >= doc.first + doc.size) {
        return false;
      }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next;
      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir);
        } else {
          return false;
        }
      } else {
        pos = next;
      }
      return true;
    }
    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null,
        group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) {
          break;
        }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
        if (group && !first && !type) {
          type = "s";
        }
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
            pos.sticky = "after";
          }
          break;
        }
        if (type) {
          sawType = type;
        }
        if (dir > 0 && !moveOnce(!first)) {
          break;
        }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) {
      result.hitSide = true;
    }
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc,
      x = pos.left,
      y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) {
        break;
      }
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function (cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };
  ContentEditableInput.prototype.init = function (display) {
    var this$1 = this;
    var input = this,
      cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck);
    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) {
        setTimeout(operation(cm, function () {
          return this$1.updateFromDOM();
        }), 20);
      }
    });
    on(div, "compositionstart", function (e) {
      this$1.composing = {
        data: e.data,
        done: false
      };
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) {
        this$1.composing = {
          data: e.data,
          done: false
        };
      }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) {
          this$1.readFromDOMSoon();
        }
        this$1.composing.done = true;
      }
    });
    on(div, "touchstart", function () {
      return input.forceCompositionEnd();
    });
    on(div, "input", function () {
      if (!this$1.composing) {
        this$1.readFromDOMSoon();
      }
    });
    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({
          lineWise: false,
          text: cm.getSelections()
        });
        if (e.type == "cut") {
          cm.replaceSelection("", null, "cut");
        }
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({
          lineWise: true,
          text: ranges.text
        });
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return;
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(),
        te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) {
          input.showPrimarySelection();
        }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };
  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = this.cm.state.focused;
    return result;
  };
  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) {
      return;
    }
    if (info.focus || takeFocus) {
      this.showPrimarySelection();
    }
    this.showMultipleSelections(info);
  };
  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = window.getSelection(),
      cm = this.cm,
      prim = cm.doc.sel.primary();
    var from = prim.from(),
      to = prim.to();
    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return;
    }
    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
      return;
    }
    var view = cm.display.view;
    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
      node: view[0].measure.map[2],
      offset: 0
    };
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {
        node: map$$1[map$$1.length - 1],
        offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]
      };
    }
    if (!start || !end) {
      sel.removeAllRanges();
      return;
    }
    var old = sel.rangeCount && sel.getRangeAt(0),
      rng;
    try {
      rng = range(start.node, start.offset, end.offset, end.node);
    } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) {
        sel.addRange(old);
      } else if (gecko) {
        this.startGracePeriod();
      }
    }
    this.rememberSelection();
  };
  ContentEditableInput.prototype.startGracePeriod = function () {
    var this$1 = this;
    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged()) {
        this$1.cm.operation(function () {
          return this$1.cm.curOp.selectionChanged = true;
        });
      }
    }, 20);
  };
  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };
  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = window.getSelection();
    this.lastAnchorNode = sel.anchorNode;
    this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode;
    this.lastFocusOffset = sel.focusOffset;
  };
  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = window.getSelection();
    if (!sel.rangeCount) {
      return false;
    }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node);
  };
  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor()) {
        this.showSelection(this.prepareSelection(), true);
      }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () {
    this.div.blur();
  };
  ContentEditableInput.prototype.getField = function () {
    return this.div;
  };
  ContentEditableInput.prototype.supportsTouch = function () {
    return true;
  };
  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor()) {
      this.pollSelection();
    } else {
      runInOp(this.cm, function () {
        return input.cm.curOp.selectionChanged = true;
      });
    }
    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };
  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = window.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
  };
  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
      return;
    }
    var sel = window.getSelection(),
      cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({
        type: "keydown",
        keyCode: 8,
        preventDefault: Math.abs
      });
      this.blur();
      this.focus();
      return;
    }
    if (this.composing) {
      return;
    }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) {
      runInOp(cm, function () {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
        if (anchor.bad || head.bad) {
          cm.curOp.selectionChanged = true;
        }
      });
    }
  };
  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }
    var cm = this.cm,
      display = cm.display,
      sel = cm.doc.sel.primary();
    var from = sel.from(),
      to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine()) {
      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
    }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
      to = Pos(to.line + 1, 0);
    }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
      return false;
    }
    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }
    if (!fromNode) {
      return false;
    }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) {
        newText.pop();
        oldText.pop();
        toLine--;
      } else if (newText[0] == oldText[0]) {
        newText.shift();
        oldText.shift();
        fromLine++;
      } else {
        break;
      }
    }
    var cutFront = 0,
      cutEnd = 0;
    var newTop = newText[0],
      oldTop = oldText[0],
      maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
      ++cutFront;
    }
    var newBot = lst(newText),
      oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      ++cutEnd;
    }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }
    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true;
    }
  };
  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) {
      return;
    }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
    var this$1 = this;
    if (this.readDOMTimeout != null) {
      return;
    }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) {
          this$1.composing = null;
        } else {
          return;
        }
      }
      this$1.updateFromDOM();
    }, 80);
  };
  ContentEditableInput.prototype.updateFromDOM = function () {
    var this$1 = this;
    if (this.cm.isReadOnly() || !this.pollContent()) {
      runInOp(this.cm, function () {
        return regChange(this$1.cm);
      });
    }
  };
  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };
  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0) {
      return;
    }
    e.preventDefault();
    if (!this.cm.isReadOnly()) {
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    }
  };
  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };
  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};
  ContentEditableInput.prototype.needsContentAttribute = true;
  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) {
      return null;
    }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);
    var order = getOrder(line, cm.doc.direction),
      side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }
  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode) {
      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
        return true;
      }
    }
    return false;
  }
  function badPos(pos, bad) {
    if (bad) {
      pos.bad = true;
    }
    return pos;
  }
  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "",
      closing = false,
      lineSep = cm.doc.lineSeparator();
    function recognizeMarker(id) {
      return function (marker) {
        return marker.id == id;
      };
    }
    function close() {
      if (closing) {
        text += lineSep;
        closing = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          addText(cmText || node.textContent.replace(/\u200b/g, ""));
          return;
        }
        var markerID = node.getAttribute("cm-marker"),
          range$$1;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range$$1 = found[0].find(0))) {
            addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep));
          }
          return;
        }
        if (node.getAttribute("contenteditable") == "false") {
          return;
        }
        var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
        if (isBlock) {
          close();
        }
        for (var i = 0; i < node.childNodes.length; i++) {
          walk(node.childNodes[i]);
        }
        if (isBlock) {
          closing = true;
        }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue);
      }
    }
    for (;;) {
      walk(from);
      if (from == to) {
        break;
      }
      from = from.nextSibling;
    }
    return text;
  }
  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) {
        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      }
      node = null;
      offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) {
          return null;
        }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
          break;
        }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode) {
        return locateNodeInLineView(lineView, node, offset);
      }
    }
  }
  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild,
      bad = false;
    if (!node || !contains(wrapper, node)) {
      return badPos(Pos(lineNo(lineView.line), 0), true);
    }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }
    var textNode = node.nodeType == 3 ? node : null,
      topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) {
        offset = textNode.nodeValue.length;
      }
    }
    while (topNode.parentNode != wrapper) {
      topNode = topNode.parentNode;
    }
    var measure = lineView.measure,
      maps = measure.maps;
    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;
            if (offset < 0 || curNode != textNode) {
              ch = map$$1[j + (offset ? 1 : 0)];
            }
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) {
      return badPos(found, bad);
    }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found) {
        return badPos(Pos(found.line, found.ch - dist), bad);
      } else {
        dist += after.textContent.length;
      }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found) {
        return badPos(Pos(found.line, found.ch + dist$1), bad);
      } else {
        dist$1 += before.textContent.length;
      }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function (cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };
  TextareaInput.prototype.init = function (display) {
    var this$1 = this;
    var input = this,
      cm = this.cm;

    // Wraps and hides input textarea
    var div = this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    var te = this.textarea = div.firstChild;
    display.wrapper.insertBefore(div, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) {
      te.style.width = "0px";
    }
    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) {
        this$1.hasSelection = null;
      }
      input.poll();
    });
    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }
      cm.state.pasteIncoming = true;
      input.fastPoll();
    });
    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({
          lineWise: false,
          text: cm.getSelections()
        });
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({
          lineWise: true,
          text: ranges.text
        });
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") {
        cm.state.cutIncoming = true;
      }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);
    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
        return;
      }
      cm.state.pasteIncoming = true;
      input.focus();
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) {
        e_preventDefault(e);
      }
    });
    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) {
        input.composing.range.clear();
      }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {
          className: "CodeMirror-composing"
        })
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };
  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm,
      display = cm.display,
      doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(),
        lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
    }
    return result;
  };
  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm,
      display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) {
      return;
    }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) {
        selectInput(this.textarea);
      }
      if (ie && ie_version >= 9) {
        this.hasSelection = content;
      }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
    }
  };
  TextareaInput.prototype.getField = function () {
    return this.textarea;
  };
  TextareaInput.prototype.supportsTouch = function () {
    return false;
  };
  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try {
        this.textarea.focus();
      } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () {
    this.textarea.blur();
  };
  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };
  TextareaInput.prototype.receivedFocus = function () {
    this.slowPoll();
  };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
    var this$1 = this;
    if (this.pollingFast) {
      return;
    }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) {
        this$1.slowPoll();
      }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false,
      input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {
        missed = true;
        input.polling.set(60, p);
      } else {
        input.pollingFast = false;
        input.slowPoll();
      }
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
    var this$1 = this;
    var cm = this.cm,
      input = this.textarea,
      prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
      return false;
    }
    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) {
      return false;
    }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false;
    }
    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) {
        prevInput = "\u200b";
      }
      if (first == 0x21da) {
        this.reset();
        return this.cm.execCommand("undo");
      }
    }
    // Find the part of the input that is actually new
    var same = 0,
      l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
      ++same;
    }
    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) {
        input.value = this$1.prevInput = "";
      } else {
        this$1.prevInput = text;
      }
      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
          className: "CodeMirror-composing"
        });
      }
    });
    return true;
  };
  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) {
      this.pollingFast = false;
    }
  };
  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) {
      this.hasSelection = null;
    }
    this.fastPoll();
  };
  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this,
      cm = input.cm,
      display = cm.display,
      te = input.textarea;
    var pos = posFromMouse(cm, e),
      scrollPos = display.scroller.scrollTop;
    if (!pos || presto) {
      return;
    } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1) {
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
    }
    var oldCSS = te.style.cssText,
      oldWrapperCSS = input.wrapper.style.cssText;
    input.wrapper.style.cssText = "position: absolute";
    var wrapperBox = input.wrapper.getBoundingClientRect();
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) {
      oldScrollY = window.scrollY;
    } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) {
      window.scrollTo(null, oldScrollY);
    }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) {
      te.value = input.prevInput = " ";
    }
    input.contextMenuPending = true;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1;
        te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) {
        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
      }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || ie && ie_version < 9) {
          prepareSelectAllHack();
        }
        var i = 0,
          poll = function () {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b") {
              operation(cm, selectAll)(cm);
            } else if (i++ < 10) {
              display.detectingSelectAll = setTimeout(poll, 500);
            } else {
              display.selForContextMenu = null;
              display.input.reset();
            }
          };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (ie && ie_version >= 9) {
      prepareSelectAllHack();
    }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };
  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) {
      this.reset();
    }
    this.textarea.disabled = val == "nocursor";
  };
  TextareaInput.prototype.setUneditable = function () {};
  TextareaInput.prototype.needsContentAttribute = false;
  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex) {
      options.tabindex = textarea.tabIndex;
    }
    if (!options.placeholder && textarea.placeholder) {
      options.placeholder = textarea.placeholder;
    }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch (e) {}
      }
    }
    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () {
        return textarea;
      };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function") {
            textarea.form.submit = realSubmit;
          }
        }
      };
    };
    textarea.style.display = "none";
    var cm = CodeMirror$1(function (node) {
      return textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  }
  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror$1);
  addEditorMethods(CodeMirror$1);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) {
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
      CodeMirror$1.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
    }
  }
  eventMixin(Doc);

  // INPUT HANDLING

  CodeMirror$1.inputStyles = {
    "textarea": TextareaInput,
    "contenteditable": ContentEditableInput
  };

  // MODE DEFINITION AND QUERYING

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror$1.defineMode = function (name /*, mode, …*/) {
    if (!CodeMirror$1.defaults.mode && name != "null") {
      CodeMirror$1.defaults.mode = name;
    }
    defineMode.apply(this, arguments);
  };
  CodeMirror$1.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror$1.defineMode("null", function () {
    return {
      token: function (stream) {
        return stream.skipToEnd();
      }
    };
  });
  CodeMirror$1.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror$1.defineExtension = function (name, func) {
    CodeMirror$1.prototype[name] = func;
  };
  CodeMirror$1.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror$1.fromTextArea = fromTextArea;
  addLegacyProps(CodeMirror$1);
  CodeMirror$1.version = "5.34.0";
  return CodeMirror$1;
});

/***/ }),

/***/ "./scripts/3rdparty-custom-fixes/codemirror/addons/lint/tooltip.css":
/*!**************************************************************************!*\
  !*** ./scripts/3rdparty-custom-fixes/codemirror/addons/lint/tooltip.css ***!
  \**************************************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty-custom-fixes/codemirror/magicss-codemirror.css":
/*!*************************************************************************!*\
  !*** ./scripts/3rdparty-custom-fixes/codemirror/magicss-codemirror.css ***!
  \*************************************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/colorpicker/colorpicker.css":
/*!************************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/colorpicker/colorpicker.css ***!
  \************************************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/hint/show-hint.css":
/*!***************************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/hint/show-hint.css ***!
  \***************************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty/codemirror/addons/lint/lint.css":
/*!**********************************************************!*\
  !*** ./scripts/3rdparty/codemirror/addons/lint/lint.css ***!
  \**********************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty/codemirror/codemirror.css":
/*!****************************************************!*\
  !*** ./scripts/3rdparty/codemirror/codemirror.css ***!
  \****************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty/codemirror/theme/ambiance.css":
/*!********************************************************!*\
  !*** ./scripts/3rdparty/codemirror/theme/ambiance.css ***!
  \********************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty/jquery-ui_customized.css":
/*!***************************************************!*\
  !*** ./scripts/3rdparty/jquery-ui_customized.css ***!
  \***************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty/magicsuggest/magicsuggest.css":
/*!********************************************************!*\
  !*** ./scripts/3rdparty/magicsuggest/magicsuggest.css ***!
  \********************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty/toastr/toastr.css":
/*!********************************************!*\
  !*** ./scripts/3rdparty/toastr/toastr.css ***!
  \********************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/3rdparty/tooltipster/tooltipster.css":
/*!******************************************************!*\
  !*** ./scripts/3rdparty/tooltipster/tooltipster.css ***!
  \******************************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/magicss/editor/editor.css":
/*!*******************************************!*\
  !*** ./scripts/magicss/editor/editor.css ***!
  \*******************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./scripts/magicss/magicss.css":
/*!*************************************!*\
  !*** ./scripts/magicss/magicss.css ***!
  \*************************************/
/***/ (() => {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../node_modules/helpmate-css/dist/format/csspretty.js":
/*!*************************************************************!*\
  !*** ../node_modules/helpmate-css/dist/format/csspretty.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "csspretty": () => (/* binding */ csspretty)
/* harmony export */ });
const csspretty = function (options) {
  var token = [],
    types = [],
    lines = [],
    uri = [],
    colors = [],
    output = "",
    endline = !1,
    objsortop = !1,
    verticalop = !1,
    colorNames = {
      aliceblue: .9288006825347457,
      antiquewhite: .8464695170775405,
      aqua: .7874,
      aquamarine: .8078549208338043,
      azure: .9726526495416643,
      beige: .8988459998705021,
      bisque: .8073232737297876,
      black: 0,
      blanchedalmond: .8508443960815607,
      blue: .0722,
      blueviolet: .12622014321946043,
      brown: .09822428787651079,
      burlywood: .5155984453389335,
      cadetblue: .29424681085422044,
      chartreuse: .7603202590262282,
      chocolate: .23898526114557292,
      coral: .3701793087292368,
      cornflowerblue: .30318641994179363,
      cornsilk: .9356211037296492,
      crimson: .16042199953025577,
      cyan: .7874,
      darkblue: .018640801980939217,
      darkcyan: .2032931783904645,
      darkgoldenrod: .27264703559992554,
      darkgray: .39675523072562674,
      darkgreen: .09114342904757505,
      darkgrey: .39675523072562674,
      darkkhaki: .45747326349994155,
      darkmagenta: .07353047651207048,
      darkolivegreen: .12651920884889156,
      darkorange: .40016167026523863,
      darkorchid: .1341314217485677,
      darkred: .05488967453113126,
      darksalmon: .4054147156338075,
      darkseagreen: .43789249325969054,
      darkslateblue: .06579284622798763,
      darkslategray: .06760815192804355,
      darkslategrey: .06760815192804355,
      darkturquoise: .4874606277449034,
      darkviolet: .10999048339343433,
      deeppink: .2386689582827583,
      deepskyblue: .444816033955754,
      dimgray: .14126329114027164,
      dimgrey: .14126329114027164,
      dodgerblue: .2744253699145608,
      firebrick: .10724525535015225,
      floralwhite: .9592248482500424,
      forestgreen: .18920812076002244,
      fuchsia: .2848,
      gainsboro: .7156935005064806,
      ghostwhite: .9431126188632283,
      gold: .6986087742815887,
      goldenrod: .41919977809568404,
      gray: .21586050011389915,
      green: .15438342968146068,
      greenyellow: .8060947261145331,
      grey: .21586050011389915,
      honeydew: .9633653555478173,
      hotpink: .3465843816971475,
      indianred: .21406134963884,
      indigo: .031075614863369846,
      ivory: .9907127060061531,
      khaki: .7701234339412052,
      lavendar: .8031875051452125,
      lavendarblush: .9017274863104644,
      lawngreen: .7390589312496334,
      lemonchiffon: .9403899224562171,
      lightblue: .6370914128080659,
      lightcoral: .35522120733134843,
      lightcyan: .9458729349482863,
      lightgoldenrodyellow: .9334835101829635,
      lightgray: .651405637419824,
      lightgreen: .6909197995686475,
      lightgrey: .651405637419824,
      lightpink: .5856615273489745,
      lightsalmon: .47806752252059587,
      lightseagreen: .3505014511704197,
      lightskyblue: .5619563761833096,
      lightslategray: .23830165007286924,
      lightslategrey: .23830165007286924,
      lightyellow: .9816181839288161,
      lime: .7152,
      limegreen: .44571042246097864,
      linen: .8835734098437936,
      magenta: .2848,
      maroon: .04589194232421496,
      mediumaquamarine: .4938970331080111,
      mediumblue: .04407778021232784,
      mediumorchid: .21639251153773428,
      mediumpurple: .22905858091648004,
      mediumseagreen: .34393112338131226,
      mediumslateblue: .20284629471622434,
      mediumspringgreen: .7070430819418444,
      mediumturquois: .5133827926447991,
      mediumvioletred: .14371899849357186,
      midnightblue: .020717866350860484,
      mintcream: .9783460494758793,
      mistyrose: .8218304785918541,
      moccasin: .8008300099156694,
      navajowhite: .7651968234278562,
      navy: .015585128108223519,
      oldlace: .9190063340554899,
      olive: .20027537200567563,
      olivedrab: .2259315095192918,
      orange: .48170267036309605,
      orangered: .2551624375341641,
      orchid: .3134880676143873,
      palegoldenrod: .7879264788761452,
      palegreen: .7793675900635259,
      paleturquoise: .764360779217138,
      palevioletred: .2875499411788909,
      papayawhip: .8779710019983541,
      peachpuff: .7490558987825108,
      peru: .3011307487793569,
      pink: .6327107070246611,
      plum: .4573422158796909,
      powderblue: .6825458650060524,
      purple: .061477070432438476,
      red: .2126,
      rosyblue: .3231945764940708,
      royalblue: .16663210743188323,
      saddlebrown: .09792228502052071,
      salmon: .3697724152759545,
      sandybrown: .46628543696283414,
      seagreen: .1973419970627483,
      seashell: .927378622069223,
      sienna: .13697631337097677,
      silver: .527115125705813,
      skyblue: .5529166851818412,
      slateblue: .14784278062136097,
      slategray: .20896704076536138,
      slategrey: .20896704076536138,
      slightsteelblue: .5398388828466575,
      snow: .9653334183484877,
      springgreen: .7305230606852947,
      steelblue: .20562642207624846,
      tan: .48237604163921527,
      teal: .1699685577896842,
      thistle: .5681840109373312,
      tomato: .3063861271941505,
      turquoise: .5895536427577983,
      violet: .40315452986676303,
      wheat: .7490970282048214,
      white: 1,
      whitesmoke: .913098651793419,
      yellow: .9278,
      yellowgreen: .5076295720870697
    },
    stats = {
      braces: 0,
      colon: 0,
      comments: {
        chars: 0,
        count: 0
      },
      properties: {
        chars: 0,
        count: 0
      },
      selectors: {
        chars: 0,
        count: 0
      },
      semi: 0,
      space: 0,
      values: {
        chars: 0,
        count: 0
      },
      variables: {
        chars: 0,
        count: 0
      }
    },
    lf = !0 === options.crlf || "true" === options.crlf ? "\r\n" : "\n";
  !function () {
    objsortop = !0 === options.objsort || "true" === options.objsort || "all" === options.objsort || "css" === options.objsort;
    options.accessibility = !0 === options.accessibility || "true" === options.accessibility;
    options.braces = !0 === options.braces || "allman" === options.braces;
    options.compressedcss = !0 === options.compressedcss || "true" === options.compressedcss;
    options.cssinsertlines = !0 === options.cssinsertlines || "true" === options.cssinsertlines;
    options.diffcomm = !0 === options.diffcomm || "true" === options.diffcomm;
    options.inchar = "string" != typeof options.inchar || "" === options.inchar ? " " : options.inchar;
    options.inlevel = !0 === isNaN(options.inlevel) ? 0 : Number(options.inlevel);
    options.insize = !0 === isNaN(options.insize) ? 4 : Number(options.insize);
    options.mode = "minify" === options.mode || "parse" === options.mode || "diff" === options.mode ? options.mode : "beautify";
    options.noleadzero = !0 === options.noleadzero || "true" === options.noleadzero;
    options.preserve = 1 === options.preserve || void 0 === options.preserve || !0 === options.preserve || "all" === options.preserve || "js" === options.preserve || "css" === options.preserve ? 1 : !1 === options.preserve || !0 === isNaN(options.preserve) || Number(options.preserve) < 1 || "none" === options.preserve ? 0 : Number(options.preserve);
    options.quoteConvert = "single" === options.quoteConvert || "double" === options.quoteConvert ? options.quoteConvert : "none";
    options.selectorlist = !0 === options.selectorlist || "true" === options.selectorlist;
    options.source = "string" != typeof options.source || "" === options.source || !0 === /^(\s+)$/.test(options.source) ? "Error: no source supplied to csspretty." : options.source.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    options.topcoms = !0 === options.topcoms || "true" === options.topcoms;
    verticalop = !0 === options.vertical || "true" === options.vertical || "all" === options.vertical || "css" === options.vertical;
    !0 === options.compressedcss && (verticalop = !1);
  }();
  if ("Error: no source supplied to csspretty." === options.source) return options.source;
  !function () {
    var a = 0,
      b = options.source.split(""),
      len = options.source.length,
      ltype = "",
      itemsize = 0,
      space = "",
      endtest = !1,
      spacecol = !1,
      nosort = [],
      spacer = function (end) {
        var slen = space.split(lf).length - 1,
          value = 0;
        0 === token.length && slen > 0 && (slen += 1);
        slen > 0 && options.preserve > 0 ? value = slen > options.preserve ? options.preserve + 1 : slen : space.length > 1 ? value = 1 : 0 === slen && "comment" === types[types.length - 1] && "comment" !== types[types.length - 2] && (types[types.length - 1] = "comment-inline");
        if (slen > 1 && !0 === end && options.preserve > 0) {
          endline = !0;
          space = "";
          return value;
        }
        space = "";
        return value;
      },
      objSort = function () {
        var cc = 0,
          dd = 0,
          ee = 0,
          startlen = token.length - 1,
          end = startlen,
          keys = [],
          keylen = 0,
          keyend = 0,
          start = 0,
          sort = function (x, y) {
            var xx = x[0],
              yy = y[0];
            if ("comment" === types[xx] || "comment-inline" === types[xx]) do {
              xx += 1;
            } while (xx < startlen && ("comment" === types[xx] || "comment-inline" === types[xx]));
            if ("comment" === types[yy] || "comment-inline" === types[yy]) do {
              yy += 1;
            } while (yy < startlen && ("comment" === types[yy] || "comment-inline" === types[yy]));
            return types[xx] < types[yy] || types[xx] === types[yy] && token[xx].toLowerCase() < token[yy].toLowerCase() ? -1 : 1;
          },
          semiTest = !0,
          pairToken = [],
          pairTypes = [],
          pairLines = [];
        if ("comment" === types[end] || "comment-inline" === types[end]) do {
          end -= 1;
        } while (end > 0 && ("comment" === types[end] || "comment-inline" === types[end]));
        for (cc = startlen; cc > -1; cc -= 1) {
          "end" === types[cc] && (dd += 1);
          "start" === types[cc] && (dd -= 1);
          if (0 === dd && ("property" === types[cc] || "selector" === types[cc] || "propvar" === types[cc]) && "property" !== types[cc - 1] && "selector" !== types[cc - 1]) {
            start = cc;
            "comment-inline" === types[end + 1] && (end += 1);
            if ("comment" === types[start - 1]) do {
              start -= 1;
            } while (start > -1 && "comment" === types[start - 1]);
            keys.push([start, end + 1, !1]);
            end = start - 1;
          }
          if (dd < 0 && cc < startlen) {
            if (keys.length > 1 && ("selector" === types[cc - 1] || "=" === token[cc - 1] || ":" === token[cc - 1] || "[" === token[cc - 1] || "{" === token[cc - 1] || "," === token[cc - 1] || 0 === cc)) {
              keys.sort(sort);
              keylen = keys.length;
              semiTest = !1;
              for (dd = 0; dd < keylen; dd += 1) {
                keyend = keys[dd][1];
                for (ee = keys[dd][0]; ee < keyend; ee += 1) {
                  pairToken.push(token[ee]);
                  pairTypes.push(types[ee]);
                  pairLines.push(lines[ee]);
                  ";" === token[ee] || "}" === token[ee] ? semiTest = !0 : ";" !== token[ee] && "}" !== token[ee] && "comment" !== types[ee] && "comment-inline" !== types[ee] && (semiTest = !1);
                }
                if (!1 === semiTest) {
                  if ("comment" === pairTypes[ee = pairTypes.length - 1] || "comment-inline" === pairTypes[ee]) do {
                    ee -= 1;
                  } while (ee > 0 && ("comment" === pairTypes[ee] || "comment-inline" === pairTypes[ee]));
                  ee += 1;
                  pairToken.splice(ee, 0, ";");
                  pairTypes.splice(ee, 0, "semi");
                  if (pairLines[ee - 1] > 0) {
                    pairLines[ee - 1] = 0;
                    pairLines.splice(ee, 0, 1);
                  } else pairLines.splice(ee, 0, 0);
                }
              }
              if ("comment" === pairTypes[ee = pairTypes.length - 1] || "comment-inline" === pairTypes[ee]) do {
                ee -= 1;
              } while (ee > 0 && ("comment" === pairTypes[ee] || "comment-inline" === pairTypes[ee]));
              keylen = token.length - (cc + 1);
              token.splice(cc + 1, keylen);
              types.splice(cc + 1, keylen);
              lines.splice(cc + 1, keylen);
              token = token.concat(pairToken);
              types = types.concat(pairTypes);
              lines = lines.concat(pairLines);
            }
            return;
          }
        }
      },
      item = function (type) {
        var aa = token.length,
          bb = 0,
          coms = [],
          value = function (val, font) {
            var x = val.split(""),
              leng = x.length,
              cc = 0,
              dd = 0,
              items = [],
              block = "",
              values = [],
              qchar = "",
              colorPush = function (value) {
                var vl = value.toLowerCase();
                (!0 === /^(#[0-9a-f]{3,6})$/.test(vl) || !0 === /^(rgba?\()/.test(vl) || void 0 !== colorNames[vl]) && colors.push(value);
                return value;
              };
            "double" === options.quoteConvert ? qchar = '"' : "single" === options.quoteConvert && (qchar = "'");
            for (cc = 0; cc < leng; cc += 1) {
              items.push(x[cc]);
              if ("" === block) {
                if ('"' === x[cc]) {
                  block = '"';
                  dd += 1;
                } else if ("'" === x[cc]) {
                  block = "'";
                  dd += 1;
                } else if ("(" === x[cc]) {
                  block = ")";
                  dd += 1;
                } else if ("[" === x[cc]) {
                  block = "]";
                  dd += 1;
                }
              } else "(" === x[cc] && ")" === block || "[" === x[cc] && "]" === block ? dd += 1 : x[cc] === block && 0 === (dd -= 1) && (block = "");
              if ("" === block && " " === x[cc]) {
                items.pop();
                values.push(colorPush(items.join("")));
                items = [];
              }
            }
            values.push(colorPush(items.join("")));
            leng = values.length;
            for (cc = 0; cc < leng; cc += 1) if (!1 === options.noleadzero && !0 === /^(\.\d)/.test(values[cc])) values[cc] = "0" + values[cc];else if (!0 === options.noleadzero && /^(0+\.)/.test(values[cc])) values[cc] = values[cc].replace(/^(0+\.)/, ".");else if (!0 === /^(0+([a-z]{2,3}|%))$/.test(values[cc])) values[cc] = "0";else if (!0 === /^(0+)/.test(values[cc])) {
              values[cc] = values[cc].replace(/0+/, "0");
              !0 === /\d/.test(values[cc].charAt(1)) && (values[cc] = values[cc].substr(1));
            } else !0 === /^url\((?!\$)/.test(values[cc]) && ")" === values[cc].charAt(values[cc].length - 1) ? "" === qchar && !1 === /url\(('|")/.test(values[cc]) ? values[cc] = values[cc].replace(/url\(('|")?/, 'url("').replace(/(('|")?\))$/, '")') : "" !== qchar && (values[cc] = values[cc].replace(/url\(('|")?/, "url(" + qchar).replace(/(('|")?\))$/, qchar + ")")) : !0 === font ? values[cc] = "'" === qchar ? values[cc].replace(/"/g, "'") : values[cc].replace(/'/g, '"') : !1 === font && "" !== qchar && ('"' === qchar && "'" === values[cc].charAt(0) && "'" === values[cc].charAt(values[cc].length - 1) || "'" === qchar && '"' === values[cc].charAt(0) && '"' === values[cc].charAt(values[cc].length - 1)) && (values[cc] = qchar + values[cc].slice(1, values[cc].length - 1) + qchar);
            return values.join(" ");
          };
        if ("comment" === ltype || "comment-inline" === ltype) do {
          ltype = types[aa -= 1];
          coms.push(token[aa]);
        } while (aa > 0 && ("comment" === ltype || "comment-inline" === ltype));else aa -= 1;
        if ("item" === ltype && types[aa].indexOf("external") < 0) if ("start" === type) {
          stats.selectors.count += 1;
          stats.selectors.chars += itemsize;
          "comment" !== types[aa - 1] && "comment-inline" !== types[aa - 1] && "end" !== types[aa - 1] && "start" !== types[aa - 1] && "semi" !== types[aa - 1] && void 0 !== types[aa - 1] && types[aa - 1].indexOf("external") < 0 ? function () {
            var dd,
              parts = [],
              cc = aa;
            do {
              parts.push(token[cc]);
              !0 === spacecol && ":" === token[cc] && ":" !== token[cc - 1] && parts.push(" ");
              cc -= 1;
            } while (cc > -1 && "comment" !== types[cc] && "comment-inline" !== types[cc] && "end" !== types[cc] && "start" !== types[cc] && "semi" !== types[cc] && void 0 !== types[cc]);
            parts.reverse();
            dd = aa - (cc += 1);
            token.splice(cc, dd);
            types.splice(cc, dd);
            lines.splice(cc, dd);
            token[aa -= dd] = parts.join("").replace(/\s*,(\s*)/g, ",");
          }() : token[aa] = token[aa].replace(/\s*,(\s*)/g, ",");
          types[aa] = "selector";
        } else if ("end" === type) {
          types[aa] = "value";
          "diff" !== options.mode && ("none" === options.quoteConvert || "font" !== token[aa - 2] && "font-family" !== token[aa - 2] ? token[aa] = value(token[aa], !1) : token[aa] = value(token[aa], !0));
          if ("beautify" === options.mode || "diff" === options.mode && !0 === options.diffcomm) if ("{" === token[token.length - 2]) {
            types[types.length - 1] = "propvar";
            stats.values.count -= 1;
            stats.values.chars -= itemsize;
            stats.variables.count += 1;
            stats.variables.chars += itemsize;
          } else if (coms.length > 0 && "semi" !== ltype && "end" !== ltype && "start" !== ltype) {
            aa = coms.length - 1;
            do {
              token.pop();
              types.pop();
              lines.pop();
              aa -= 1;
            } while (aa > 0);
            "diff" === options.mode ? token.push("x;") : token.push(";");
            types.push("semi");
            lines.push(spacer(!1));
            bb = coms.length - 1;
            do {
              token.push(coms[aa]);
              0 === coms[aa].indexOf("//") && 0 === lines[lines.length - 1] ? types.push("comment-inline") : types.push("comment");
              lines.push(0);
              aa += 1;
            } while (aa < bb);
          } else {
            "diff" === options.mode ? token.push("x;") : token.push(";");
            types.push("semi");
            lines.push(spacer(!1));
          }
          stats.values.count += 1;
          stats.values.chars += itemsize;
        } else if ("semi" === type) {
          if ("colon" === types[aa - 1]) {
            stats.values.count += 1;
            stats.values.chars += itemsize;
            types[aa] = "value";
            "diff" !== options.mode && ("none" === options.quoteConvert || "font" !== token[aa - 2] && "font-family" !== token[aa - 2] ? token[aa] = value(token[aa], !1) : token[aa] = value(token[aa], !0));
          } else {
            types[aa] = "propvar";
            stats.variables.count += 1;
            stats.variables.chars += itemsize;
          }
        } else if ("colon" === type) {
          types[aa] = "property";
          stats.properties.count += 1;
          stats.properties.chars += itemsize;
        }
      },
      external = function (open, end) {
        var store = [],
          quote = "",
          name = "",
          endlen = 0,
          start = open.length,
          linev = spacer(!1);
        nosort[nosort.length - 1] = !0;
        for (; a < len; a += 1) {
          store.push(b[a]);
          if ("" === quote) {
            if ('"' === b[a]) quote = '"';else if ("'" === b[a]) quote = "'";else if ("/" === b[a]) "/" === b[a + 1] ? quote = "/" : "*" === b[a + 1] && (quote = "*");else if (b[a + 1] === end.charAt(0)) {
              do {
                endlen += 1;
                a += 1;
                store.push(b[a]);
              } while (a < len && endlen < end.length && b[a + 1] === end.charAt(endlen));
              if (endlen === end.length) {
                quote = store.join("");
                if (!0 === /\s/.test(quote.charAt(start))) do {
                  start += 1;
                } while (!0 === /\s/.test(quote.charAt(start)));
                endlen = start;
                do {
                  endlen += 1;
                } while (endlen < end.length && !1 === /\s/.test(quote.charAt(endlen)));
                endlen === quote.length && (endlen -= end.length);
                "{%" === open && (quote = quote.replace(/^(\{%\s*)/, "{% ").replace(/(\s*%\})$/, " %}"));
                lines.push(linev);
                token.push(quote);
                if ("{%" === open) {
                  store = ["autoescape", "block", "capture", "case", "comment", "embed", "filter", "for", "form", "if", "macro", "raw", "sandbox", "spaceless", "tablerow", "unless", "verbatim"];
                  if ("else" === (name = (name = quote.slice(3)).slice(0, name.indexOf(" "))) || "elseif" === name || "when" === name) return types.push("external_else");
                  for (endlen = store.length - 1; endlen > -1; endlen -= 1) {
                    if (name === store[endlen]) return types.push("external_start");
                    if (name === "end" + store[endlen]) return types.push("external_end");
                  }
                }
                return types.push("external");
              }
              endlen = 0;
            }
          } else quote === b[a] && ('"' === quote || "'" === quote ? quote = "" : "/" !== quote || "\r" !== b[a] && "\n" !== b[a] ? "*" === quote && "/" === b[a + 1] && (quote = "") : quote = "");
        }
      },
      comment = function (inline) {
        var type,
          aa = 0,
          out = [b[a]],
          spareType = [],
          spareToke = [],
          spareLine = [],
          linev = spacer(!1);
        type = !0 === inline && 0 === linev ? "comment-inline" : "comment";
        for (aa = a + 1; aa < len; aa += 1) {
          out.push(b[aa]);
          if (!1 === inline && "*" === b[aa - 1] && "/" === b[aa] || !0 === inline && "\n" === b[aa + 1]) break;
        }
        a = aa;
        stats.comments.count += 1;
        stats.comments.chars += out.length;
        "minify" === options.mode && out.push("\n");
        if ("beautify" === options.mode || "diff" === options.mode && !0 === options.diffcomm || "minify" === options.mode && !0 === options.topcoms) if (token.length > 0 && "," === token[token.length - 1].charAt(token[token.length - 1].length - 1) && "comment" !== types[types.length - 1] && "comment-inline" !== types[types.length - 1]) {
          spareToke.push(token[token.length - 1]);
          token.pop();
          types.pop();
          lines.pop();
          token.push(out.join(""));
          types.push(type);
          lines.push(linev);
          token.push(spareToke[0]);
          types.push("selector");
          lines.push(0);
        } else if ("colon" === ltype || "property" === ltype || "value" === ltype || "propvar" === ltype) {
          do {
            spareToke.push(token[token.length - 1]);
            spareType.push(types[types.length - 1]);
            spareLine.push(lines[lines.length - 1]);
            token.pop();
            types.pop();
            lines.pop();
          } while (types.length > 1 && "semi" !== types[types.length - 1] && "start" !== types[types.length - 1]);
          token.push(out.join(""));
          types.push(type);
          lines.push(linev);
          do {
            token.push(spareToke[spareToke.length - 1]);
            types.push(spareType[spareType.length - 1]);
            lines.push(spareLine[spareLine.length - 1]);
            spareToke.pop();
            spareType.pop();
            spareLine.pop();
          } while (spareToke.length > 0);
        } else {
          ltype = type;
          types.push(type);
          token.push(out.join(""));
          lines.push(linev);
        }
      },
      buildtoken = function () {
        var aa = 0,
          bb = 0,
          out = [],
          block = "",
          comma = token.length > 0 && "," === token[token.length - 1].charAt(token[token.length - 1].length - 1),
          linev = spacer(!1);
        for (aa = a; aa < len; aa += 1) {
          out.push(b[aa]);
          if ("" === block) {
            if ('"' === b[aa]) {
              block = '"';
              bb += 1;
            } else if ("'" === b[aa]) {
              block = "'";
              bb += 1;
            } else if ("(" === b[aa]) {
              block = ")";
              bb += 1;
            } else if ("[" === b[aa]) {
              block = "]";
              bb += 1;
            } else if ("#" === b[aa] && "{" === b[aa + 1]) {
              block = "}";
              bb += 1;
            }
          } else "(" === b[aa] && ")" === block || "[" === b[aa] && "]" === block ? bb += 1 : b[aa] === block && 0 === (bb -= 1) && (block = "");
          if ("" === block && "\\" !== b[aa] && (";" === b[aa + 1] || ":" === b[aa + 1] || "}" === b[aa + 1] || "{" === b[aa + 1] || "/" === b[aa + 1] && ("*" === b[aa + 2] || "/" === b[aa + 2]))) break;
        }
        a = aa;
        itemsize = out.length;
        if (!0 !== comma || "comment" === types[types.length - 1] || "comment-inline" === types[types.length - 1]) {
          token.push(out.join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, ""));
          lines.push(linev);
          if (0 === token[token.length - 1].indexOf("extend(")) {
            ltype = "pseudo";
            types.push("pseudo");
          } else {
            ltype = "item";
            types.push("item");
          }
        } else token[token.length - 1] = token[token.length - 1] + out.join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "");
      },
      properties = function () {
        var aa = 0,
          bb = 1,
          cc = 0,
          dd = 0,
          p = [],
          set = [[]],
          next = 0,
          stoke = [],
          stype = [],
          sline = [];
        for (aa = token.length - 1; aa > -1; aa -= 1) {
          if ("start" === types[aa] && 0 === (bb -= 1)) {
            next = aa;
            set.pop();
            for (aa = set.length - 1; aa > -1; aa -= 1) set[aa].reverse();
            break;
          }
          "end" === types[aa] && (bb += 1);
          1 === bb && "property" === types[aa] && "beautify" === options.mode && p.push(aa);
          set[set.length - 1].push(aa);
          1 !== bb || "comment" !== types[aa - 1] && "comment-inline" !== types[aa - 1] && "semi" !== types[aa - 1] && "end" !== types[aa - 1] && "start" !== types[aa - 1] || "start" === types[aa] || "end" === types[aa] || set.push([]);
        }
        set.reverse();
        p.reverse();
        !function () {
          var leng = set.length,
            fourcount = function (name) {
              for (var test = [!1, !1, !1, !1], value = ["0", "0", "0", "0"], zero = /^(0+([a-z]+|%))/, start = aa, yy = -1, zz = 0, valsplit = [], important = !1, store = function (side) {
                  yy += 1;
                  value[side] = token[set[aa][2]];
                  test[side] = !0;
                  start < 0 && (start = aa);
                }; aa < leng; aa += 1) {
                if (void 0 !== token[set[aa][2]] && 0 === token[set[aa][0]].indexOf(name)) {
                  if (token[set[aa][2]].indexOf("!important") > -1) {
                    important = !0;
                    token[set[aa][2]] = token[set[aa][2]].replace(/\s*!important/, "");
                  }
                  if (token[set[aa][0]] === name || 0 === token[set[aa][0]].indexOf(name + " ")) {
                    yy += 1;
                    if (1 === (valsplit = token[set[aa][2]].split(" ")).length) value = [token[set[aa][2]], token[set[aa][2]], token[set[aa][2]], token[set[aa][2]]];else if (2 === valsplit.length) value = [valsplit[0], valsplit[1], valsplit[0], valsplit[1]];else if (3 === valsplit.length) value = [valsplit[0], valsplit[1], valsplit[2], valsplit[1]];else {
                      if (4 !== valsplit.length) return;
                      value = [valsplit[0], valsplit[1], valsplit[2], valsplit[3]];
                    }
                    test = [!0, !0, !0, !0];
                  } else 0 === token[set[aa][0]].indexOf(name + "-bottom") ? store(2) : 0 === token[set[aa][0]].indexOf(name + "-left") ? store(3) : 0 === token[set[aa][0]].indexOf(name + "-right") ? store(1) : 0 === token[set[aa][0]].indexOf(name + "-top") && store(0);
                }
                if (void 0 === set[aa + 1] || token[set[aa + 1][0]].indexOf(name) < 0 || aa === leng - 1) {
                  if (!0 === test[0] && !0 === test[1] && !0 === test[2] && !0 === test[3]) {
                    set.splice(start + 1, yy);
                    leng -= yy;
                    aa -= yy;
                    zz = 0;
                    bb = p.length;
                    do {
                      if (p[zz] === set[start][0]) break;
                      zz += 1;
                    } while (zz < bb);
                    zz < bb && p.splice(zz + 1, yy);
                    token[set[start][0]] = name;
                    !0 === zero.test(value[0]) && (value[0] = "0");
                    !0 === zero.test(value[1]) && (value[1] = "0");
                    !0 === zero.test(value[2]) && (value[2] = "0");
                    !0 === zero.test(value[3]) && (value[3] = "0");
                    if (value[1] === value[3]) {
                      value.pop();
                      if (value[0] === value[2]) {
                        value.pop();
                        value[0] === value[1] && value.pop();
                      }
                    }
                    token[set[start][2]] = value.join(" ");
                    if ("beautify" === options.mode && !0 === verticalop && " " === token[set[start][0]].charAt(token[set[start][0]].length - 1)) {
                      yy = token[set[start][0]].length - name.length;
                      do {
                        name += " ";
                        yy -= 1;
                      } while (yy > 0);
                    }
                  }
                  !0 === important && (token[set[start][2]] = token[set[start][2]] + " !important");
                  break;
                }
              }
              !0 === important && token[set[aa][2]].indexOf("!important") < 0 && (token[set[aa][2]] = token[set[aa][2]] + " !important");
            };
          for (aa = 0; aa < leng; aa += 1) if ("property" === types[set[aa][0]]) {
            0 === token[set[aa][0]].indexOf("margin") && fourcount("margin");
            0 === token[set[aa][0]].indexOf("padding") && fourcount("padding");
          }
        }();
        if (!0 === verticalop) {
          bb = 0;
          for (aa = p.length - 1; aa > -1; aa -= 1) token[p[aa]].length > bb && "filter" !== token[p[aa]] && "progid" !== token[p[aa]] && (bb = token[p[aa]].length);
          for (aa = p.length - 1; aa > -1; aa -= 1) if ((cc = bb - token[p[aa]].length) > 0 && "filter" !== token[p[aa]] && "progid" !== token[p[aa]]) do {
            token[p[aa]] = token[p[aa]] + " ";
            cc -= 1;
          } while (cc > 0);
          if (!1 === endtest) return;
        }
        bb = set.length;
        for (aa = 0; aa < bb; aa += 1) {
          dd = set[aa].length;
          for (cc = 0; cc < dd; cc += 1) {
            stoke.push(token[set[aa][cc]]);
            stype.push(types[set[aa][cc]]);
            sline.push(lines[set[aa][cc]]);
          }
        }
        token.splice(next + 1, token.length - next - 1);
        types.splice(next + 1, types.length - next - 1);
        lines.splice(next + 1, lines.length - next - 1);
        token = token.concat(stoke);
        types = types.concat(stype);
        lines = lines.concat(sline);
      };
    for (a = 0; a < len; a += 1) {
      "comment" !== ltype && "comment-inline" !== ltype && "" !== ltype && !0 === options.topcoms && (options.topcoms = !1);
      if (!0 === /\s/.test(b[a])) {
        stats.space += 1;
        space += b[a];
      } else if ("/" === b[a] && "*" === b[a + 1]) comment(!1);else if ("/" === b[a] && "/" === b[a + 1]) comment(!0);else if ("<" === b[a] && "?" === b[a + 1] && "p" === b[a + 2] && "h" === b[a + 3] && "p" === b[a + 4]) external("<?php", "?>");else if ("<" === b[a] && "%" === b[a + 1]) external("<%", "%>");else if ("{" === b[a] && "%" === b[a + 1]) external("{%", "%}");else if ("{" === b[a] && "{" === b[a + 1] && "{" === b[a + 2]) external("{{{", "}}}");else if ("{" === b[a] && "{" === b[a + 1]) external("{{", "}}");else if ("<" === b[a] && "!" === b[a + 1] && "-" === b[a + 2] && "-" === b[a + 3] && "#" === b[a + 4]) external("\x3c!--#", "--\x3e");else if ("{" === b[a]) {
        ":" === token[token.length - 2] && (types[types.length - 1] = "pseudo");
        item("start");
        ltype = "start";
        types.push("start");
        token.push("{");
        nosort.push(!1);
        lines.push(spacer(!1));
        stats.braces += 1;
        spacecol = !1;
      } else if ("}" === b[a]) {
        endtest = !0;
        if ("item" === types[types.length - 1] && "{" === token[token.length - 2] && void 0 !== token[token.length - 3] && "@" === token[token.length - 3].charAt(token[token.length - 3].length - 1)) {
          token[token.length - 3] = token[token.length - 3] + "{" + token[token.length - 1] + "}";
          token.pop();
          token.pop();
          types.pop();
          types.pop();
          lines.pop();
          lines.pop();
        } else {
          item("end");
          "diff" !== options.mode && properties();
          ltype = "end";
          !0 === objsortop && !1 === nosort[nosort.length - 1] && objSort();
          nosort.pop();
          types.push("end");
          token.push("}");
          lines.push(spacer(!1));
          stats.braces += 1;
        }
      } else if (";" === b[a]) {
        item("semi");
        if ("semi" !== types[types.length - 1]) {
          ltype = "semi";
          types.push("semi");
          token.push(";");
          lines.push(spacer(!1));
        }
        stats.semi += 1;
        space = "";
      } else if (":" === b[a]) {
        item("colon");
        types.push("colon");
        token.push(":");
        lines.push(0);
        ltype = "colon";
        stats.colon += 1;
        space = "";
        !0 === /\s/.test(b[a - 1]) ? spacecol = !0 : ":" !== b[a - 1] && (spacecol = !1);
      } else buildtoken();
    }
    !1 === endtest && !0 === verticalop && properties();
  }();
  if ("parse" === options.mode) return {
    token: token,
    types: types
  };
  output = "minify" !== options.mode ? function () {
    var a = 0,
      len = token.length,
      build = [],
      indent = options.inlevel,
      mixin = !1,
      tab = function () {
        var aa = 0,
          bb = [];
        for (aa = 0; aa < options.insize; aa += 1) bb.push(options.inchar);
        return bb.join("");
      }(),
      nl = function (tabs) {
        var aa = 0;
        if (build[build.length - 1] === tab) do {
          build.pop();
        } while (build[build.length - 1] === tab);
        build.push(lf);
        for (aa = 0; aa < tabs; aa += 1) build.push(tab);
      },
      selector = function (item) {
        var aa = 0,
          bb = 0,
          cc = 0,
          block = "",
          items = [],
          leng = item.length;
        !0 === options.compressedcss && !0 === /\)\s*when\s*\(/.test(item) && (item = item.replace(/\)\s*when\s*\(/, ")" + lf + function () {
          var wtab = "",
            aaa = indent + 1;
          do {
            wtab += tab;
            aaa -= 1;
          } while (aaa > 0);
          return wtab;
        }() + "when ("));
        for (aa = 0; aa < leng; aa += 1) {
          if ("" === block) {
            if ('"' === item.charAt(aa)) {
              block = '"';
              bb += 1;
            } else if ("'" === item.charAt(aa)) {
              block = "'";
              bb += 1;
            } else if ("(" === item.charAt(aa)) {
              block = ")";
              bb += 1;
            } else if ("[" === item.charAt(aa)) {
              block = "]";
              bb += 1;
            }
          } else "(" === item.charAt(aa) && ")" === block || "[" === item.charAt(aa) && "]" === block ? bb += 1 : item.charAt(aa) === block && 0 === (bb -= 1) && (block = "");
          if ("" === block && "," === item.charAt(aa)) {
            items.push(item.substring(cc, aa + 1));
            cc = aa + 1;
          }
        }
        cc > 0 && items.push(item.substr(cc));
        0 === (leng = items.length) && items.push(item);
        if (!0 === options.selectorlist) build.push(items.join(" "));else {
          build.push(items[0].replace(/,(\s*)/g, ", ").replace(/(,\ )$/, ","));
          for (aa = 1; aa < leng; aa += 1) {
            nl(indent);
            build.push(items[aa].replace(/,(\s*)/g, ", ").replace(/(,\ )$/, ","));
          }
        }
        !1 === options.compressedcss && build.push(" ");
      };
    if (options.inlevel > 0) {
      a = options.inlevel;
      do {
        a -= 1;
        build.push(tab);
      } while (a > 0);
    }
    for (a = 0; a < len; a += 1) {
      if (lines[a] > 1 && !1 === options.compressedcss && ("start" === types[a] || "end" === types[a] || "selector" === types[a] || "comment" === types[a] || "property" === types[a] || types[a].indexOf("external") > -1)) {
        !0 === options.cssinsertlines && "selector" === types[a] && "comment" !== types[a - 1] && (lines[a] -= 1);
        if (build[build.length - 1] === tab) do {
          build.pop();
        } while (build[build.length - 1] === tab);
        if (lines[a] > 1) {
          if (lines[a] > 2) do {
            lines[a] -= 1;
            build.push(lf);
          } while (lines[a] > 2);
          nl(indent);
        }
      }
      if ("start" === types[a]) {
        if (a > 0 && "#" === token[a - 1].charAt(token[a - 1].length - 1)) build.push(token[a]);else {
          if (!0 === options.braces) {
            " " === build[build.length - 1] && build.pop();
            nl(indent);
          } else "colon" === types[a - 1] && build.push(" ");
          build.push(token[a]);
          indent += 1;
          "end" === types[a + 1] || !1 !== options.compressedcss && (!0 !== options.compressedcss || "start" !== types[a + 1]) || "selector" === types[a + 1] && !1 !== options.cssinsertlines || nl(indent);
        }
      } else if ("end" === types[a]) {
        if (!0 === mixin) {
          mixin = !1;
          build.push(token[a]);
          build.push(" ");
        } else {
          indent -= 1;
          "start" !== types[a - 1] && !1 === options.compressedcss && nl(indent);
          build.push(token[a]);
          !0 === options.compressedcss && "end" === types[a + 1] ? nl(indent - 1) : !0 === options.cssinsertlines && "selector" === types[a + 1] && lines[a] < 2 && "{" !== token[a - 1] ? build.push(lf) : "end" !== types[a + 1] && "semi" !== types[a + 1] && "comment" !== types[a + 1] && nl(indent);
        }
      } else if ("semi" === types[a]) {
        "x;" !== token[a] && (!1 === options.compressedcss || !0 === options.compressedcss && "end" !== types[a + 1]) && build.push(token[a]);
        "comment-inline" === types[a + 1] ? build.push(" ") : "end" !== types[a + 1] && "comment" !== types[a + 1] && !1 === options.compressedcss && (!0 === options.cssinsertlines && "selector" === types[a + 1] ? build.push(lf) : nl(indent));
      } else if ("selector" === types[a]) {
        a > 0 && "comment" !== types[a - 1] && (!0 === options.cssinsertlines || !0 === options.compressedcss && ("start" === types[a - 1] || "semi" === types[a - 1])) && nl(indent);
        if ("#" === token[a].charAt(token[a].length - 1)) {
          build.push(token[a]);
          mixin = !0;
        } else if (token[a].indexOf(",") > -1) selector(token[a]);else {
          ":" === token[a].charAt(0) && "}" === token[a - 1] && " " === build[build.length - 1] && build.pop();
          build.push(token[a]);
          !1 === options.compressedcss && build.push(" ");
        }
      } else if ("comment" !== types[a] && "comment-inline" !== types[a] || "colon" === types[a - 1] || "property" === types[a - 1]) {
        !("value" === types[a] || types[a].indexOf("external") > -1 && "colon" === types[a - 1]) || "semi" === types[a - 1] || !1 !== options.compressedcss || !1 !== mixin && ":" !== token[a - 1] || "filter" === token[a - 2] || "progid" === token[a - 2] || build.push(" ");
        if ("external_start" === types[a] && "selector" !== types[a + 1]) indent += 1;else if ("external_end" !== types[a] || "end" !== types[a + 1] && "external_end" !== types[a + 1]) "external_else" === types[a] && build[build.length - 1] === tab && build.pop();else {
          indent -= 1;
          build[build.length - 1] === tab && "end" === types[a - 1] && build.pop();
        }
        build.push(token[a]);
        types[a].indexOf("external") > -1 && "semi" !== types[a + 1] && (lines[a + 1] < 0 || "selector" === types[a + 1] || void 0 !== types[a + 1] && lines[a + 1] > 0 && types[a + 1].indexOf("external") > -1) && ("external_end" === types[a] ? nl(indent - 1) : nl(indent));
      } else {
        if (a > 0 && !0 === options.compressedcss && "comment" === types[a] && "comment" !== types[a - 1]) {
          build.push(lf);
          nl(indent);
        } else a > 0 && "start" !== types[a - 1] && "comment-inline" !== types[a] && nl(indent);
        build.push(token[a]);
        "end" !== types[a + 1] && "comment" !== types[a + 1] && nl(indent);
      }
    }
    return options.preserve > 0 && (lines[lines.length - 1] > 0 || !0 === endline) ? build.join("").replace(/(\s+)$/, lf) : build.join("").replace(/(\s+)$/, "");
  }() : token.join("").replace(/;\}/g, "}");
  "beautify" === options.mode && function () {
    var summ = [],
      inl = options.source.length,
      out = output.length,
      uris = uri.length,
      uric = 0,
      a = 0,
      b = 0,
      color = [];
    !function () {
      var aa = 0,
        bb = 0,
        cc = colors.length;
      colors.sort();
      color.push(colors[0]);
      for (aa = 0; aa < cc; aa += 1) if (colors[aa] !== color[bb]) {
        color.push(colors[aa]);
        bb += 1;
      }
    }();
    summ.push("<div class='report' id='cssreport'><p><strong>Number of HTTP requests:</strong> <em>");
    summ.push(uris);
    summ.push("</em></p><table class='analysis' id='css-parts' summary='Component counts and sizes'><caption>Component counts and sizes</caption><thead><tr><th>Type Name</th><th>Quantity</th><th>Character Size</th></tr></thead><tbody><tr><th>curly braces</th><td>");
    summ.push(stats.braces);
    summ.push("</td><td>");
    summ.push(stats.braces);
    summ.push("</td></tr><tr><th>colon</th><td>");
    summ.push(stats.colon);
    summ.push("</td><td>");
    summ.push(stats.colon);
    summ.push("</td></tr><tr><th>comments</th><td>");
    summ.push(stats.comments.count);
    summ.push("</td><td>");
    summ.push(stats.comments.chars);
    summ.push("</td></tr><tr><th>properties</th><td>");
    summ.push(stats.properties.count);
    summ.push("</td><td>");
    summ.push(stats.properties.chars);
    summ.push("</td></tr><tr><th>selectors</th><td>");
    summ.push(stats.selectors.count);
    summ.push("</td><td>");
    summ.push(stats.selectors.chars);
    summ.push("</td></tr><tr><th>semicolons</th><td>");
    summ.push(stats.semi);
    summ.push("</td><td>");
    summ.push(stats.semi);
    summ.push("</td></tr><tr><th>white space</th><td>");
    summ.push(stats.space);
    summ.push("</td><td>");
    summ.push(stats.space);
    summ.push("</td></tr><tr><th>values</th><td>");
    summ.push(stats.values.count);
    summ.push("</td><td>");
    summ.push(stats.values.chars);
    summ.push("</td></tr><tr><th>variables</th><td>");
    summ.push(stats.variables.count);
    summ.push("</td><td>");
    summ.push(stats.variables.chars);
    summ.push("</td></tr></tbody></table><table class='analysis' id='css-size' summary='CSS character size change'><caption>CSS character size change</caption><tbody><tr><th>Input</th><td>");
    summ.push(inl);
    summ.push("</td></tr><tr><th>Output</th><td>");
    summ.push(out);
    summ.push("</td></tr><tr><th>");
    if (out > inl) {
      summ.push("Increase</th><td>");
      summ.push(out - inl);
      summ.push("</td></tr><tr><th>Percent Change</th><td>");
      a = (out - inl) / out * 100;
      summ.push(a.toFixed(2));
    } else {
      summ.push("Decrease</th><td>");
      summ.push(inl - out);
      summ.push("</td></tr><tr><th>Percent Change</th><td>");
      a = (inl - out) / inl * 100;
      summ.push(a.toFixed(2));
    }
    summ.push("%</td></tr></tbody></table><table class='analysis' id='css-uri' summary='A list of HTTP requests'><caption>A List of HTTP Requests</caption><thead><tr><th>Quantity</th><th>URI</th></tr></thead><tbody>");
    for (a = 0; a < uris; a += 1) {
      uric = 1;
      for (b = a + 1; b < uris; b += 1) if (uri[a] === uri[b]) {
        uric += 1;
        uri.splice(b, 1);
        uris -= 1;
      }
      summ.push("<tr><td>");
      summ.push(uric);
      summ.push("</td><td>");
      summ.push(uri[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"));
      summ.push("</td></tr>");
    }
    summ.push("</tbody></table>");
    summ.push("</div><span class='clear'></span>");
    if (0 === color.length) summ.push("<h4>0 colors were identified in the provided code.</h4>");else {
      summ.push("<h4>These ");
      summ.push(color.length);
      color.length > 1 && summ.push(" different");
      summ.push(" color");
      color.length > 1 && summ.push("s");
      summ.push(" were identified in the provided code:</h4><p>");
      summ.push(color.join(", "));
      summ.push("</p>");
      !0 === options.accessibility && function () {
        var vl = "",
          bb = color.length,
          aa = 0,
          luminance = function (rgb) {
            var convert = function (x) {
              if (0 === x) return 0;
              if (1e5 * (x /= 255) <= 3928) return 100 * x / 1292 * 1e4;
              x *= 1e5;
              return 1e4 * Math.pow((x + 5500) / 105500, 2.4);
            };
            return (2126 * convert(rgb[0]) + 7152 * convert(rgb[1]) + 722 * convert(rgb[2])) / 1e8;
          },
          hexToDec = function (val) {
            var str = val.slice(1).split(""),
              rgb = [],
              num = [],
              aaa = 0,
              bbb = str.length;
            for (aaa = 0; aaa < bbb; aaa += 1) "a" === str[aaa] ? num.push(10) : "b" === str[aaa] ? num.push(11) : "c" === str[aaa] ? num.push(12) : "d" === str[aaa] ? num.push(13) : "e" === str[aaa] ? num.push(14) : "f" === str[aaa] ? num.push(15) : num.push(Number(str[aaa]));
            if (3 === bbb) {
              rgb.push(16 * num[0] + num[0]);
              rgb.push(16 * num[1] + num[1]);
              rgb.push(16 * num[2] + num[2]);
            } else {
              rgb.push(16 * num[0] + num[1]);
              rgb.push(16 * num[2] + num[3]);
              rgb.push(16 * num[4] + num[5]);
            }
            return luminance(rgb);
          },
          rgbToDec = function (val) {
            var rgb = [],
              rgbs = [],
              rr = 0;
            "a" === vl.charAt(3) ? (rgbs = (vl = vl.slice(5, vl.length - 1).replace(/\s+/g, "")).split(",")).pop() : rgbs = (vl = vl.slice(4, vl.length - 1).replace(/\s+/g, "")).split(",");
            do {
              if (!1 === /^([0-9a-f]{2})$/.test(rgbs[rr])) if ("%" === rgbs[rr].charAt(rgbs[rr].length - 1)) {
                vl = rgbs[rr].slice(0, rgbs[rr].length - 1);
                if (!0 === isNaN(vl)) return val;
                rgb.push(Number(vl));
                rgb[rr] < 0 ? rgb[rr] = 0 : rgb[rr] > 100 && (rgb[rr] = 100);
                rgb[rr] = Math.round(2.55 * rgb[rr]);
              } else {
                if (!0 === isNaN(rgbs[rr])) return val;
                rgb.push(Number(rgbs[rr]));
                rgb[rr] < 0 ? rgb[rr] = 0 : rgb[rr] > 255 && (rgb[rr] = 255);
                rgb[rr] = Math.round(rgb[rr]);
              }
              rr += 1;
            } while (rr < 3);
            return luminance(rgb);
          };
        colors = [];
        for (aa = 0; aa < bb && void 0 !== color[aa]; aa += 1) {
          vl = color[aa].toLowerCase();
          !0 === /^(#[0-9a-f]{3,6})$/.test(vl) ? colors.push(hexToDec(vl.slice(1))) : !0 === /^(rgba?\()/.test(vl) ? colors.push(rgbToDec(vl)) : void 0 !== colorNames[vl] && colors.push(colorNames[vl]);
        }
      }();
    }
  }();
  return output;
};
"object" == typeof exports || "function" == typeof exports ? exports.api = function (x) {
  return csspretty(x);
} : "object" != typeof define && "function" != typeof define || void 0 !== ace && void 0 !== ace.prettydiffid || define(function (require, exports) {
  exports.api = function (x) {
    return csspretty(x);
  };
  return "number" == typeof require ? require : exports.api;
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!********************************!*\
  !*** ./scripts/load-editor.js ***!
  \********************************/
/* harmony import */ var _loading_magic_css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loading-magic-css.js */ "./scripts/loading-magic-css.js");
/* harmony import */ var _3rdparty_css_escape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./3rdparty/css.escape.js */ "./scripts/3rdparty/css.escape.js");
/* harmony import */ var _3rdparty_css_escape_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_css_escape_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _3rdparty_codemirror_codemirror_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./3rdparty/codemirror/codemirror.css */ "./scripts/3rdparty/codemirror/codemirror.css");
/* harmony import */ var _3rdparty_codemirror_theme_ambiance_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./3rdparty/codemirror/theme/ambiance.css */ "./scripts/3rdparty/codemirror/theme/ambiance.css");
/* harmony import */ var _3rdparty_custom_fixes_codemirror_magicss_codemirror_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./3rdparty-custom-fixes/codemirror/magicss-codemirror.css */ "./scripts/3rdparty-custom-fixes/codemirror/magicss-codemirror.css");
/* harmony import */ var _3rdparty_custom_fixes_codemirror_codemirror_as_global_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./3rdparty-custom-fixes/codemirror/codemirror-as-global.js */ "./scripts/3rdparty-custom-fixes/codemirror/codemirror-as-global.js");
/* harmony import */ var _3rdparty_codemirror_mode_css_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./3rdparty/codemirror/mode/css.js */ "./scripts/3rdparty/codemirror/mode/css.js");
/* harmony import */ var _3rdparty_codemirror_mode_css_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_mode_css_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _3rdparty_codemirror_addons_display_placeholder_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/display/placeholder.js */ "./scripts/3rdparty/codemirror/addons/display/placeholder.js");
/* harmony import */ var _3rdparty_codemirror_addons_display_placeholder_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_display_placeholder_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _3rdparty_codemirror_addons_selection_active_line_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/selection/active-line.js */ "./scripts/3rdparty/codemirror/addons/selection/active-line.js");
/* harmony import */ var _3rdparty_codemirror_addons_selection_active_line_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_selection_active_line_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _3rdparty_codemirror_addons_edit_closebrackets_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/edit/closebrackets.js */ "./scripts/3rdparty/codemirror/addons/edit/closebrackets.js");
/* harmony import */ var _3rdparty_codemirror_addons_edit_closebrackets_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_edit_closebrackets_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _3rdparty_codemirror_addons_edit_matchbrackets_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/edit/matchbrackets.js */ "./scripts/3rdparty/codemirror/addons/edit/matchbrackets.js");
/* harmony import */ var _3rdparty_codemirror_addons_edit_matchbrackets_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_edit_matchbrackets_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _3rdparty_codemirror_addons_search_searchcursor_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/search/searchcursor.js */ "./scripts/3rdparty/codemirror/addons/search/searchcursor.js");
/* harmony import */ var _3rdparty_codemirror_addons_search_searchcursor_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_search_searchcursor_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _3rdparty_codemirror_addons_comment_comment_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/comment/comment.js */ "./scripts/3rdparty/codemirror/addons/comment/comment.js");
/* harmony import */ var _3rdparty_codemirror_addons_comment_comment_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_comment_comment_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _3rdparty_csslint_csslint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./3rdparty/csslint/csslint.js */ "./scripts/3rdparty/csslint/csslint.js");
/* harmony import */ var _3rdparty_csslint_csslint_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_csslint_csslint_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _3rdparty_custom_fixes_csslint_ignore_some_rules_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./3rdparty-custom-fixes/csslint/ignore-some-rules.js */ "./scripts/3rdparty-custom-fixes/csslint/ignore-some-rules.js");
/* harmony import */ var _3rdparty_custom_fixes_csslint_ignore_some_rules_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_custom_fixes_csslint_ignore_some_rules_js__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _3rdparty_codemirror_addons_lint_lint_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/lint/lint.css */ "./scripts/3rdparty/codemirror/addons/lint/lint.css");
/* harmony import */ var _3rdparty_custom_fixes_codemirror_addons_lint_tooltip_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./3rdparty-custom-fixes/codemirror/addons/lint/tooltip.css */ "./scripts/3rdparty-custom-fixes/codemirror/addons/lint/tooltip.css");
/* harmony import */ var _3rdparty_codemirror_addons_lint_lint_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/lint/lint.js */ "./scripts/3rdparty/codemirror/addons/lint/lint.js");
/* harmony import */ var _3rdparty_codemirror_addons_lint_lint_js__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_lint_lint_js__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _3rdparty_codemirror_addons_lint_css_lint_customized_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/lint/css-lint_customized.js */ "./scripts/3rdparty/codemirror/addons/lint/css-lint_customized.js");
/* harmony import */ var _3rdparty_codemirror_addons_lint_css_lint_customized_js__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_lint_css_lint_customized_js__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var _3rdparty_codemirror_addons_hint_show_hint_css__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/hint/show-hint.css */ "./scripts/3rdparty/codemirror/addons/hint/show-hint.css");
/* harmony import */ var _3rdparty_codemirror_addons_hint_show_hint_customized_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/hint/show-hint_customized.js */ "./scripts/3rdparty/codemirror/addons/hint/show-hint_customized.js");
/* harmony import */ var _3rdparty_codemirror_addons_hint_show_hint_customized_js__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_hint_show_hint_customized_js__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _3rdparty_codemirror_addons_hint_css_hint_customized_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/hint/css-hint_customized.js */ "./scripts/3rdparty/codemirror/addons/hint/css-hint_customized.js");
/* harmony import */ var _3rdparty_codemirror_addons_hint_css_hint_customized_js__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_hint_css_hint_customized_js__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _3rdparty_codemirror_addons_colorpicker_colorpicker_css__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/colorpicker/colorpicker.css */ "./scripts/3rdparty/codemirror/addons/colorpicker/colorpicker.css");
/* harmony import */ var _3rdparty_codemirror_addons_colorpicker_colorview_customized_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/colorpicker/colorview_customized.js */ "./scripts/3rdparty/codemirror/addons/colorpicker/colorview_customized.js");
/* harmony import */ var _3rdparty_codemirror_addons_colorpicker_colorview_customized_js__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_colorpicker_colorview_customized_js__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _3rdparty_codemirror_addons_colorpicker_colorpicker_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/colorpicker/colorpicker.js */ "./scripts/3rdparty/codemirror/addons/colorpicker/colorpicker.js");
/* harmony import */ var _3rdparty_codemirror_addons_colorpicker_colorpicker_js__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_colorpicker_colorpicker_js__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _3rdparty_codemirror_addons_emmet_emmet_codemirror_plugin_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./3rdparty/codemirror/addons/emmet/emmet-codemirror-plugin.js */ "./scripts/3rdparty/codemirror/addons/emmet/emmet-codemirror-plugin.js");
/* harmony import */ var _3rdparty_codemirror_addons_emmet_emmet_codemirror_plugin_js__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_addons_emmet_emmet_codemirror_plugin_js__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var _3rdparty_codemirror_keymap_sublime_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./3rdparty/codemirror/keymap/sublime.js */ "./scripts/3rdparty/codemirror/keymap/sublime.js");
/* harmony import */ var _3rdparty_codemirror_keymap_sublime_js__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_codemirror_keymap_sublime_js__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var _3rdparty_custom_fixes_jquery_jquery_as_global_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./3rdparty-custom-fixes/jquery/jquery-as-global.js */ "./scripts/3rdparty-custom-fixes/jquery/jquery-as-global.js");
/* harmony import */ var _3rdparty_jquery_ui_customized_css__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./3rdparty/jquery-ui_customized.css */ "./scripts/3rdparty/jquery-ui_customized.css");
/* harmony import */ var _3rdparty_jquery_ui_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./3rdparty/jquery-ui.js */ "./scripts/3rdparty/jquery-ui.js");
/* harmony import */ var _3rdparty_jquery_ui_js__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_jquery_ui_js__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var _3rdparty_jquery_ui_touch_punch_customized_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./3rdparty/jquery.ui.touch-punch_customized.js */ "./scripts/3rdparty/jquery.ui.touch-punch_customized.js");
/* harmony import */ var _3rdparty_jquery_ui_touch_punch_customized_js__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_jquery_ui_touch_punch_customized_js__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _3rdparty_custom_fixes_socket_io_socket_io_as_global_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./3rdparty-custom-fixes/socket.io/socket.io-as-global.js */ "./scripts/3rdparty-custom-fixes/socket.io/socket.io-as-global.js");
/* harmony import */ var _3rdparty_amplify_store_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./3rdparty/amplify-store.js */ "./scripts/3rdparty/amplify-store.js");
/* harmony import */ var _migrate_storage_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./migrate-storage.js */ "./scripts/migrate-storage.js");
/* harmony import */ var _3rdparty_tooltipster_tooltipster_css__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./3rdparty/tooltipster/tooltipster.css */ "./scripts/3rdparty/tooltipster/tooltipster.css");
/* harmony import */ var _3rdparty_tooltipster_jquery_tooltipster_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./3rdparty/tooltipster/jquery.tooltipster.js */ "./scripts/3rdparty/tooltipster/jquery.tooltipster.js");
/* harmony import */ var _3rdparty_tooltipster_jquery_tooltipster_js__WEBPACK_IMPORTED_MODULE_35___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_tooltipster_jquery_tooltipster_js__WEBPACK_IMPORTED_MODULE_35__);
/* harmony import */ var _3rdparty_tooltipster_tooltipster_scrollableTip_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./3rdparty/tooltipster/tooltipster-scrollableTip.js */ "./scripts/3rdparty/tooltipster/tooltipster-scrollableTip.js");
/* harmony import */ var _3rdparty_tooltipster_tooltipster_scrollableTip_js__WEBPACK_IMPORTED_MODULE_36___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_tooltipster_tooltipster_scrollableTip_js__WEBPACK_IMPORTED_MODULE_36__);
/* harmony import */ var _3rdparty_toastr_toastr_css__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./3rdparty/toastr/toastr.css */ "./scripts/3rdparty/toastr/toastr.css");
/* harmony import */ var _3rdparty_toastr_toastr_customized_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./3rdparty/toastr/toastr_customized.js */ "./scripts/3rdparty/toastr/toastr_customized.js");
/* harmony import */ var _3rdparty_toastr_toastr_customized_js__WEBPACK_IMPORTED_MODULE_38___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_toastr_toastr_customized_js__WEBPACK_IMPORTED_MODULE_38__);
/* harmony import */ var _3rdparty_magicsuggest_magicsuggest_css__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./3rdparty/magicsuggest/magicsuggest.css */ "./scripts/3rdparty/magicsuggest/magicsuggest.css");
/* harmony import */ var _3rdparty_magicsuggest_magicsuggest_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./3rdparty/magicsuggest/magicsuggest.js */ "./scripts/3rdparty/magicsuggest/magicsuggest.js");
/* harmony import */ var _3rdparty_magicsuggest_magicsuggest_js__WEBPACK_IMPORTED_MODULE_40___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_magicsuggest_magicsuggest_js__WEBPACK_IMPORTED_MODULE_40__);
/* harmony import */ var _3rdparty_custom_fixes_csspretty_pre_csspretty_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./3rdparty-custom-fixes/csspretty/pre-csspretty.js */ "./scripts/3rdparty-custom-fixes/csspretty/pre-csspretty.js");
/* harmony import */ var _3rdparty_custom_fixes_csspretty_pre_csspretty_js__WEBPACK_IMPORTED_MODULE_41___default = /*#__PURE__*/__webpack_require__.n(_3rdparty_custom_fixes_csspretty_pre_csspretty_js__WEBPACK_IMPORTED_MODULE_41__);
/* harmony import */ var _3rdparty_csspretty_csspretty_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./3rdparty/csspretty/csspretty.js */ "./scripts/3rdparty/csspretty/csspretty.js");
/* harmony import */ var _magicss_editor_editor_css__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./magicss/editor/editor.css */ "./scripts/magicss/editor/editor.css");
/* harmony import */ var _magicss_editor_editor_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./magicss/editor/editor.js */ "./scripts/magicss/editor/editor.js");
/* harmony import */ var _magicss_magicss_css__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./magicss/magicss.css */ "./scripts/magicss/magicss.css");
/* harmony import */ var _magicss_generate_selector_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./magicss/generate-selector.js */ "./scripts/magicss/generate-selector.js");
/* harmony import */ var _magicss_generate_selector_js__WEBPACK_IMPORTED_MODULE_46___default = /*#__PURE__*/__webpack_require__.n(_magicss_generate_selector_js__WEBPACK_IMPORTED_MODULE_46__);
/* harmony import */ var _magicss_magicss_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./magicss/magicss.js */ "./scripts/magicss/magicss.js");












// This is required for some cases in multi-selection (using Ctrl+D)












// https://github.com/easylogic/codemirror-colorpicker





















// Alternatively, use cssbeautify & Yahoo's CSS Min libraries
// import './3rdparty/cssbeautify/cssbeautify.js';
// import './3rdparty/yui-cssmin/cssmin.js';

// http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.5/less.js
// import './3rdparty/less.js';
// // TODO: Remove this piece of commented out code. Now loading 'less' dynamically via `loadIfNotAvailable`
// import './3rdparty/basic-less-with-sourcemap-support.browserified.js';

// Commented out so that Opera users can use Sass the way it is loaded in Chrome (when installed from Chrome Web Store)
// {
//     src: import './3rdparty/sass/sass.sync.min.js';
//     skip: (runningInBrowserExtension && isOpera) ? false : true
// },

// http://www.miyconst.com/Blog/View/14/conver-css-to-less-with-css2less-js
// import './3rdparty/css2less/linq.js';
// import './3rdparty/css2less/css2less.js';






})();

/******/ })()
;